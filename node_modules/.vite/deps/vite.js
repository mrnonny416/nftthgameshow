import {
  __commonJS,
  __esm,
  __export,
  __objRest,
  __require,
  __spreadProps as __spreadProps2,
  __spreadValues as __spreadValues2,
  __toCommonJS
} from "./chunk-XYVWA2NS.js";

// browser-external:fs
var fs_exports = {};
__export(fs_exports, {
  default: () => fs_default
});
var fs_default;
var init_fs = __esm({
  "browser-external:fs"() {
    fs_default = new Proxy({}, {
      get() {
        throw new Error('Module "fs" has been externalized for browser compatibility and cannot be accessed in client code.');
      }
    });
  }
});

// browser-external:path
var path_exports = {};
__export(path_exports, {
  default: () => path_default
});
var path_default;
var init_path = __esm({
  "browser-external:path"() {
    path_default = new Proxy({}, {
      get() {
        throw new Error('Module "path" has been externalized for browser compatibility and cannot be accessed in client code.');
      }
    });
  }
});

// browser-external:tty
var tty_exports = {};
__export(tty_exports, {
  default: () => tty_default
});
var tty_default;
var init_tty = __esm({
  "browser-external:tty"() {
    tty_default = new Proxy({}, {
      get() {
        throw new Error('Module "tty" has been externalized for browser compatibility and cannot be accessed in client code.');
      }
    });
  }
});

// browser-external:util
var util_exports = {};
__export(util_exports, {
  default: () => util_default
});
var util_default;
var init_util = __esm({
  "browser-external:util"() {
    util_default = new Proxy({}, {
      get() {
        throw new Error('Module "util" has been externalized for browser compatibility and cannot be accessed in client code.');
      }
    });
  }
});

// browser-external:net
var net_exports = {};
__export(net_exports, {
  default: () => net_default
});
var net_default;
var init_net = __esm({
  "browser-external:net"() {
    net_default = new Proxy({}, {
      get() {
        throw new Error('Module "net" has been externalized for browser compatibility and cannot be accessed in client code.');
      }
    });
  }
});

// browser-external:events
var events_exports = {};
__export(events_exports, {
  default: () => events_default
});
var events_default;
var init_events = __esm({
  "browser-external:events"() {
    events_default = new Proxy({}, {
      get() {
        throw new Error('Module "events" has been externalized for browser compatibility and cannot be accessed in client code.');
      }
    });
  }
});

// browser-external:url
var url_exports = {};
__export(url_exports, {
  default: () => url_default
});
var url_default;
var init_url = __esm({
  "browser-external:url"() {
    url_default = new Proxy({}, {
      get() {
        throw new Error('Module "url" has been externalized for browser compatibility and cannot be accessed in client code.');
      }
    });
  }
});

// browser-external:http
var http_exports = {};
__export(http_exports, {
  default: () => http_default
});
var http_default;
var init_http = __esm({
  "browser-external:http"() {
    http_default = new Proxy({}, {
      get() {
        throw new Error('Module "http" has been externalized for browser compatibility and cannot be accessed in client code.');
      }
    });
  }
});

// browser-external:stream
var stream_exports = {};
__export(stream_exports, {
  default: () => stream_default
});
var stream_default;
var init_stream = __esm({
  "browser-external:stream"() {
    stream_default = new Proxy({}, {
      get() {
        throw new Error('Module "stream" has been externalized for browser compatibility and cannot be accessed in client code.');
      }
    });
  }
});

// browser-external:os
var os_exports = {};
__export(os_exports, {
  default: () => os_default
});
var os_default;
var init_os = __esm({
  "browser-external:os"() {
    os_default = new Proxy({}, {
      get() {
        throw new Error('Module "os" has been externalized for browser compatibility and cannot be accessed in client code.');
      }
    });
  }
});

// node_modules/resolve/lib/homedir.js
var require_homedir = __commonJS({
  "node_modules/resolve/lib/homedir.js"(exports2, module2) {
    "use strict";
    var os3 = (init_os(), __toCommonJS(os_exports));
    module2.exports = os3.homedir || function homedir() {
      var home = process.env.HOME;
      var user = process.env.LOGNAME || process.env.USER || process.env.LNAME || process.env.USERNAME;
      if (process.platform === "win32") {
        return process.env.USERPROFILE || process.env.HOMEDRIVE + process.env.HOMEPATH || home || null;
      }
      if (process.platform === "darwin") {
        return home || (user ? "/Users/" + user : null);
      }
      if (process.platform === "linux") {
        return home || (process.getuid() === 0 ? "/root" : user ? "/home/" + user : null);
      }
      return home || null;
    };
  }
});

// node_modules/resolve/lib/caller.js
var require_caller = __commonJS({
  "node_modules/resolve/lib/caller.js"(exports2, module2) {
    module2.exports = function() {
      var origPrepareStackTrace = Error.prepareStackTrace;
      Error.prepareStackTrace = function(_2, stack3) {
        return stack3;
      };
      var stack2 = new Error().stack;
      Error.prepareStackTrace = origPrepareStackTrace;
      return stack2[2].getFileName();
    };
  }
});

// node_modules/path-parse/index.js
var require_path_parse = __commonJS({
  "node_modules/path-parse/index.js"(exports2, module2) {
    "use strict";
    var isWindows2 = process.platform === "win32";
    var splitWindowsRe = /^(((?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?[\\\/]?)(?:[^\\\/]*[\\\/])*)((\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))[\\\/]*$/;
    var win322 = {};
    function win32SplitPath(filename2) {
      return splitWindowsRe.exec(filename2).slice(1);
    }
    win322.parse = function(pathString) {
      if (typeof pathString !== "string") {
        throw new TypeError("Parameter 'pathString' must be a string, not " + typeof pathString);
      }
      var allParts = win32SplitPath(pathString);
      if (!allParts || allParts.length !== 5) {
        throw new TypeError("Invalid path '" + pathString + "'");
      }
      return {
        root: allParts[1],
        dir: allParts[0] === allParts[1] ? allParts[0] : allParts[0].slice(0, -1),
        base: allParts[2],
        ext: allParts[4],
        name: allParts[3]
      };
    };
    var splitPathRe = /^((\/?)(?:[^\/]*\/)*)((\.{1,2}|[^\/]+?|)(\.[^.\/]*|))[\/]*$/;
    var posix2 = {};
    function posixSplitPath(filename2) {
      return splitPathRe.exec(filename2).slice(1);
    }
    posix2.parse = function(pathString) {
      if (typeof pathString !== "string") {
        throw new TypeError("Parameter 'pathString' must be a string, not " + typeof pathString);
      }
      var allParts = posixSplitPath(pathString);
      if (!allParts || allParts.length !== 5) {
        throw new TypeError("Invalid path '" + pathString + "'");
      }
      return {
        root: allParts[1],
        dir: allParts[0].slice(0, -1),
        base: allParts[2],
        ext: allParts[4],
        name: allParts[3]
      };
    };
    if (isWindows2)
      module2.exports = win322.parse;
    else
      module2.exports = posix2.parse;
    module2.exports.posix = posix2.parse;
    module2.exports.win32 = win322.parse;
  }
});

// node_modules/resolve/lib/node-modules-paths.js
var require_node_modules_paths = __commonJS({
  "node_modules/resolve/lib/node-modules-paths.js"(exports2, module2) {
    var path2 = (init_path(), __toCommonJS(path_exports));
    var parse2 = path2.parse || require_path_parse();
    var getNodeModulesDirs = function getNodeModulesDirs2(absoluteStart, modules) {
      var prefix = "/";
      if (/^([A-Za-z]:)/.test(absoluteStart)) {
        prefix = "";
      } else if (/^\\\\/.test(absoluteStart)) {
        prefix = "\\\\";
      }
      var paths = [absoluteStart];
      var parsed = parse2(absoluteStart);
      while (parsed.dir !== paths[paths.length - 1]) {
        paths.push(parsed.dir);
        parsed = parse2(parsed.dir);
      }
      return paths.reduce(function(dirs, aPath) {
        return dirs.concat(modules.map(function(moduleDir) {
          return path2.resolve(prefix, aPath, moduleDir);
        }));
      }, []);
    };
    module2.exports = function nodeModulesPaths(start, opts, request) {
      var modules = opts && opts.moduleDirectory ? [].concat(opts.moduleDirectory) : ["node_modules"];
      if (opts && typeof opts.paths === "function") {
        return opts.paths(request, start, function() {
          return getNodeModulesDirs(start, modules);
        }, opts);
      }
      var dirs = getNodeModulesDirs(start, modules);
      return opts && opts.paths ? dirs.concat(opts.paths) : dirs;
    };
  }
});

// node_modules/resolve/lib/normalize-options.js
var require_normalize_options = __commonJS({
  "node_modules/resolve/lib/normalize-options.js"(exports2, module2) {
    module2.exports = function(x2, opts) {
      return opts || {};
    };
  }
});

// node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "node_modules/function-bind/implementation.js"(exports2, module2) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var slice2 = Array.prototype.slice;
    var toStr = Object.prototype.toString;
    var funcType = "[object Function]";
    module2.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slice2.call(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result2 = target.apply(this, args.concat(slice2.call(arguments)));
          if (Object(result2) === result2) {
            return result2;
          }
          return this;
        } else {
          return target.apply(that, args.concat(slice2.call(arguments)));
        }
      };
      var boundLength = Math.max(0, target.length - args.length);
      var boundArgs = [];
      for (var i2 = 0; i2 < boundLength; i2++) {
        boundArgs.push("$" + i2);
      }
      bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "node_modules/function-bind/index.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation();
    module2.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/has/src/index.js
var require_src = __commonJS({
  "node_modules/has/src/index.js"(exports2, module2) {
    "use strict";
    var bind = require_function_bind();
    module2.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
  }
});

// node_modules/is-core-module/core.json
var require_core = __commonJS({
  "node_modules/is-core-module/core.json"(exports2, module2) {
    module2.exports = {
      assert: true,
      "node:assert": [">= 14.18 && < 15", ">= 16"],
      "assert/strict": ">= 15",
      "node:assert/strict": ">= 16",
      async_hooks: ">= 8",
      "node:async_hooks": [">= 14.18 && < 15", ">= 16"],
      buffer_ieee754: ">= 0.5 && < 0.9.7",
      buffer: true,
      "node:buffer": [">= 14.18 && < 15", ">= 16"],
      child_process: true,
      "node:child_process": [">= 14.18 && < 15", ">= 16"],
      cluster: ">= 0.5",
      "node:cluster": [">= 14.18 && < 15", ">= 16"],
      console: true,
      "node:console": [">= 14.18 && < 15", ">= 16"],
      constants: true,
      "node:constants": [">= 14.18 && < 15", ">= 16"],
      crypto: true,
      "node:crypto": [">= 14.18 && < 15", ">= 16"],
      _debug_agent: ">= 1 && < 8",
      _debugger: "< 8",
      dgram: true,
      "node:dgram": [">= 14.18 && < 15", ">= 16"],
      diagnostics_channel: [">= 14.17 && < 15", ">= 15.1"],
      "node:diagnostics_channel": [">= 14.18 && < 15", ">= 16"],
      dns: true,
      "node:dns": [">= 14.18 && < 15", ">= 16"],
      "dns/promises": ">= 15",
      "node:dns/promises": ">= 16",
      domain: ">= 0.7.12",
      "node:domain": [">= 14.18 && < 15", ">= 16"],
      events: true,
      "node:events": [">= 14.18 && < 15", ">= 16"],
      freelist: "< 6",
      fs: true,
      "node:fs": [">= 14.18 && < 15", ">= 16"],
      "fs/promises": [">= 10 && < 10.1", ">= 14"],
      "node:fs/promises": [">= 14.18 && < 15", ">= 16"],
      _http_agent: ">= 0.11.1",
      "node:_http_agent": [">= 14.18 && < 15", ">= 16"],
      _http_client: ">= 0.11.1",
      "node:_http_client": [">= 14.18 && < 15", ">= 16"],
      _http_common: ">= 0.11.1",
      "node:_http_common": [">= 14.18 && < 15", ">= 16"],
      _http_incoming: ">= 0.11.1",
      "node:_http_incoming": [">= 14.18 && < 15", ">= 16"],
      _http_outgoing: ">= 0.11.1",
      "node:_http_outgoing": [">= 14.18 && < 15", ">= 16"],
      _http_server: ">= 0.11.1",
      "node:_http_server": [">= 14.18 && < 15", ">= 16"],
      http: true,
      "node:http": [">= 14.18 && < 15", ">= 16"],
      http2: ">= 8.8",
      "node:http2": [">= 14.18 && < 15", ">= 16"],
      https: true,
      "node:https": [">= 14.18 && < 15", ">= 16"],
      inspector: ">= 8",
      "node:inspector": [">= 14.18 && < 15", ">= 16"],
      _linklist: "< 8",
      module: true,
      "node:module": [">= 14.18 && < 15", ">= 16"],
      net: true,
      "node:net": [">= 14.18 && < 15", ">= 16"],
      "node-inspect/lib/_inspect": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_client": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_repl": ">= 7.6 && < 12",
      os: true,
      "node:os": [">= 14.18 && < 15", ">= 16"],
      path: true,
      "node:path": [">= 14.18 && < 15", ">= 16"],
      "path/posix": ">= 15.3",
      "node:path/posix": ">= 16",
      "path/win32": ">= 15.3",
      "node:path/win32": ">= 16",
      perf_hooks: ">= 8.5",
      "node:perf_hooks": [">= 14.18 && < 15", ">= 16"],
      process: ">= 1",
      "node:process": [">= 14.18 && < 15", ">= 16"],
      punycode: ">= 0.5",
      "node:punycode": [">= 14.18 && < 15", ">= 16"],
      querystring: true,
      "node:querystring": [">= 14.18 && < 15", ">= 16"],
      readline: true,
      "node:readline": [">= 14.18 && < 15", ">= 16"],
      "readline/promises": ">= 17",
      "node:readline/promises": ">= 17",
      repl: true,
      "node:repl": [">= 14.18 && < 15", ">= 16"],
      smalloc: ">= 0.11.5 && < 3",
      _stream_duplex: ">= 0.9.4",
      "node:_stream_duplex": [">= 14.18 && < 15", ">= 16"],
      _stream_transform: ">= 0.9.4",
      "node:_stream_transform": [">= 14.18 && < 15", ">= 16"],
      _stream_wrap: ">= 1.4.1",
      "node:_stream_wrap": [">= 14.18 && < 15", ">= 16"],
      _stream_passthrough: ">= 0.9.4",
      "node:_stream_passthrough": [">= 14.18 && < 15", ">= 16"],
      _stream_readable: ">= 0.9.4",
      "node:_stream_readable": [">= 14.18 && < 15", ">= 16"],
      _stream_writable: ">= 0.9.4",
      "node:_stream_writable": [">= 14.18 && < 15", ">= 16"],
      stream: true,
      "node:stream": [">= 14.18 && < 15", ">= 16"],
      "stream/consumers": ">= 16.7",
      "node:stream/consumers": ">= 16.7",
      "stream/promises": ">= 15",
      "node:stream/promises": ">= 16",
      "stream/web": ">= 16.5",
      "node:stream/web": ">= 16.5",
      string_decoder: true,
      "node:string_decoder": [">= 14.18 && < 15", ">= 16"],
      sys: [">= 0.4 && < 0.7", ">= 0.8"],
      "node:sys": [">= 14.18 && < 15", ">= 16"],
      timers: true,
      "node:timers": [">= 14.18 && < 15", ">= 16"],
      "timers/promises": ">= 15",
      "node:timers/promises": ">= 16",
      _tls_common: ">= 0.11.13",
      "node:_tls_common": [">= 14.18 && < 15", ">= 16"],
      _tls_legacy: ">= 0.11.3 && < 10",
      _tls_wrap: ">= 0.11.3",
      "node:_tls_wrap": [">= 14.18 && < 15", ">= 16"],
      tls: true,
      "node:tls": [">= 14.18 && < 15", ">= 16"],
      trace_events: ">= 10",
      "node:trace_events": [">= 14.18 && < 15", ">= 16"],
      tty: true,
      "node:tty": [">= 14.18 && < 15", ">= 16"],
      url: true,
      "node:url": [">= 14.18 && < 15", ">= 16"],
      util: true,
      "node:util": [">= 14.18 && < 15", ">= 16"],
      "util/types": ">= 15.3",
      "node:util/types": ">= 16",
      "v8/tools/arguments": ">= 10 && < 12",
      "v8/tools/codemap": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/consarray": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/csvparser": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/logreader": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/profile_view": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/splaytree": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      v8: ">= 1",
      "node:v8": [">= 14.18 && < 15", ">= 16"],
      vm: true,
      "node:vm": [">= 14.18 && < 15", ">= 16"],
      wasi: ">= 13.4 && < 13.5",
      worker_threads: ">= 11.7",
      "node:worker_threads": [">= 14.18 && < 15", ">= 16"],
      zlib: ">= 0.5",
      "node:zlib": [">= 14.18 && < 15", ">= 16"]
    };
  }
});

// node_modules/is-core-module/index.js
var require_is_core_module = __commonJS({
  "node_modules/is-core-module/index.js"(exports2, module2) {
    "use strict";
    var has = require_src();
    function specifierIncluded(current, specifier) {
      var nodeParts = current.split(".");
      var parts = specifier.split(" ");
      var op = parts.length > 1 ? parts[0] : "=";
      var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split(".");
      for (var i2 = 0; i2 < 3; ++i2) {
        var cur = parseInt(nodeParts[i2] || 0, 10);
        var ver = parseInt(versionParts[i2] || 0, 10);
        if (cur === ver) {
          continue;
        }
        if (op === "<") {
          return cur < ver;
        }
        if (op === ">=") {
          return cur >= ver;
        }
        return false;
      }
      return op === ">=";
    }
    function matchesRange(current, range2) {
      var specifiers = range2.split(/ ?&& ?/);
      if (specifiers.length === 0) {
        return false;
      }
      for (var i2 = 0; i2 < specifiers.length; ++i2) {
        if (!specifierIncluded(current, specifiers[i2])) {
          return false;
        }
      }
      return true;
    }
    function versionIncluded(nodeVersion, specifierValue) {
      if (typeof specifierValue === "boolean") {
        return specifierValue;
      }
      var current = typeof nodeVersion === "undefined" ? process.versions && process.versions.node : nodeVersion;
      if (typeof current !== "string") {
        throw new TypeError(typeof nodeVersion === "undefined" ? "Unable to determine current node version" : "If provided, a valid node version is required");
      }
      if (specifierValue && typeof specifierValue === "object") {
        for (var i2 = 0; i2 < specifierValue.length; ++i2) {
          if (matchesRange(current, specifierValue[i2])) {
            return true;
          }
        }
        return false;
      }
      return matchesRange(current, specifierValue);
    }
    var data2 = require_core();
    module2.exports = function isCore(x2, nodeVersion) {
      return has(data2, x2) && versionIncluded(nodeVersion, data2[x2]);
    };
  }
});

// node_modules/resolve/lib/async.js
var require_async = __commonJS({
  "node_modules/resolve/lib/async.js"(exports2, module2) {
    var fs3 = (init_fs(), __toCommonJS(fs_exports));
    var getHomedir = require_homedir();
    var path2 = (init_path(), __toCommonJS(path_exports));
    var caller = require_caller();
    var nodeModulesPaths = require_node_modules_paths();
    var normalizeOptions = require_normalize_options();
    var isCore = require_is_core_module();
    var realpathFS = fs3.realpath && typeof fs3.realpath.native === "function" ? fs3.realpath.native : fs3.realpath;
    var homedir = getHomedir();
    var defaultPaths = function() {
      return [
        path2.join(homedir, ".node_modules"),
        path2.join(homedir, ".node_libraries")
      ];
    };
    var defaultIsFile = function isFile(file, cb) {
      fs3.stat(file, function(err, stat2) {
        if (!err) {
          return cb(null, stat2.isFile() || stat2.isFIFO());
        }
        if (err.code === "ENOENT" || err.code === "ENOTDIR")
          return cb(null, false);
        return cb(err);
      });
    };
    var defaultIsDir = function isDirectory2(dir, cb) {
      fs3.stat(dir, function(err, stat2) {
        if (!err) {
          return cb(null, stat2.isDirectory());
        }
        if (err.code === "ENOENT" || err.code === "ENOTDIR")
          return cb(null, false);
        return cb(err);
      });
    };
    var defaultRealpath = function realpath2(x2, cb) {
      realpathFS(x2, function(realpathErr, realPath) {
        if (realpathErr && realpathErr.code !== "ENOENT")
          cb(realpathErr);
        else
          cb(null, realpathErr ? x2 : realPath);
      });
    };
    var maybeRealpath = function maybeRealpath2(realpath2, x2, opts, cb) {
      if (opts && opts.preserveSymlinks === false) {
        realpath2(x2, cb);
      } else {
        cb(null, x2);
      }
    };
    var defaultReadPackage = function defaultReadPackage2(readFile2, pkgfile, cb) {
      readFile2(pkgfile, function(readFileErr, body) {
        if (readFileErr)
          cb(readFileErr);
        else {
          try {
            var pkg = JSON.parse(body);
            cb(null, pkg);
          } catch (jsonErr) {
            cb(null);
          }
        }
      });
    };
    var getPackageCandidates = function getPackageCandidates2(x2, start, opts) {
      var dirs = nodeModulesPaths(start, opts, x2);
      for (var i2 = 0; i2 < dirs.length; i2++) {
        dirs[i2] = path2.join(dirs[i2], x2);
      }
      return dirs;
    };
    module2.exports = function resolve2(x2, options2, callback) {
      var cb = callback;
      var opts = options2;
      if (typeof options2 === "function") {
        cb = opts;
        opts = {};
      }
      if (typeof x2 !== "string") {
        var err = new TypeError("Path must be a string.");
        return process.nextTick(function() {
          cb(err);
        });
      }
      opts = normalizeOptions(x2, opts);
      var isFile = opts.isFile || defaultIsFile;
      var isDirectory2 = opts.isDirectory || defaultIsDir;
      var readFile2 = opts.readFile || fs3.readFile;
      var realpath2 = opts.realpath || defaultRealpath;
      var readPackage = opts.readPackage || defaultReadPackage;
      if (opts.readFile && opts.readPackage) {
        var conflictErr = new TypeError("`readFile` and `readPackage` are mutually exclusive.");
        return process.nextTick(function() {
          cb(conflictErr);
        });
      }
      var packageIterator = opts.packageIterator;
      var extensions2 = opts.extensions || [".js"];
      var includeCoreModules = opts.includeCoreModules !== false;
      var basedir = opts.basedir || path2.dirname(caller());
      var parent = opts.filename || basedir;
      opts.paths = opts.paths || defaultPaths();
      var absoluteStart = path2.resolve(basedir);
      maybeRealpath(realpath2, absoluteStart, opts, function(err2, realStart) {
        if (err2)
          cb(err2);
        else
          init2(realStart);
      });
      var res;
      function init2(basedir2) {
        if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x2)) {
          res = path2.resolve(basedir2, x2);
          if (x2 === "." || x2 === ".." || x2.slice(-1) === "/")
            res += "/";
          if (/\/$/.test(x2) && res === basedir2) {
            loadAsDirectory(res, opts.package, onfile);
          } else
            loadAsFile(res, opts.package, onfile);
        } else if (includeCoreModules && isCore(x2)) {
          return cb(null, x2);
        } else
          loadNodeModules(x2, basedir2, function(err2, n3, pkg) {
            if (err2)
              cb(err2);
            else if (n3) {
              return maybeRealpath(realpath2, n3, opts, function(err3, realN) {
                if (err3) {
                  cb(err3);
                } else {
                  cb(null, realN, pkg);
                }
              });
            } else {
              var moduleError = new Error("Cannot find module '" + x2 + "' from '" + parent + "'");
              moduleError.code = "MODULE_NOT_FOUND";
              cb(moduleError);
            }
          });
      }
      function onfile(err2, m3, pkg) {
        if (err2)
          cb(err2);
        else if (m3)
          cb(null, m3, pkg);
        else
          loadAsDirectory(res, function(err3, d3, pkg2) {
            if (err3)
              cb(err3);
            else if (d3) {
              maybeRealpath(realpath2, d3, opts, function(err4, realD) {
                if (err4) {
                  cb(err4);
                } else {
                  cb(null, realD, pkg2);
                }
              });
            } else {
              var moduleError = new Error("Cannot find module '" + x2 + "' from '" + parent + "'");
              moduleError.code = "MODULE_NOT_FOUND";
              cb(moduleError);
            }
          });
      }
      function loadAsFile(x3, thePackage, callback2) {
        var loadAsFilePackage = thePackage;
        var cb2 = callback2;
        if (typeof loadAsFilePackage === "function") {
          cb2 = loadAsFilePackage;
          loadAsFilePackage = void 0;
        }
        var exts = [""].concat(extensions2);
        load2(exts, x3, loadAsFilePackage);
        function load2(exts2, x4, loadPackage) {
          if (exts2.length === 0)
            return cb2(null, void 0, loadPackage);
          var file = x4 + exts2[0];
          var pkg = loadPackage;
          if (pkg)
            onpkg(null, pkg);
          else
            loadpkg(path2.dirname(file), onpkg);
          function onpkg(err2, pkg_, dir) {
            pkg = pkg_;
            if (err2)
              return cb2(err2);
            if (dir && pkg && opts.pathFilter) {
              var rfile = path2.relative(dir, file);
              var rel = rfile.slice(0, rfile.length - exts2[0].length);
              var r2 = opts.pathFilter(pkg, x4, rel);
              if (r2)
                return load2([""].concat(extensions2.slice()), path2.resolve(dir, r2), pkg);
            }
            isFile(file, onex);
          }
          function onex(err2, ex) {
            if (err2)
              return cb2(err2);
            if (ex)
              return cb2(null, file, pkg);
            load2(exts2.slice(1), x4, pkg);
          }
        }
      }
      function loadpkg(dir, cb2) {
        if (dir === "" || dir === "/")
          return cb2(null);
        if (process.platform === "win32" && /^\w:[/\\]*$/.test(dir)) {
          return cb2(null);
        }
        if (/[/\\]node_modules[/\\]*$/.test(dir))
          return cb2(null);
        maybeRealpath(realpath2, dir, opts, function(unwrapErr, pkgdir) {
          if (unwrapErr)
            return loadpkg(path2.dirname(dir), cb2);
          var pkgfile = path2.join(pkgdir, "package.json");
          isFile(pkgfile, function(err2, ex) {
            if (!ex)
              return loadpkg(path2.dirname(dir), cb2);
            readPackage(readFile2, pkgfile, function(err3, pkgParam) {
              if (err3)
                cb2(err3);
              var pkg = pkgParam;
              if (pkg && opts.packageFilter) {
                pkg = opts.packageFilter(pkg, pkgfile);
              }
              cb2(null, pkg, dir);
            });
          });
        });
      }
      function loadAsDirectory(x3, loadAsDirectoryPackage, callback2) {
        var cb2 = callback2;
        var fpkg = loadAsDirectoryPackage;
        if (typeof fpkg === "function") {
          cb2 = fpkg;
          fpkg = opts.package;
        }
        maybeRealpath(realpath2, x3, opts, function(unwrapErr, pkgdir) {
          if (unwrapErr)
            return cb2(unwrapErr);
          var pkgfile = path2.join(pkgdir, "package.json");
          isFile(pkgfile, function(err2, ex) {
            if (err2)
              return cb2(err2);
            if (!ex)
              return loadAsFile(path2.join(x3, "index"), fpkg, cb2);
            readPackage(readFile2, pkgfile, function(err3, pkgParam) {
              if (err3)
                return cb2(err3);
              var pkg = pkgParam;
              if (pkg && opts.packageFilter) {
                pkg = opts.packageFilter(pkg, pkgfile);
              }
              if (pkg && pkg.main) {
                if (typeof pkg.main !== "string") {
                  var mainError = new TypeError("package \u201C" + pkg.name + "\u201D `main` must be a string");
                  mainError.code = "INVALID_PACKAGE_MAIN";
                  return cb2(mainError);
                }
                if (pkg.main === "." || pkg.main === "./") {
                  pkg.main = "index";
                }
                loadAsFile(path2.resolve(x3, pkg.main), pkg, function(err4, m3, pkg2) {
                  if (err4)
                    return cb2(err4);
                  if (m3)
                    return cb2(null, m3, pkg2);
                  if (!pkg2)
                    return loadAsFile(path2.join(x3, "index"), pkg2, cb2);
                  var dir = path2.resolve(x3, pkg2.main);
                  loadAsDirectory(dir, pkg2, function(err5, n3, pkg3) {
                    if (err5)
                      return cb2(err5);
                    if (n3)
                      return cb2(null, n3, pkg3);
                    loadAsFile(path2.join(x3, "index"), pkg3, cb2);
                  });
                });
                return;
              }
              loadAsFile(path2.join(x3, "/index"), pkg, cb2);
            });
          });
        });
      }
      function processDirs(cb2, dirs) {
        if (dirs.length === 0)
          return cb2(null, void 0);
        var dir = dirs[0];
        isDirectory2(path2.dirname(dir), isdir);
        function isdir(err2, isdir2) {
          if (err2)
            return cb2(err2);
          if (!isdir2)
            return processDirs(cb2, dirs.slice(1));
          loadAsFile(dir, opts.package, onfile2);
        }
        function onfile2(err2, m3, pkg) {
          if (err2)
            return cb2(err2);
          if (m3)
            return cb2(null, m3, pkg);
          loadAsDirectory(dir, opts.package, ondir);
        }
        function ondir(err2, n3, pkg) {
          if (err2)
            return cb2(err2);
          if (n3)
            return cb2(null, n3, pkg);
          processDirs(cb2, dirs.slice(1));
        }
      }
      function loadNodeModules(x3, start, cb2) {
        var thunk = function() {
          return getPackageCandidates(x3, start, opts);
        };
        processDirs(cb2, packageIterator ? packageIterator(x3, start, thunk, opts) : thunk());
      }
    };
  }
});

// node_modules/resolve/lib/core.json
var require_core2 = __commonJS({
  "node_modules/resolve/lib/core.json"(exports2, module2) {
    module2.exports = {
      assert: true,
      "node:assert": [">= 14.18 && < 15", ">= 16"],
      "assert/strict": ">= 15",
      "node:assert/strict": ">= 16",
      async_hooks: ">= 8",
      "node:async_hooks": [">= 14.18 && < 15", ">= 16"],
      buffer_ieee754: ">= 0.5 && < 0.9.7",
      buffer: true,
      "node:buffer": [">= 14.18 && < 15", ">= 16"],
      child_process: true,
      "node:child_process": [">= 14.18 && < 15", ">= 16"],
      cluster: ">= 0.5",
      "node:cluster": [">= 14.18 && < 15", ">= 16"],
      console: true,
      "node:console": [">= 14.18 && < 15", ">= 16"],
      constants: true,
      "node:constants": [">= 14.18 && < 15", ">= 16"],
      crypto: true,
      "node:crypto": [">= 14.18 && < 15", ">= 16"],
      _debug_agent: ">= 1 && < 8",
      _debugger: "< 8",
      dgram: true,
      "node:dgram": [">= 14.18 && < 15", ">= 16"],
      diagnostics_channel: [">= 14.17 && < 15", ">= 15.1"],
      "node:diagnostics_channel": [">= 14.18 && < 15", ">= 16"],
      dns: true,
      "node:dns": [">= 14.18 && < 15", ">= 16"],
      "dns/promises": ">= 15",
      "node:dns/promises": ">= 16",
      domain: ">= 0.7.12",
      "node:domain": [">= 14.18 && < 15", ">= 16"],
      events: true,
      "node:events": [">= 14.18 && < 15", ">= 16"],
      freelist: "< 6",
      fs: true,
      "node:fs": [">= 14.18 && < 15", ">= 16"],
      "fs/promises": [">= 10 && < 10.1", ">= 14"],
      "node:fs/promises": [">= 14.18 && < 15", ">= 16"],
      _http_agent: ">= 0.11.1",
      "node:_http_agent": [">= 14.18 && < 15", ">= 16"],
      _http_client: ">= 0.11.1",
      "node:_http_client": [">= 14.18 && < 15", ">= 16"],
      _http_common: ">= 0.11.1",
      "node:_http_common": [">= 14.18 && < 15", ">= 16"],
      _http_incoming: ">= 0.11.1",
      "node:_http_incoming": [">= 14.18 && < 15", ">= 16"],
      _http_outgoing: ">= 0.11.1",
      "node:_http_outgoing": [">= 14.18 && < 15", ">= 16"],
      _http_server: ">= 0.11.1",
      "node:_http_server": [">= 14.18 && < 15", ">= 16"],
      http: true,
      "node:http": [">= 14.18 && < 15", ">= 16"],
      http2: ">= 8.8",
      "node:http2": [">= 14.18 && < 15", ">= 16"],
      https: true,
      "node:https": [">= 14.18 && < 15", ">= 16"],
      inspector: ">= 8",
      "node:inspector": [">= 14.18 && < 15", ">= 16"],
      _linklist: "< 8",
      module: true,
      "node:module": [">= 14.18 && < 15", ">= 16"],
      net: true,
      "node:net": [">= 14.18 && < 15", ">= 16"],
      "node-inspect/lib/_inspect": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_client": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_repl": ">= 7.6 && < 12",
      os: true,
      "node:os": [">= 14.18 && < 15", ">= 16"],
      path: true,
      "node:path": [">= 14.18 && < 15", ">= 16"],
      "path/posix": ">= 15.3",
      "node:path/posix": ">= 16",
      "path/win32": ">= 15.3",
      "node:path/win32": ">= 16",
      perf_hooks: ">= 8.5",
      "node:perf_hooks": [">= 14.18 && < 15", ">= 16"],
      process: ">= 1",
      "node:process": [">= 14.18 && < 15", ">= 16"],
      punycode: ">= 0.5",
      "node:punycode": [">= 14.18 && < 15", ">= 16"],
      querystring: true,
      "node:querystring": [">= 14.18 && < 15", ">= 16"],
      readline: true,
      "node:readline": [">= 14.18 && < 15", ">= 16"],
      "readline/promises": ">= 17",
      "node:readline/promises": ">= 17",
      repl: true,
      "node:repl": [">= 14.18 && < 15", ">= 16"],
      smalloc: ">= 0.11.5 && < 3",
      _stream_duplex: ">= 0.9.4",
      "node:_stream_duplex": [">= 14.18 && < 15", ">= 16"],
      _stream_transform: ">= 0.9.4",
      "node:_stream_transform": [">= 14.18 && < 15", ">= 16"],
      _stream_wrap: ">= 1.4.1",
      "node:_stream_wrap": [">= 14.18 && < 15", ">= 16"],
      _stream_passthrough: ">= 0.9.4",
      "node:_stream_passthrough": [">= 14.18 && < 15", ">= 16"],
      _stream_readable: ">= 0.9.4",
      "node:_stream_readable": [">= 14.18 && < 15", ">= 16"],
      _stream_writable: ">= 0.9.4",
      "node:_stream_writable": [">= 14.18 && < 15", ">= 16"],
      stream: true,
      "node:stream": [">= 14.18 && < 15", ">= 16"],
      "stream/consumers": ">= 16.7",
      "node:stream/consumers": ">= 16.7",
      "stream/promises": ">= 15",
      "node:stream/promises": ">= 16",
      "stream/web": ">= 16.5",
      "node:stream/web": ">= 16.5",
      string_decoder: true,
      "node:string_decoder": [">= 14.18 && < 15", ">= 16"],
      sys: [">= 0.4 && < 0.7", ">= 0.8"],
      "node:sys": [">= 14.18 && < 15", ">= 16"],
      timers: true,
      "node:timers": [">= 14.18 && < 15", ">= 16"],
      "timers/promises": ">= 15",
      "node:timers/promises": ">= 16",
      _tls_common: ">= 0.11.13",
      "node:_tls_common": [">= 14.18 && < 15", ">= 16"],
      _tls_legacy: ">= 0.11.3 && < 10",
      _tls_wrap: ">= 0.11.3",
      "node:_tls_wrap": [">= 14.18 && < 15", ">= 16"],
      tls: true,
      "node:tls": [">= 14.18 && < 15", ">= 16"],
      trace_events: ">= 10",
      "node:trace_events": [">= 14.18 && < 15", ">= 16"],
      tty: true,
      "node:tty": [">= 14.18 && < 15", ">= 16"],
      url: true,
      "node:url": [">= 14.18 && < 15", ">= 16"],
      util: true,
      "node:util": [">= 14.18 && < 15", ">= 16"],
      "util/types": ">= 15.3",
      "node:util/types": ">= 16",
      "v8/tools/arguments": ">= 10 && < 12",
      "v8/tools/codemap": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/consarray": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/csvparser": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/logreader": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/profile_view": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/splaytree": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      v8: ">= 1",
      "node:v8": [">= 14.18 && < 15", ">= 16"],
      vm: true,
      "node:vm": [">= 14.18 && < 15", ">= 16"],
      wasi: ">= 13.4 && < 13.5",
      worker_threads: ">= 11.7",
      "node:worker_threads": [">= 14.18 && < 15", ">= 16"],
      zlib: ">= 0.5",
      "node:zlib": [">= 14.18 && < 15", ">= 16"]
    };
  }
});

// node_modules/resolve/lib/core.js
var require_core3 = __commonJS({
  "node_modules/resolve/lib/core.js"(exports2, module2) {
    var current = process.versions && process.versions.node && process.versions.node.split(".") || [];
    function specifierIncluded(specifier) {
      var parts = specifier.split(" ");
      var op = parts.length > 1 ? parts[0] : "=";
      var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split(".");
      for (var i2 = 0; i2 < 3; ++i2) {
        var cur = parseInt(current[i2] || 0, 10);
        var ver = parseInt(versionParts[i2] || 0, 10);
        if (cur === ver) {
          continue;
        }
        if (op === "<") {
          return cur < ver;
        } else if (op === ">=") {
          return cur >= ver;
        }
        return false;
      }
      return op === ">=";
    }
    function matchesRange(range2) {
      var specifiers = range2.split(/ ?&& ?/);
      if (specifiers.length === 0) {
        return false;
      }
      for (var i2 = 0; i2 < specifiers.length; ++i2) {
        if (!specifierIncluded(specifiers[i2])) {
          return false;
        }
      }
      return true;
    }
    function versionIncluded(specifierValue) {
      if (typeof specifierValue === "boolean") {
        return specifierValue;
      }
      if (specifierValue && typeof specifierValue === "object") {
        for (var i2 = 0; i2 < specifierValue.length; ++i2) {
          if (matchesRange(specifierValue[i2])) {
            return true;
          }
        }
        return false;
      }
      return matchesRange(specifierValue);
    }
    var data2 = require_core2();
    var core2 = {};
    for (mod in data2) {
      if (Object.prototype.hasOwnProperty.call(data2, mod)) {
        core2[mod] = versionIncluded(data2[mod]);
      }
    }
    var mod;
    module2.exports = core2;
  }
});

// node_modules/resolve/lib/is-core.js
var require_is_core = __commonJS({
  "node_modules/resolve/lib/is-core.js"(exports2, module2) {
    var isCoreModule = require_is_core_module();
    module2.exports = function isCore(x2) {
      return isCoreModule(x2);
    };
  }
});

// node_modules/resolve/lib/sync.js
var require_sync = __commonJS({
  "node_modules/resolve/lib/sync.js"(exports2, module2) {
    var isCore = require_is_core_module();
    var fs3 = (init_fs(), __toCommonJS(fs_exports));
    var path2 = (init_path(), __toCommonJS(path_exports));
    var getHomedir = require_homedir();
    var caller = require_caller();
    var nodeModulesPaths = require_node_modules_paths();
    var normalizeOptions = require_normalize_options();
    var realpathFS = fs3.realpathSync && typeof fs3.realpathSync.native === "function" ? fs3.realpathSync.native : fs3.realpathSync;
    var homedir = getHomedir();
    var defaultPaths = function() {
      return [
        path2.join(homedir, ".node_modules"),
        path2.join(homedir, ".node_libraries")
      ];
    };
    var defaultIsFile = function isFile(file) {
      try {
        var stat2 = fs3.statSync(file, { throwIfNoEntry: false });
      } catch (e2) {
        if (e2 && (e2.code === "ENOENT" || e2.code === "ENOTDIR"))
          return false;
        throw e2;
      }
      return !!stat2 && (stat2.isFile() || stat2.isFIFO());
    };
    var defaultIsDir = function isDirectory2(dir) {
      try {
        var stat2 = fs3.statSync(dir, { throwIfNoEntry: false });
      } catch (e2) {
        if (e2 && (e2.code === "ENOENT" || e2.code === "ENOTDIR"))
          return false;
        throw e2;
      }
      return !!stat2 && stat2.isDirectory();
    };
    var defaultRealpathSync = function realpathSync2(x2) {
      try {
        return realpathFS(x2);
      } catch (realpathErr) {
        if (realpathErr.code !== "ENOENT") {
          throw realpathErr;
        }
      }
      return x2;
    };
    var maybeRealpathSync = function maybeRealpathSync2(realpathSync2, x2, opts) {
      if (opts && opts.preserveSymlinks === false) {
        return realpathSync2(x2);
      }
      return x2;
    };
    var defaultReadPackageSync = function defaultReadPackageSync2(readFileSync, pkgfile) {
      var body = readFileSync(pkgfile);
      try {
        var pkg = JSON.parse(body);
        return pkg;
      } catch (jsonErr) {
      }
    };
    var getPackageCandidates = function getPackageCandidates2(x2, start, opts) {
      var dirs = nodeModulesPaths(start, opts, x2);
      for (var i2 = 0; i2 < dirs.length; i2++) {
        dirs[i2] = path2.join(dirs[i2], x2);
      }
      return dirs;
    };
    module2.exports = function resolveSync(x2, options2) {
      if (typeof x2 !== "string") {
        throw new TypeError("Path must be a string.");
      }
      var opts = normalizeOptions(x2, options2);
      var isFile = opts.isFile || defaultIsFile;
      var readFileSync = opts.readFileSync || fs3.readFileSync;
      var isDirectory2 = opts.isDirectory || defaultIsDir;
      var realpathSync2 = opts.realpathSync || defaultRealpathSync;
      var readPackageSync = opts.readPackageSync || defaultReadPackageSync;
      if (opts.readFileSync && opts.readPackageSync) {
        throw new TypeError("`readFileSync` and `readPackageSync` are mutually exclusive.");
      }
      var packageIterator = opts.packageIterator;
      var extensions2 = opts.extensions || [".js"];
      var includeCoreModules = opts.includeCoreModules !== false;
      var basedir = opts.basedir || path2.dirname(caller());
      var parent = opts.filename || basedir;
      opts.paths = opts.paths || defaultPaths();
      var absoluteStart = maybeRealpathSync(realpathSync2, path2.resolve(basedir), opts);
      if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x2)) {
        var res = path2.resolve(absoluteStart, x2);
        if (x2 === "." || x2 === ".." || x2.slice(-1) === "/")
          res += "/";
        var m3 = loadAsFileSync(res) || loadAsDirectorySync(res);
        if (m3)
          return maybeRealpathSync(realpathSync2, m3, opts);
      } else if (includeCoreModules && isCore(x2)) {
        return x2;
      } else {
        var n3 = loadNodeModulesSync(x2, absoluteStart);
        if (n3)
          return maybeRealpathSync(realpathSync2, n3, opts);
      }
      var err = new Error("Cannot find module '" + x2 + "' from '" + parent + "'");
      err.code = "MODULE_NOT_FOUND";
      throw err;
      function loadAsFileSync(x3) {
        var pkg = loadpkg(path2.dirname(x3));
        if (pkg && pkg.dir && pkg.pkg && opts.pathFilter) {
          var rfile = path2.relative(pkg.dir, x3);
          var r2 = opts.pathFilter(pkg.pkg, x3, rfile);
          if (r2) {
            x3 = path2.resolve(pkg.dir, r2);
          }
        }
        if (isFile(x3)) {
          return x3;
        }
        for (var i2 = 0; i2 < extensions2.length; i2++) {
          var file = x3 + extensions2[i2];
          if (isFile(file)) {
            return file;
          }
        }
      }
      function loadpkg(dir) {
        if (dir === "" || dir === "/")
          return;
        if (process.platform === "win32" && /^\w:[/\\]*$/.test(dir)) {
          return;
        }
        if (/[/\\]node_modules[/\\]*$/.test(dir))
          return;
        var pkgfile = path2.join(maybeRealpathSync(realpathSync2, dir, opts), "package.json");
        if (!isFile(pkgfile)) {
          return loadpkg(path2.dirname(dir));
        }
        var pkg = readPackageSync(readFileSync, pkgfile);
        if (pkg && opts.packageFilter) {
          pkg = opts.packageFilter(pkg, dir);
        }
        return { pkg, dir };
      }
      function loadAsDirectorySync(x3) {
        var pkgfile = path2.join(maybeRealpathSync(realpathSync2, x3, opts), "/package.json");
        if (isFile(pkgfile)) {
          try {
            var pkg = readPackageSync(readFileSync, pkgfile);
          } catch (e2) {
          }
          if (pkg && opts.packageFilter) {
            pkg = opts.packageFilter(pkg, x3);
          }
          if (pkg && pkg.main) {
            if (typeof pkg.main !== "string") {
              var mainError = new TypeError("package \u201C" + pkg.name + "\u201D `main` must be a string");
              mainError.code = "INVALID_PACKAGE_MAIN";
              throw mainError;
            }
            if (pkg.main === "." || pkg.main === "./") {
              pkg.main = "index";
            }
            try {
              var m4 = loadAsFileSync(path2.resolve(x3, pkg.main));
              if (m4)
                return m4;
              var n4 = loadAsDirectorySync(path2.resolve(x3, pkg.main));
              if (n4)
                return n4;
            } catch (e2) {
            }
          }
        }
        return loadAsFileSync(path2.join(x3, "/index"));
      }
      function loadNodeModulesSync(x3, start) {
        var thunk = function() {
          return getPackageCandidates(x3, start, opts);
        };
        var dirs = packageIterator ? packageIterator(x3, start, thunk, opts) : thunk();
        for (var i2 = 0; i2 < dirs.length; i2++) {
          var dir = dirs[i2];
          if (isDirectory2(path2.dirname(dir))) {
            var m4 = loadAsFileSync(dir);
            if (m4)
              return m4;
            var n4 = loadAsDirectorySync(dir);
            if (n4)
              return n4;
          }
        }
      }
    };
  }
});

// node_modules/resolve/index.js
var require_resolve = __commonJS({
  "node_modules/resolve/index.js"(exports2, module2) {
    var async2 = require_async();
    async2.core = require_core3();
    async2.isCore = require_is_core();
    async2.sync = require_sync();
    module2.exports = async2;
  }
});

// browser-external:module
var module_exports = {};
__export(module_exports, {
  default: () => module_default
});
var module_default;
var init_module = __esm({
  "browser-external:module"() {
    module_default = new Proxy({}, {
      get() {
        throw new Error('Module "module" has been externalized for browser compatibility and cannot be accessed in client code.');
      }
    });
  }
});

// browser-external:perf_hooks
var perf_hooks_exports = {};
__export(perf_hooks_exports, {
  default: () => perf_hooks_default
});
var perf_hooks_default;
var init_perf_hooks = __esm({
  "browser-external:perf_hooks"() {
    perf_hooks_default = new Proxy({}, {
      get() {
        throw new Error('Module "perf_hooks" has been externalized for browser compatibility and cannot be accessed in client code.');
      }
    });
  }
});

// browser-external:https
var https_exports = {};
__export(https_exports, {
  default: () => https_default
});
var https_default;
var init_https = __esm({
  "browser-external:https"() {
    https_default = new Proxy({}, {
      get() {
        throw new Error('Module "https" has been externalized for browser compatibility and cannot be accessed in client code.');
      }
    });
  }
});

// browser-external:zlib
var zlib_exports = {};
__export(zlib_exports, {
  default: () => zlib_default
});
var zlib_default;
var init_zlib = __esm({
  "browser-external:zlib"() {
    zlib_default = new Proxy({}, {
      get() {
        throw new Error('Module "zlib" has been externalized for browser compatibility and cannot be accessed in client code.');
      }
    });
  }
});

// browser-external:crypto
var crypto_exports = {};
__export(crypto_exports, {
  default: () => crypto_default
});
var crypto_default;
var init_crypto = __esm({
  "browser-external:crypto"() {
    crypto_default = new Proxy({}, {
      get() {
        throw new Error('Module "crypto" has been externalized for browser compatibility and cannot be accessed in client code.');
      }
    });
  }
});

// browser-external:tls
var tls_exports = {};
__export(tls_exports, {
  default: () => tls_default
});
var tls_default;
var init_tls = __esm({
  "browser-external:tls"() {
    tls_default = new Proxy({}, {
      get() {
        throw new Error('Module "tls" has been externalized for browser compatibility and cannot be accessed in client code.');
      }
    });
  }
});

// browser-external:assert
var assert_exports = {};
__export(assert_exports, {
  default: () => assert_default
});
var assert_default;
var init_assert = __esm({
  "browser-external:assert"() {
    assert_default = new Proxy({}, {
      get() {
        throw new Error('Module "assert" has been externalized for browser compatibility and cannot be accessed in client code.');
      }
    });
  }
});

// browser-external:child_process
var child_process_exports = {};
__export(child_process_exports, {
  default: () => child_process_default
});
var child_process_default;
var init_child_process = __esm({
  "browser-external:child_process"() {
    child_process_default = new Proxy({}, {
      get() {
        throw new Error('Module "child_process" has been externalized for browser compatibility and cannot be accessed in client code.');
      }
    });
  }
});

// browser-external:worker_threads
var worker_threads_exports = {};
__export(worker_threads_exports, {
  default: () => worker_threads_default
});
var worker_threads_default;
var init_worker_threads = __esm({
  "browser-external:worker_threads"() {
    worker_threads_default = new Proxy({}, {
      get() {
        throw new Error('Module "worker_threads" has been externalized for browser compatibility and cannot be accessed in client code.');
      }
    });
  }
});

// node_modules/esbuild/lib/main.js
var require_main = __commonJS({
  "node_modules/esbuild/lib/main.js"(exports2, module2) {
    var __defProp2 = Object.defineProperty;
    var __defProps2 = Object.defineProperties;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropDescs2 = Object.getOwnPropertyDescriptors;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getOwnPropSymbols2 = Object.getOwnPropertySymbols;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __propIsEnum2 = Object.prototype.propertyIsEnumerable;
    var __defNormalProp2 = (obj, key2, value) => key2 in obj ? __defProp2(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
    var __spreadValues3 = (a2, b2) => {
      for (var prop in b2 || (b2 = {}))
        if (__hasOwnProp2.call(b2, prop))
          __defNormalProp2(a2, prop, b2[prop]);
      if (__getOwnPropSymbols2)
        for (var prop of __getOwnPropSymbols2(b2)) {
          if (__propIsEnum2.call(b2, prop))
            __defNormalProp2(a2, prop, b2[prop]);
        }
      return a2;
    };
    var __spreadProps3 = (a2, b2) => __defProps2(a2, __getOwnPropDescs2(b2));
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to2, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key2 of __getOwnPropNames(from))
          if (!__hasOwnProp2.call(to2, key2) && key2 !== except)
            __defProp2(to2, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc(from, key2)) || desc.enumerable });
      }
      return to2;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
    var node_exports = {};
    __export2(node_exports, {
      analyzeMetafile: () => analyzeMetafile,
      analyzeMetafileSync: () => analyzeMetafileSync,
      build: () => build2,
      buildSync: () => buildSync,
      default: () => node_default,
      formatMessages: () => formatMessages,
      formatMessagesSync: () => formatMessagesSync,
      initialize: () => initialize,
      serve: () => serve,
      transform: () => transform2,
      transformSync: () => transformSync,
      version: () => version2
    });
    module2.exports = __toCommonJS2(node_exports);
    function encodePacket(packet) {
      let visit2 = (value) => {
        if (value === null) {
          bb.write8(0);
        } else if (typeof value === "boolean") {
          bb.write8(1);
          bb.write8(+value);
        } else if (typeof value === "number") {
          bb.write8(2);
          bb.write32(value | 0);
        } else if (typeof value === "string") {
          bb.write8(3);
          bb.write(encodeUTF8(value));
        } else if (value instanceof Uint8Array) {
          bb.write8(4);
          bb.write(value);
        } else if (value instanceof Array) {
          bb.write8(5);
          bb.write32(value.length);
          for (let item of value) {
            visit2(item);
          }
        } else {
          let keys = Object.keys(value);
          bb.write8(6);
          bb.write32(keys.length);
          for (let key2 of keys) {
            bb.write(encodeUTF8(key2));
            visit2(value[key2]);
          }
        }
      };
      let bb = new ByteBuffer();
      bb.write32(0);
      bb.write32(packet.id << 1 | +!packet.isRequest);
      visit2(packet.value);
      writeUInt32LE(bb.buf, bb.len - 4, 0);
      return bb.buf.subarray(0, bb.len);
    }
    function decodePacket(bytes) {
      let visit2 = () => {
        switch (bb.read8()) {
          case 0:
            return null;
          case 1:
            return !!bb.read8();
          case 2:
            return bb.read32();
          case 3:
            return decodeUTF8(bb.read());
          case 4:
            return bb.read();
          case 5: {
            let count = bb.read32();
            let value2 = [];
            for (let i2 = 0; i2 < count; i2++) {
              value2.push(visit2());
            }
            return value2;
          }
          case 6: {
            let count = bb.read32();
            let value2 = {};
            for (let i2 = 0; i2 < count; i2++) {
              value2[decodeUTF8(bb.read())] = visit2();
            }
            return value2;
          }
          default:
            throw new Error("Invalid packet");
        }
      };
      let bb = new ByteBuffer(bytes);
      let id = bb.read32();
      let isRequest = (id & 1) === 0;
      id >>>= 1;
      let value = visit2();
      if (bb.ptr !== bytes.length) {
        throw new Error("Invalid packet");
      }
      return { id, isRequest, value };
    }
    var ByteBuffer = class {
      constructor(buf = new Uint8Array(1024)) {
        this.buf = buf;
        this.len = 0;
        this.ptr = 0;
      }
      _write(delta) {
        if (this.len + delta > this.buf.length) {
          let clone = new Uint8Array((this.len + delta) * 2);
          clone.set(this.buf);
          this.buf = clone;
        }
        this.len += delta;
        return this.len - delta;
      }
      write8(value) {
        let offset2 = this._write(1);
        this.buf[offset2] = value;
      }
      write32(value) {
        let offset2 = this._write(4);
        writeUInt32LE(this.buf, value, offset2);
      }
      write(bytes) {
        let offset2 = this._write(4 + bytes.length);
        writeUInt32LE(this.buf, bytes.length, offset2);
        this.buf.set(bytes, offset2 + 4);
      }
      _read(delta) {
        if (this.ptr + delta > this.buf.length) {
          throw new Error("Invalid packet");
        }
        this.ptr += delta;
        return this.ptr - delta;
      }
      read8() {
        return this.buf[this._read(1)];
      }
      read32() {
        return readUInt32LE(this.buf, this._read(4));
      }
      read() {
        let length = this.read32();
        let bytes = new Uint8Array(length);
        let ptr = this._read(bytes.length);
        bytes.set(this.buf.subarray(ptr, ptr + length));
        return bytes;
      }
    };
    var encodeUTF8;
    var decodeUTF8;
    if (typeof TextEncoder !== "undefined" && typeof TextDecoder !== "undefined") {
      let encoder = new TextEncoder();
      let decoder = new TextDecoder();
      encodeUTF8 = (text) => encoder.encode(text);
      decodeUTF8 = (bytes) => decoder.decode(bytes);
    } else if (typeof Buffer !== "undefined") {
      encodeUTF8 = (text) => {
        let buffer2 = Buffer.from(text);
        if (!(buffer2 instanceof Uint8Array)) {
          buffer2 = new Uint8Array(buffer2);
        }
        return buffer2;
      };
      decodeUTF8 = (bytes) => {
        let { buffer: buffer2, byteOffset, byteLength } = bytes;
        return Buffer.from(buffer2, byteOffset, byteLength).toString();
      };
    } else {
      throw new Error("No UTF-8 codec found");
    }
    function readUInt32LE(buffer2, offset2) {
      return buffer2[offset2++] | buffer2[offset2++] << 8 | buffer2[offset2++] << 16 | buffer2[offset2++] << 24;
    }
    function writeUInt32LE(buffer2, value, offset2) {
      buffer2[offset2++] = value;
      buffer2[offset2++] = value >> 8;
      buffer2[offset2++] = value >> 16;
      buffer2[offset2++] = value >> 24;
    }
    function validateTarget(target) {
      target += "";
      if (target.indexOf(",") >= 0)
        throw new Error(`Invalid target: ${target}`);
      return target;
    }
    var canBeAnything = () => null;
    var mustBeBoolean = (value) => typeof value === "boolean" ? null : "a boolean";
    var mustBeBooleanOrObject = (value) => typeof value === "boolean" || typeof value === "object" && !Array.isArray(value) ? null : "a boolean or an object";
    var mustBeString = (value) => typeof value === "string" ? null : "a string";
    var mustBeRegExp = (value) => value instanceof RegExp ? null : "a RegExp object";
    var mustBeInteger = (value) => typeof value === "number" && value === (value | 0) ? null : "an integer";
    var mustBeFunction = (value) => typeof value === "function" ? null : "a function";
    var mustBeArray = (value) => Array.isArray(value) ? null : "an array";
    var mustBeObject = (value) => typeof value === "object" && value !== null && !Array.isArray(value) ? null : "an object";
    var mustBeWebAssemblyModule = (value) => value instanceof WebAssembly.Module ? null : "a WebAssembly.Module";
    var mustBeArrayOrRecord = (value) => typeof value === "object" && value !== null ? null : "an array or an object";
    var mustBeObjectOrNull = (value) => typeof value === "object" && !Array.isArray(value) ? null : "an object or null";
    var mustBeStringOrBoolean = (value) => typeof value === "string" || typeof value === "boolean" ? null : "a string or a boolean";
    var mustBeStringOrObject = (value) => typeof value === "string" || typeof value === "object" && value !== null && !Array.isArray(value) ? null : "a string or an object";
    var mustBeStringOrArray = (value) => typeof value === "string" || Array.isArray(value) ? null : "a string or an array";
    var mustBeStringOrUint8Array = (value) => typeof value === "string" || value instanceof Uint8Array ? null : "a string or a Uint8Array";
    function getFlag(object, keys, key2, mustBeFn) {
      let value = object[key2];
      keys[key2 + ""] = true;
      if (value === void 0)
        return void 0;
      let mustBe = mustBeFn(value);
      if (mustBe !== null)
        throw new Error(`"${key2}" must be ${mustBe}`);
      return value;
    }
    function checkForInvalidFlags(object, keys, where) {
      for (let key2 in object) {
        if (!(key2 in keys)) {
          throw new Error(`Invalid option ${where}: "${key2}"`);
        }
      }
    }
    function validateInitializeOptions(options2) {
      let keys = /* @__PURE__ */ Object.create(null);
      let wasmURL = getFlag(options2, keys, "wasmURL", mustBeString);
      let wasmModule = getFlag(options2, keys, "wasmModule", mustBeWebAssemblyModule);
      let worker = getFlag(options2, keys, "worker", mustBeBoolean);
      checkForInvalidFlags(options2, keys, "in initialize() call");
      return {
        wasmURL,
        wasmModule,
        worker
      };
    }
    function validateMangleCache(mangleCache) {
      let validated;
      if (mangleCache !== void 0) {
        validated = /* @__PURE__ */ Object.create(null);
        for (let key2 of Object.keys(mangleCache)) {
          let value = mangleCache[key2];
          if (typeof value === "string" || value === false) {
            validated[key2] = value;
          } else {
            throw new Error(`Expected ${JSON.stringify(key2)} in mangle cache to map to either a string or false`);
          }
        }
      }
      return validated;
    }
    function pushLogFlags(flags, options2, keys, isTTY2, logLevelDefault) {
      let color = getFlag(options2, keys, "color", mustBeBoolean);
      let logLevel = getFlag(options2, keys, "logLevel", mustBeString);
      let logLimit = getFlag(options2, keys, "logLimit", mustBeInteger);
      if (color !== void 0)
        flags.push(`--color=${color}`);
      else if (isTTY2)
        flags.push(`--color=true`);
      flags.push(`--log-level=${logLevel || logLevelDefault}`);
      flags.push(`--log-limit=${logLimit || 0}`);
    }
    function pushCommonFlags(flags, options2, keys) {
      let legalComments = getFlag(options2, keys, "legalComments", mustBeString);
      let sourceRoot = getFlag(options2, keys, "sourceRoot", mustBeString);
      let sourcesContent = getFlag(options2, keys, "sourcesContent", mustBeBoolean);
      let target = getFlag(options2, keys, "target", mustBeStringOrArray);
      let format2 = getFlag(options2, keys, "format", mustBeString);
      let globalName = getFlag(options2, keys, "globalName", mustBeString);
      let mangleProps = getFlag(options2, keys, "mangleProps", mustBeRegExp);
      let reserveProps = getFlag(options2, keys, "reserveProps", mustBeRegExp);
      let mangleQuoted = getFlag(options2, keys, "mangleQuoted", mustBeBoolean);
      let minify = getFlag(options2, keys, "minify", mustBeBoolean);
      let minifySyntax = getFlag(options2, keys, "minifySyntax", mustBeBoolean);
      let minifyWhitespace = getFlag(options2, keys, "minifyWhitespace", mustBeBoolean);
      let minifyIdentifiers = getFlag(options2, keys, "minifyIdentifiers", mustBeBoolean);
      let drop = getFlag(options2, keys, "drop", mustBeArray);
      let charset = getFlag(options2, keys, "charset", mustBeString);
      let treeShaking = getFlag(options2, keys, "treeShaking", mustBeBoolean);
      let ignoreAnnotations = getFlag(options2, keys, "ignoreAnnotations", mustBeBoolean);
      let jsx = getFlag(options2, keys, "jsx", mustBeString);
      let jsxFactory = getFlag(options2, keys, "jsxFactory", mustBeString);
      let jsxFragment = getFlag(options2, keys, "jsxFragment", mustBeString);
      let define = getFlag(options2, keys, "define", mustBeObject);
      let pure = getFlag(options2, keys, "pure", mustBeArray);
      let keepNames = getFlag(options2, keys, "keepNames", mustBeBoolean);
      if (legalComments)
        flags.push(`--legal-comments=${legalComments}`);
      if (sourceRoot !== void 0)
        flags.push(`--source-root=${sourceRoot}`);
      if (sourcesContent !== void 0)
        flags.push(`--sources-content=${sourcesContent}`);
      if (target) {
        if (Array.isArray(target))
          flags.push(`--target=${Array.from(target).map(validateTarget).join(",")}`);
        else
          flags.push(`--target=${validateTarget(target)}`);
      }
      if (format2)
        flags.push(`--format=${format2}`);
      if (globalName)
        flags.push(`--global-name=${globalName}`);
      if (minify)
        flags.push("--minify");
      if (minifySyntax)
        flags.push("--minify-syntax");
      if (minifyWhitespace)
        flags.push("--minify-whitespace");
      if (minifyIdentifiers)
        flags.push("--minify-identifiers");
      if (charset)
        flags.push(`--charset=${charset}`);
      if (treeShaking !== void 0)
        flags.push(`--tree-shaking=${treeShaking}`);
      if (ignoreAnnotations)
        flags.push(`--ignore-annotations`);
      if (drop)
        for (let what of drop)
          flags.push(`--drop:${what}`);
      if (mangleProps)
        flags.push(`--mangle-props=${mangleProps.source}`);
      if (reserveProps)
        flags.push(`--reserve-props=${reserveProps.source}`);
      if (mangleQuoted !== void 0)
        flags.push(`--mangle-quoted=${mangleQuoted}`);
      if (jsx)
        flags.push(`--jsx=${jsx}`);
      if (jsxFactory)
        flags.push(`--jsx-factory=${jsxFactory}`);
      if (jsxFragment)
        flags.push(`--jsx-fragment=${jsxFragment}`);
      if (define) {
        for (let key2 in define) {
          if (key2.indexOf("=") >= 0)
            throw new Error(`Invalid define: ${key2}`);
          flags.push(`--define:${key2}=${define[key2]}`);
        }
      }
      if (pure)
        for (let fn2 of pure)
          flags.push(`--pure:${fn2}`);
      if (keepNames)
        flags.push(`--keep-names`);
    }
    function flagsForBuildOptions(callName, options2, isTTY2, logLevelDefault, writeDefault) {
      var _a22;
      let flags = [];
      let entries = [];
      let keys = /* @__PURE__ */ Object.create(null);
      let stdinContents = null;
      let stdinResolveDir = null;
      let watchMode = null;
      pushLogFlags(flags, options2, keys, isTTY2, logLevelDefault);
      pushCommonFlags(flags, options2, keys);
      let sourcemap = getFlag(options2, keys, "sourcemap", mustBeStringOrBoolean);
      let bundle = getFlag(options2, keys, "bundle", mustBeBoolean);
      let watch2 = getFlag(options2, keys, "watch", mustBeBooleanOrObject);
      let splitting = getFlag(options2, keys, "splitting", mustBeBoolean);
      let preserveSymlinks = getFlag(options2, keys, "preserveSymlinks", mustBeBoolean);
      let metafile = getFlag(options2, keys, "metafile", mustBeBoolean);
      let outfile = getFlag(options2, keys, "outfile", mustBeString);
      let outdir = getFlag(options2, keys, "outdir", mustBeString);
      let outbase = getFlag(options2, keys, "outbase", mustBeString);
      let platform2 = getFlag(options2, keys, "platform", mustBeString);
      let tsconfig = getFlag(options2, keys, "tsconfig", mustBeString);
      let resolveExtensions = getFlag(options2, keys, "resolveExtensions", mustBeArray);
      let nodePathsInput = getFlag(options2, keys, "nodePaths", mustBeArray);
      let mainFields = getFlag(options2, keys, "mainFields", mustBeArray);
      let conditions = getFlag(options2, keys, "conditions", mustBeArray);
      let external = getFlag(options2, keys, "external", mustBeArray);
      let loader = getFlag(options2, keys, "loader", mustBeObject);
      let outExtension = getFlag(options2, keys, "outExtension", mustBeObject);
      let publicPath = getFlag(options2, keys, "publicPath", mustBeString);
      let entryNames = getFlag(options2, keys, "entryNames", mustBeString);
      let chunkNames = getFlag(options2, keys, "chunkNames", mustBeString);
      let assetNames = getFlag(options2, keys, "assetNames", mustBeString);
      let inject = getFlag(options2, keys, "inject", mustBeArray);
      let banner = getFlag(options2, keys, "banner", mustBeObject);
      let footer = getFlag(options2, keys, "footer", mustBeObject);
      let entryPoints = getFlag(options2, keys, "entryPoints", mustBeArrayOrRecord);
      let absWorkingDir = getFlag(options2, keys, "absWorkingDir", mustBeString);
      let stdin = getFlag(options2, keys, "stdin", mustBeObject);
      let write = (_a22 = getFlag(options2, keys, "write", mustBeBoolean)) != null ? _a22 : writeDefault;
      let allowOverwrite = getFlag(options2, keys, "allowOverwrite", mustBeBoolean);
      let incremental = getFlag(options2, keys, "incremental", mustBeBoolean) === true;
      let mangleCache = getFlag(options2, keys, "mangleCache", mustBeObject);
      keys.plugins = true;
      checkForInvalidFlags(options2, keys, `in ${callName}() call`);
      if (sourcemap)
        flags.push(`--sourcemap${sourcemap === true ? "" : `=${sourcemap}`}`);
      if (bundle)
        flags.push("--bundle");
      if (allowOverwrite)
        flags.push("--allow-overwrite");
      if (watch2) {
        flags.push("--watch");
        if (typeof watch2 === "boolean") {
          watchMode = {};
        } else {
          let watchKeys = /* @__PURE__ */ Object.create(null);
          let onRebuild = getFlag(watch2, watchKeys, "onRebuild", mustBeFunction);
          checkForInvalidFlags(watch2, watchKeys, `on "watch" in ${callName}() call`);
          watchMode = { onRebuild };
        }
      }
      if (splitting)
        flags.push("--splitting");
      if (preserveSymlinks)
        flags.push("--preserve-symlinks");
      if (metafile)
        flags.push(`--metafile`);
      if (outfile)
        flags.push(`--outfile=${outfile}`);
      if (outdir)
        flags.push(`--outdir=${outdir}`);
      if (outbase)
        flags.push(`--outbase=${outbase}`);
      if (platform2)
        flags.push(`--platform=${platform2}`);
      if (tsconfig)
        flags.push(`--tsconfig=${tsconfig}`);
      if (resolveExtensions) {
        let values = [];
        for (let value of resolveExtensions) {
          value += "";
          if (value.indexOf(",") >= 0)
            throw new Error(`Invalid resolve extension: ${value}`);
          values.push(value);
        }
        flags.push(`--resolve-extensions=${values.join(",")}`);
      }
      if (publicPath)
        flags.push(`--public-path=${publicPath}`);
      if (entryNames)
        flags.push(`--entry-names=${entryNames}`);
      if (chunkNames)
        flags.push(`--chunk-names=${chunkNames}`);
      if (assetNames)
        flags.push(`--asset-names=${assetNames}`);
      if (mainFields) {
        let values = [];
        for (let value of mainFields) {
          value += "";
          if (value.indexOf(",") >= 0)
            throw new Error(`Invalid main field: ${value}`);
          values.push(value);
        }
        flags.push(`--main-fields=${values.join(",")}`);
      }
      if (conditions) {
        let values = [];
        for (let value of conditions) {
          value += "";
          if (value.indexOf(",") >= 0)
            throw new Error(`Invalid condition: ${value}`);
          values.push(value);
        }
        flags.push(`--conditions=${values.join(",")}`);
      }
      if (external)
        for (let name of external)
          flags.push(`--external:${name}`);
      if (banner) {
        for (let type in banner) {
          if (type.indexOf("=") >= 0)
            throw new Error(`Invalid banner file type: ${type}`);
          flags.push(`--banner:${type}=${banner[type]}`);
        }
      }
      if (footer) {
        for (let type in footer) {
          if (type.indexOf("=") >= 0)
            throw new Error(`Invalid footer file type: ${type}`);
          flags.push(`--footer:${type}=${footer[type]}`);
        }
      }
      if (inject)
        for (let path3 of inject)
          flags.push(`--inject:${path3}`);
      if (loader) {
        for (let ext2 in loader) {
          if (ext2.indexOf("=") >= 0)
            throw new Error(`Invalid loader extension: ${ext2}`);
          flags.push(`--loader:${ext2}=${loader[ext2]}`);
        }
      }
      if (outExtension) {
        for (let ext2 in outExtension) {
          if (ext2.indexOf("=") >= 0)
            throw new Error(`Invalid out extension: ${ext2}`);
          flags.push(`--out-extension:${ext2}=${outExtension[ext2]}`);
        }
      }
      if (entryPoints) {
        if (Array.isArray(entryPoints)) {
          for (let entryPoint of entryPoints) {
            entries.push(["", entryPoint + ""]);
          }
        } else {
          for (let [key2, value] of Object.entries(entryPoints)) {
            entries.push([key2 + "", value + ""]);
          }
        }
      }
      if (stdin) {
        let stdinKeys = /* @__PURE__ */ Object.create(null);
        let contents = getFlag(stdin, stdinKeys, "contents", mustBeString);
        let resolveDir = getFlag(stdin, stdinKeys, "resolveDir", mustBeString);
        let sourcefile = getFlag(stdin, stdinKeys, "sourcefile", mustBeString);
        let loader2 = getFlag(stdin, stdinKeys, "loader", mustBeString);
        checkForInvalidFlags(stdin, stdinKeys, 'in "stdin" object');
        if (sourcefile)
          flags.push(`--sourcefile=${sourcefile}`);
        if (loader2)
          flags.push(`--loader=${loader2}`);
        if (resolveDir)
          stdinResolveDir = resolveDir + "";
        stdinContents = contents ? contents + "" : "";
      }
      let nodePaths = [];
      if (nodePathsInput) {
        for (let value of nodePathsInput) {
          value += "";
          nodePaths.push(value);
        }
      }
      return {
        entries,
        flags,
        write,
        stdinContents,
        stdinResolveDir,
        absWorkingDir,
        incremental,
        nodePaths,
        watch: watchMode,
        mangleCache: validateMangleCache(mangleCache)
      };
    }
    function flagsForTransformOptions(callName, options2, isTTY2, logLevelDefault) {
      let flags = [];
      let keys = /* @__PURE__ */ Object.create(null);
      pushLogFlags(flags, options2, keys, isTTY2, logLevelDefault);
      pushCommonFlags(flags, options2, keys);
      let sourcemap = getFlag(options2, keys, "sourcemap", mustBeStringOrBoolean);
      let tsconfigRaw = getFlag(options2, keys, "tsconfigRaw", mustBeStringOrObject);
      let sourcefile = getFlag(options2, keys, "sourcefile", mustBeString);
      let loader = getFlag(options2, keys, "loader", mustBeString);
      let banner = getFlag(options2, keys, "banner", mustBeString);
      let footer = getFlag(options2, keys, "footer", mustBeString);
      let mangleCache = getFlag(options2, keys, "mangleCache", mustBeObject);
      checkForInvalidFlags(options2, keys, `in ${callName}() call`);
      if (sourcemap)
        flags.push(`--sourcemap=${sourcemap === true ? "external" : sourcemap}`);
      if (tsconfigRaw)
        flags.push(`--tsconfig-raw=${typeof tsconfigRaw === "string" ? tsconfigRaw : JSON.stringify(tsconfigRaw)}`);
      if (sourcefile)
        flags.push(`--sourcefile=${sourcefile}`);
      if (loader)
        flags.push(`--loader=${loader}`);
      if (banner)
        flags.push(`--banner=${banner}`);
      if (footer)
        flags.push(`--footer=${footer}`);
      return {
        flags,
        mangleCache: validateMangleCache(mangleCache)
      };
    }
    function createChannel(streamIn) {
      let responseCallbacks = /* @__PURE__ */ new Map();
      let pluginCallbacks = /* @__PURE__ */ new Map();
      let watchCallbacks = /* @__PURE__ */ new Map();
      let serveCallbacks = /* @__PURE__ */ new Map();
      let closeData = null;
      let nextRequestID = 0;
      let nextBuildKey = 0;
      let stdout = new Uint8Array(16 * 1024);
      let stdoutUsed = 0;
      let readFromStdout = (chunk) => {
        let limit = stdoutUsed + chunk.length;
        if (limit > stdout.length) {
          let swap = new Uint8Array(limit * 2);
          swap.set(stdout);
          stdout = swap;
        }
        stdout.set(chunk, stdoutUsed);
        stdoutUsed += chunk.length;
        let offset2 = 0;
        while (offset2 + 4 <= stdoutUsed) {
          let length = readUInt32LE(stdout, offset2);
          if (offset2 + 4 + length > stdoutUsed) {
            break;
          }
          offset2 += 4;
          handleIncomingPacket(stdout.subarray(offset2, offset2 + length));
          offset2 += length;
        }
        if (offset2 > 0) {
          stdout.copyWithin(0, offset2, stdoutUsed);
          stdoutUsed -= offset2;
        }
      };
      let afterClose = (error2) => {
        closeData = { reason: error2 ? ": " + (error2.message || error2) : "" };
        const text = "The service was stopped" + closeData.reason;
        for (let callback of responseCallbacks.values()) {
          callback(text, null);
        }
        responseCallbacks.clear();
        for (let callbacks of serveCallbacks.values()) {
          callbacks.onWait(text);
        }
        serveCallbacks.clear();
        for (let callback of watchCallbacks.values()) {
          try {
            callback(new Error(text), null);
          } catch (e2) {
            console.error(e2);
          }
        }
        watchCallbacks.clear();
      };
      let sendRequest = (refs, value, callback) => {
        if (closeData)
          return callback("The service is no longer running" + closeData.reason, null);
        let id = nextRequestID++;
        responseCallbacks.set(id, (error2, response) => {
          try {
            callback(error2, response);
          } finally {
            if (refs)
              refs.unref();
          }
        });
        if (refs)
          refs.ref();
        streamIn.writeToStdin(encodePacket({ id, isRequest: true, value }));
      };
      let sendResponse = (id, value) => {
        if (closeData)
          throw new Error("The service is no longer running" + closeData.reason);
        streamIn.writeToStdin(encodePacket({ id, isRequest: false, value }));
      };
      let handleRequest = async (id, request) => {
        try {
          switch (request.command) {
            case "ping": {
              sendResponse(id, {});
              break;
            }
            case "on-start": {
              let callback = pluginCallbacks.get(request.key);
              if (!callback)
                sendResponse(id, {});
              else
                sendResponse(id, await callback(request));
              break;
            }
            case "on-resolve": {
              let callback = pluginCallbacks.get(request.key);
              if (!callback)
                sendResponse(id, {});
              else
                sendResponse(id, await callback(request));
              break;
            }
            case "on-load": {
              let callback = pluginCallbacks.get(request.key);
              if (!callback)
                sendResponse(id, {});
              else
                sendResponse(id, await callback(request));
              break;
            }
            case "serve-request": {
              let callbacks = serveCallbacks.get(request.key);
              if (callbacks && callbacks.onRequest)
                callbacks.onRequest(request.args);
              sendResponse(id, {});
              break;
            }
            case "serve-wait": {
              let callbacks = serveCallbacks.get(request.key);
              if (callbacks)
                callbacks.onWait(request.error);
              sendResponse(id, {});
              break;
            }
            case "watch-rebuild": {
              let callback = watchCallbacks.get(request.key);
              try {
                if (callback)
                  callback(null, request.args);
              } catch (err) {
                console.error(err);
              }
              sendResponse(id, {});
              break;
            }
            default:
              throw new Error(`Invalid command: ` + request.command);
          }
        } catch (e2) {
          sendResponse(id, { errors: [extractErrorMessageV8(e2, streamIn, null, void 0, "")] });
        }
      };
      let isFirstPacket = true;
      let handleIncomingPacket = (bytes) => {
        if (isFirstPacket) {
          isFirstPacket = false;
          let binaryVersion = String.fromCharCode(...bytes);
          if (binaryVersion !== "0.14.34") {
            throw new Error(`Cannot start service: Host version "${"0.14.34"}" does not match binary version ${JSON.stringify(binaryVersion)}`);
          }
          return;
        }
        let packet = decodePacket(bytes);
        if (packet.isRequest) {
          handleRequest(packet.id, packet.value);
        } else {
          let callback = responseCallbacks.get(packet.id);
          responseCallbacks.delete(packet.id);
          if (packet.value.error)
            callback(packet.value.error, {});
          else
            callback(null, packet.value);
        }
      };
      let handlePlugins = async (initialOptions, plugins2, buildKey, stash, refs) => {
        let onStartCallbacks = [];
        let onEndCallbacks = [];
        let onResolveCallbacks = {};
        let onLoadCallbacks = {};
        let nextCallbackID = 0;
        let i2 = 0;
        let requestPlugins = [];
        let isSetupDone = false;
        plugins2 = [...plugins2];
        for (let item of plugins2) {
          let keys = {};
          if (typeof item !== "object")
            throw new Error(`Plugin at index ${i2} must be an object`);
          const name = getFlag(item, keys, "name", mustBeString);
          if (typeof name !== "string" || name === "")
            throw new Error(`Plugin at index ${i2} is missing a name`);
          try {
            let setup2 = getFlag(item, keys, "setup", mustBeFunction);
            if (typeof setup2 !== "function")
              throw new Error(`Plugin is missing a setup function`);
            checkForInvalidFlags(item, keys, `on plugin ${JSON.stringify(name)}`);
            let plugin = {
              name,
              onResolve: [],
              onLoad: []
            };
            i2++;
            let resolve2 = (path3, options2 = {}) => {
              if (!isSetupDone)
                throw new Error('Cannot call "resolve" before plugin setup has completed');
              if (typeof path3 !== "string")
                throw new Error(`The path to resolve must be a string`);
              let keys2 = /* @__PURE__ */ Object.create(null);
              let pluginName = getFlag(options2, keys2, "pluginName", mustBeString);
              let importer = getFlag(options2, keys2, "importer", mustBeString);
              let namespace = getFlag(options2, keys2, "namespace", mustBeString);
              let resolveDir = getFlag(options2, keys2, "resolveDir", mustBeString);
              let kind = getFlag(options2, keys2, "kind", mustBeString);
              let pluginData = getFlag(options2, keys2, "pluginData", canBeAnything);
              checkForInvalidFlags(options2, keys2, "in resolve() call");
              return new Promise((resolve22, reject) => {
                const request = {
                  command: "resolve",
                  path: path3,
                  key: buildKey,
                  pluginName: name
                };
                if (pluginName != null)
                  request.pluginName = pluginName;
                if (importer != null)
                  request.importer = importer;
                if (namespace != null)
                  request.namespace = namespace;
                if (resolveDir != null)
                  request.resolveDir = resolveDir;
                if (kind != null)
                  request.kind = kind;
                if (pluginData != null)
                  request.pluginData = stash.store(pluginData);
                sendRequest(refs, request, (error2, response) => {
                  if (error2 !== null)
                    reject(new Error(error2));
                  else
                    resolve22({
                      errors: replaceDetailsInMessages(response.errors, stash),
                      warnings: replaceDetailsInMessages(response.warnings, stash),
                      path: response.path,
                      external: response.external,
                      sideEffects: response.sideEffects,
                      namespace: response.namespace,
                      suffix: response.suffix,
                      pluginData: stash.load(response.pluginData)
                    });
                });
              });
            };
            let promise2 = setup2({
              initialOptions,
              resolve: resolve2,
              onStart(callback2) {
                let registeredText = `This error came from the "onStart" callback registered here:`;
                let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onStart");
                onStartCallbacks.push({ name, callback: callback2, note: registeredNote });
              },
              onEnd(callback2) {
                let registeredText = `This error came from the "onEnd" callback registered here:`;
                let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onEnd");
                onEndCallbacks.push({ name, callback: callback2, note: registeredNote });
              },
              onResolve(options2, callback2) {
                let registeredText = `This error came from the "onResolve" callback registered here:`;
                let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onResolve");
                let keys2 = {};
                let filter2 = getFlag(options2, keys2, "filter", mustBeRegExp);
                let namespace = getFlag(options2, keys2, "namespace", mustBeString);
                checkForInvalidFlags(options2, keys2, `in onResolve() call for plugin ${JSON.stringify(name)}`);
                if (filter2 == null)
                  throw new Error(`onResolve() call is missing a filter`);
                let id = nextCallbackID++;
                onResolveCallbacks[id] = { name, callback: callback2, note: registeredNote };
                plugin.onResolve.push({ id, filter: filter2.source, namespace: namespace || "" });
              },
              onLoad(options2, callback2) {
                let registeredText = `This error came from the "onLoad" callback registered here:`;
                let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onLoad");
                let keys2 = {};
                let filter2 = getFlag(options2, keys2, "filter", mustBeRegExp);
                let namespace = getFlag(options2, keys2, "namespace", mustBeString);
                checkForInvalidFlags(options2, keys2, `in onLoad() call for plugin ${JSON.stringify(name)}`);
                if (filter2 == null)
                  throw new Error(`onLoad() call is missing a filter`);
                let id = nextCallbackID++;
                onLoadCallbacks[id] = { name, callback: callback2, note: registeredNote };
                plugin.onLoad.push({ id, filter: filter2.source, namespace: namespace || "" });
              },
              esbuild: streamIn.esbuild
            });
            if (promise2)
              await promise2;
            requestPlugins.push(plugin);
          } catch (e2) {
            return { ok: false, error: e2, pluginName: name };
          }
        }
        const callback = async (request) => {
          switch (request.command) {
            case "on-start": {
              let response = { errors: [], warnings: [] };
              await Promise.all(onStartCallbacks.map(async ({ name, callback: callback2, note }) => {
                try {
                  let result2 = await callback2();
                  if (result2 != null) {
                    if (typeof result2 !== "object")
                      throw new Error(`Expected onStart() callback in plugin ${JSON.stringify(name)} to return an object`);
                    let keys = {};
                    let errors = getFlag(result2, keys, "errors", mustBeArray);
                    let warnings2 = getFlag(result2, keys, "warnings", mustBeArray);
                    checkForInvalidFlags(result2, keys, `from onStart() callback in plugin ${JSON.stringify(name)}`);
                    if (errors != null)
                      response.errors.push(...sanitizeMessages(errors, "errors", stash, name));
                    if (warnings2 != null)
                      response.warnings.push(...sanitizeMessages(warnings2, "warnings", stash, name));
                  }
                } catch (e2) {
                  response.errors.push(extractErrorMessageV8(e2, streamIn, stash, note && note(), name));
                }
              }));
              return response;
            }
            case "on-resolve": {
              let response = {}, name = "", callback2, note;
              for (let id of request.ids) {
                try {
                  ({ name, callback: callback2, note } = onResolveCallbacks[id]);
                  let result2 = await callback2({
                    path: request.path,
                    importer: request.importer,
                    namespace: request.namespace,
                    resolveDir: request.resolveDir,
                    kind: request.kind,
                    pluginData: stash.load(request.pluginData)
                  });
                  if (result2 != null) {
                    if (typeof result2 !== "object")
                      throw new Error(`Expected onResolve() callback in plugin ${JSON.stringify(name)} to return an object`);
                    let keys = {};
                    let pluginName = getFlag(result2, keys, "pluginName", mustBeString);
                    let path3 = getFlag(result2, keys, "path", mustBeString);
                    let namespace = getFlag(result2, keys, "namespace", mustBeString);
                    let suffix = getFlag(result2, keys, "suffix", mustBeString);
                    let external = getFlag(result2, keys, "external", mustBeBoolean);
                    let sideEffects = getFlag(result2, keys, "sideEffects", mustBeBoolean);
                    let pluginData = getFlag(result2, keys, "pluginData", canBeAnything);
                    let errors = getFlag(result2, keys, "errors", mustBeArray);
                    let warnings2 = getFlag(result2, keys, "warnings", mustBeArray);
                    let watchFiles = getFlag(result2, keys, "watchFiles", mustBeArray);
                    let watchDirs = getFlag(result2, keys, "watchDirs", mustBeArray);
                    checkForInvalidFlags(result2, keys, `from onResolve() callback in plugin ${JSON.stringify(name)}`);
                    response.id = id;
                    if (pluginName != null)
                      response.pluginName = pluginName;
                    if (path3 != null)
                      response.path = path3;
                    if (namespace != null)
                      response.namespace = namespace;
                    if (suffix != null)
                      response.suffix = suffix;
                    if (external != null)
                      response.external = external;
                    if (sideEffects != null)
                      response.sideEffects = sideEffects;
                    if (pluginData != null)
                      response.pluginData = stash.store(pluginData);
                    if (errors != null)
                      response.errors = sanitizeMessages(errors, "errors", stash, name);
                    if (warnings2 != null)
                      response.warnings = sanitizeMessages(warnings2, "warnings", stash, name);
                    if (watchFiles != null)
                      response.watchFiles = sanitizeStringArray(watchFiles, "watchFiles");
                    if (watchDirs != null)
                      response.watchDirs = sanitizeStringArray(watchDirs, "watchDirs");
                    break;
                  }
                } catch (e2) {
                  return { id, errors: [extractErrorMessageV8(e2, streamIn, stash, note && note(), name)] };
                }
              }
              return response;
            }
            case "on-load": {
              let response = {}, name = "", callback2, note;
              for (let id of request.ids) {
                try {
                  ({ name, callback: callback2, note } = onLoadCallbacks[id]);
                  let result2 = await callback2({
                    path: request.path,
                    namespace: request.namespace,
                    suffix: request.suffix,
                    pluginData: stash.load(request.pluginData)
                  });
                  if (result2 != null) {
                    if (typeof result2 !== "object")
                      throw new Error(`Expected onLoad() callback in plugin ${JSON.stringify(name)} to return an object`);
                    let keys = {};
                    let pluginName = getFlag(result2, keys, "pluginName", mustBeString);
                    let contents = getFlag(result2, keys, "contents", mustBeStringOrUint8Array);
                    let resolveDir = getFlag(result2, keys, "resolveDir", mustBeString);
                    let pluginData = getFlag(result2, keys, "pluginData", canBeAnything);
                    let loader = getFlag(result2, keys, "loader", mustBeString);
                    let errors = getFlag(result2, keys, "errors", mustBeArray);
                    let warnings2 = getFlag(result2, keys, "warnings", mustBeArray);
                    let watchFiles = getFlag(result2, keys, "watchFiles", mustBeArray);
                    let watchDirs = getFlag(result2, keys, "watchDirs", mustBeArray);
                    checkForInvalidFlags(result2, keys, `from onLoad() callback in plugin ${JSON.stringify(name)}`);
                    response.id = id;
                    if (pluginName != null)
                      response.pluginName = pluginName;
                    if (contents instanceof Uint8Array)
                      response.contents = contents;
                    else if (contents != null)
                      response.contents = encodeUTF8(contents);
                    if (resolveDir != null)
                      response.resolveDir = resolveDir;
                    if (pluginData != null)
                      response.pluginData = stash.store(pluginData);
                    if (loader != null)
                      response.loader = loader;
                    if (errors != null)
                      response.errors = sanitizeMessages(errors, "errors", stash, name);
                    if (warnings2 != null)
                      response.warnings = sanitizeMessages(warnings2, "warnings", stash, name);
                    if (watchFiles != null)
                      response.watchFiles = sanitizeStringArray(watchFiles, "watchFiles");
                    if (watchDirs != null)
                      response.watchDirs = sanitizeStringArray(watchDirs, "watchDirs");
                    break;
                  }
                } catch (e2) {
                  return { id, errors: [extractErrorMessageV8(e2, streamIn, stash, note && note(), name)] };
                }
              }
              return response;
            }
            default:
              throw new Error(`Invalid command: ` + request.command);
          }
        };
        let runOnEndCallbacks = (result2, logPluginError, done) => done();
        if (onEndCallbacks.length > 0) {
          runOnEndCallbacks = (result2, logPluginError, done) => {
            (async () => {
              for (const { name, callback: callback2, note } of onEndCallbacks) {
                try {
                  await callback2(result2);
                } catch (e2) {
                  result2.errors.push(await new Promise((resolve2) => logPluginError(e2, name, note && note(), resolve2)));
                }
              }
            })().then(done);
          };
        }
        isSetupDone = true;
        let refCount = 0;
        return {
          ok: true,
          requestPlugins,
          runOnEndCallbacks,
          pluginRefs: {
            ref() {
              if (++refCount === 1)
                pluginCallbacks.set(buildKey, callback);
            },
            unref() {
              if (--refCount === 0)
                pluginCallbacks.delete(buildKey);
            }
          }
        };
      };
      let buildServeData = (refs, options2, request, key2) => {
        let keys = {};
        let port = getFlag(options2, keys, "port", mustBeInteger);
        let host = getFlag(options2, keys, "host", mustBeString);
        let servedir = getFlag(options2, keys, "servedir", mustBeString);
        let onRequest = getFlag(options2, keys, "onRequest", mustBeFunction);
        let onWait;
        let wait = new Promise((resolve2, reject) => {
          onWait = (error2) => {
            serveCallbacks.delete(key2);
            if (error2 !== null)
              reject(new Error(error2));
            else
              resolve2();
          };
        });
        request.serve = {};
        checkForInvalidFlags(options2, keys, `in serve() call`);
        if (port !== void 0)
          request.serve.port = port;
        if (host !== void 0)
          request.serve.host = host;
        if (servedir !== void 0)
          request.serve.servedir = servedir;
        serveCallbacks.set(key2, {
          onRequest,
          onWait
        });
        return {
          wait,
          stop() {
            sendRequest(refs, { command: "serve-stop", key: key2 }, () => {
            });
          }
        };
      };
      const buildLogLevelDefault = "warning";
      const transformLogLevelDefault = "silent";
      let buildOrServe = (args) => {
        let key2 = nextBuildKey++;
        const details = createObjectStash();
        let plugins2;
        let { refs, options: options2, isTTY: isTTY2, callback } = args;
        if (typeof options2 === "object") {
          let value = options2.plugins;
          if (value !== void 0) {
            if (!Array.isArray(value))
              throw new Error(`"plugins" must be an array`);
            plugins2 = value;
          }
        }
        let logPluginError = (e2, pluginName, note, done) => {
          let flags = [];
          try {
            pushLogFlags(flags, options2, {}, isTTY2, buildLogLevelDefault);
          } catch {
          }
          const message = extractErrorMessageV8(e2, streamIn, details, note, pluginName);
          sendRequest(refs, { command: "error", flags, error: message }, () => {
            message.detail = details.load(message.detail);
            done(message);
          });
        };
        let handleError = (e2, pluginName) => {
          logPluginError(e2, pluginName, void 0, (error2) => {
            callback(failureErrorWithLog("Build failed", [error2], []), null);
          });
        };
        if (plugins2 && plugins2.length > 0) {
          if (streamIn.isSync)
            return handleError(new Error("Cannot use plugins in synchronous API calls"), "");
          handlePlugins(options2, plugins2, key2, details, refs).then((result2) => {
            if (!result2.ok) {
              handleError(result2.error, result2.pluginName);
            } else {
              try {
                buildOrServeContinue(__spreadProps3(__spreadValues3({}, args), {
                  key: key2,
                  details,
                  logPluginError,
                  requestPlugins: result2.requestPlugins,
                  runOnEndCallbacks: result2.runOnEndCallbacks,
                  pluginRefs: result2.pluginRefs
                }));
              } catch (e2) {
                handleError(e2, "");
              }
            }
          }, (e2) => handleError(e2, ""));
        } else {
          try {
            buildOrServeContinue(__spreadProps3(__spreadValues3({}, args), {
              key: key2,
              details,
              logPluginError,
              requestPlugins: null,
              runOnEndCallbacks: (result2, logPluginError2, done) => done(),
              pluginRefs: null
            }));
          } catch (e2) {
            handleError(e2, "");
          }
        }
      };
      let buildOrServeContinue = ({
        callName,
        refs: callerRefs,
        serveOptions,
        options: options2,
        isTTY: isTTY2,
        defaultWD: defaultWD2,
        callback,
        key: key2,
        details,
        logPluginError,
        requestPlugins,
        runOnEndCallbacks,
        pluginRefs
      }) => {
        const refs = {
          ref() {
            if (pluginRefs)
              pluginRefs.ref();
            if (callerRefs)
              callerRefs.ref();
          },
          unref() {
            if (pluginRefs)
              pluginRefs.unref();
            if (callerRefs)
              callerRefs.unref();
          }
        };
        let writeDefault = !streamIn.isBrowser;
        let {
          entries,
          flags,
          write,
          stdinContents,
          stdinResolveDir,
          absWorkingDir,
          incremental,
          nodePaths,
          watch: watch2,
          mangleCache
        } = flagsForBuildOptions(callName, options2, isTTY2, buildLogLevelDefault, writeDefault);
        let request = {
          command: "build",
          key: key2,
          entries,
          flags,
          write,
          stdinContents,
          stdinResolveDir,
          absWorkingDir: absWorkingDir || defaultWD2,
          incremental,
          nodePaths
        };
        if (requestPlugins)
          request.plugins = requestPlugins;
        if (mangleCache)
          request.mangleCache = mangleCache;
        let serve2 = serveOptions && buildServeData(refs, serveOptions, request, key2);
        let rebuild;
        let stop;
        let copyResponseToResult = (response, result2) => {
          if (response.outputFiles)
            result2.outputFiles = response.outputFiles.map(convertOutputFiles);
          if (response.metafile)
            result2.metafile = JSON.parse(response.metafile);
          if (response.mangleCache)
            result2.mangleCache = response.mangleCache;
          if (response.writeToStdout !== void 0)
            console.log(decodeUTF8(response.writeToStdout).replace(/\n$/, ""));
        };
        let buildResponseToResult = (response, callback2) => {
          let result2 = {
            errors: replaceDetailsInMessages(response.errors, details),
            warnings: replaceDetailsInMessages(response.warnings, details)
          };
          copyResponseToResult(response, result2);
          runOnEndCallbacks(result2, logPluginError, () => {
            if (result2.errors.length > 0) {
              return callback2(failureErrorWithLog("Build failed", result2.errors, result2.warnings), null);
            }
            if (response.rebuild) {
              if (!rebuild) {
                let isDisposed = false;
                rebuild = () => new Promise((resolve2, reject) => {
                  if (isDisposed || closeData)
                    throw new Error("Cannot rebuild");
                  sendRequest(refs, { command: "rebuild", key: key2 }, (error2, response2) => {
                    if (error2) {
                      const message = { pluginName: "", text: error2, location: null, notes: [], detail: void 0 };
                      return callback2(failureErrorWithLog("Build failed", [message], []), null);
                    }
                    buildResponseToResult(response2, (error3, result3) => {
                      if (error3)
                        reject(error3);
                      else
                        resolve2(result3);
                    });
                  });
                });
                refs.ref();
                rebuild.dispose = () => {
                  if (isDisposed)
                    return;
                  isDisposed = true;
                  sendRequest(refs, { command: "rebuild-dispose", key: key2 }, () => {
                  });
                  refs.unref();
                };
              }
              result2.rebuild = rebuild;
            }
            if (response.watch) {
              if (!stop) {
                let isStopped = false;
                refs.ref();
                stop = () => {
                  if (isStopped)
                    return;
                  isStopped = true;
                  watchCallbacks.delete(key2);
                  sendRequest(refs, { command: "watch-stop", key: key2 }, () => {
                  });
                  refs.unref();
                };
                if (watch2) {
                  watchCallbacks.set(key2, (serviceStopError, watchResponse) => {
                    if (serviceStopError) {
                      if (watch2.onRebuild)
                        watch2.onRebuild(serviceStopError, null);
                      return;
                    }
                    let result22 = {
                      errors: replaceDetailsInMessages(watchResponse.errors, details),
                      warnings: replaceDetailsInMessages(watchResponse.warnings, details)
                    };
                    copyResponseToResult(watchResponse, result22);
                    runOnEndCallbacks(result22, logPluginError, () => {
                      if (result22.errors.length > 0) {
                        if (watch2.onRebuild)
                          watch2.onRebuild(failureErrorWithLog("Build failed", result22.errors, result22.warnings), null);
                        return;
                      }
                      if (watchResponse.rebuildID !== void 0)
                        result22.rebuild = rebuild;
                      result22.stop = stop;
                      if (watch2.onRebuild)
                        watch2.onRebuild(null, result22);
                    });
                  });
                }
              }
              result2.stop = stop;
            }
            callback2(null, result2);
          });
        };
        if (write && streamIn.isBrowser)
          throw new Error(`Cannot enable "write" in the browser`);
        if (incremental && streamIn.isSync)
          throw new Error(`Cannot use "incremental" with a synchronous build`);
        if (watch2 && streamIn.isSync)
          throw new Error(`Cannot use "watch" with a synchronous build`);
        sendRequest(refs, request, (error2, response) => {
          if (error2)
            return callback(new Error(error2), null);
          if (serve2) {
            let serveResponse = response;
            let isStopped = false;
            refs.ref();
            let result2 = {
              port: serveResponse.port,
              host: serveResponse.host,
              wait: serve2.wait,
              stop() {
                if (isStopped)
                  return;
                isStopped = true;
                serve2.stop();
                refs.unref();
              }
            };
            refs.ref();
            serve2.wait.then(refs.unref, refs.unref);
            return callback(null, result2);
          }
          return buildResponseToResult(response, callback);
        });
      };
      let transform22 = ({ callName, refs, input, options: options2, isTTY: isTTY2, fs: fs32, callback }) => {
        const details = createObjectStash();
        let start = (inputPath) => {
          try {
            if (typeof input !== "string")
              throw new Error('The input to "transform" must be a string');
            let {
              flags,
              mangleCache
            } = flagsForTransformOptions(callName, options2, isTTY2, transformLogLevelDefault);
            let request = {
              command: "transform",
              flags,
              inputFS: inputPath !== null,
              input: inputPath !== null ? inputPath : input
            };
            if (mangleCache)
              request.mangleCache = mangleCache;
            sendRequest(refs, request, (error2, response) => {
              if (error2)
                return callback(new Error(error2), null);
              let errors = replaceDetailsInMessages(response.errors, details);
              let warnings2 = replaceDetailsInMessages(response.warnings, details);
              let outstanding = 1;
              let next = () => {
                if (--outstanding === 0) {
                  let result2 = { warnings: warnings2, code: response.code, map: response.map };
                  if (response.mangleCache)
                    result2.mangleCache = response == null ? void 0 : response.mangleCache;
                  callback(null, result2);
                }
              };
              if (errors.length > 0)
                return callback(failureErrorWithLog("Transform failed", errors, warnings2), null);
              if (response.codeFS) {
                outstanding++;
                fs32.readFile(response.code, (err, contents) => {
                  if (err !== null) {
                    callback(err, null);
                  } else {
                    response.code = contents;
                    next();
                  }
                });
              }
              if (response.mapFS) {
                outstanding++;
                fs32.readFile(response.map, (err, contents) => {
                  if (err !== null) {
                    callback(err, null);
                  } else {
                    response.map = contents;
                    next();
                  }
                });
              }
              next();
            });
          } catch (e2) {
            let flags = [];
            try {
              pushLogFlags(flags, options2, {}, isTTY2, transformLogLevelDefault);
            } catch {
            }
            const error2 = extractErrorMessageV8(e2, streamIn, details, void 0, "");
            sendRequest(refs, { command: "error", flags, error: error2 }, () => {
              error2.detail = details.load(error2.detail);
              callback(failureErrorWithLog("Transform failed", [error2], []), null);
            });
          }
        };
        if (typeof input === "string" && input.length > 1024 * 1024) {
          let next = start;
          start = () => fs32.writeFile(input, next);
        }
        start(null);
      };
      let formatMessages2 = ({ callName, refs, messages, options: options2, callback }) => {
        let result2 = sanitizeMessages(messages, "messages", null, "");
        if (!options2)
          throw new Error(`Missing second argument in ${callName}() call`);
        let keys = {};
        let kind = getFlag(options2, keys, "kind", mustBeString);
        let color = getFlag(options2, keys, "color", mustBeBoolean);
        let terminalWidth = getFlag(options2, keys, "terminalWidth", mustBeInteger);
        checkForInvalidFlags(options2, keys, `in ${callName}() call`);
        if (kind === void 0)
          throw new Error(`Missing "kind" in ${callName}() call`);
        if (kind !== "error" && kind !== "warning")
          throw new Error(`Expected "kind" to be "error" or "warning" in ${callName}() call`);
        let request = {
          command: "format-msgs",
          messages: result2,
          isWarning: kind === "warning"
        };
        if (color !== void 0)
          request.color = color;
        if (terminalWidth !== void 0)
          request.terminalWidth = terminalWidth;
        sendRequest(refs, request, (error2, response) => {
          if (error2)
            return callback(new Error(error2), null);
          callback(null, response.messages);
        });
      };
      let analyzeMetafile2 = ({ callName, refs, metafile, options: options2, callback }) => {
        if (options2 === void 0)
          options2 = {};
        let keys = {};
        let color = getFlag(options2, keys, "color", mustBeBoolean);
        let verbose = getFlag(options2, keys, "verbose", mustBeBoolean);
        checkForInvalidFlags(options2, keys, `in ${callName}() call`);
        let request = {
          command: "analyze-metafile",
          metafile
        };
        if (color !== void 0)
          request.color = color;
        if (verbose !== void 0)
          request.verbose = verbose;
        sendRequest(refs, request, (error2, response) => {
          if (error2)
            return callback(new Error(error2), null);
          callback(null, response.result);
        });
      };
      return {
        readFromStdout,
        afterClose,
        service: {
          buildOrServe,
          transform: transform22,
          formatMessages: formatMessages2,
          analyzeMetafile: analyzeMetafile2
        }
      };
    }
    function createObjectStash() {
      const map2 = /* @__PURE__ */ new Map();
      let nextID = 0;
      return {
        load(id) {
          return map2.get(id);
        },
        store(value) {
          if (value === void 0)
            return -1;
          const id = nextID++;
          map2.set(id, value);
          return id;
        }
      };
    }
    function extractCallerV8(e2, streamIn, ident) {
      let note;
      let tried = false;
      return () => {
        if (tried)
          return note;
        tried = true;
        try {
          let lines = (e2.stack + "").split("\n");
          lines.splice(1, 1);
          let location = parseStackLinesV8(streamIn, lines, ident);
          if (location) {
            note = { text: e2.message, location };
            return note;
          }
        } catch {
        }
      };
    }
    function extractErrorMessageV8(e2, streamIn, stash, note, pluginName) {
      let text = "Internal error";
      let location = null;
      try {
        text = (e2 && e2.message || e2) + "";
      } catch {
      }
      try {
        location = parseStackLinesV8(streamIn, (e2.stack + "").split("\n"), "");
      } catch {
      }
      return { pluginName, text, location, notes: note ? [note] : [], detail: stash ? stash.store(e2) : -1 };
    }
    function parseStackLinesV8(streamIn, lines, ident) {
      let at2 = "    at ";
      if (streamIn.readFileSync && !lines[0].startsWith(at2) && lines[1].startsWith(at2)) {
        for (let i2 = 1; i2 < lines.length; i2++) {
          let line2 = lines[i2];
          if (!line2.startsWith(at2))
            continue;
          line2 = line2.slice(at2.length);
          while (true) {
            let match2 = /^(?:new |async )?\S+ \((.*)\)$/.exec(line2);
            if (match2) {
              line2 = match2[1];
              continue;
            }
            match2 = /^eval at \S+ \((.*)\)(?:, \S+:\d+:\d+)?$/.exec(line2);
            if (match2) {
              line2 = match2[1];
              continue;
            }
            match2 = /^(\S+):(\d+):(\d+)$/.exec(line2);
            if (match2) {
              let contents;
              try {
                contents = streamIn.readFileSync(match2[1], "utf8");
              } catch {
                break;
              }
              let lineText = contents.split(/\r\n|\r|\n|\u2028|\u2029/)[+match2[2] - 1] || "";
              let column2 = +match2[3] - 1;
              let length = lineText.slice(column2, column2 + ident.length) === ident ? ident.length : 0;
              return {
                file: match2[1],
                namespace: "file",
                line: +match2[2],
                column: encodeUTF8(lineText.slice(0, column2)).length,
                length: encodeUTF8(lineText.slice(column2, column2 + length)).length,
                lineText: lineText + "\n" + lines.slice(1).join("\n"),
                suggestion: ""
              };
            }
            break;
          }
        }
      }
      return null;
    }
    function failureErrorWithLog(text, errors, warnings2) {
      let limit = 5;
      let summary = errors.length < 1 ? "" : ` with ${errors.length} error${errors.length < 2 ? "" : "s"}:` + errors.slice(0, limit + 1).map((e2, i2) => {
        if (i2 === limit)
          return "\n...";
        if (!e2.location)
          return `
error: ${e2.text}`;
        let { file, line: line2, column: column2 } = e2.location;
        let pluginText = e2.pluginName ? `[plugin: ${e2.pluginName}] ` : "";
        return `
${file}:${line2}:${column2}: ERROR: ${pluginText}${e2.text}`;
      }).join("");
      let error2 = new Error(`${text}${summary}`);
      error2.errors = errors;
      error2.warnings = warnings2;
      return error2;
    }
    function replaceDetailsInMessages(messages, stash) {
      for (const message of messages) {
        message.detail = stash.load(message.detail);
      }
      return messages;
    }
    function sanitizeLocation(location, where) {
      if (location == null)
        return null;
      let keys = {};
      let file = getFlag(location, keys, "file", mustBeString);
      let namespace = getFlag(location, keys, "namespace", mustBeString);
      let line2 = getFlag(location, keys, "line", mustBeInteger);
      let column2 = getFlag(location, keys, "column", mustBeInteger);
      let length = getFlag(location, keys, "length", mustBeInteger);
      let lineText = getFlag(location, keys, "lineText", mustBeString);
      let suggestion = getFlag(location, keys, "suggestion", mustBeString);
      checkForInvalidFlags(location, keys, where);
      return {
        file: file || "",
        namespace: namespace || "",
        line: line2 || 0,
        column: column2 || 0,
        length: length || 0,
        lineText: lineText || "",
        suggestion: suggestion || ""
      };
    }
    function sanitizeMessages(messages, property, stash, fallbackPluginName) {
      let messagesClone = [];
      let index2 = 0;
      for (const message of messages) {
        let keys = {};
        let pluginName = getFlag(message, keys, "pluginName", mustBeString);
        let text = getFlag(message, keys, "text", mustBeString);
        let location = getFlag(message, keys, "location", mustBeObjectOrNull);
        let notes = getFlag(message, keys, "notes", mustBeArray);
        let detail = getFlag(message, keys, "detail", canBeAnything);
        let where = `in element ${index2} of "${property}"`;
        checkForInvalidFlags(message, keys, where);
        let notesClone = [];
        if (notes) {
          for (const note of notes) {
            let noteKeys = {};
            let noteText = getFlag(note, noteKeys, "text", mustBeString);
            let noteLocation = getFlag(note, noteKeys, "location", mustBeObjectOrNull);
            checkForInvalidFlags(note, noteKeys, where);
            notesClone.push({
              text: noteText || "",
              location: sanitizeLocation(noteLocation, where)
            });
          }
        }
        messagesClone.push({
          pluginName: pluginName || fallbackPluginName,
          text: text || "",
          location: sanitizeLocation(location, where),
          notes: notesClone,
          detail: stash ? stash.store(detail) : -1
        });
        index2++;
      }
      return messagesClone;
    }
    function sanitizeStringArray(values, property) {
      const result2 = [];
      for (const value of values) {
        if (typeof value !== "string")
          throw new Error(`${JSON.stringify(property)} must be an array of strings`);
        result2.push(value);
      }
      return result2;
    }
    function convertOutputFiles({ path: path3, contents }) {
      let text = null;
      return {
        path: path3,
        contents,
        get text() {
          if (text === null)
            text = decodeUTF8(contents);
          return text;
        }
      };
    }
    var fs3 = (init_fs(), __toCommonJS(fs_exports));
    var os3 = (init_os(), __toCommonJS(os_exports));
    var path2 = (init_path(), __toCommonJS(path_exports));
    var ESBUILD_BINARY_PATH = process.env.ESBUILD_BINARY_PATH || ESBUILD_BINARY_PATH;
    var knownWindowsPackages = {
      "win32 arm64 LE": "esbuild-windows-arm64",
      "win32 ia32 LE": "esbuild-windows-32",
      "win32 x64 LE": "esbuild-windows-64"
    };
    var knownUnixlikePackages = {
      "android arm64 LE": "esbuild-android-arm64",
      "darwin arm64 LE": "esbuild-darwin-arm64",
      "darwin x64 LE": "esbuild-darwin-64",
      "freebsd arm64 LE": "esbuild-freebsd-arm64",
      "freebsd x64 LE": "esbuild-freebsd-64",
      "linux arm LE": "esbuild-linux-arm",
      "linux arm64 LE": "esbuild-linux-arm64",
      "linux ia32 LE": "esbuild-linux-32",
      "linux mips64el LE": "esbuild-linux-mips64le",
      "linux ppc64 LE": "esbuild-linux-ppc64le",
      "linux riscv64 LE": "esbuild-linux-riscv64",
      "linux s390x BE": "esbuild-linux-s390x",
      "linux x64 LE": "esbuild-linux-64",
      "netbsd x64 LE": "esbuild-netbsd-64",
      "openbsd x64 LE": "esbuild-openbsd-64",
      "sunos x64 LE": "esbuild-sunos-64"
    };
    var knownWebAssemblyFallbackPackages = {
      "android x64 LE": "esbuild-android-64"
    };
    function pkgAndSubpathForCurrentPlatform() {
      let pkg;
      let subpath;
      let isWASM = false;
      let platformKey = `${process.platform} ${os3.arch()} ${os3.endianness()}`;
      if (platformKey in knownWindowsPackages) {
        pkg = knownWindowsPackages[platformKey];
        subpath = "esbuild.exe";
      } else if (platformKey in knownUnixlikePackages) {
        pkg = knownUnixlikePackages[platformKey];
        subpath = "bin/esbuild";
      } else if (platformKey in knownWebAssemblyFallbackPackages) {
        pkg = knownWebAssemblyFallbackPackages[platformKey];
        subpath = "bin/esbuild";
        isWASM = true;
      } else {
        throw new Error(`Unsupported platform: ${platformKey}`);
      }
      return { pkg, subpath, isWASM };
    }
    function pkgForSomeOtherPlatform() {
      const libMainJS = __require.resolve("esbuild");
      const nodeModulesDirectory = path2.dirname(path2.dirname(path2.dirname(libMainJS)));
      if (path2.basename(nodeModulesDirectory) === "node_modules") {
        for (const unixKey in knownUnixlikePackages) {
          try {
            const pkg = knownUnixlikePackages[unixKey];
            if (fs3.existsSync(path2.join(nodeModulesDirectory, pkg)))
              return pkg;
          } catch {
          }
        }
        for (const windowsKey in knownWindowsPackages) {
          try {
            const pkg = knownWindowsPackages[windowsKey];
            if (fs3.existsSync(path2.join(nodeModulesDirectory, pkg)))
              return pkg;
          } catch {
          }
        }
      }
      return null;
    }
    function downloadedBinPath(pkg, subpath) {
      const esbuildLibDir = path2.dirname(__require.resolve("esbuild"));
      return path2.join(esbuildLibDir, `downloaded-${pkg}-${path2.basename(subpath)}`);
    }
    function generateBinPath() {
      if (ESBUILD_BINARY_PATH) {
        return { binPath: ESBUILD_BINARY_PATH, isWASM: false };
      }
      const { pkg, subpath, isWASM } = pkgAndSubpathForCurrentPlatform();
      let binPath;
      try {
        binPath = __require.resolve(`${pkg}/${subpath}`);
      } catch (e2) {
        binPath = downloadedBinPath(pkg, subpath);
        if (!fs3.existsSync(binPath)) {
          try {
            __require.resolve(pkg);
          } catch {
            const otherPkg = pkgForSomeOtherPlatform();
            if (otherPkg) {
              throw new Error(`
You installed esbuild on another platform than the one you're currently using.
This won't work because esbuild is written with native code and needs to
install a platform-specific binary executable.

Specifically the "${otherPkg}" package is present but this platform
needs the "${pkg}" package instead. People often get into this
situation by installing esbuild on Windows or macOS and copying "node_modules"
into a Docker image that runs Linux, or by copying "node_modules" between
Windows and WSL environments.

If you are installing with npm, you can try not copying the "node_modules"
directory when you copy the files over, and running "npm ci" or "npm install"
on the destination platform after the copy. Or you could consider using yarn
instead which has built-in support for installing a package on multiple
platforms simultaneously.

If you are installing with yarn, you can try listing both this platform and the
other platform in your ".yarnrc.yml" file using the "supportedArchitectures"
feature: https://yarnpkg.com/configuration/yarnrc/#supportedArchitectures
Keep in mind that this means multiple copies of esbuild will be present.

Another alternative is to use the "esbuild-wasm" package instead, which works
the same way on all platforms. But it comes with a heavy performance cost and
can sometimes be 10x slower than the "esbuild" package, so you may also not
want to do that.
`);
            }
            throw new Error(`The package "${pkg}" could not be found, and is needed by esbuild.

If you are installing esbuild with npm, make sure that you don't specify the
"--no-optional" flag. The "optionalDependencies" package.json feature is used
by esbuild to install the correct binary executable for your current platform.`);
          }
          throw e2;
        }
      }
      let isYarnPnP = false;
      try {
        __require("pnpapi");
        isYarnPnP = true;
      } catch (e2) {
      }
      if (isYarnPnP) {
        const esbuildLibDir = path2.dirname(__require.resolve("esbuild"));
        const binTargetPath = path2.join(esbuildLibDir, `pnpapi-${pkg}-${path2.basename(subpath)}`);
        if (!fs3.existsSync(binTargetPath)) {
          fs3.copyFileSync(binPath, binTargetPath);
          fs3.chmodSync(binTargetPath, 493);
        }
        return { binPath: binTargetPath, isWASM };
      }
      return { binPath, isWASM };
    }
    var child_process = (init_child_process(), __toCommonJS(child_process_exports));
    var crypto2 = (init_crypto(), __toCommonJS(crypto_exports));
    var path22 = (init_path(), __toCommonJS(path_exports));
    var fs22 = (init_fs(), __toCommonJS(fs_exports));
    var os22 = (init_os(), __toCommonJS(os_exports));
    var tty2 = (init_tty(), __toCommonJS(tty_exports));
    var worker_threads;
    if (process.env.ESBUILD_WORKER_THREADS !== "0") {
      try {
        worker_threads = (init_worker_threads(), __toCommonJS(worker_threads_exports));
      } catch {
      }
      let [major, minor] = process.versions.node.split(".");
      if (+major < 12 || +major === 12 && +minor < 17 || +major === 13 && +minor < 13) {
        worker_threads = void 0;
      }
    }
    var _a2;
    var isInternalWorkerThread = ((_a2 = worker_threads == null ? void 0 : worker_threads.workerData) == null ? void 0 : _a2.esbuildVersion) === "0.14.34";
    var esbuildCommandAndArgs = () => {
      if ((!ESBUILD_BINARY_PATH || false) && (path22.basename(__filename) !== "main.js" || path22.basename(__dirname) !== "lib")) {
        throw new Error(`The esbuild JavaScript API cannot be bundled. Please mark the "esbuild" package as external so it's not included in the bundle.

More information: The file containing the code for esbuild's JavaScript API (${__filename}) does not appear to be inside the esbuild package on the file system, which usually means that the esbuild package was bundled into another file. This is problematic because the API needs to run a binary executable inside the esbuild package which is located using a relative path from the API code to the executable. If the esbuild package is bundled, the relative path will be incorrect and the executable won't be found.`);
      }
      if (false) {
        return ["node", [path22.join(__dirname, "..", "bin", "esbuild")]];
      }
      const { binPath, isWASM } = generateBinPath();
      if (isWASM) {
        return ["node", [binPath]];
      } else {
        return [binPath, []];
      }
    };
    var isTTY = () => tty2.isatty(2);
    var fsSync = {
      readFile(tempFile, callback) {
        try {
          let contents = fs22.readFileSync(tempFile, "utf8");
          try {
            fs22.unlinkSync(tempFile);
          } catch {
          }
          callback(null, contents);
        } catch (err) {
          callback(err, null);
        }
      },
      writeFile(contents, callback) {
        try {
          let tempFile = randomFileName();
          fs22.writeFileSync(tempFile, contents);
          callback(tempFile);
        } catch {
          callback(null);
        }
      }
    };
    var fsAsync = {
      readFile(tempFile, callback) {
        try {
          fs22.readFile(tempFile, "utf8", (err, contents) => {
            try {
              fs22.unlink(tempFile, () => callback(err, contents));
            } catch {
              callback(err, contents);
            }
          });
        } catch (err) {
          callback(err, null);
        }
      },
      writeFile(contents, callback) {
        try {
          let tempFile = randomFileName();
          fs22.writeFile(tempFile, contents, (err) => err !== null ? callback(null) : callback(tempFile));
        } catch {
          callback(null);
        }
      }
    };
    var version2 = "0.14.34";
    var build2 = (options2) => ensureServiceIsRunning().build(options2);
    var serve = (serveOptions, buildOptions) => ensureServiceIsRunning().serve(serveOptions, buildOptions);
    var transform2 = (input, options2) => ensureServiceIsRunning().transform(input, options2);
    var formatMessages = (messages, options2) => ensureServiceIsRunning().formatMessages(messages, options2);
    var analyzeMetafile = (messages, options2) => ensureServiceIsRunning().analyzeMetafile(messages, options2);
    var buildSync = (options2) => {
      if (worker_threads && !isInternalWorkerThread) {
        if (!workerThreadService)
          workerThreadService = startWorkerThreadService(worker_threads);
        return workerThreadService.buildSync(options2);
      }
      let result2;
      runServiceSync((service) => service.buildOrServe({
        callName: "buildSync",
        refs: null,
        serveOptions: null,
        options: options2,
        isTTY: isTTY(),
        defaultWD,
        callback: (err, res) => {
          if (err)
            throw err;
          result2 = res;
        }
      }));
      return result2;
    };
    var transformSync = (input, options2) => {
      if (worker_threads && !isInternalWorkerThread) {
        if (!workerThreadService)
          workerThreadService = startWorkerThreadService(worker_threads);
        return workerThreadService.transformSync(input, options2);
      }
      let result2;
      runServiceSync((service) => service.transform({
        callName: "transformSync",
        refs: null,
        input,
        options: options2 || {},
        isTTY: isTTY(),
        fs: fsSync,
        callback: (err, res) => {
          if (err)
            throw err;
          result2 = res;
        }
      }));
      return result2;
    };
    var formatMessagesSync = (messages, options2) => {
      if (worker_threads && !isInternalWorkerThread) {
        if (!workerThreadService)
          workerThreadService = startWorkerThreadService(worker_threads);
        return workerThreadService.formatMessagesSync(messages, options2);
      }
      let result2;
      runServiceSync((service) => service.formatMessages({
        callName: "formatMessagesSync",
        refs: null,
        messages,
        options: options2,
        callback: (err, res) => {
          if (err)
            throw err;
          result2 = res;
        }
      }));
      return result2;
    };
    var analyzeMetafileSync = (metafile, options2) => {
      if (worker_threads && !isInternalWorkerThread) {
        if (!workerThreadService)
          workerThreadService = startWorkerThreadService(worker_threads);
        return workerThreadService.analyzeMetafileSync(metafile, options2);
      }
      let result2;
      runServiceSync((service) => service.analyzeMetafile({
        callName: "analyzeMetafileSync",
        refs: null,
        metafile: typeof metafile === "string" ? metafile : JSON.stringify(metafile),
        options: options2,
        callback: (err, res) => {
          if (err)
            throw err;
          result2 = res;
        }
      }));
      return result2;
    };
    var initializeWasCalled = false;
    var initialize = (options2) => {
      options2 = validateInitializeOptions(options2 || {});
      if (options2.wasmURL)
        throw new Error(`The "wasmURL" option only works in the browser`);
      if (options2.worker)
        throw new Error(`The "worker" option only works in the browser`);
      if (initializeWasCalled)
        throw new Error('Cannot call "initialize" more than once');
      ensureServiceIsRunning();
      initializeWasCalled = true;
      return Promise.resolve();
    };
    var defaultWD = process.cwd();
    var longLivedService;
    var ensureServiceIsRunning = () => {
      if (longLivedService)
        return longLivedService;
      let [command, args] = esbuildCommandAndArgs();
      let child = child_process.spawn(command, args.concat(`--service=${"0.14.34"}`, "--ping"), {
        windowsHide: true,
        stdio: ["pipe", "pipe", "inherit"],
        cwd: defaultWD
      });
      let { readFromStdout, afterClose, service } = createChannel({
        writeToStdin(bytes) {
          child.stdin.write(bytes, (err) => {
            if (err)
              afterClose(err);
          });
        },
        readFileSync: fs22.readFileSync,
        isSync: false,
        isBrowser: false,
        esbuild: node_exports
      });
      child.stdin.on("error", afterClose);
      child.on("error", afterClose);
      const stdin = child.stdin;
      const stdout = child.stdout;
      stdout.on("data", readFromStdout);
      stdout.on("end", afterClose);
      let refCount = 0;
      child.unref();
      if (stdin.unref) {
        stdin.unref();
      }
      if (stdout.unref) {
        stdout.unref();
      }
      const refs = {
        ref() {
          if (++refCount === 1)
            child.ref();
        },
        unref() {
          if (--refCount === 0)
            child.unref();
        }
      };
      longLivedService = {
        build: (options2) => {
          return new Promise((resolve2, reject) => {
            service.buildOrServe({
              callName: "build",
              refs,
              serveOptions: null,
              options: options2,
              isTTY: isTTY(),
              defaultWD,
              callback: (err, res) => err ? reject(err) : resolve2(res)
            });
          });
        },
        serve: (serveOptions, buildOptions) => {
          if (serveOptions === null || typeof serveOptions !== "object")
            throw new Error("The first argument must be an object");
          return new Promise((resolve2, reject) => service.buildOrServe({
            callName: "serve",
            refs,
            serveOptions,
            options: buildOptions,
            isTTY: isTTY(),
            defaultWD,
            callback: (err, res) => err ? reject(err) : resolve2(res)
          }));
        },
        transform: (input, options2) => {
          return new Promise((resolve2, reject) => service.transform({
            callName: "transform",
            refs,
            input,
            options: options2 || {},
            isTTY: isTTY(),
            fs: fsAsync,
            callback: (err, res) => err ? reject(err) : resolve2(res)
          }));
        },
        formatMessages: (messages, options2) => {
          return new Promise((resolve2, reject) => service.formatMessages({
            callName: "formatMessages",
            refs,
            messages,
            options: options2,
            callback: (err, res) => err ? reject(err) : resolve2(res)
          }));
        },
        analyzeMetafile: (metafile, options2) => {
          return new Promise((resolve2, reject) => service.analyzeMetafile({
            callName: "analyzeMetafile",
            refs,
            metafile: typeof metafile === "string" ? metafile : JSON.stringify(metafile),
            options: options2,
            callback: (err, res) => err ? reject(err) : resolve2(res)
          }));
        }
      };
      return longLivedService;
    };
    var runServiceSync = (callback) => {
      let [command, args] = esbuildCommandAndArgs();
      let stdin = new Uint8Array();
      let { readFromStdout, afterClose, service } = createChannel({
        writeToStdin(bytes) {
          if (stdin.length !== 0)
            throw new Error("Must run at most one command");
          stdin = bytes;
        },
        isSync: true,
        isBrowser: false,
        esbuild: node_exports
      });
      callback(service);
      let stdout = child_process.execFileSync(command, args.concat(`--service=${"0.14.34"}`), {
        cwd: defaultWD,
        windowsHide: true,
        input: stdin,
        maxBuffer: +process.env.ESBUILD_MAX_BUFFER || 16 * 1024 * 1024
      });
      readFromStdout(stdout);
      afterClose(null);
    };
    var randomFileName = () => {
      return path22.join(os22.tmpdir(), `esbuild-${crypto2.randomBytes(32).toString("hex")}`);
    };
    var workerThreadService = null;
    var startWorkerThreadService = (worker_threads2) => {
      let { port1: mainPort, port2: workerPort } = new worker_threads2.MessageChannel();
      let worker = new worker_threads2.Worker(__filename, {
        workerData: { workerPort, defaultWD, esbuildVersion: "0.14.34" },
        transferList: [workerPort],
        execArgv: []
      });
      let nextID = 0;
      let wasStopped = false;
      let fakeBuildError = (text) => {
        let error2 = new Error(`Build failed with 1 error:
error: ${text}`);
        let errors = [{ pluginName: "", text, location: null, notes: [], detail: void 0 }];
        error2.errors = errors;
        error2.warnings = [];
        return error2;
      };
      let validateBuildSyncOptions = (options2) => {
        if (!options2)
          return;
        let plugins2 = options2.plugins;
        let incremental = options2.incremental;
        let watch2 = options2.watch;
        if (plugins2 && plugins2.length > 0)
          throw fakeBuildError(`Cannot use plugins in synchronous API calls`);
        if (incremental)
          throw fakeBuildError(`Cannot use "incremental" with a synchronous build`);
        if (watch2)
          throw fakeBuildError(`Cannot use "watch" with a synchronous build`);
      };
      let applyProperties = (object, properties) => {
        for (let key2 in properties) {
          object[key2] = properties[key2];
        }
      };
      let runCallSync = (command, args) => {
        if (wasStopped)
          throw new Error("The service was stopped");
        let id = nextID++;
        let sharedBuffer = new SharedArrayBuffer(8);
        let sharedBufferView = new Int32Array(sharedBuffer);
        let msg = { sharedBuffer, id, command, args };
        worker.postMessage(msg);
        let status2 = Atomics.wait(sharedBufferView, 0, 0);
        if (status2 !== "ok" && status2 !== "not-equal")
          throw new Error("Internal error: Atomics.wait() failed: " + status2);
        let { message: { id: id2, resolve: resolve2, reject, properties } } = worker_threads2.receiveMessageOnPort(mainPort);
        if (id !== id2)
          throw new Error(`Internal error: Expected id ${id} but got id ${id2}`);
        if (reject) {
          applyProperties(reject, properties);
          throw reject;
        }
        return resolve2;
      };
      worker.unref();
      return {
        buildSync(options2) {
          validateBuildSyncOptions(options2);
          return runCallSync("build", [options2]);
        },
        transformSync(input, options2) {
          return runCallSync("transform", [input, options2]);
        },
        formatMessagesSync(messages, options2) {
          return runCallSync("formatMessages", [messages, options2]);
        },
        analyzeMetafileSync(metafile, options2) {
          return runCallSync("analyzeMetafile", [metafile, options2]);
        }
      };
    };
    var startSyncServiceWorker = () => {
      let workerPort = worker_threads.workerData.workerPort;
      let parentPort = worker_threads.parentPort;
      let service = ensureServiceIsRunning();
      defaultWD = worker_threads.workerData.defaultWD;
      let extractProperties = (object) => {
        let properties = {};
        if (object && typeof object === "object") {
          for (let key2 in object) {
            properties[key2] = object[key2];
          }
        }
        return properties;
      };
      parentPort.on("message", (msg) => {
        (async () => {
          let { sharedBuffer, id, command, args } = msg;
          let sharedBufferView = new Int32Array(sharedBuffer);
          try {
            switch (command) {
              case "build":
                workerPort.postMessage({ id, resolve: await service.build(args[0]) });
                break;
              case "transform":
                workerPort.postMessage({ id, resolve: await service.transform(args[0], args[1]) });
                break;
              case "formatMessages":
                workerPort.postMessage({ id, resolve: await service.formatMessages(args[0], args[1]) });
                break;
              case "analyzeMetafile":
                workerPort.postMessage({ id, resolve: await service.analyzeMetafile(args[0], args[1]) });
                break;
              default:
                throw new Error(`Invalid command: ${command}`);
            }
          } catch (reject) {
            workerPort.postMessage({ id, reject, properties: extractProperties(reject) });
          }
          Atomics.add(sharedBufferView, 0, 1);
          Atomics.notify(sharedBufferView, 0, Infinity);
        })();
      });
    };
    if (isInternalWorkerThread) {
      startSyncServiceWorker();
    }
    var node_default = node_exports;
  }
});

// browser-external:buffer
var buffer_exports = {};
__export(buffer_exports, {
  default: () => buffer_default
});
var buffer_default;
var init_buffer = __esm({
  "browser-external:buffer"() {
    buffer_default = new Proxy({}, {
      get() {
        throw new Error('Module "buffer" has been externalized for browser compatibility and cannot be accessed in client code.');
      }
    });
  }
});

// browser-external:querystring
var querystring_exports = {};
__export(querystring_exports, {
  default: () => querystring_default
});
var querystring_default;
var init_querystring = __esm({
  "browser-external:querystring"() {
    querystring_default = new Proxy({}, {
      get() {
        throw new Error('Module "querystring" has been externalized for browser compatibility and cannot be accessed in client code.');
      }
    });
  }
});

// browser-external:readline
var readline_exports = {};
__export(readline_exports, {
  default: () => readline_default
});
var readline_default;
var init_readline = __esm({
  "browser-external:readline"() {
    readline_default = new Proxy({}, {
      get() {
        throw new Error('Module "readline" has been externalized for browser compatibility and cannot be accessed in client code.');
      }
    });
  }
});

// node_modules/supports-color/browser.js
var require_browser = __commonJS({
  "node_modules/supports-color/browser.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      stdout: false,
      stderr: false
    };
  }
});

// node_modules/vite/dist/node/chunks/dep-86378e0d.js
var require_dep_86378e0d = __commonJS({
  "node_modules/vite/dist/node/chunks/dep-86378e0d.js"(exports2) {
    "use strict";
    var index2 = require_dep_611778e0();
    function _mergeNamespaces2(n3, m3) {
      for (var i2 = 0; i2 < m3.length; i2++) {
        var e2 = m3[i2];
        if (typeof e2 !== "string" && !Array.isArray(e2)) {
          for (var k2 in e2) {
            if (k2 !== "default" && !(k2 in n3)) {
              n3[k2] = e2[k2];
            }
          }
        }
      }
      return n3;
    }
    var compilerDom_cjs$2 = {};
    function makeMap(str, expectsLowerCase) {
      const map2 = /* @__PURE__ */ Object.create(null);
      const list2 = str.split(",");
      for (let i2 = 0; i2 < list2.length; i2++) {
        map2[list2[i2]] = true;
      }
      return expectsLowerCase ? (val) => !!map2[val.toLowerCase()] : (val) => !!map2[val];
    }
    var PatchFlagNames = {
      [1]: `TEXT`,
      [2]: `CLASS`,
      [4]: `STYLE`,
      [8]: `PROPS`,
      [16]: `FULL_PROPS`,
      [32]: `HYDRATE_EVENTS`,
      [64]: `STABLE_FRAGMENT`,
      [128]: `KEYED_FRAGMENT`,
      [256]: `UNKEYED_FRAGMENT`,
      [512]: `NEED_PATCH`,
      [1024]: `DYNAMIC_SLOTS`,
      [2048]: `DEV_ROOT_FRAGMENT`,
      [-1]: `HOISTED`,
      [-2]: `BAIL`
    };
    var slotFlagsText = {
      [1]: "STABLE",
      [2]: "DYNAMIC",
      [3]: "FORWARDED"
    };
    var GLOBALS_WHITE_LISTED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt";
    var isGloballyWhitelisted = makeMap(GLOBALS_WHITE_LISTED);
    var range2 = 2;
    function generateCodeFrame2(source2, start = 0, end = source2.length) {
      let lines = source2.split(/(\r?\n)/);
      const newlineSequences = lines.filter((_2, idx) => idx % 2 === 1);
      lines = lines.filter((_2, idx) => idx % 2 === 0);
      let count = 0;
      const res = [];
      for (let i2 = 0; i2 < lines.length; i2++) {
        count += lines[i2].length + (newlineSequences[i2] && newlineSequences[i2].length || 0);
        if (count >= start) {
          for (let j2 = i2 - range2; j2 <= i2 + range2 || end > count; j2++) {
            if (j2 < 0 || j2 >= lines.length)
              continue;
            const line2 = j2 + 1;
            res.push(`${line2}${" ".repeat(Math.max(3 - String(line2).length, 0))}|  ${lines[j2]}`);
            const lineLength = lines[j2].length;
            const newLineSeqLength = newlineSequences[j2] && newlineSequences[j2].length || 0;
            if (j2 === i2) {
              const pad2 = start - (count - (lineLength + newLineSeqLength));
              const length = Math.max(1, end > count ? lineLength - pad2 : end - start);
              res.push(`   |  ` + " ".repeat(pad2) + "^".repeat(length));
            } else if (j2 > i2) {
              if (end > count) {
                const length = Math.max(Math.min(end - count, lineLength), 1);
                res.push(`   |  ` + "^".repeat(length));
              }
              count += lineLength + newLineSeqLength;
            }
          }
          break;
        }
      }
      return res.join("\n");
    }
    var specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
    var isSpecialBooleanAttr = makeMap(specialBooleanAttrs);
    var isBooleanAttr = makeMap(specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`);
    function includeBooleanAttr(value) {
      return !!value || value === "";
    }
    var unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/;
    var attrValidationCache = {};
    function isSSRSafeAttrName(name) {
      if (attrValidationCache.hasOwnProperty(name)) {
        return attrValidationCache[name];
      }
      const isUnsafe = unsafeAttrCharRE.test(name);
      if (isUnsafe) {
        console.error(`unsafe attribute name: ${name}`);
      }
      return attrValidationCache[name] = !isUnsafe;
    }
    var propsToAttrMap = {
      acceptCharset: "accept-charset",
      className: "class",
      htmlFor: "for",
      httpEquiv: "http-equiv"
    };
    var isNoUnitNumericStyleProp = makeMap(`animation-iteration-count,border-image-outset,border-image-slice,border-image-width,box-flex,box-flex-group,box-ordinal-group,column-count,columns,flex,flex-grow,flex-positive,flex-shrink,flex-negative,flex-order,grid-row,grid-row-end,grid-row-span,grid-row-start,grid-column,grid-column-end,grid-column-span,grid-column-start,font-weight,line-clamp,line-height,opacity,order,orphans,tab-size,widows,z-index,zoom,fill-opacity,flood-opacity,stop-opacity,stroke-dasharray,stroke-dashoffset,stroke-miterlimit,stroke-opacity,stroke-width`);
    var isKnownHtmlAttr = makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap`);
    var isKnownSvgAttr = makeMap(`xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`);
    function normalizeStyle(value) {
      if (isArray2(value)) {
        const res = {};
        for (let i2 = 0; i2 < value.length; i2++) {
          const item = value[i2];
          const normalized = isString2(item) ? parseStringStyle(item) : normalizeStyle(item);
          if (normalized) {
            for (const key2 in normalized) {
              res[key2] = normalized[key2];
            }
          }
        }
        return res;
      } else if (isString2(value)) {
        return value;
      } else if (isObject2(value)) {
        return value;
      }
    }
    var listDelimiterRE = /;(?![^(]*\))/g;
    var propertyDelimiterRE = /:(.+)/;
    function parseStringStyle(cssText) {
      const ret = {};
      cssText.split(listDelimiterRE).forEach((item) => {
        if (item) {
          const tmp = item.split(propertyDelimiterRE);
          tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
        }
      });
      return ret;
    }
    function stringifyStyle(styles) {
      let ret = "";
      if (!styles || isString2(styles)) {
        return ret;
      }
      for (const key2 in styles) {
        const value = styles[key2];
        const normalizedKey = key2.startsWith(`--`) ? key2 : hyphenate(key2);
        if (isString2(value) || typeof value === "number" && isNoUnitNumericStyleProp(normalizedKey)) {
          ret += `${normalizedKey}:${value};`;
        }
      }
      return ret;
    }
    function normalizeClass(value) {
      let res = "";
      if (isString2(value)) {
        res = value;
      } else if (isArray2(value)) {
        for (let i2 = 0; i2 < value.length; i2++) {
          const normalized = normalizeClass(value[i2]);
          if (normalized) {
            res += normalized + " ";
          }
        }
      } else if (isObject2(value)) {
        for (const name in value) {
          if (value[name]) {
            res += name + " ";
          }
        }
      }
      return res.trim();
    }
    function normalizeProps(props) {
      if (!props)
        return null;
      let { class: klass, style } = props;
      if (klass && !isString2(klass)) {
        props.class = normalizeClass(klass);
      }
      if (style) {
        props.style = normalizeStyle(style);
      }
      return props;
    }
    var HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
    var SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
    var VOID_TAGS = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr";
    var isHTMLTag = makeMap(HTML_TAGS);
    var isSVGTag = makeMap(SVG_TAGS);
    var isVoidTag = makeMap(VOID_TAGS);
    var escapeRE = /["'&<>]/;
    function escapeHtml2(string2) {
      const str = "" + string2;
      const match2 = escapeRE.exec(str);
      if (!match2) {
        return str;
      }
      let html = "";
      let escaped2;
      let index3;
      let lastIndex = 0;
      for (index3 = match2.index; index3 < str.length; index3++) {
        switch (str.charCodeAt(index3)) {
          case 34:
            escaped2 = "&quot;";
            break;
          case 38:
            escaped2 = "&amp;";
            break;
          case 39:
            escaped2 = "&#39;";
            break;
          case 60:
            escaped2 = "&lt;";
            break;
          case 62:
            escaped2 = "&gt;";
            break;
          default:
            continue;
        }
        if (lastIndex !== index3) {
          html += str.slice(lastIndex, index3);
        }
        lastIndex = index3 + 1;
        html += escaped2;
      }
      return lastIndex !== index3 ? html + str.slice(lastIndex, index3) : html;
    }
    var commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;
    function escapeHtmlComment(src2) {
      return src2.replace(commentStripRE, "");
    }
    function looseCompareArrays(a2, b2) {
      if (a2.length !== b2.length)
        return false;
      let equal = true;
      for (let i2 = 0; equal && i2 < a2.length; i2++) {
        equal = looseEqual(a2[i2], b2[i2]);
      }
      return equal;
    }
    function looseEqual(a2, b2) {
      if (a2 === b2)
        return true;
      let aValidType = isDate(a2);
      let bValidType = isDate(b2);
      if (aValidType || bValidType) {
        return aValidType && bValidType ? a2.getTime() === b2.getTime() : false;
      }
      aValidType = isArray2(a2);
      bValidType = isArray2(b2);
      if (aValidType || bValidType) {
        return aValidType && bValidType ? looseCompareArrays(a2, b2) : false;
      }
      aValidType = isObject2(a2);
      bValidType = isObject2(b2);
      if (aValidType || bValidType) {
        if (!aValidType || !bValidType) {
          return false;
        }
        const aKeysCount = Object.keys(a2).length;
        const bKeysCount = Object.keys(b2).length;
        if (aKeysCount !== bKeysCount) {
          return false;
        }
        for (const key2 in a2) {
          const aHasKey = a2.hasOwnProperty(key2);
          const bHasKey = b2.hasOwnProperty(key2);
          if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a2[key2], b2[key2])) {
            return false;
          }
        }
      }
      return String(a2) === String(b2);
    }
    function looseIndexOf(arr, val) {
      return arr.findIndex((item) => looseEqual(item, val));
    }
    var toDisplayString = (val) => {
      return isString2(val) ? val : val == null ? "" : isArray2(val) || isObject2(val) && (val.toString === objectToString || !isFunction2(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
    };
    var replacer = (_key, val) => {
      if (val && val.__v_isRef) {
        return replacer(_key, val.value);
      } else if (isMap(val)) {
        return {
          [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key2, val2]) => {
            entries[`${key2} =>`] = val2;
            return entries;
          }, {})
        };
      } else if (isSet(val)) {
        return {
          [`Set(${val.size})`]: [...val.values()]
        };
      } else if (isObject2(val) && !isArray2(val) && !isPlainObject(val)) {
        return String(val);
      }
      return val;
    };
    var EMPTY_OBJ = true ? Object.freeze({}) : {};
    var EMPTY_ARR = true ? Object.freeze([]) : [];
    var NOOP2 = () => {
    };
    var NO = () => false;
    var onRE = /^on[^a-z]/;
    var isOn = (key2) => onRE.test(key2);
    var isModelListener = (key2) => key2.startsWith("onUpdate:");
    var extend2 = Object.assign;
    var remove2 = (arr, el2) => {
      const i2 = arr.indexOf(el2);
      if (i2 > -1) {
        arr.splice(i2, 1);
      }
    };
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    var hasOwn2 = (val, key2) => hasOwnProperty2.call(val, key2);
    var isArray2 = Array.isArray;
    var isMap = (val) => toTypeString(val) === "[object Map]";
    var isSet = (val) => toTypeString(val) === "[object Set]";
    var isDate = (val) => val instanceof Date;
    var isFunction2 = (val) => typeof val === "function";
    var isString2 = (val) => typeof val === "string";
    var isSymbol = (val) => typeof val === "symbol";
    var isObject2 = (val) => val !== null && typeof val === "object";
    var isPromise = (val) => {
      return isObject2(val) && isFunction2(val.then) && isFunction2(val.catch);
    };
    var objectToString = Object.prototype.toString;
    var toTypeString = (value) => objectToString.call(value);
    var toRawType = (value) => {
      return toTypeString(value).slice(8, -1);
    };
    var isPlainObject = (val) => toTypeString(val) === "[object Object]";
    var isIntegerKey = (key2) => isString2(key2) && key2 !== "NaN" && key2[0] !== "-" && "" + parseInt(key2, 10) === key2;
    var isReservedProp = makeMap(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted");
    var isBuiltInDirective = makeMap("bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo");
    var cacheStringFunction$1 = (fn2) => {
      const cache2 = /* @__PURE__ */ Object.create(null);
      return (str) => {
        const hit = cache2[str];
        return hit || (cache2[str] = fn2(str));
      };
    };
    var camelizeRE$1 = /-(\w)/g;
    var camelize$1 = cacheStringFunction$1((str) => {
      return str.replace(camelizeRE$1, (_2, c3) => c3 ? c3.toUpperCase() : "");
    });
    var hyphenateRE = /\B([A-Z])/g;
    var hyphenate = cacheStringFunction$1((str) => str.replace(hyphenateRE, "-$1").toLowerCase());
    var capitalize = cacheStringFunction$1((str) => str.charAt(0).toUpperCase() + str.slice(1));
    var toHandlerKey = cacheStringFunction$1((str) => str ? `on${capitalize(str)}` : ``);
    var hasChanged = (value, oldValue) => !Object.is(value, oldValue);
    var invokeArrayFns = (fns, arg) => {
      for (let i2 = 0; i2 < fns.length; i2++) {
        fns[i2](arg);
      }
    };
    var def = (obj, key2, value) => {
      Object.defineProperty(obj, key2, {
        configurable: true,
        enumerable: false,
        value
      });
    };
    var toNumber = (val) => {
      const n3 = parseFloat(val);
      return isNaN(n3) ? val : n3;
    };
    var _globalThis;
    var getGlobalThis = () => {
      return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
    };
    var shared_esmBundler = {
      __proto__: null,
      EMPTY_ARR,
      EMPTY_OBJ,
      NO,
      NOOP: NOOP2,
      PatchFlagNames,
      camelize: camelize$1,
      capitalize,
      def,
      escapeHtml: escapeHtml2,
      escapeHtmlComment,
      extend: extend2,
      generateCodeFrame: generateCodeFrame2,
      getGlobalThis,
      hasChanged,
      hasOwn: hasOwn2,
      hyphenate,
      includeBooleanAttr,
      invokeArrayFns,
      isArray: isArray2,
      isBooleanAttr,
      isBuiltInDirective,
      isDate,
      isFunction: isFunction2,
      isGloballyWhitelisted,
      isHTMLTag,
      isIntegerKey,
      isKnownHtmlAttr,
      isKnownSvgAttr,
      isMap,
      isModelListener,
      isNoUnitNumericStyleProp,
      isObject: isObject2,
      isOn,
      isPlainObject,
      isPromise,
      isReservedProp,
      isSSRSafeAttrName,
      isSVGTag,
      isSet,
      isSpecialBooleanAttr,
      isString: isString2,
      isSymbol,
      isVoidTag,
      looseEqual,
      looseIndexOf,
      makeMap,
      normalizeClass,
      normalizeProps,
      normalizeStyle,
      objectToString,
      parseStringStyle,
      propsToAttrMap,
      remove: remove2,
      slotFlagsText,
      stringifyStyle,
      toDisplayString,
      toHandlerKey,
      toNumber,
      toRawType,
      toTypeString
    };
    function defaultOnError(error2) {
      throw error2;
    }
    function defaultOnWarn(msg) {
      console.warn(`[Vue warn] ${msg.message}`);
    }
    function createCompilerError(code, loc, messages, additionalMessage) {
      const msg = true ? (messages || errorMessages)[code] + (additionalMessage || ``) : code;
      const error2 = new SyntaxError(String(msg));
      error2.code = code;
      error2.loc = loc;
      return error2;
    }
    var errorMessages = {
      [0]: "Illegal comment.",
      [1]: "CDATA section is allowed only in XML context.",
      [2]: "Duplicate attribute.",
      [3]: "End tag cannot have attributes.",
      [4]: "Illegal '/' in tags.",
      [5]: "Unexpected EOF in tag.",
      [6]: "Unexpected EOF in CDATA section.",
      [7]: "Unexpected EOF in comment.",
      [8]: "Unexpected EOF in script.",
      [9]: "Unexpected EOF in tag.",
      [10]: "Incorrectly closed comment.",
      [11]: "Incorrectly opened comment.",
      [12]: "Illegal tag name. Use '&lt;' to print '<'.",
      [13]: "Attribute value was expected.",
      [14]: "End tag name was expected.",
      [15]: "Whitespace was expected.",
      [16]: "Unexpected '<!--' in comment.",
      [17]: `Attribute name cannot contain U+0022 ("), U+0027 ('), and U+003C (<).`,
      [18]: "Unquoted attribute value cannot contain U+0022 (\"), U+0027 ('), U+003C (<), U+003D (=), and U+0060 (`).",
      [19]: "Attribute name cannot start with '='.",
      [21]: "'<?' is allowed only in XML context.",
      [20]: `Unexpected null character.`,
      [22]: "Illegal '/' in tags.",
      [23]: "Invalid end tag.",
      [24]: "Element is missing end tag.",
      [25]: "Interpolation end sign was not found.",
      [27]: "End bracket for dynamic directive argument was not found. Note that dynamic directive argument cannot contain spaces.",
      [26]: "Legal directive name was expected.",
      [28]: `v-if/v-else-if is missing expression.`,
      [29]: `v-if/else branches must use unique keys.`,
      [30]: `v-else/v-else-if has no adjacent v-if or v-else-if.`,
      [31]: `v-for is missing expression.`,
      [32]: `v-for has invalid expression.`,
      [33]: `<template v-for> key should be placed on the <template> tag.`,
      [34]: `v-bind is missing expression.`,
      [35]: `v-on is missing expression.`,
      [36]: `Unexpected custom directive on <slot> outlet.`,
      [37]: `Mixed v-slot usage on both the component and nested <template>.When there are multiple named slots, all slots should use <template> syntax to avoid scope ambiguity.`,
      [38]: `Duplicate slot names found. `,
      [39]: `Extraneous children found when component already has explicitly named default slot. These children will be ignored.`,
      [40]: `v-slot can only be used on components or <template> tags.`,
      [41]: `v-model is missing expression.`,
      [42]: `v-model value must be a valid JavaScript member expression.`,
      [43]: `v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,
      [44]: `Error parsing JavaScript expression: `,
      [45]: `<KeepAlive> expects exactly one child component.`,
      [46]: `"prefixIdentifiers" option is not supported in this build of compiler.`,
      [47]: `ES module mode is not supported in this build of compiler.`,
      [48]: `"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.`,
      [49]: `"scopeId" option is only supported in module mode.`,
      [50]: ``
    };
    var FRAGMENT = Symbol(true ? `Fragment` : ``);
    var TELEPORT = Symbol(true ? `Teleport` : ``);
    var SUSPENSE = Symbol(true ? `Suspense` : ``);
    var KEEP_ALIVE = Symbol(true ? `KeepAlive` : ``);
    var BASE_TRANSITION = Symbol(true ? `BaseTransition` : ``);
    var OPEN_BLOCK = Symbol(true ? `openBlock` : ``);
    var CREATE_BLOCK = Symbol(true ? `createBlock` : ``);
    var CREATE_ELEMENT_BLOCK = Symbol(true ? `createElementBlock` : ``);
    var CREATE_VNODE = Symbol(true ? `createVNode` : ``);
    var CREATE_ELEMENT_VNODE = Symbol(true ? `createElementVNode` : ``);
    var CREATE_COMMENT = Symbol(true ? `createCommentVNode` : ``);
    var CREATE_TEXT = Symbol(true ? `createTextVNode` : ``);
    var CREATE_STATIC = Symbol(true ? `createStaticVNode` : ``);
    var RESOLVE_COMPONENT = Symbol(true ? `resolveComponent` : ``);
    var RESOLVE_DYNAMIC_COMPONENT = Symbol(true ? `resolveDynamicComponent` : ``);
    var RESOLVE_DIRECTIVE = Symbol(true ? `resolveDirective` : ``);
    var RESOLVE_FILTER = Symbol(true ? `resolveFilter` : ``);
    var WITH_DIRECTIVES = Symbol(true ? `withDirectives` : ``);
    var RENDER_LIST = Symbol(true ? `renderList` : ``);
    var RENDER_SLOT = Symbol(true ? `renderSlot` : ``);
    var CREATE_SLOTS = Symbol(true ? `createSlots` : ``);
    var TO_DISPLAY_STRING = Symbol(true ? `toDisplayString` : ``);
    var MERGE_PROPS = Symbol(true ? `mergeProps` : ``);
    var NORMALIZE_CLASS = Symbol(true ? `normalizeClass` : ``);
    var NORMALIZE_STYLE = Symbol(true ? `normalizeStyle` : ``);
    var NORMALIZE_PROPS = Symbol(true ? `normalizeProps` : ``);
    var GUARD_REACTIVE_PROPS = Symbol(true ? `guardReactiveProps` : ``);
    var TO_HANDLERS = Symbol(true ? `toHandlers` : ``);
    var CAMELIZE = Symbol(true ? `camelize` : ``);
    var CAPITALIZE = Symbol(true ? `capitalize` : ``);
    var TO_HANDLER_KEY = Symbol(true ? `toHandlerKey` : ``);
    var SET_BLOCK_TRACKING = Symbol(true ? `setBlockTracking` : ``);
    var PUSH_SCOPE_ID = Symbol(true ? `pushScopeId` : ``);
    var POP_SCOPE_ID = Symbol(true ? `popScopeId` : ``);
    var WITH_CTX = Symbol(true ? `withCtx` : ``);
    var UNREF = Symbol(true ? `unref` : ``);
    var IS_REF = Symbol(true ? `isRef` : ``);
    var WITH_MEMO = Symbol(true ? `withMemo` : ``);
    var IS_MEMO_SAME = Symbol(true ? `isMemoSame` : ``);
    var helperNameMap = {
      [FRAGMENT]: `Fragment`,
      [TELEPORT]: `Teleport`,
      [SUSPENSE]: `Suspense`,
      [KEEP_ALIVE]: `KeepAlive`,
      [BASE_TRANSITION]: `BaseTransition`,
      [OPEN_BLOCK]: `openBlock`,
      [CREATE_BLOCK]: `createBlock`,
      [CREATE_ELEMENT_BLOCK]: `createElementBlock`,
      [CREATE_VNODE]: `createVNode`,
      [CREATE_ELEMENT_VNODE]: `createElementVNode`,
      [CREATE_COMMENT]: `createCommentVNode`,
      [CREATE_TEXT]: `createTextVNode`,
      [CREATE_STATIC]: `createStaticVNode`,
      [RESOLVE_COMPONENT]: `resolveComponent`,
      [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,
      [RESOLVE_DIRECTIVE]: `resolveDirective`,
      [RESOLVE_FILTER]: `resolveFilter`,
      [WITH_DIRECTIVES]: `withDirectives`,
      [RENDER_LIST]: `renderList`,
      [RENDER_SLOT]: `renderSlot`,
      [CREATE_SLOTS]: `createSlots`,
      [TO_DISPLAY_STRING]: `toDisplayString`,
      [MERGE_PROPS]: `mergeProps`,
      [NORMALIZE_CLASS]: `normalizeClass`,
      [NORMALIZE_STYLE]: `normalizeStyle`,
      [NORMALIZE_PROPS]: `normalizeProps`,
      [GUARD_REACTIVE_PROPS]: `guardReactiveProps`,
      [TO_HANDLERS]: `toHandlers`,
      [CAMELIZE]: `camelize`,
      [CAPITALIZE]: `capitalize`,
      [TO_HANDLER_KEY]: `toHandlerKey`,
      [SET_BLOCK_TRACKING]: `setBlockTracking`,
      [PUSH_SCOPE_ID]: `pushScopeId`,
      [POP_SCOPE_ID]: `popScopeId`,
      [WITH_CTX]: `withCtx`,
      [UNREF]: `unref`,
      [IS_REF]: `isRef`,
      [WITH_MEMO]: `withMemo`,
      [IS_MEMO_SAME]: `isMemoSame`
    };
    function registerRuntimeHelpers(helpers) {
      Object.getOwnPropertySymbols(helpers).forEach((s2) => {
        helperNameMap[s2] = helpers[s2];
      });
    }
    var locStub = {
      source: "",
      start: { line: 1, column: 1, offset: 0 },
      end: { line: 1, column: 1, offset: 0 }
    };
    function createRoot(children, loc = locStub) {
      return {
        type: 0,
        children,
        helpers: [],
        components: [],
        directives: [],
        hoists: [],
        imports: [],
        cached: 0,
        temps: 0,
        codegenNode: void 0,
        loc
      };
    }
    function createVNodeCall(context2, tag, props, children, patchFlag, dynamicProps, directives, isBlock = false, disableTracking = false, isComponent2 = false, loc = locStub) {
      if (context2) {
        if (isBlock) {
          context2.helper(OPEN_BLOCK);
          context2.helper(getVNodeBlockHelper(context2.inSSR, isComponent2));
        } else {
          context2.helper(getVNodeHelper(context2.inSSR, isComponent2));
        }
        if (directives) {
          context2.helper(WITH_DIRECTIVES);
        }
      }
      return {
        type: 13,
        tag,
        props,
        children,
        patchFlag,
        dynamicProps,
        directives,
        isBlock,
        disableTracking,
        isComponent: isComponent2,
        loc
      };
    }
    function createArrayExpression(elements, loc = locStub) {
      return {
        type: 17,
        loc,
        elements
      };
    }
    function createObjectExpression(properties, loc = locStub) {
      return {
        type: 15,
        loc,
        properties
      };
    }
    function createObjectProperty(key2, value) {
      return {
        type: 16,
        loc: locStub,
        key: isString2(key2) ? createSimpleExpression(key2, true) : key2,
        value
      };
    }
    function createSimpleExpression(content2, isStatic = false, loc = locStub, constType = 0) {
      return {
        type: 4,
        loc,
        content: content2,
        isStatic,
        constType: isStatic ? 3 : constType
      };
    }
    function createInterpolation(content2, loc) {
      return {
        type: 5,
        loc,
        content: isString2(content2) ? createSimpleExpression(content2, false, loc) : content2
      };
    }
    function createCompoundExpression(children, loc = locStub) {
      return {
        type: 8,
        loc,
        children
      };
    }
    function createCallExpression(callee, args = [], loc = locStub) {
      return {
        type: 14,
        loc,
        callee,
        arguments: args
      };
    }
    function createFunctionExpression(params, returns = void 0, newline = false, isSlot = false, loc = locStub) {
      return {
        type: 18,
        params,
        returns,
        newline,
        isSlot,
        loc
      };
    }
    function createConditionalExpression(test, consequent, alternate, newline = true) {
      return {
        type: 19,
        test,
        consequent,
        alternate,
        newline,
        loc: locStub
      };
    }
    function createCacheExpression(index3, value, isVNode = false) {
      return {
        type: 20,
        index: index3,
        value,
        isVNode,
        loc: locStub
      };
    }
    function createBlockStatement(body) {
      return {
        type: 21,
        body,
        loc: locStub
      };
    }
    function createTemplateLiteral(elements) {
      return {
        type: 22,
        elements,
        loc: locStub
      };
    }
    function createIfStatement(test, consequent, alternate) {
      return {
        type: 23,
        test,
        consequent,
        alternate,
        loc: locStub
      };
    }
    function createAssignmentExpression(left, right) {
      return {
        type: 24,
        left,
        right,
        loc: locStub
      };
    }
    function createSequenceExpression(expressions) {
      return {
        type: 25,
        expressions,
        loc: locStub
      };
    }
    function createReturnStatement(returns) {
      return {
        type: 26,
        returns,
        loc: locStub
      };
    }
    var isStaticExp = (p2) => p2.type === 4 && p2.isStatic;
    var isBuiltInType = (tag, expected) => tag === expected || tag === hyphenate(expected);
    function isCoreComponent(tag) {
      if (isBuiltInType(tag, "Teleport")) {
        return TELEPORT;
      } else if (isBuiltInType(tag, "Suspense")) {
        return SUSPENSE;
      } else if (isBuiltInType(tag, "KeepAlive")) {
        return KEEP_ALIVE;
      } else if (isBuiltInType(tag, "BaseTransition")) {
        return BASE_TRANSITION;
      }
    }
    var nonIdentifierRE = /^\d|[^\$\w]/;
    var isSimpleIdentifier = (name) => !nonIdentifierRE.test(name);
    var validFirstIdentCharRE = /[A-Za-z_$\xA0-\uFFFF]/;
    var validIdentCharRE = /[\.\?\w$\xA0-\uFFFF]/;
    var whitespaceRE = /\s+[.[]\s*|\s*[.[]\s+/g;
    var isMemberExpressionBrowser = (path2) => {
      path2 = path2.trim().replace(whitespaceRE, (s2) => s2.trim());
      let state = 0;
      let stateStack = [];
      let currentOpenBracketCount = 0;
      let currentOpenParensCount = 0;
      let currentStringType = null;
      for (let i2 = 0; i2 < path2.length; i2++) {
        const char = path2.charAt(i2);
        switch (state) {
          case 0:
            if (char === "[") {
              stateStack.push(state);
              state = 1;
              currentOpenBracketCount++;
            } else if (char === "(") {
              stateStack.push(state);
              state = 2;
              currentOpenParensCount++;
            } else if (!(i2 === 0 ? validFirstIdentCharRE : validIdentCharRE).test(char)) {
              return false;
            }
            break;
          case 1:
            if (char === `'` || char === `"` || char === "`") {
              stateStack.push(state);
              state = 3;
              currentStringType = char;
            } else if (char === `[`) {
              currentOpenBracketCount++;
            } else if (char === `]`) {
              if (!--currentOpenBracketCount) {
                state = stateStack.pop();
              }
            }
            break;
          case 2:
            if (char === `'` || char === `"` || char === "`") {
              stateStack.push(state);
              state = 3;
              currentStringType = char;
            } else if (char === `(`) {
              currentOpenParensCount++;
            } else if (char === `)`) {
              if (i2 === path2.length - 1) {
                return false;
              }
              if (!--currentOpenParensCount) {
                state = stateStack.pop();
              }
            }
            break;
          case 3:
            if (char === currentStringType) {
              state = stateStack.pop();
              currentStringType = null;
            }
            break;
        }
      }
      return !currentOpenBracketCount && !currentOpenParensCount;
    };
    var isMemberExpressionNode = NOOP2;
    var isMemberExpression = isMemberExpressionBrowser;
    function getInnerRange(loc, offset2, length) {
      const source2 = loc.source.slice(offset2, offset2 + length);
      const newLoc = {
        source: source2,
        start: advancePositionWithClone(loc.start, loc.source, offset2),
        end: loc.end
      };
      if (length != null) {
        newLoc.end = advancePositionWithClone(loc.start, loc.source, offset2 + length);
      }
      return newLoc;
    }
    function advancePositionWithClone(pos2, source2, numberOfCharacters = source2.length) {
      return advancePositionWithMutation(extend2({}, pos2), source2, numberOfCharacters);
    }
    function advancePositionWithMutation(pos2, source2, numberOfCharacters = source2.length) {
      let linesCount = 0;
      let lastNewLinePos = -1;
      for (let i2 = 0; i2 < numberOfCharacters; i2++) {
        if (source2.charCodeAt(i2) === 10) {
          linesCount++;
          lastNewLinePos = i2;
        }
      }
      pos2.offset += numberOfCharacters;
      pos2.line += linesCount;
      pos2.column = lastNewLinePos === -1 ? pos2.column + numberOfCharacters : numberOfCharacters - lastNewLinePos;
      return pos2;
    }
    function assert2(condition, msg) {
      if (!condition) {
        throw new Error(msg || `unexpected compiler condition`);
      }
    }
    function findDir(node2, name, allowEmpty = false) {
      for (let i2 = 0; i2 < node2.props.length; i2++) {
        const p2 = node2.props[i2];
        if (p2.type === 7 && (allowEmpty || p2.exp) && (isString2(name) ? p2.name === name : name.test(p2.name))) {
          return p2;
        }
      }
    }
    function findProp(node2, name, dynamicOnly = false, allowEmpty = false) {
      for (let i2 = 0; i2 < node2.props.length; i2++) {
        const p2 = node2.props[i2];
        if (p2.type === 6) {
          if (dynamicOnly)
            continue;
          if (p2.name === name && (p2.value || allowEmpty)) {
            return p2;
          }
        } else if (p2.name === "bind" && (p2.exp || allowEmpty) && isStaticArgOf(p2.arg, name)) {
          return p2;
        }
      }
    }
    function isStaticArgOf(arg, name) {
      return !!(arg && isStaticExp(arg) && arg.content === name);
    }
    function hasDynamicKeyVBind(node2) {
      return node2.props.some((p2) => p2.type === 7 && p2.name === "bind" && (!p2.arg || p2.arg.type !== 4 || !p2.arg.isStatic));
    }
    function isText(node2) {
      return node2.type === 5 || node2.type === 2;
    }
    function isVSlot(p2) {
      return p2.type === 7 && p2.name === "slot";
    }
    function isTemplateNode(node2) {
      return node2.type === 1 && node2.tagType === 3;
    }
    function isSlotOutlet(node2) {
      return node2.type === 1 && node2.tagType === 2;
    }
    function getVNodeHelper(ssr, isComponent2) {
      return ssr || isComponent2 ? CREATE_VNODE : CREATE_ELEMENT_VNODE;
    }
    function getVNodeBlockHelper(ssr, isComponent2) {
      return ssr || isComponent2 ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK;
    }
    var propsHelperSet = /* @__PURE__ */ new Set([NORMALIZE_PROPS, GUARD_REACTIVE_PROPS]);
    function getUnnormalizedProps(props, callPath = []) {
      if (props && !isString2(props) && props.type === 14) {
        const callee = props.callee;
        if (!isString2(callee) && propsHelperSet.has(callee)) {
          return getUnnormalizedProps(props.arguments[0], callPath.concat(props));
        }
      }
      return [props, callPath];
    }
    function injectProp(node2, prop, context2) {
      let propsWithInjection;
      let props = node2.type === 13 ? node2.props : node2.arguments[2];
      let callPath = [];
      let parentCall;
      if (props && !isString2(props) && props.type === 14) {
        const ret = getUnnormalizedProps(props);
        props = ret[0];
        callPath = ret[1];
        parentCall = callPath[callPath.length - 1];
      }
      if (props == null || isString2(props)) {
        propsWithInjection = createObjectExpression([prop]);
      } else if (props.type === 14) {
        const first2 = props.arguments[0];
        if (!isString2(first2) && first2.type === 15) {
          first2.properties.unshift(prop);
        } else {
          if (props.callee === TO_HANDLERS) {
            propsWithInjection = createCallExpression(context2.helper(MERGE_PROPS), [
              createObjectExpression([prop]),
              props
            ]);
          } else {
            props.arguments.unshift(createObjectExpression([prop]));
          }
        }
        !propsWithInjection && (propsWithInjection = props);
      } else if (props.type === 15) {
        let alreadyExists = false;
        if (prop.key.type === 4) {
          const propKeyName = prop.key.content;
          alreadyExists = props.properties.some((p2) => p2.key.type === 4 && p2.key.content === propKeyName);
        }
        if (!alreadyExists) {
          props.properties.unshift(prop);
        }
        propsWithInjection = props;
      } else {
        propsWithInjection = createCallExpression(context2.helper(MERGE_PROPS), [
          createObjectExpression([prop]),
          props
        ]);
        if (parentCall && parentCall.callee === GUARD_REACTIVE_PROPS) {
          parentCall = callPath[callPath.length - 2];
        }
      }
      if (node2.type === 13) {
        if (parentCall) {
          parentCall.arguments[0] = propsWithInjection;
        } else {
          node2.props = propsWithInjection;
        }
      } else {
        if (parentCall) {
          parentCall.arguments[0] = propsWithInjection;
        } else {
          node2.arguments[2] = propsWithInjection;
        }
      }
    }
    function toValidAssetId(name, type) {
      return `_${type}_${name.replace(/[^\w]/g, (searchValue, replaceValue) => {
        return searchValue === "-" ? "_" : name.charCodeAt(replaceValue).toString();
      })}`;
    }
    function hasScopeRef(node2, ids) {
      if (!node2 || Object.keys(ids).length === 0) {
        return false;
      }
      switch (node2.type) {
        case 1:
          for (let i2 = 0; i2 < node2.props.length; i2++) {
            const p2 = node2.props[i2];
            if (p2.type === 7 && (hasScopeRef(p2.arg, ids) || hasScopeRef(p2.exp, ids))) {
              return true;
            }
          }
          return node2.children.some((c3) => hasScopeRef(c3, ids));
        case 11:
          if (hasScopeRef(node2.source, ids)) {
            return true;
          }
          return node2.children.some((c3) => hasScopeRef(c3, ids));
        case 9:
          return node2.branches.some((b2) => hasScopeRef(b2, ids));
        case 10:
          if (hasScopeRef(node2.condition, ids)) {
            return true;
          }
          return node2.children.some((c3) => hasScopeRef(c3, ids));
        case 4:
          return !node2.isStatic && isSimpleIdentifier(node2.content) && !!ids[node2.content];
        case 8:
          return node2.children.some((c3) => isObject2(c3) && hasScopeRef(c3, ids));
        case 5:
        case 12:
          return hasScopeRef(node2.content, ids);
        case 2:
        case 3:
          return false;
        default:
          if (true)
            ;
          return false;
      }
    }
    function getMemoedVNodeCall(node2) {
      if (node2.type === 14 && node2.callee === WITH_MEMO) {
        return node2.arguments[1].returns;
      } else {
        return node2;
      }
    }
    function makeBlock(node2, { helper, removeHelper, inSSR }) {
      if (!node2.isBlock) {
        node2.isBlock = true;
        removeHelper(getVNodeHelper(inSSR, node2.isComponent));
        helper(OPEN_BLOCK);
        helper(getVNodeBlockHelper(inSSR, node2.isComponent));
      }
    }
    var deprecationData = {
      ["COMPILER_IS_ON_ELEMENT"]: {
        message: `Platform-native elements with "is" prop will no longer be treated as components in Vue 3 unless the "is" value is explicitly prefixed with "vue:".`,
        link: `https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html`
      },
      ["COMPILER_V_BIND_SYNC"]: {
        message: (key2) => `.sync modifier for v-bind has been removed. Use v-model with argument instead. \`v-bind:${key2}.sync\` should be changed to \`v-model:${key2}\`.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/v-model.html`
      },
      ["COMPILER_V_BIND_PROP"]: {
        message: `.prop modifier for v-bind has been removed and no longer necessary. Vue 3 will automatically set a binding as DOM property when appropriate.`
      },
      ["COMPILER_V_BIND_OBJECT_ORDER"]: {
        message: `v-bind="obj" usage is now order sensitive and behaves like JavaScript object spread: it will now overwrite an existing non-mergeable attribute that appears before v-bind in the case of conflict. To retain 2.x behavior, move v-bind to make it the first attribute. You can also suppress this warning if the usage is intended.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/v-bind.html`
      },
      ["COMPILER_V_ON_NATIVE"]: {
        message: `.native modifier for v-on has been removed as is no longer necessary.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html`
      },
      ["COMPILER_V_IF_V_FOR_PRECEDENCE"]: {
        message: `v-if / v-for precedence when used on the same element has changed in Vue 3: v-if now takes higher precedence and will no longer have access to v-for scope variables. It is best to avoid the ambiguity with <template> tags or use a computed property that filters v-for data source.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html`
      },
      ["COMPILER_NATIVE_TEMPLATE"]: {
        message: `<template> with no special directives will render as a native template element instead of its inner content in Vue 3.`
      },
      ["COMPILER_INLINE_TEMPLATE"]: {
        message: `"inline-template" has been removed in Vue 3.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html`
      },
      ["COMPILER_FILTER"]: {
        message: `filters have been removed in Vue 3. The "|" symbol will be treated as native JavaScript bitwise OR operator. Use method calls or computed properties instead.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/filters.html`
      }
    };
    function getCompatValue(key2, context2) {
      const config2 = context2.options ? context2.options.compatConfig : context2.compatConfig;
      const value = config2 && config2[key2];
      if (key2 === "MODE") {
        return value || 3;
      } else {
        return value;
      }
    }
    function isCompatEnabled(key2, context2) {
      const mode2 = getCompatValue("MODE", context2);
      const value = getCompatValue(key2, context2);
      return mode2 === 3 ? value === true : value !== false;
    }
    function checkCompatEnabled(key2, context2, loc, ...args) {
      const enabled = isCompatEnabled(key2, context2);
      if (enabled) {
        warnDeprecation(key2, context2, loc, ...args);
      }
      return enabled;
    }
    function warnDeprecation(key2, context2, loc, ...args) {
      const val = getCompatValue(key2, context2);
      if (val === "suppress-warning") {
        return;
      }
      const { message, link } = deprecationData[key2];
      const msg = `(deprecation ${key2}) ${typeof message === "function" ? message(...args) : message}${link ? `
  Details: ${link}` : ``}`;
      const err = new SyntaxError(msg);
      err.code = key2;
      if (loc)
        err.loc = loc;
      context2.onWarn(err);
    }
    var decodeRE = /&(gt|lt|amp|apos|quot);/g;
    var decodeMap = {
      gt: ">",
      lt: "<",
      amp: "&",
      apos: "'",
      quot: '"'
    };
    var defaultParserOptions = {
      delimiters: [`{{`, `}}`],
      getNamespace: () => 0,
      getTextMode: () => 0,
      isVoidTag: NO,
      isPreTag: NO,
      isCustomElement: NO,
      decodeEntities: (rawText) => rawText.replace(decodeRE, (_2, p1) => decodeMap[p1]),
      onError: defaultOnError,
      onWarn: defaultOnWarn,
      comments: true
    };
    function baseParse(content2, options2 = {}) {
      const context2 = createParserContext(content2, options2);
      const start = getCursor(context2);
      return createRoot(parseChildren(context2, 0, []), getSelection(context2, start));
    }
    function createParserContext(content2, rawOptions) {
      const options2 = extend2({}, defaultParserOptions);
      let key2;
      for (key2 in rawOptions) {
        options2[key2] = rawOptions[key2] === void 0 ? defaultParserOptions[key2] : rawOptions[key2];
      }
      return {
        options: options2,
        column: 1,
        line: 1,
        offset: 0,
        originalSource: content2,
        source: content2,
        inPre: false,
        inVPre: false,
        onWarn: options2.onWarn
      };
    }
    function parseChildren(context2, mode2, ancestors) {
      const parent = last(ancestors);
      const ns2 = parent ? parent.ns : 0;
      const nodes = [];
      while (!isEnd(context2, mode2, ancestors)) {
        const s2 = context2.source;
        let node2 = void 0;
        if (mode2 === 0 || mode2 === 1) {
          if (!context2.inVPre && startsWith(s2, context2.options.delimiters[0])) {
            node2 = parseInterpolation(context2, mode2);
          } else if (mode2 === 0 && s2[0] === "<") {
            if (s2.length === 1) {
              emitError(context2, 5, 1);
            } else if (s2[1] === "!") {
              if (startsWith(s2, "<!--")) {
                node2 = parseComment(context2);
              } else if (startsWith(s2, "<!DOCTYPE")) {
                node2 = parseBogusComment(context2);
              } else if (startsWith(s2, "<![CDATA[")) {
                if (ns2 !== 0) {
                  node2 = parseCDATA(context2, ancestors);
                } else {
                  emitError(context2, 1);
                  node2 = parseBogusComment(context2);
                }
              } else {
                emitError(context2, 11);
                node2 = parseBogusComment(context2);
              }
            } else if (s2[1] === "/") {
              if (s2.length === 2) {
                emitError(context2, 5, 2);
              } else if (s2[2] === ">") {
                emitError(context2, 14, 2);
                advanceBy(context2, 3);
                continue;
              } else if (/[a-z]/i.test(s2[2])) {
                emitError(context2, 23);
                parseTag(context2, 1, parent);
                continue;
              } else {
                emitError(context2, 12, 2);
                node2 = parseBogusComment(context2);
              }
            } else if (/[a-z]/i.test(s2[1])) {
              node2 = parseElement(context2, ancestors);
              if (isCompatEnabled("COMPILER_NATIVE_TEMPLATE", context2) && node2 && node2.tag === "template" && !node2.props.some((p2) => p2.type === 7 && isSpecialTemplateDirective(p2.name))) {
                warnDeprecation("COMPILER_NATIVE_TEMPLATE", context2, node2.loc);
                node2 = node2.children;
              }
            } else if (s2[1] === "?") {
              emitError(context2, 21, 1);
              node2 = parseBogusComment(context2);
            } else {
              emitError(context2, 12, 1);
            }
          }
        }
        if (!node2) {
          node2 = parseText(context2, mode2);
        }
        if (isArray2(node2)) {
          for (let i2 = 0; i2 < node2.length; i2++) {
            pushNode(nodes, node2[i2]);
          }
        } else {
          pushNode(nodes, node2);
        }
      }
      let removedWhitespace = false;
      if (mode2 !== 2 && mode2 !== 1) {
        const shouldCondense = context2.options.whitespace !== "preserve";
        for (let i2 = 0; i2 < nodes.length; i2++) {
          const node2 = nodes[i2];
          if (!context2.inPre && node2.type === 2) {
            if (!/[^\t\r\n\f ]/.test(node2.content)) {
              const prev = nodes[i2 - 1];
              const next = nodes[i2 + 1];
              if (!prev || !next || shouldCondense && (prev.type === 3 || next.type === 3 || prev.type === 1 && next.type === 1 && /[\r\n]/.test(node2.content))) {
                removedWhitespace = true;
                nodes[i2] = null;
              } else {
                node2.content = " ";
              }
            } else if (shouldCondense) {
              node2.content = node2.content.replace(/[\t\r\n\f ]+/g, " ");
            }
          } else if (node2.type === 3 && !context2.options.comments) {
            removedWhitespace = true;
            nodes[i2] = null;
          }
        }
        if (context2.inPre && parent && context2.options.isPreTag(parent.tag)) {
          const first2 = nodes[0];
          if (first2 && first2.type === 2) {
            first2.content = first2.content.replace(/^\r?\n/, "");
          }
        }
      }
      return removedWhitespace ? nodes.filter(Boolean) : nodes;
    }
    function pushNode(nodes, node2) {
      if (node2.type === 2) {
        const prev = last(nodes);
        if (prev && prev.type === 2 && prev.loc.end.offset === node2.loc.start.offset) {
          prev.content += node2.content;
          prev.loc.end = node2.loc.end;
          prev.loc.source += node2.loc.source;
          return;
        }
      }
      nodes.push(node2);
    }
    function parseCDATA(context2, ancestors) {
      advanceBy(context2, 9);
      const nodes = parseChildren(context2, 3, ancestors);
      if (context2.source.length === 0) {
        emitError(context2, 6);
      } else {
        advanceBy(context2, 3);
      }
      return nodes;
    }
    function parseComment(context2) {
      const start = getCursor(context2);
      let content2;
      const match2 = /--(\!)?>/.exec(context2.source);
      if (!match2) {
        content2 = context2.source.slice(4);
        advanceBy(context2, context2.source.length);
        emitError(context2, 7);
      } else {
        if (match2.index <= 3) {
          emitError(context2, 0);
        }
        if (match2[1]) {
          emitError(context2, 10);
        }
        content2 = context2.source.slice(4, match2.index);
        const s2 = context2.source.slice(0, match2.index);
        let prevIndex = 1, nestedIndex = 0;
        while ((nestedIndex = s2.indexOf("<!--", prevIndex)) !== -1) {
          advanceBy(context2, nestedIndex - prevIndex + 1);
          if (nestedIndex + 4 < s2.length) {
            emitError(context2, 16);
          }
          prevIndex = nestedIndex + 1;
        }
        advanceBy(context2, match2.index + match2[0].length - prevIndex + 1);
      }
      return {
        type: 3,
        content: content2,
        loc: getSelection(context2, start)
      };
    }
    function parseBogusComment(context2) {
      const start = getCursor(context2);
      const contentStart = context2.source[1] === "?" ? 1 : 2;
      let content2;
      const closeIndex = context2.source.indexOf(">");
      if (closeIndex === -1) {
        content2 = context2.source.slice(contentStart);
        advanceBy(context2, context2.source.length);
      } else {
        content2 = context2.source.slice(contentStart, closeIndex);
        advanceBy(context2, closeIndex + 1);
      }
      return {
        type: 3,
        content: content2,
        loc: getSelection(context2, start)
      };
    }
    function parseElement(context2, ancestors) {
      const wasInPre = context2.inPre;
      const wasInVPre = context2.inVPre;
      const parent = last(ancestors);
      const element = parseTag(context2, 0, parent);
      const isPreBoundary = context2.inPre && !wasInPre;
      const isVPreBoundary = context2.inVPre && !wasInVPre;
      if (element.isSelfClosing || context2.options.isVoidTag(element.tag)) {
        if (isPreBoundary) {
          context2.inPre = false;
        }
        if (isVPreBoundary) {
          context2.inVPre = false;
        }
        return element;
      }
      ancestors.push(element);
      const mode2 = context2.options.getTextMode(element, parent);
      const children = parseChildren(context2, mode2, ancestors);
      ancestors.pop();
      {
        const inlineTemplateProp = element.props.find((p2) => p2.type === 6 && p2.name === "inline-template");
        if (inlineTemplateProp && checkCompatEnabled("COMPILER_INLINE_TEMPLATE", context2, inlineTemplateProp.loc)) {
          const loc = getSelection(context2, element.loc.end);
          inlineTemplateProp.value = {
            type: 2,
            content: loc.source,
            loc
          };
        }
      }
      element.children = children;
      if (startsWithEndTagOpen(context2.source, element.tag)) {
        parseTag(context2, 1, parent);
      } else {
        emitError(context2, 24, 0, element.loc.start);
        if (context2.source.length === 0 && element.tag.toLowerCase() === "script") {
          const first2 = children[0];
          if (first2 && startsWith(first2.loc.source, "<!--")) {
            emitError(context2, 8);
          }
        }
      }
      element.loc = getSelection(context2, element.loc.start);
      if (isPreBoundary) {
        context2.inPre = false;
      }
      if (isVPreBoundary) {
        context2.inVPre = false;
      }
      return element;
    }
    var isSpecialTemplateDirective = makeMap(`if,else,else-if,for,slot`);
    function parseTag(context2, type, parent) {
      const start = getCursor(context2);
      const match2 = /^<\/?([a-z][^\t\r\n\f />]*)/i.exec(context2.source);
      const tag = match2[1];
      const ns2 = context2.options.getNamespace(tag, parent);
      advanceBy(context2, match2[0].length);
      advanceSpaces(context2);
      const cursor = getCursor(context2);
      const currentSource = context2.source;
      if (context2.options.isPreTag(tag)) {
        context2.inPre = true;
      }
      let props = parseAttributes(context2, type);
      if (type === 0 && !context2.inVPre && props.some((p2) => p2.type === 7 && p2.name === "pre")) {
        context2.inVPre = true;
        extend2(context2, cursor);
        context2.source = currentSource;
        props = parseAttributes(context2, type).filter((p2) => p2.name !== "v-pre");
      }
      let isSelfClosing = false;
      if (context2.source.length === 0) {
        emitError(context2, 9);
      } else {
        isSelfClosing = startsWith(context2.source, "/>");
        if (type === 1 && isSelfClosing) {
          emitError(context2, 4);
        }
        advanceBy(context2, isSelfClosing ? 2 : 1);
      }
      if (type === 1) {
        return;
      }
      if (isCompatEnabled("COMPILER_V_IF_V_FOR_PRECEDENCE", context2)) {
        let hasIf = false;
        let hasFor = false;
        for (let i2 = 0; i2 < props.length; i2++) {
          const p2 = props[i2];
          if (p2.type === 7) {
            if (p2.name === "if") {
              hasIf = true;
            } else if (p2.name === "for") {
              hasFor = true;
            }
          }
          if (hasIf && hasFor) {
            warnDeprecation("COMPILER_V_IF_V_FOR_PRECEDENCE", context2, getSelection(context2, start));
            break;
          }
        }
      }
      let tagType = 0;
      if (!context2.inVPre) {
        if (tag === "slot") {
          tagType = 2;
        } else if (tag === "template") {
          if (props.some((p2) => p2.type === 7 && isSpecialTemplateDirective(p2.name))) {
            tagType = 3;
          }
        } else if (isComponent(tag, props, context2)) {
          tagType = 1;
        }
      }
      return {
        type: 1,
        ns: ns2,
        tag,
        tagType,
        props,
        isSelfClosing,
        children: [],
        loc: getSelection(context2, start),
        codegenNode: void 0
      };
    }
    function isComponent(tag, props, context2) {
      const options2 = context2.options;
      if (options2.isCustomElement(tag)) {
        return false;
      }
      if (tag === "component" || /^[A-Z]/.test(tag) || isCoreComponent(tag) || options2.isBuiltInComponent && options2.isBuiltInComponent(tag) || options2.isNativeTag && !options2.isNativeTag(tag)) {
        return true;
      }
      for (let i2 = 0; i2 < props.length; i2++) {
        const p2 = props[i2];
        if (p2.type === 6) {
          if (p2.name === "is" && p2.value) {
            if (p2.value.content.startsWith("vue:")) {
              return true;
            } else if (checkCompatEnabled("COMPILER_IS_ON_ELEMENT", context2, p2.loc)) {
              return true;
            }
          }
        } else {
          if (p2.name === "is") {
            return true;
          } else if (p2.name === "bind" && isStaticArgOf(p2.arg, "is") && true && checkCompatEnabled("COMPILER_IS_ON_ELEMENT", context2, p2.loc)) {
            return true;
          }
        }
      }
    }
    function parseAttributes(context2, type) {
      const props = [];
      const attributeNames = /* @__PURE__ */ new Set();
      while (context2.source.length > 0 && !startsWith(context2.source, ">") && !startsWith(context2.source, "/>")) {
        if (startsWith(context2.source, "/")) {
          emitError(context2, 22);
          advanceBy(context2, 1);
          advanceSpaces(context2);
          continue;
        }
        if (type === 1) {
          emitError(context2, 3);
        }
        const attr = parseAttribute(context2, attributeNames);
        if (attr.type === 6 && attr.value && attr.name === "class") {
          attr.value.content = attr.value.content.replace(/\s+/g, " ").trim();
        }
        if (type === 0) {
          props.push(attr);
        }
        if (/^[^\t\r\n\f />]/.test(context2.source)) {
          emitError(context2, 15);
        }
        advanceSpaces(context2);
      }
      return props;
    }
    function parseAttribute(context2, nameSet) {
      const start = getCursor(context2);
      const match2 = /^[^\t\r\n\f />][^\t\r\n\f />=]*/.exec(context2.source);
      const name = match2[0];
      if (nameSet.has(name)) {
        emitError(context2, 2);
      }
      nameSet.add(name);
      if (name[0] === "=") {
        emitError(context2, 19);
      }
      {
        const pattern2 = /["'<]/g;
        let m3;
        while (m3 = pattern2.exec(name)) {
          emitError(context2, 17, m3.index);
        }
      }
      advanceBy(context2, name.length);
      let value = void 0;
      if (/^[\t\r\n\f ]*=/.test(context2.source)) {
        advanceSpaces(context2);
        advanceBy(context2, 1);
        advanceSpaces(context2);
        value = parseAttributeValue(context2);
        if (!value) {
          emitError(context2, 13);
        }
      }
      const loc = getSelection(context2, start);
      if (!context2.inVPre && /^(v-[A-Za-z0-9-]|:|\.|@|#)/.test(name)) {
        const match3 = /(?:^v-([a-z0-9-]+))?(?:(?::|^\.|^@|^#)(\[[^\]]+\]|[^\.]+))?(.+)?$/i.exec(name);
        let isPropShorthand = startsWith(name, ".");
        let dirName = match3[1] || (isPropShorthand || startsWith(name, ":") ? "bind" : startsWith(name, "@") ? "on" : "slot");
        let arg;
        if (match3[2]) {
          const isSlot = dirName === "slot";
          const startOffset = name.lastIndexOf(match3[2]);
          const loc2 = getSelection(context2, getNewPosition(context2, start, startOffset), getNewPosition(context2, start, startOffset + match3[2].length + (isSlot && match3[3] || "").length));
          let content2 = match3[2];
          let isStatic = true;
          if (content2.startsWith("[")) {
            isStatic = false;
            if (!content2.endsWith("]")) {
              emitError(context2, 27);
              content2 = content2.slice(1);
            } else {
              content2 = content2.slice(1, content2.length - 1);
            }
          } else if (isSlot) {
            content2 += match3[3] || "";
          }
          arg = {
            type: 4,
            content: content2,
            isStatic,
            constType: isStatic ? 3 : 0,
            loc: loc2
          };
        }
        if (value && value.isQuoted) {
          const valueLoc = value.loc;
          valueLoc.start.offset++;
          valueLoc.start.column++;
          valueLoc.end = advancePositionWithClone(valueLoc.start, value.content);
          valueLoc.source = valueLoc.source.slice(1, -1);
        }
        const modifiers = match3[3] ? match3[3].slice(1).split(".") : [];
        if (isPropShorthand)
          modifiers.push("prop");
        if (dirName === "bind" && arg) {
          if (modifiers.includes("sync") && checkCompatEnabled("COMPILER_V_BIND_SYNC", context2, loc, arg.loc.source)) {
            dirName = "model";
            modifiers.splice(modifiers.indexOf("sync"), 1);
          }
          if (modifiers.includes("prop")) {
            checkCompatEnabled("COMPILER_V_BIND_PROP", context2, loc);
          }
        }
        return {
          type: 7,
          name: dirName,
          exp: value && {
            type: 4,
            content: value.content,
            isStatic: false,
            constType: 0,
            loc: value.loc
          },
          arg,
          modifiers,
          loc
        };
      }
      if (!context2.inVPre && startsWith(name, "v-")) {
        emitError(context2, 26);
      }
      return {
        type: 6,
        name,
        value: value && {
          type: 2,
          content: value.content,
          loc: value.loc
        },
        loc
      };
    }
    function parseAttributeValue(context2) {
      const start = getCursor(context2);
      let content2;
      const quote = context2.source[0];
      const isQuoted = quote === `"` || quote === `'`;
      if (isQuoted) {
        advanceBy(context2, 1);
        const endIndex = context2.source.indexOf(quote);
        if (endIndex === -1) {
          content2 = parseTextData(context2, context2.source.length, 4);
        } else {
          content2 = parseTextData(context2, endIndex, 4);
          advanceBy(context2, 1);
        }
      } else {
        const match2 = /^[^\t\r\n\f >]+/.exec(context2.source);
        if (!match2) {
          return void 0;
        }
        const unexpectedChars = /["'<=`]/g;
        let m3;
        while (m3 = unexpectedChars.exec(match2[0])) {
          emitError(context2, 18, m3.index);
        }
        content2 = parseTextData(context2, match2[0].length, 4);
      }
      return { content: content2, isQuoted, loc: getSelection(context2, start) };
    }
    function parseInterpolation(context2, mode2) {
      const [open2, close2] = context2.options.delimiters;
      const closeIndex = context2.source.indexOf(close2, open2.length);
      if (closeIndex === -1) {
        emitError(context2, 25);
        return void 0;
      }
      const start = getCursor(context2);
      advanceBy(context2, open2.length);
      const innerStart = getCursor(context2);
      const innerEnd = getCursor(context2);
      const rawContentLength = closeIndex - open2.length;
      const rawContent = context2.source.slice(0, rawContentLength);
      const preTrimContent = parseTextData(context2, rawContentLength, mode2);
      const content2 = preTrimContent.trim();
      const startOffset = preTrimContent.indexOf(content2);
      if (startOffset > 0) {
        advancePositionWithMutation(innerStart, rawContent, startOffset);
      }
      const endOffset = rawContentLength - (preTrimContent.length - content2.length - startOffset);
      advancePositionWithMutation(innerEnd, rawContent, endOffset);
      advanceBy(context2, close2.length);
      return {
        type: 5,
        content: {
          type: 4,
          isStatic: false,
          constType: 0,
          content: content2,
          loc: getSelection(context2, innerStart, innerEnd)
        },
        loc: getSelection(context2, start)
      };
    }
    function parseText(context2, mode2) {
      const endTokens = mode2 === 3 ? ["]]>"] : ["<", context2.options.delimiters[0]];
      let endIndex = context2.source.length;
      for (let i2 = 0; i2 < endTokens.length; i2++) {
        const index3 = context2.source.indexOf(endTokens[i2], 1);
        if (index3 !== -1 && endIndex > index3) {
          endIndex = index3;
        }
      }
      const start = getCursor(context2);
      const content2 = parseTextData(context2, endIndex, mode2);
      return {
        type: 2,
        content: content2,
        loc: getSelection(context2, start)
      };
    }
    function parseTextData(context2, length, mode2) {
      const rawText = context2.source.slice(0, length);
      advanceBy(context2, length);
      if (mode2 === 2 || mode2 === 3 || !rawText.includes("&")) {
        return rawText;
      } else {
        return context2.options.decodeEntities(rawText, mode2 === 4);
      }
    }
    function getCursor(context2) {
      const { column: column2, line: line2, offset: offset2 } = context2;
      return { column: column2, line: line2, offset: offset2 };
    }
    function getSelection(context2, start, end) {
      end = end || getCursor(context2);
      return {
        start,
        end,
        source: context2.originalSource.slice(start.offset, end.offset)
      };
    }
    function last(xs2) {
      return xs2[xs2.length - 1];
    }
    function startsWith(source2, searchString) {
      return source2.startsWith(searchString);
    }
    function advanceBy(context2, numberOfCharacters) {
      const { source: source2 } = context2;
      advancePositionWithMutation(context2, source2, numberOfCharacters);
      context2.source = source2.slice(numberOfCharacters);
    }
    function advanceSpaces(context2) {
      const match2 = /^[\t\r\n\f ]+/.exec(context2.source);
      if (match2) {
        advanceBy(context2, match2[0].length);
      }
    }
    function getNewPosition(context2, start, numberOfCharacters) {
      return advancePositionWithClone(start, context2.originalSource.slice(start.offset, numberOfCharacters), numberOfCharacters);
    }
    function emitError(context2, code, offset2, loc = getCursor(context2)) {
      if (offset2) {
        loc.offset += offset2;
        loc.column += offset2;
      }
      context2.options.onError(createCompilerError(code, {
        start: loc,
        end: loc,
        source: ""
      }));
    }
    function isEnd(context2, mode2, ancestors) {
      const s2 = context2.source;
      switch (mode2) {
        case 0:
          if (startsWith(s2, "</")) {
            for (let i2 = ancestors.length - 1; i2 >= 0; --i2) {
              if (startsWithEndTagOpen(s2, ancestors[i2].tag)) {
                return true;
              }
            }
          }
          break;
        case 1:
        case 2: {
          const parent = last(ancestors);
          if (parent && startsWithEndTagOpen(s2, parent.tag)) {
            return true;
          }
          break;
        }
        case 3:
          if (startsWith(s2, "]]>")) {
            return true;
          }
          break;
      }
      return !s2;
    }
    function startsWithEndTagOpen(source2, tag) {
      return startsWith(source2, "</") && source2.slice(2, 2 + tag.length).toLowerCase() === tag.toLowerCase() && /[\t\r\n\f />]/.test(source2[2 + tag.length] || ">");
    }
    function hoistStatic(root2, context2) {
      walk2(root2, context2, isSingleElementRoot(root2, root2.children[0]));
    }
    function isSingleElementRoot(root2, child) {
      const { children } = root2;
      return children.length === 1 && child.type === 1 && !isSlotOutlet(child);
    }
    function walk2(node2, context2, doNotHoistNode = false) {
      const { children } = node2;
      const originalCount = children.length;
      let hoistedCount = 0;
      for (let i2 = 0; i2 < children.length; i2++) {
        const child = children[i2];
        if (child.type === 1 && child.tagType === 0) {
          const constantType = doNotHoistNode ? 0 : getConstantType(child, context2);
          if (constantType > 0) {
            if (constantType >= 2) {
              child.codegenNode.patchFlag = -1 + (true ? ` /* HOISTED */` : ``);
              child.codegenNode = context2.hoist(child.codegenNode);
              hoistedCount++;
              continue;
            }
          } else {
            const codegenNode = child.codegenNode;
            if (codegenNode.type === 13) {
              const flag = getPatchFlag(codegenNode);
              if ((!flag || flag === 512 || flag === 1) && getGeneratedPropsConstantType(child, context2) >= 2) {
                const props = getNodeProps(child);
                if (props) {
                  codegenNode.props = context2.hoist(props);
                }
              }
              if (codegenNode.dynamicProps) {
                codegenNode.dynamicProps = context2.hoist(codegenNode.dynamicProps);
              }
            }
          }
        } else if (child.type === 12 && getConstantType(child.content, context2) >= 2) {
          child.codegenNode = context2.hoist(child.codegenNode);
          hoistedCount++;
        }
        if (child.type === 1) {
          const isComponent2 = child.tagType === 1;
          if (isComponent2) {
            context2.scopes.vSlot++;
          }
          walk2(child, context2);
          if (isComponent2) {
            context2.scopes.vSlot--;
          }
        } else if (child.type === 11) {
          walk2(child, context2, child.children.length === 1);
        } else if (child.type === 9) {
          for (let i3 = 0; i3 < child.branches.length; i3++) {
            walk2(child.branches[i3], context2, child.branches[i3].children.length === 1);
          }
        }
      }
      if (hoistedCount && context2.transformHoist) {
        context2.transformHoist(children, context2, node2);
      }
      if (hoistedCount && hoistedCount === originalCount && node2.type === 1 && node2.tagType === 0 && node2.codegenNode && node2.codegenNode.type === 13 && isArray2(node2.codegenNode.children)) {
        node2.codegenNode.children = context2.hoist(createArrayExpression(node2.codegenNode.children));
      }
    }
    function getConstantType(node2, context2) {
      const { constantCache } = context2;
      switch (node2.type) {
        case 1:
          if (node2.tagType !== 0) {
            return 0;
          }
          const cached = constantCache.get(node2);
          if (cached !== void 0) {
            return cached;
          }
          const codegenNode = node2.codegenNode;
          if (codegenNode.type !== 13) {
            return 0;
          }
          if (codegenNode.isBlock && node2.tag !== "svg" && node2.tag !== "foreignObject") {
            return 0;
          }
          const flag = getPatchFlag(codegenNode);
          if (!flag) {
            let returnType2 = 3;
            const generatedPropsType = getGeneratedPropsConstantType(node2, context2);
            if (generatedPropsType === 0) {
              constantCache.set(node2, 0);
              return 0;
            }
            if (generatedPropsType < returnType2) {
              returnType2 = generatedPropsType;
            }
            for (let i2 = 0; i2 < node2.children.length; i2++) {
              const childType = getConstantType(node2.children[i2], context2);
              if (childType === 0) {
                constantCache.set(node2, 0);
                return 0;
              }
              if (childType < returnType2) {
                returnType2 = childType;
              }
            }
            if (returnType2 > 1) {
              for (let i2 = 0; i2 < node2.props.length; i2++) {
                const p2 = node2.props[i2];
                if (p2.type === 7 && p2.name === "bind" && p2.exp) {
                  const expType = getConstantType(p2.exp, context2);
                  if (expType === 0) {
                    constantCache.set(node2, 0);
                    return 0;
                  }
                  if (expType < returnType2) {
                    returnType2 = expType;
                  }
                }
              }
            }
            if (codegenNode.isBlock) {
              context2.removeHelper(OPEN_BLOCK);
              context2.removeHelper(getVNodeBlockHelper(context2.inSSR, codegenNode.isComponent));
              codegenNode.isBlock = false;
              context2.helper(getVNodeHelper(context2.inSSR, codegenNode.isComponent));
            }
            constantCache.set(node2, returnType2);
            return returnType2;
          } else {
            constantCache.set(node2, 0);
            return 0;
          }
        case 2:
        case 3:
          return 3;
        case 9:
        case 11:
        case 10:
          return 0;
        case 5:
        case 12:
          return getConstantType(node2.content, context2);
        case 4:
          return node2.constType;
        case 8:
          let returnType = 3;
          for (let i2 = 0; i2 < node2.children.length; i2++) {
            const child = node2.children[i2];
            if (isString2(child) || isSymbol(child)) {
              continue;
            }
            const childType = getConstantType(child, context2);
            if (childType === 0) {
              return 0;
            } else if (childType < returnType) {
              returnType = childType;
            }
          }
          return returnType;
        default:
          if (true)
            ;
          return 0;
      }
    }
    var allowHoistedHelperSet = /* @__PURE__ */ new Set([
      NORMALIZE_CLASS,
      NORMALIZE_STYLE,
      NORMALIZE_PROPS,
      GUARD_REACTIVE_PROPS
    ]);
    function getConstantTypeOfHelperCall(value, context2) {
      if (value.type === 14 && !isString2(value.callee) && allowHoistedHelperSet.has(value.callee)) {
        const arg = value.arguments[0];
        if (arg.type === 4) {
          return getConstantType(arg, context2);
        } else if (arg.type === 14) {
          return getConstantTypeOfHelperCall(arg, context2);
        }
      }
      return 0;
    }
    function getGeneratedPropsConstantType(node2, context2) {
      let returnType = 3;
      const props = getNodeProps(node2);
      if (props && props.type === 15) {
        const { properties } = props;
        for (let i2 = 0; i2 < properties.length; i2++) {
          const { key: key2, value } = properties[i2];
          const keyType = getConstantType(key2, context2);
          if (keyType === 0) {
            return keyType;
          }
          if (keyType < returnType) {
            returnType = keyType;
          }
          let valueType;
          if (value.type === 4) {
            valueType = getConstantType(value, context2);
          } else if (value.type === 14) {
            valueType = getConstantTypeOfHelperCall(value, context2);
          } else {
            valueType = 0;
          }
          if (valueType === 0) {
            return valueType;
          }
          if (valueType < returnType) {
            returnType = valueType;
          }
        }
      }
      return returnType;
    }
    function getNodeProps(node2) {
      const codegenNode = node2.codegenNode;
      if (codegenNode.type === 13) {
        return codegenNode.props;
      }
    }
    function getPatchFlag(node2) {
      const flag = node2.patchFlag;
      return flag ? parseInt(flag, 10) : void 0;
    }
    function createTransformContext(root2, { filename: filename2 = "", prefixIdentifiers = false, hoistStatic: hoistStatic2 = false, cacheHandlers = false, nodeTransforms = [], directiveTransforms = {}, transformHoist = null, isBuiltInComponent = NOOP2, isCustomElement = NOOP2, expressionPlugins = [], scopeId = null, slotted = true, ssr = false, inSSR = false, ssrCssVars = ``, bindingMetadata = EMPTY_OBJ, inline = false, isTS = false, onError = defaultOnError, onWarn = defaultOnWarn, compatConfig }) {
      const nameMatch = filename2.replace(/\?.*$/, "").match(/([^/\\]+)\.\w+$/);
      const context2 = {
        selfName: nameMatch && capitalize(camelize$1(nameMatch[1])),
        prefixIdentifiers,
        hoistStatic: hoistStatic2,
        cacheHandlers,
        nodeTransforms,
        directiveTransforms,
        transformHoist,
        isBuiltInComponent,
        isCustomElement,
        expressionPlugins,
        scopeId,
        slotted,
        ssr,
        inSSR,
        ssrCssVars,
        bindingMetadata,
        inline,
        isTS,
        onError,
        onWarn,
        compatConfig,
        root: root2,
        helpers: /* @__PURE__ */ new Map(),
        components: /* @__PURE__ */ new Set(),
        directives: /* @__PURE__ */ new Set(),
        hoists: [],
        imports: [],
        constantCache: /* @__PURE__ */ new Map(),
        temps: 0,
        cached: 0,
        identifiers: /* @__PURE__ */ Object.create(null),
        scopes: {
          vFor: 0,
          vSlot: 0,
          vPre: 0,
          vOnce: 0
        },
        parent: null,
        currentNode: root2,
        childIndex: 0,
        inVOnce: false,
        helper(name) {
          const count = context2.helpers.get(name) || 0;
          context2.helpers.set(name, count + 1);
          return name;
        },
        removeHelper(name) {
          const count = context2.helpers.get(name);
          if (count) {
            const currentCount = count - 1;
            if (!currentCount) {
              context2.helpers.delete(name);
            } else {
              context2.helpers.set(name, currentCount);
            }
          }
        },
        helperString(name) {
          return `_${helperNameMap[context2.helper(name)]}`;
        },
        replaceNode(node2) {
          if (true) {
            if (!context2.currentNode) {
              throw new Error(`Node being replaced is already removed.`);
            }
            if (!context2.parent) {
              throw new Error(`Cannot replace root node.`);
            }
          }
          context2.parent.children[context2.childIndex] = context2.currentNode = node2;
        },
        removeNode(node2) {
          if (!context2.parent) {
            throw new Error(`Cannot remove root node.`);
          }
          const list2 = context2.parent.children;
          const removalIndex = node2 ? list2.indexOf(node2) : context2.currentNode ? context2.childIndex : -1;
          if (removalIndex < 0) {
            throw new Error(`node being removed is not a child of current parent`);
          }
          if (!node2 || node2 === context2.currentNode) {
            context2.currentNode = null;
            context2.onNodeRemoved();
          } else {
            if (context2.childIndex > removalIndex) {
              context2.childIndex--;
              context2.onNodeRemoved();
            }
          }
          context2.parent.children.splice(removalIndex, 1);
        },
        onNodeRemoved: () => {
        },
        addIdentifiers(exp) {
        },
        removeIdentifiers(exp) {
        },
        hoist(exp) {
          if (isString2(exp))
            exp = createSimpleExpression(exp);
          context2.hoists.push(exp);
          const identifier = createSimpleExpression(`_hoisted_${context2.hoists.length}`, false, exp.loc, 2);
          identifier.hoisted = exp;
          return identifier;
        },
        cache(exp, isVNode = false) {
          return createCacheExpression(context2.cached++, exp, isVNode);
        }
      };
      {
        context2.filters = /* @__PURE__ */ new Set();
      }
      return context2;
    }
    function transform2(root2, options2) {
      const context2 = createTransformContext(root2, options2);
      traverseNode(root2, context2);
      if (options2.hoistStatic) {
        hoistStatic(root2, context2);
      }
      if (!options2.ssr) {
        createRootCodegen(root2, context2);
      }
      root2.helpers = [...context2.helpers.keys()];
      root2.components = [...context2.components];
      root2.directives = [...context2.directives];
      root2.imports = context2.imports;
      root2.hoists = context2.hoists;
      root2.temps = context2.temps;
      root2.cached = context2.cached;
      {
        root2.filters = [...context2.filters];
      }
    }
    function createRootCodegen(root2, context2) {
      const { helper } = context2;
      const { children } = root2;
      if (children.length === 1) {
        const child = children[0];
        if (isSingleElementRoot(root2, child) && child.codegenNode) {
          const codegenNode = child.codegenNode;
          if (codegenNode.type === 13) {
            makeBlock(codegenNode, context2);
          }
          root2.codegenNode = codegenNode;
        } else {
          root2.codegenNode = child;
        }
      } else if (children.length > 1) {
        let patchFlag = 64;
        let patchFlagText = PatchFlagNames[64];
        if (children.filter((c3) => c3.type !== 3).length === 1) {
          patchFlag |= 2048;
          patchFlagText += `, ${PatchFlagNames[2048]}`;
        }
        root2.codegenNode = createVNodeCall(context2, helper(FRAGMENT), void 0, root2.children, patchFlag + (true ? ` /* ${patchFlagText} */` : ``), void 0, void 0, true, void 0, false);
      } else
        ;
    }
    function traverseChildren(parent, context2) {
      let i2 = 0;
      const nodeRemoved = () => {
        i2--;
      };
      for (; i2 < parent.children.length; i2++) {
        const child = parent.children[i2];
        if (isString2(child))
          continue;
        context2.parent = parent;
        context2.childIndex = i2;
        context2.onNodeRemoved = nodeRemoved;
        traverseNode(child, context2);
      }
    }
    function traverseNode(node2, context2) {
      context2.currentNode = node2;
      const { nodeTransforms } = context2;
      const exitFns = [];
      for (let i3 = 0; i3 < nodeTransforms.length; i3++) {
        const onExit = nodeTransforms[i3](node2, context2);
        if (onExit) {
          if (isArray2(onExit)) {
            exitFns.push(...onExit);
          } else {
            exitFns.push(onExit);
          }
        }
        if (!context2.currentNode) {
          return;
        } else {
          node2 = context2.currentNode;
        }
      }
      switch (node2.type) {
        case 3:
          if (!context2.ssr) {
            context2.helper(CREATE_COMMENT);
          }
          break;
        case 5:
          if (!context2.ssr) {
            context2.helper(TO_DISPLAY_STRING);
          }
          break;
        case 9:
          for (let i3 = 0; i3 < node2.branches.length; i3++) {
            traverseNode(node2.branches[i3], context2);
          }
          break;
        case 10:
        case 11:
        case 1:
        case 0:
          traverseChildren(node2, context2);
          break;
      }
      context2.currentNode = node2;
      let i2 = exitFns.length;
      while (i2--) {
        exitFns[i2]();
      }
    }
    function createStructuralDirectiveTransform(name, fn2) {
      const matches2 = isString2(name) ? (n3) => n3 === name : (n3) => name.test(n3);
      return (node2, context2) => {
        if (node2.type === 1) {
          const { props } = node2;
          if (node2.tagType === 3 && props.some(isVSlot)) {
            return;
          }
          const exitFns = [];
          for (let i2 = 0; i2 < props.length; i2++) {
            const prop = props[i2];
            if (prop.type === 7 && matches2(prop.name)) {
              props.splice(i2, 1);
              i2--;
              const onExit = fn2(node2, prop, context2);
              if (onExit)
                exitFns.push(onExit);
            }
          }
          return exitFns;
        }
      };
    }
    var PURE_ANNOTATION = `/*#__PURE__*/`;
    function createCodegenContext(ast, { mode: mode2 = "function", prefixIdentifiers = mode2 === "module", sourceMap = false, filename: filename2 = `template.vue.html`, scopeId = null, optimizeImports = false, runtimeGlobalName = `Vue`, runtimeModuleName = `vue`, ssrRuntimeModuleName = "vue/server-renderer", ssr = false, isTS = false, inSSR = false }) {
      const context2 = {
        mode: mode2,
        prefixIdentifiers,
        sourceMap,
        filename: filename2,
        scopeId,
        optimizeImports,
        runtimeGlobalName,
        runtimeModuleName,
        ssrRuntimeModuleName,
        ssr,
        isTS,
        inSSR,
        source: ast.loc.source,
        code: ``,
        column: 1,
        line: 1,
        offset: 0,
        indentLevel: 0,
        pure: false,
        map: void 0,
        helper(key2) {
          return `_${helperNameMap[key2]}`;
        },
        push(code, node2) {
          context2.code += code;
        },
        indent() {
          newline(++context2.indentLevel);
        },
        deindent(withoutNewLine = false) {
          if (withoutNewLine) {
            --context2.indentLevel;
          } else {
            newline(--context2.indentLevel);
          }
        },
        newline() {
          newline(context2.indentLevel);
        }
      };
      function newline(n3) {
        context2.push("\n" + `  `.repeat(n3));
      }
      return context2;
    }
    function generate2(ast, options2 = {}) {
      const context2 = createCodegenContext(ast, options2);
      if (options2.onContextCreated)
        options2.onContextCreated(context2);
      const { mode: mode2, push: push2, prefixIdentifiers, indent, deindent, newline, scopeId, ssr } = context2;
      const hasHelpers = ast.helpers.length > 0;
      const useWithBlock = !prefixIdentifiers && mode2 !== "module";
      const preambleContext = context2;
      {
        genFunctionPreamble(ast, preambleContext);
      }
      const functionName = ssr ? `ssrRender` : `render`;
      const args = ssr ? ["_ctx", "_push", "_parent", "_attrs"] : ["_ctx", "_cache"];
      const signature = args.join(", ");
      {
        push2(`function ${functionName}(${signature}) {`);
      }
      indent();
      if (useWithBlock) {
        push2(`with (_ctx) {`);
        indent();
        if (hasHelpers) {
          push2(`const { ${ast.helpers.map((s2) => `${helperNameMap[s2]}: _${helperNameMap[s2]}`).join(", ")} } = _Vue`);
          push2(`
`);
          newline();
        }
      }
      if (ast.components.length) {
        genAssets(ast.components, "component", context2);
        if (ast.directives.length || ast.temps > 0) {
          newline();
        }
      }
      if (ast.directives.length) {
        genAssets(ast.directives, "directive", context2);
        if (ast.temps > 0) {
          newline();
        }
      }
      if (ast.filters && ast.filters.length) {
        newline();
        genAssets(ast.filters, "filter", context2);
        newline();
      }
      if (ast.temps > 0) {
        push2(`let `);
        for (let i2 = 0; i2 < ast.temps; i2++) {
          push2(`${i2 > 0 ? `, ` : ``}_temp${i2}`);
        }
      }
      if (ast.components.length || ast.directives.length || ast.temps) {
        push2(`
`);
        newline();
      }
      if (!ssr) {
        push2(`return `);
      }
      if (ast.codegenNode) {
        genNode(ast.codegenNode, context2);
      } else {
        push2(`null`);
      }
      if (useWithBlock) {
        deindent();
        push2(`}`);
      }
      deindent();
      push2(`}`);
      return {
        ast,
        code: context2.code,
        preamble: ``,
        map: context2.map ? context2.map.toJSON() : void 0
      };
    }
    function genFunctionPreamble(ast, context2) {
      const { ssr, prefixIdentifiers, push: push2, newline, runtimeModuleName, runtimeGlobalName, ssrRuntimeModuleName } = context2;
      const VueBinding = runtimeGlobalName;
      const aliasHelper = (s2) => `${helperNameMap[s2]}: _${helperNameMap[s2]}`;
      if (ast.helpers.length > 0) {
        {
          push2(`const _Vue = ${VueBinding}
`);
          if (ast.hoists.length) {
            const staticHelpers = [
              CREATE_VNODE,
              CREATE_ELEMENT_VNODE,
              CREATE_COMMENT,
              CREATE_TEXT,
              CREATE_STATIC
            ].filter((helper) => ast.helpers.includes(helper)).map(aliasHelper).join(", ");
            push2(`const { ${staticHelpers} } = _Vue
`);
          }
        }
      }
      genHoists(ast.hoists, context2);
      newline();
      push2(`return `);
    }
    function genAssets(assets, type, { helper, push: push2, newline, isTS }) {
      const resolver = helper(type === "filter" ? RESOLVE_FILTER : type === "component" ? RESOLVE_COMPONENT : RESOLVE_DIRECTIVE);
      for (let i2 = 0; i2 < assets.length; i2++) {
        let id = assets[i2];
        const maybeSelfReference = id.endsWith("__self");
        if (maybeSelfReference) {
          id = id.slice(0, -6);
        }
        push2(`const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)}${maybeSelfReference ? `, true` : ``})${isTS ? `!` : ``}`);
        if (i2 < assets.length - 1) {
          newline();
        }
      }
    }
    function genHoists(hoists, context2) {
      if (!hoists.length) {
        return;
      }
      context2.pure = true;
      const { push: push2, newline, helper, scopeId, mode: mode2 } = context2;
      newline();
      for (let i2 = 0; i2 < hoists.length; i2++) {
        const exp = hoists[i2];
        if (exp) {
          push2(`const _hoisted_${i2 + 1} = ${``}`);
          genNode(exp, context2);
          newline();
        }
      }
      context2.pure = false;
    }
    function isText$1(n3) {
      return isString2(n3) || n3.type === 4 || n3.type === 2 || n3.type === 5 || n3.type === 8;
    }
    function genNodeListAsArray(nodes, context2) {
      const multilines = nodes.length > 3 || nodes.some((n3) => isArray2(n3) || !isText$1(n3));
      context2.push(`[`);
      multilines && context2.indent();
      genNodeList(nodes, context2, multilines);
      multilines && context2.deindent();
      context2.push(`]`);
    }
    function genNodeList(nodes, context2, multilines = false, comma2 = true) {
      const { push: push2, newline } = context2;
      for (let i2 = 0; i2 < nodes.length; i2++) {
        const node2 = nodes[i2];
        if (isString2(node2)) {
          push2(node2);
        } else if (isArray2(node2)) {
          genNodeListAsArray(node2, context2);
        } else {
          genNode(node2, context2);
        }
        if (i2 < nodes.length - 1) {
          if (multilines) {
            comma2 && push2(",");
            newline();
          } else {
            comma2 && push2(", ");
          }
        }
      }
    }
    function genNode(node2, context2) {
      if (isString2(node2)) {
        context2.push(node2);
        return;
      }
      if (isSymbol(node2)) {
        context2.push(context2.helper(node2));
        return;
      }
      switch (node2.type) {
        case 1:
        case 9:
        case 11:
          assert2(node2.codegenNode != null, `Codegen node is missing for element/if/for node. Apply appropriate transforms first.`);
          genNode(node2.codegenNode, context2);
          break;
        case 2:
          genText(node2, context2);
          break;
        case 4:
          genExpression(node2, context2);
          break;
        case 5:
          genInterpolation(node2, context2);
          break;
        case 12:
          genNode(node2.codegenNode, context2);
          break;
        case 8:
          genCompoundExpression(node2, context2);
          break;
        case 3:
          genComment(node2, context2);
          break;
        case 13:
          genVNodeCall(node2, context2);
          break;
        case 14:
          genCallExpression(node2, context2);
          break;
        case 15:
          genObjectExpression(node2, context2);
          break;
        case 17:
          genArrayExpression(node2, context2);
          break;
        case 18:
          genFunctionExpression(node2, context2);
          break;
        case 19:
          genConditionalExpression(node2, context2);
          break;
        case 20:
          genCacheExpression(node2, context2);
          break;
        case 21:
          genNodeList(node2.body, context2, true, false);
          break;
        case 22:
          break;
        case 23:
          break;
        case 24:
          break;
        case 25:
          break;
        case 26:
          break;
        case 10:
          break;
        default:
          if (true) {
            assert2(false, `unhandled codegen node type: ${node2.type}`);
            const exhaustiveCheck = node2;
            return exhaustiveCheck;
          }
      }
    }
    function genText(node2, context2) {
      context2.push(JSON.stringify(node2.content), node2);
    }
    function genExpression(node2, context2) {
      const { content: content2, isStatic } = node2;
      context2.push(isStatic ? JSON.stringify(content2) : content2, node2);
    }
    function genInterpolation(node2, context2) {
      const { push: push2, helper, pure } = context2;
      if (pure)
        push2(PURE_ANNOTATION);
      push2(`${helper(TO_DISPLAY_STRING)}(`);
      genNode(node2.content, context2);
      push2(`)`);
    }
    function genCompoundExpression(node2, context2) {
      for (let i2 = 0; i2 < node2.children.length; i2++) {
        const child = node2.children[i2];
        if (isString2(child)) {
          context2.push(child);
        } else {
          genNode(child, context2);
        }
      }
    }
    function genExpressionAsPropertyKey(node2, context2) {
      const { push: push2 } = context2;
      if (node2.type === 8) {
        push2(`[`);
        genCompoundExpression(node2, context2);
        push2(`]`);
      } else if (node2.isStatic) {
        const text = isSimpleIdentifier(node2.content) ? node2.content : JSON.stringify(node2.content);
        push2(text, node2);
      } else {
        push2(`[${node2.content}]`, node2);
      }
    }
    function genComment(node2, context2) {
      const { push: push2, helper, pure } = context2;
      if (pure) {
        push2(PURE_ANNOTATION);
      }
      push2(`${helper(CREATE_COMMENT)}(${JSON.stringify(node2.content)})`, node2);
    }
    function genVNodeCall(node2, context2) {
      const { push: push2, helper, pure } = context2;
      const { tag, props, children, patchFlag, dynamicProps, directives, isBlock, disableTracking, isComponent: isComponent2 } = node2;
      if (directives) {
        push2(helper(WITH_DIRECTIVES) + `(`);
      }
      if (isBlock) {
        push2(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `);
      }
      if (pure) {
        push2(PURE_ANNOTATION);
      }
      const callHelper = isBlock ? getVNodeBlockHelper(context2.inSSR, isComponent2) : getVNodeHelper(context2.inSSR, isComponent2);
      push2(helper(callHelper) + `(`, node2);
      genNodeList(genNullableArgs([tag, props, children, patchFlag, dynamicProps]), context2);
      push2(`)`);
      if (isBlock) {
        push2(`)`);
      }
      if (directives) {
        push2(`, `);
        genNode(directives, context2);
        push2(`)`);
      }
    }
    function genNullableArgs(args) {
      let i2 = args.length;
      while (i2--) {
        if (args[i2] != null)
          break;
      }
      return args.slice(0, i2 + 1).map((arg) => arg || `null`);
    }
    function genCallExpression(node2, context2) {
      const { push: push2, helper, pure } = context2;
      const callee = isString2(node2.callee) ? node2.callee : helper(node2.callee);
      if (pure) {
        push2(PURE_ANNOTATION);
      }
      push2(callee + `(`, node2);
      genNodeList(node2.arguments, context2);
      push2(`)`);
    }
    function genObjectExpression(node2, context2) {
      const { push: push2, indent, deindent, newline } = context2;
      const { properties } = node2;
      if (!properties.length) {
        push2(`{}`, node2);
        return;
      }
      const multilines = properties.length > 1 || properties.some((p2) => p2.value.type !== 4);
      push2(multilines ? `{` : `{ `);
      multilines && indent();
      for (let i2 = 0; i2 < properties.length; i2++) {
        const { key: key2, value } = properties[i2];
        genExpressionAsPropertyKey(key2, context2);
        push2(`: `);
        genNode(value, context2);
        if (i2 < properties.length - 1) {
          push2(`,`);
          newline();
        }
      }
      multilines && deindent();
      push2(multilines ? `}` : ` }`);
    }
    function genArrayExpression(node2, context2) {
      genNodeListAsArray(node2.elements, context2);
    }
    function genFunctionExpression(node2, context2) {
      const { push: push2, indent, deindent } = context2;
      const { params, returns, body, newline, isSlot } = node2;
      if (isSlot) {
        push2(`_${helperNameMap[WITH_CTX]}(`);
      }
      push2(`(`, node2);
      if (isArray2(params)) {
        genNodeList(params, context2);
      } else if (params) {
        genNode(params, context2);
      }
      push2(`) => `);
      if (newline || body) {
        push2(`{`);
        indent();
      }
      if (returns) {
        if (newline) {
          push2(`return `);
        }
        if (isArray2(returns)) {
          genNodeListAsArray(returns, context2);
        } else {
          genNode(returns, context2);
        }
      } else if (body) {
        genNode(body, context2);
      }
      if (newline || body) {
        deindent();
        push2(`}`);
      }
      if (isSlot) {
        if (node2.isNonScopedSlot) {
          push2(`, undefined, true`);
        }
        push2(`)`);
      }
    }
    function genConditionalExpression(node2, context2) {
      const { test, consequent, alternate, newline: needNewline } = node2;
      const { push: push2, indent, deindent, newline } = context2;
      if (test.type === 4) {
        const needsParens = !isSimpleIdentifier(test.content);
        needsParens && push2(`(`);
        genExpression(test, context2);
        needsParens && push2(`)`);
      } else {
        push2(`(`);
        genNode(test, context2);
        push2(`)`);
      }
      needNewline && indent();
      context2.indentLevel++;
      needNewline || push2(` `);
      push2(`? `);
      genNode(consequent, context2);
      context2.indentLevel--;
      needNewline && newline();
      needNewline || push2(` `);
      push2(`: `);
      const isNested = alternate.type === 19;
      if (!isNested) {
        context2.indentLevel++;
      }
      genNode(alternate, context2);
      if (!isNested) {
        context2.indentLevel--;
      }
      needNewline && deindent(true);
    }
    function genCacheExpression(node2, context2) {
      const { push: push2, helper, indent, deindent, newline } = context2;
      push2(`_cache[${node2.index}] || (`);
      if (node2.isVNode) {
        indent();
        push2(`${helper(SET_BLOCK_TRACKING)}(-1),`);
        newline();
      }
      push2(`_cache[${node2.index}] = `);
      genNode(node2.value, context2);
      if (node2.isVNode) {
        push2(`,`);
        newline();
        push2(`${helper(SET_BLOCK_TRACKING)}(1),`);
        newline();
        push2(`_cache[${node2.index}]`);
        deindent();
      }
      push2(`)`);
    }
    function walkIdentifiers(root2, onIdentifier, includeAll = false, parentStack = [], knownIds = /* @__PURE__ */ Object.create(null)) {
      {
        return;
      }
    }
    function isReferencedIdentifier(id, parent, parentStack) {
      {
        return false;
      }
    }
    function isInDestructureAssignment(parent, parentStack) {
      if (parent && (parent.type === "ObjectProperty" || parent.type === "ArrayPattern")) {
        let i2 = parentStack.length;
        while (i2--) {
          const p2 = parentStack[i2];
          if (p2.type === "AssignmentExpression") {
            return true;
          } else if (p2.type !== "ObjectProperty" && !p2.type.endsWith("Pattern")) {
            break;
          }
        }
      }
      return false;
    }
    function walkFunctionParams(node2, onIdent) {
      for (const p2 of node2.params) {
        for (const id of extractIdentifiers(p2)) {
          onIdent(id);
        }
      }
    }
    function walkBlockDeclarations(block, onIdent) {
      for (const stmt of block.body) {
        if (stmt.type === "VariableDeclaration") {
          if (stmt.declare)
            continue;
          for (const decl of stmt.declarations) {
            for (const id of extractIdentifiers(decl.id)) {
              onIdent(id);
            }
          }
        } else if (stmt.type === "FunctionDeclaration" || stmt.type === "ClassDeclaration") {
          if (stmt.declare || !stmt.id)
            continue;
          onIdent(stmt.id);
        }
      }
    }
    function extractIdentifiers(param, nodes = []) {
      switch (param.type) {
        case "Identifier":
          nodes.push(param);
          break;
        case "MemberExpression":
          let object = param;
          while (object.type === "MemberExpression") {
            object = object.object;
          }
          nodes.push(object);
          break;
        case "ObjectPattern":
          for (const prop of param.properties) {
            if (prop.type === "RestElement") {
              extractIdentifiers(prop.argument, nodes);
            } else {
              extractIdentifiers(prop.value, nodes);
            }
          }
          break;
        case "ArrayPattern":
          param.elements.forEach((element) => {
            if (element)
              extractIdentifiers(element, nodes);
          });
          break;
        case "RestElement":
          extractIdentifiers(param.argument, nodes);
          break;
        case "AssignmentPattern":
          extractIdentifiers(param.left, nodes);
          break;
      }
      return nodes;
    }
    var isFunctionType = (node2) => {
      return /Function(?:Expression|Declaration)$|Method$/.test(node2.type);
    };
    var isStaticProperty2 = (node2) => node2 && (node2.type === "ObjectProperty" || node2.type === "ObjectMethod") && !node2.computed;
    var isStaticPropertyKey2 = (node2, parent) => isStaticProperty2(parent) && parent.key === node2;
    var prohibitedKeywordRE = new RegExp("\\b" + "do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,super,throw,while,yield,delete,export,import,return,switch,default,extends,finally,continue,debugger,function,arguments,typeof,void".split(",").join("\\b|\\b") + "\\b");
    var stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;
    function validateBrowserExpression(node2, context2, asParams = false, asRawStatements = false) {
      const exp = node2.content;
      if (!exp.trim()) {
        return;
      }
      try {
        new Function(asRawStatements ? ` ${exp} ` : `return ${asParams ? `(${exp}) => {}` : `(${exp})`}`);
      } catch (e2) {
        let message = e2.message;
        const keywordMatch = exp.replace(stripStringRE, "").match(prohibitedKeywordRE);
        if (keywordMatch) {
          message = `avoid using JavaScript keyword as property name: "${keywordMatch[0]}"`;
        }
        context2.onError(createCompilerError(44, node2.loc, void 0, message));
      }
    }
    var transformExpression = (node2, context2) => {
      if (node2.type === 5) {
        node2.content = processExpression(node2.content, context2);
      } else if (node2.type === 1) {
        for (let i2 = 0; i2 < node2.props.length; i2++) {
          const dir = node2.props[i2];
          if (dir.type === 7 && dir.name !== "for") {
            const exp = dir.exp;
            const arg = dir.arg;
            if (exp && exp.type === 4 && !(dir.name === "on" && arg)) {
              dir.exp = processExpression(exp, context2, dir.name === "slot");
            }
            if (arg && arg.type === 4 && !arg.isStatic) {
              dir.arg = processExpression(arg, context2);
            }
          }
        }
      }
    };
    function processExpression(node2, context2, asParams = false, asRawStatements = false, localVars = Object.create(context2.identifiers)) {
      {
        if (true) {
          validateBrowserExpression(node2, context2, asParams, asRawStatements);
        }
        return node2;
      }
    }
    var transformIf = createStructuralDirectiveTransform(/^(if|else|else-if)$/, (node2, dir, context2) => {
      return processIf(node2, dir, context2, (ifNode, branch, isRoot) => {
        const siblings = context2.parent.children;
        let i2 = siblings.indexOf(ifNode);
        let key2 = 0;
        while (i2-- >= 0) {
          const sibling = siblings[i2];
          if (sibling && sibling.type === 9) {
            key2 += sibling.branches.length;
          }
        }
        return () => {
          if (isRoot) {
            ifNode.codegenNode = createCodegenNodeForBranch(branch, key2, context2);
          } else {
            const parentCondition = getParentCondition(ifNode.codegenNode);
            parentCondition.alternate = createCodegenNodeForBranch(branch, key2 + ifNode.branches.length - 1, context2);
          }
        };
      });
    });
    function processIf(node2, dir, context2, processCodegen) {
      if (dir.name !== "else" && (!dir.exp || !dir.exp.content.trim())) {
        const loc = dir.exp ? dir.exp.loc : node2.loc;
        context2.onError(createCompilerError(28, dir.loc));
        dir.exp = createSimpleExpression(`true`, false, loc);
      }
      if (dir.exp) {
        validateBrowserExpression(dir.exp, context2);
      }
      if (dir.name === "if") {
        const branch = createIfBranch(node2, dir);
        const ifNode = {
          type: 9,
          loc: node2.loc,
          branches: [branch]
        };
        context2.replaceNode(ifNode);
        if (processCodegen) {
          return processCodegen(ifNode, branch, true);
        }
      } else {
        const siblings = context2.parent.children;
        const comments = [];
        let i2 = siblings.indexOf(node2);
        while (i2-- >= -1) {
          const sibling = siblings[i2];
          if (sibling && sibling.type === 3) {
            context2.removeNode(sibling);
            comments.unshift(sibling);
            continue;
          }
          if (sibling && sibling.type === 2 && !sibling.content.trim().length) {
            context2.removeNode(sibling);
            continue;
          }
          if (sibling && sibling.type === 9) {
            if (dir.name === "else-if" && sibling.branches[sibling.branches.length - 1].condition === void 0) {
              context2.onError(createCompilerError(30, node2.loc));
            }
            context2.removeNode();
            const branch = createIfBranch(node2, dir);
            if (comments.length && !(context2.parent && context2.parent.type === 1 && isBuiltInType(context2.parent.tag, "transition"))) {
              branch.children = [...comments, ...branch.children];
            }
            if (true) {
              const key2 = branch.userKey;
              if (key2) {
                sibling.branches.forEach(({ userKey }) => {
                  if (isSameKey(userKey, key2)) {
                    context2.onError(createCompilerError(29, branch.userKey.loc));
                  }
                });
              }
            }
            sibling.branches.push(branch);
            const onExit = processCodegen && processCodegen(sibling, branch, false);
            traverseNode(branch, context2);
            if (onExit)
              onExit();
            context2.currentNode = null;
          } else {
            context2.onError(createCompilerError(30, node2.loc));
          }
          break;
        }
      }
    }
    function createIfBranch(node2, dir) {
      return {
        type: 10,
        loc: node2.loc,
        condition: dir.name === "else" ? void 0 : dir.exp,
        children: node2.tagType === 3 && !findDir(node2, "for") ? node2.children : [node2],
        userKey: findProp(node2, `key`)
      };
    }
    function createCodegenNodeForBranch(branch, keyIndex, context2) {
      if (branch.condition) {
        return createConditionalExpression(branch.condition, createChildrenCodegenNode(branch, keyIndex, context2), createCallExpression(context2.helper(CREATE_COMMENT), [
          true ? '"v-if"' : '""',
          "true"
        ]));
      } else {
        return createChildrenCodegenNode(branch, keyIndex, context2);
      }
    }
    function createChildrenCodegenNode(branch, keyIndex, context2) {
      const { helper } = context2;
      const keyProperty = createObjectProperty(`key`, createSimpleExpression(`${keyIndex}`, false, locStub, 2));
      const { children } = branch;
      const firstChild = children[0];
      const needFragmentWrapper = children.length !== 1 || firstChild.type !== 1;
      if (needFragmentWrapper) {
        if (children.length === 1 && firstChild.type === 11) {
          const vnodeCall = firstChild.codegenNode;
          injectProp(vnodeCall, keyProperty, context2);
          return vnodeCall;
        } else {
          let patchFlag = 64;
          let patchFlagText = PatchFlagNames[64];
          if (children.filter((c3) => c3.type !== 3).length === 1) {
            patchFlag |= 2048;
            patchFlagText += `, ${PatchFlagNames[2048]}`;
          }
          return createVNodeCall(context2, helper(FRAGMENT), createObjectExpression([keyProperty]), children, patchFlag + (true ? ` /* ${patchFlagText} */` : ``), void 0, void 0, true, false, false, branch.loc);
        }
      } else {
        const ret = firstChild.codegenNode;
        const vnodeCall = getMemoedVNodeCall(ret);
        if (vnodeCall.type === 13) {
          makeBlock(vnodeCall, context2);
        }
        injectProp(vnodeCall, keyProperty, context2);
        return ret;
      }
    }
    function isSameKey(a2, b2) {
      if (!a2 || a2.type !== b2.type) {
        return false;
      }
      if (a2.type === 6) {
        if (a2.value.content !== b2.value.content) {
          return false;
        }
      } else {
        const exp = a2.exp;
        const branchExp = b2.exp;
        if (exp.type !== branchExp.type) {
          return false;
        }
        if (exp.type !== 4 || exp.isStatic !== branchExp.isStatic || exp.content !== branchExp.content) {
          return false;
        }
      }
      return true;
    }
    function getParentCondition(node2) {
      while (true) {
        if (node2.type === 19) {
          if (node2.alternate.type === 19) {
            node2 = node2.alternate;
          } else {
            return node2;
          }
        } else if (node2.type === 20) {
          node2 = node2.value;
        }
      }
    }
    var transformFor = createStructuralDirectiveTransform("for", (node2, dir, context2) => {
      const { helper, removeHelper } = context2;
      return processFor(node2, dir, context2, (forNode) => {
        const renderExp = createCallExpression(helper(RENDER_LIST), [
          forNode.source
        ]);
        const isTemplate = isTemplateNode(node2);
        const memo = findDir(node2, "memo");
        const keyProp = findProp(node2, `key`);
        const keyExp = keyProp && (keyProp.type === 6 ? createSimpleExpression(keyProp.value.content, true) : keyProp.exp);
        const keyProperty = keyProp ? createObjectProperty(`key`, keyExp) : null;
        const isStableFragment = forNode.source.type === 4 && forNode.source.constType > 0;
        const fragmentFlag = isStableFragment ? 64 : keyProp ? 128 : 256;
        forNode.codegenNode = createVNodeCall(context2, helper(FRAGMENT), void 0, renderExp, fragmentFlag + (true ? ` /* ${PatchFlagNames[fragmentFlag]} */` : ``), void 0, void 0, true, !isStableFragment, false, node2.loc);
        return () => {
          let childBlock;
          const { children } = forNode;
          if (isTemplate) {
            node2.children.some((c3) => {
              if (c3.type === 1) {
                const key2 = findProp(c3, "key");
                if (key2) {
                  context2.onError(createCompilerError(33, key2.loc));
                  return true;
                }
              }
            });
          }
          const needFragmentWrapper = children.length !== 1 || children[0].type !== 1;
          const slotOutlet = isSlotOutlet(node2) ? node2 : isTemplate && node2.children.length === 1 && isSlotOutlet(node2.children[0]) ? node2.children[0] : null;
          if (slotOutlet) {
            childBlock = slotOutlet.codegenNode;
            if (isTemplate && keyProperty) {
              injectProp(childBlock, keyProperty, context2);
            }
          } else if (needFragmentWrapper) {
            childBlock = createVNodeCall(context2, helper(FRAGMENT), keyProperty ? createObjectExpression([keyProperty]) : void 0, node2.children, 64 + (true ? ` /* ${PatchFlagNames[64]} */` : ``), void 0, void 0, true, void 0, false);
          } else {
            childBlock = children[0].codegenNode;
            if (isTemplate && keyProperty) {
              injectProp(childBlock, keyProperty, context2);
            }
            if (childBlock.isBlock !== !isStableFragment) {
              if (childBlock.isBlock) {
                removeHelper(OPEN_BLOCK);
                removeHelper(getVNodeBlockHelper(context2.inSSR, childBlock.isComponent));
              } else {
                removeHelper(getVNodeHelper(context2.inSSR, childBlock.isComponent));
              }
            }
            childBlock.isBlock = !isStableFragment;
            if (childBlock.isBlock) {
              helper(OPEN_BLOCK);
              helper(getVNodeBlockHelper(context2.inSSR, childBlock.isComponent));
            } else {
              helper(getVNodeHelper(context2.inSSR, childBlock.isComponent));
            }
          }
          if (memo) {
            const loop2 = createFunctionExpression(createForLoopParams(forNode.parseResult, [
              createSimpleExpression(`_cached`)
            ]));
            loop2.body = createBlockStatement([
              createCompoundExpression([`const _memo = (`, memo.exp, `)`]),
              createCompoundExpression([
                `if (_cached`,
                ...keyExp ? [` && _cached.key === `, keyExp] : [],
                ` && ${context2.helperString(IS_MEMO_SAME)}(_cached, _memo)) return _cached`
              ]),
              createCompoundExpression([`const _item = `, childBlock]),
              createSimpleExpression(`_item.memo = _memo`),
              createSimpleExpression(`return _item`)
            ]);
            renderExp.arguments.push(loop2, createSimpleExpression(`_cache`), createSimpleExpression(String(context2.cached++)));
          } else {
            renderExp.arguments.push(createFunctionExpression(createForLoopParams(forNode.parseResult), childBlock, true));
          }
        };
      });
    });
    function processFor(node2, dir, context2, processCodegen) {
      if (!dir.exp) {
        context2.onError(createCompilerError(31, dir.loc));
        return;
      }
      const parseResult = parseForExpression(dir.exp, context2);
      if (!parseResult) {
        context2.onError(createCompilerError(32, dir.loc));
        return;
      }
      const { addIdentifiers, removeIdentifiers, scopes } = context2;
      const { source: source2, value, key: key2, index: index3 } = parseResult;
      const forNode = {
        type: 11,
        loc: dir.loc,
        source: source2,
        valueAlias: value,
        keyAlias: key2,
        objectIndexAlias: index3,
        parseResult,
        children: isTemplateNode(node2) ? node2.children : [node2]
      };
      context2.replaceNode(forNode);
      scopes.vFor++;
      const onExit = processCodegen && processCodegen(forNode);
      return () => {
        scopes.vFor--;
        if (onExit)
          onExit();
      };
    }
    var forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
    var forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
    var stripParensRE = /^\(|\)$/g;
    function parseForExpression(input, context2) {
      const loc = input.loc;
      const exp = input.content;
      const inMatch = exp.match(forAliasRE);
      if (!inMatch)
        return;
      const [, LHS, RHS] = inMatch;
      const result2 = {
        source: createAliasExpression(loc, RHS.trim(), exp.indexOf(RHS, LHS.length)),
        value: void 0,
        key: void 0,
        index: void 0
      };
      if (true) {
        validateBrowserExpression(result2.source, context2);
      }
      let valueContent = LHS.trim().replace(stripParensRE, "").trim();
      const trimmedOffset = LHS.indexOf(valueContent);
      const iteratorMatch = valueContent.match(forIteratorRE);
      if (iteratorMatch) {
        valueContent = valueContent.replace(forIteratorRE, "").trim();
        const keyContent = iteratorMatch[1].trim();
        let keyOffset;
        if (keyContent) {
          keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length);
          result2.key = createAliasExpression(loc, keyContent, keyOffset);
          if (true) {
            validateBrowserExpression(result2.key, context2, true);
          }
        }
        if (iteratorMatch[2]) {
          const indexContent = iteratorMatch[2].trim();
          if (indexContent) {
            result2.index = createAliasExpression(loc, indexContent, exp.indexOf(indexContent, result2.key ? keyOffset + keyContent.length : trimmedOffset + valueContent.length));
            if (true) {
              validateBrowserExpression(result2.index, context2, true);
            }
          }
        }
      }
      if (valueContent) {
        result2.value = createAliasExpression(loc, valueContent, trimmedOffset);
        if (true) {
          validateBrowserExpression(result2.value, context2, true);
        }
      }
      return result2;
    }
    function createAliasExpression(range3, content2, offset2) {
      return createSimpleExpression(content2, false, getInnerRange(range3, offset2, content2.length));
    }
    function createForLoopParams({ value, key: key2, index: index3 }, memoArgs = []) {
      return createParamsList([value, key2, index3, ...memoArgs]);
    }
    function createParamsList(args) {
      let i2 = args.length;
      while (i2--) {
        if (args[i2])
          break;
      }
      return args.slice(0, i2 + 1).map((arg, i3) => arg || createSimpleExpression(`_`.repeat(i3 + 1), false));
    }
    var defaultFallback = createSimpleExpression(`undefined`, false);
    var trackSlotScopes = (node2, context2) => {
      if (node2.type === 1 && (node2.tagType === 1 || node2.tagType === 3)) {
        const vSlot = findDir(node2, "slot");
        if (vSlot) {
          context2.scopes.vSlot++;
          return () => {
            context2.scopes.vSlot--;
          };
        }
      }
    };
    var trackVForSlotScopes = (node2, context2) => {
      let vFor;
      if (isTemplateNode(node2) && node2.props.some(isVSlot) && (vFor = findDir(node2, "for"))) {
        const result2 = vFor.parseResult = parseForExpression(vFor.exp, context2);
        if (result2) {
          const { value, key: key2, index: index3 } = result2;
          const { addIdentifiers, removeIdentifiers } = context2;
          value && addIdentifiers(value);
          key2 && addIdentifiers(key2);
          index3 && addIdentifiers(index3);
          return () => {
            value && removeIdentifiers(value);
            key2 && removeIdentifiers(key2);
            index3 && removeIdentifiers(index3);
          };
        }
      }
    };
    var buildClientSlotFn = (props, children, loc) => createFunctionExpression(props, children, false, true, children.length ? children[0].loc : loc);
    function buildSlots(node2, context2, buildSlotFn = buildClientSlotFn) {
      context2.helper(WITH_CTX);
      const { children, loc } = node2;
      const slotsProperties = [];
      const dynamicSlots = [];
      let hasDynamicSlots = context2.scopes.vSlot > 0 || context2.scopes.vFor > 0;
      const onComponentSlot = findDir(node2, "slot", true);
      if (onComponentSlot) {
        const { arg, exp } = onComponentSlot;
        if (arg && !isStaticExp(arg)) {
          hasDynamicSlots = true;
        }
        slotsProperties.push(createObjectProperty(arg || createSimpleExpression("default", true), buildSlotFn(exp, children, loc)));
      }
      let hasTemplateSlots = false;
      let hasNamedDefaultSlot = false;
      const implicitDefaultChildren = [];
      const seenSlotNames = /* @__PURE__ */ new Set();
      for (let i2 = 0; i2 < children.length; i2++) {
        const slotElement = children[i2];
        let slotDir;
        if (!isTemplateNode(slotElement) || !(slotDir = findDir(slotElement, "slot", true))) {
          if (slotElement.type !== 3) {
            implicitDefaultChildren.push(slotElement);
          }
          continue;
        }
        if (onComponentSlot) {
          context2.onError(createCompilerError(37, slotDir.loc));
          break;
        }
        hasTemplateSlots = true;
        const { children: slotChildren, loc: slotLoc } = slotElement;
        const { arg: slotName = createSimpleExpression(`default`, true), exp: slotProps, loc: dirLoc } = slotDir;
        let staticSlotName;
        if (isStaticExp(slotName)) {
          staticSlotName = slotName ? slotName.content : `default`;
        } else {
          hasDynamicSlots = true;
        }
        const slotFunction = buildSlotFn(slotProps, slotChildren, slotLoc);
        let vIf;
        let vElse;
        let vFor;
        if (vIf = findDir(slotElement, "if")) {
          hasDynamicSlots = true;
          dynamicSlots.push(createConditionalExpression(vIf.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback));
        } else if (vElse = findDir(slotElement, /^else(-if)?$/, true)) {
          let j2 = i2;
          let prev;
          while (j2--) {
            prev = children[j2];
            if (prev.type !== 3) {
              break;
            }
          }
          if (prev && isTemplateNode(prev) && findDir(prev, "if")) {
            children.splice(i2, 1);
            i2--;
            let conditional = dynamicSlots[dynamicSlots.length - 1];
            while (conditional.alternate.type === 19) {
              conditional = conditional.alternate;
            }
            conditional.alternate = vElse.exp ? createConditionalExpression(vElse.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback) : buildDynamicSlot(slotName, slotFunction);
          } else {
            context2.onError(createCompilerError(30, vElse.loc));
          }
        } else if (vFor = findDir(slotElement, "for")) {
          hasDynamicSlots = true;
          const parseResult = vFor.parseResult || parseForExpression(vFor.exp, context2);
          if (parseResult) {
            dynamicSlots.push(createCallExpression(context2.helper(RENDER_LIST), [
              parseResult.source,
              createFunctionExpression(createForLoopParams(parseResult), buildDynamicSlot(slotName, slotFunction), true)
            ]));
          } else {
            context2.onError(createCompilerError(32, vFor.loc));
          }
        } else {
          if (staticSlotName) {
            if (seenSlotNames.has(staticSlotName)) {
              context2.onError(createCompilerError(38, dirLoc));
              continue;
            }
            seenSlotNames.add(staticSlotName);
            if (staticSlotName === "default") {
              hasNamedDefaultSlot = true;
            }
          }
          slotsProperties.push(createObjectProperty(slotName, slotFunction));
        }
      }
      if (!onComponentSlot) {
        const buildDefaultSlotProperty = (props, children2) => {
          const fn2 = buildSlotFn(props, children2, loc);
          if (context2.compatConfig) {
            fn2.isNonScopedSlot = true;
          }
          return createObjectProperty(`default`, fn2);
        };
        if (!hasTemplateSlots) {
          slotsProperties.push(buildDefaultSlotProperty(void 0, children));
        } else if (implicitDefaultChildren.length && implicitDefaultChildren.some((node3) => isNonWhitespaceContent(node3))) {
          if (hasNamedDefaultSlot) {
            context2.onError(createCompilerError(39, implicitDefaultChildren[0].loc));
          } else {
            slotsProperties.push(buildDefaultSlotProperty(void 0, implicitDefaultChildren));
          }
        }
      }
      const slotFlag = hasDynamicSlots ? 2 : hasForwardedSlots(node2.children) ? 3 : 1;
      let slots = createObjectExpression(slotsProperties.concat(createObjectProperty(`_`, createSimpleExpression(slotFlag + (true ? ` /* ${slotFlagsText[slotFlag]} */` : ``), false))), loc);
      if (dynamicSlots.length) {
        slots = createCallExpression(context2.helper(CREATE_SLOTS), [
          slots,
          createArrayExpression(dynamicSlots)
        ]);
      }
      return {
        slots,
        hasDynamicSlots
      };
    }
    function buildDynamicSlot(name, fn2) {
      return createObjectExpression([
        createObjectProperty(`name`, name),
        createObjectProperty(`fn`, fn2)
      ]);
    }
    function hasForwardedSlots(children) {
      for (let i2 = 0; i2 < children.length; i2++) {
        const child = children[i2];
        switch (child.type) {
          case 1:
            if (child.tagType === 2 || hasForwardedSlots(child.children)) {
              return true;
            }
            break;
          case 9:
            if (hasForwardedSlots(child.branches))
              return true;
            break;
          case 10:
          case 11:
            if (hasForwardedSlots(child.children))
              return true;
            break;
        }
      }
      return false;
    }
    function isNonWhitespaceContent(node2) {
      if (node2.type !== 2 && node2.type !== 12)
        return true;
      return node2.type === 2 ? !!node2.content.trim() : isNonWhitespaceContent(node2.content);
    }
    var directiveImportMap = /* @__PURE__ */ new WeakMap();
    var transformElement = (node2, context2) => {
      return function postTransformElement() {
        node2 = context2.currentNode;
        if (!(node2.type === 1 && (node2.tagType === 0 || node2.tagType === 1))) {
          return;
        }
        const { tag, props } = node2;
        const isComponent2 = node2.tagType === 1;
        let vnodeTag = isComponent2 ? resolveComponentType(node2, context2) : `"${tag}"`;
        const isDynamicComponent = isObject2(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;
        let vnodeProps;
        let vnodeChildren;
        let vnodePatchFlag;
        let patchFlag = 0;
        let vnodeDynamicProps;
        let dynamicPropNames;
        let vnodeDirectives;
        let shouldUseBlock = isDynamicComponent || vnodeTag === TELEPORT || vnodeTag === SUSPENSE || !isComponent2 && (tag === "svg" || tag === "foreignObject");
        if (props.length > 0) {
          const propsBuildResult = buildProps(node2, context2);
          vnodeProps = propsBuildResult.props;
          patchFlag = propsBuildResult.patchFlag;
          dynamicPropNames = propsBuildResult.dynamicPropNames;
          const directives = propsBuildResult.directives;
          vnodeDirectives = directives && directives.length ? createArrayExpression(directives.map((dir) => buildDirectiveArgs(dir, context2))) : void 0;
          if (propsBuildResult.shouldUseBlock) {
            shouldUseBlock = true;
          }
        }
        if (node2.children.length > 0) {
          if (vnodeTag === KEEP_ALIVE) {
            shouldUseBlock = true;
            patchFlag |= 1024;
            if (node2.children.length > 1) {
              context2.onError(createCompilerError(45, {
                start: node2.children[0].loc.start,
                end: node2.children[node2.children.length - 1].loc.end,
                source: ""
              }));
            }
          }
          const shouldBuildAsSlots = isComponent2 && vnodeTag !== TELEPORT && vnodeTag !== KEEP_ALIVE;
          if (shouldBuildAsSlots) {
            const { slots, hasDynamicSlots } = buildSlots(node2, context2);
            vnodeChildren = slots;
            if (hasDynamicSlots) {
              patchFlag |= 1024;
            }
          } else if (node2.children.length === 1 && vnodeTag !== TELEPORT) {
            const child = node2.children[0];
            const type = child.type;
            const hasDynamicTextChild = type === 5 || type === 8;
            if (hasDynamicTextChild && getConstantType(child, context2) === 0) {
              patchFlag |= 1;
            }
            if (hasDynamicTextChild || type === 2) {
              vnodeChildren = child;
            } else {
              vnodeChildren = node2.children;
            }
          } else {
            vnodeChildren = node2.children;
          }
        }
        if (patchFlag !== 0) {
          if (true) {
            if (patchFlag < 0) {
              vnodePatchFlag = patchFlag + ` /* ${PatchFlagNames[patchFlag]} */`;
            } else {
              const flagNames = Object.keys(PatchFlagNames).map(Number).filter((n3) => n3 > 0 && patchFlag & n3).map((n3) => PatchFlagNames[n3]).join(`, `);
              vnodePatchFlag = patchFlag + ` /* ${flagNames} */`;
            }
          } else {
            vnodePatchFlag = String(patchFlag);
          }
          if (dynamicPropNames && dynamicPropNames.length) {
            vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);
          }
        }
        node2.codegenNode = createVNodeCall(context2, vnodeTag, vnodeProps, vnodeChildren, vnodePatchFlag, vnodeDynamicProps, vnodeDirectives, !!shouldUseBlock, false, isComponent2, node2.loc);
      };
    };
    function resolveComponentType(node2, context2, ssr = false) {
      let { tag } = node2;
      const isExplicitDynamic = isComponentTag(tag);
      const isProp = findProp(node2, "is");
      if (isProp) {
        if (isExplicitDynamic || isCompatEnabled("COMPILER_IS_ON_ELEMENT", context2)) {
          const exp = isProp.type === 6 ? isProp.value && createSimpleExpression(isProp.value.content, true) : isProp.exp;
          if (exp) {
            return createCallExpression(context2.helper(RESOLVE_DYNAMIC_COMPONENT), [
              exp
            ]);
          }
        } else if (isProp.type === 6 && isProp.value.content.startsWith("vue:")) {
          tag = isProp.value.content.slice(4);
        }
      }
      const isDir = !isExplicitDynamic && findDir(node2, "is");
      if (isDir && isDir.exp) {
        return createCallExpression(context2.helper(RESOLVE_DYNAMIC_COMPONENT), [
          isDir.exp
        ]);
      }
      const builtIn = isCoreComponent(tag) || context2.isBuiltInComponent(tag);
      if (builtIn) {
        if (!ssr)
          context2.helper(builtIn);
        return builtIn;
      }
      context2.helper(RESOLVE_COMPONENT);
      context2.components.add(tag);
      return toValidAssetId(tag, `component`);
    }
    function buildProps(node2, context2, props = node2.props, ssr = false) {
      const { tag, loc: elementLoc, children } = node2;
      const isComponent2 = node2.tagType === 1;
      let properties = [];
      const mergeArgs = [];
      const runtimeDirectives = [];
      const hasChildren = children.length > 0;
      let shouldUseBlock = false;
      let patchFlag = 0;
      let hasRef = false;
      let hasClassBinding = false;
      let hasStyleBinding = false;
      let hasHydrationEventBinding = false;
      let hasDynamicKeys = false;
      let hasVnodeHook = false;
      const dynamicPropNames = [];
      const analyzePatchFlag = ({ key: key2, value }) => {
        if (isStaticExp(key2)) {
          const name = key2.content;
          const isEventHandler = isOn(name);
          if (!isComponent2 && isEventHandler && name.toLowerCase() !== "onclick" && name !== "onUpdate:modelValue" && !isReservedProp(name)) {
            hasHydrationEventBinding = true;
          }
          if (isEventHandler && isReservedProp(name)) {
            hasVnodeHook = true;
          }
          if (value.type === 20 || (value.type === 4 || value.type === 8) && getConstantType(value, context2) > 0) {
            return;
          }
          if (name === "ref") {
            hasRef = true;
          } else if (name === "class") {
            hasClassBinding = true;
          } else if (name === "style") {
            hasStyleBinding = true;
          } else if (name !== "key" && !dynamicPropNames.includes(name)) {
            dynamicPropNames.push(name);
          }
          if (isComponent2 && (name === "class" || name === "style") && !dynamicPropNames.includes(name)) {
            dynamicPropNames.push(name);
          }
        } else {
          hasDynamicKeys = true;
        }
      };
      for (let i2 = 0; i2 < props.length; i2++) {
        const prop = props[i2];
        if (prop.type === 6) {
          const { loc, name, value } = prop;
          let isStatic = true;
          if (name === "ref") {
            hasRef = true;
            if (context2.scopes.vFor > 0) {
              properties.push(createObjectProperty(createSimpleExpression("ref_for", true), createSimpleExpression("true")));
            }
          }
          if (name === "is" && (isComponentTag(tag) || value && value.content.startsWith("vue:") || isCompatEnabled("COMPILER_IS_ON_ELEMENT", context2))) {
            continue;
          }
          properties.push(createObjectProperty(createSimpleExpression(name, true, getInnerRange(loc, 0, name.length)), createSimpleExpression(value ? value.content : "", isStatic, value ? value.loc : loc)));
        } else {
          const { name, arg, exp, loc } = prop;
          const isVBind = name === "bind";
          const isVOn = name === "on";
          if (name === "slot") {
            if (!isComponent2) {
              context2.onError(createCompilerError(40, loc));
            }
            continue;
          }
          if (name === "once" || name === "memo") {
            continue;
          }
          if (name === "is" || isVBind && isStaticArgOf(arg, "is") && (isComponentTag(tag) || isCompatEnabled("COMPILER_IS_ON_ELEMENT", context2))) {
            continue;
          }
          if (isVOn && ssr) {
            continue;
          }
          if (isVBind && isStaticArgOf(arg, "key") || isVOn && hasChildren && isStaticArgOf(arg, "vue:before-update")) {
            shouldUseBlock = true;
          }
          if (isVBind && isStaticArgOf(arg, "ref") && context2.scopes.vFor > 0) {
            properties.push(createObjectProperty(createSimpleExpression("ref_for", true), createSimpleExpression("true")));
          }
          if (!arg && (isVBind || isVOn)) {
            hasDynamicKeys = true;
            if (exp) {
              if (properties.length) {
                mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));
                properties = [];
              }
              if (isVBind) {
                {
                  if (true) {
                    const hasOverridableKeys = mergeArgs.some((arg2) => {
                      if (arg2.type === 15) {
                        return arg2.properties.some(({ key: key2 }) => {
                          if (key2.type !== 4 || !key2.isStatic) {
                            return true;
                          }
                          return key2.content !== "class" && key2.content !== "style" && !isOn(key2.content);
                        });
                      } else {
                        return true;
                      }
                    });
                    if (hasOverridableKeys) {
                      checkCompatEnabled("COMPILER_V_BIND_OBJECT_ORDER", context2, loc);
                    }
                  }
                  if (isCompatEnabled("COMPILER_V_BIND_OBJECT_ORDER", context2)) {
                    mergeArgs.unshift(exp);
                    continue;
                  }
                }
                mergeArgs.push(exp);
              } else {
                mergeArgs.push({
                  type: 14,
                  loc,
                  callee: context2.helper(TO_HANDLERS),
                  arguments: [exp]
                });
              }
            } else {
              context2.onError(createCompilerError(isVBind ? 34 : 35, loc));
            }
            continue;
          }
          const directiveTransform = context2.directiveTransforms[name];
          if (directiveTransform) {
            const { props: props2, needRuntime } = directiveTransform(prop, node2, context2);
            !ssr && props2.forEach(analyzePatchFlag);
            properties.push(...props2);
            if (needRuntime) {
              runtimeDirectives.push(prop);
              if (isSymbol(needRuntime)) {
                directiveImportMap.set(prop, needRuntime);
              }
            }
          } else if (!isBuiltInDirective(name)) {
            runtimeDirectives.push(prop);
            if (hasChildren) {
              shouldUseBlock = true;
            }
          }
        }
      }
      let propsExpression = void 0;
      if (mergeArgs.length) {
        if (properties.length) {
          mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));
        }
        if (mergeArgs.length > 1) {
          propsExpression = createCallExpression(context2.helper(MERGE_PROPS), mergeArgs, elementLoc);
        } else {
          propsExpression = mergeArgs[0];
        }
      } else if (properties.length) {
        propsExpression = createObjectExpression(dedupeProperties(properties), elementLoc);
      }
      if (hasDynamicKeys) {
        patchFlag |= 16;
      } else {
        if (hasClassBinding && !isComponent2) {
          patchFlag |= 2;
        }
        if (hasStyleBinding && !isComponent2) {
          patchFlag |= 4;
        }
        if (dynamicPropNames.length) {
          patchFlag |= 8;
        }
        if (hasHydrationEventBinding) {
          patchFlag |= 32;
        }
      }
      if (!shouldUseBlock && (patchFlag === 0 || patchFlag === 32) && (hasRef || hasVnodeHook || runtimeDirectives.length > 0)) {
        patchFlag |= 512;
      }
      if (!context2.inSSR && propsExpression) {
        switch (propsExpression.type) {
          case 15:
            let classKeyIndex = -1;
            let styleKeyIndex = -1;
            let hasDynamicKey = false;
            for (let i2 = 0; i2 < propsExpression.properties.length; i2++) {
              const key2 = propsExpression.properties[i2].key;
              if (isStaticExp(key2)) {
                if (key2.content === "class") {
                  classKeyIndex = i2;
                } else if (key2.content === "style") {
                  styleKeyIndex = i2;
                }
              } else if (!key2.isHandlerKey) {
                hasDynamicKey = true;
              }
            }
            const classProp = propsExpression.properties[classKeyIndex];
            const styleProp = propsExpression.properties[styleKeyIndex];
            if (!hasDynamicKey) {
              if (classProp && !isStaticExp(classProp.value)) {
                classProp.value = createCallExpression(context2.helper(NORMALIZE_CLASS), [classProp.value]);
              }
              if (styleProp && !isStaticExp(styleProp.value) && (hasStyleBinding || styleProp.value.type === 17)) {
                styleProp.value = createCallExpression(context2.helper(NORMALIZE_STYLE), [styleProp.value]);
              }
            } else {
              propsExpression = createCallExpression(context2.helper(NORMALIZE_PROPS), [propsExpression]);
            }
            break;
          case 14:
            break;
          default:
            propsExpression = createCallExpression(context2.helper(NORMALIZE_PROPS), [
              createCallExpression(context2.helper(GUARD_REACTIVE_PROPS), [
                propsExpression
              ])
            ]);
            break;
        }
      }
      return {
        props: propsExpression,
        directives: runtimeDirectives,
        patchFlag,
        dynamicPropNames,
        shouldUseBlock
      };
    }
    function dedupeProperties(properties) {
      const knownProps = /* @__PURE__ */ new Map();
      const deduped = [];
      for (let i2 = 0; i2 < properties.length; i2++) {
        const prop = properties[i2];
        if (prop.key.type === 8 || !prop.key.isStatic) {
          deduped.push(prop);
          continue;
        }
        const name = prop.key.content;
        const existing = knownProps.get(name);
        if (existing) {
          if (name === "style" || name === "class" || isOn(name)) {
            mergeAsArray(existing, prop);
          }
        } else {
          knownProps.set(name, prop);
          deduped.push(prop);
        }
      }
      return deduped;
    }
    function mergeAsArray(existing, incoming) {
      if (existing.value.type === 17) {
        existing.value.elements.push(incoming.value);
      } else {
        existing.value = createArrayExpression([existing.value, incoming.value], existing.loc);
      }
    }
    function buildDirectiveArgs(dir, context2) {
      const dirArgs = [];
      const runtime = directiveImportMap.get(dir);
      if (runtime) {
        dirArgs.push(context2.helperString(runtime));
      } else {
        {
          context2.helper(RESOLVE_DIRECTIVE);
          context2.directives.add(dir.name);
          dirArgs.push(toValidAssetId(dir.name, `directive`));
        }
      }
      const { loc } = dir;
      if (dir.exp)
        dirArgs.push(dir.exp);
      if (dir.arg) {
        if (!dir.exp) {
          dirArgs.push(`void 0`);
        }
        dirArgs.push(dir.arg);
      }
      if (Object.keys(dir.modifiers).length) {
        if (!dir.arg) {
          if (!dir.exp) {
            dirArgs.push(`void 0`);
          }
          dirArgs.push(`void 0`);
        }
        const trueExpression = createSimpleExpression(`true`, false, loc);
        dirArgs.push(createObjectExpression(dir.modifiers.map((modifier) => createObjectProperty(modifier, trueExpression)), loc));
      }
      return createArrayExpression(dirArgs, dir.loc);
    }
    function stringifyDynamicPropNames(props) {
      let propsNamesString = `[`;
      for (let i2 = 0, l2 = props.length; i2 < l2; i2++) {
        propsNamesString += JSON.stringify(props[i2]);
        if (i2 < l2 - 1)
          propsNamesString += ", ";
      }
      return propsNamesString + `]`;
    }
    function isComponentTag(tag) {
      return tag === "component" || tag === "Component";
    }
    true ? Object.freeze({}) : {};
    true ? Object.freeze([]) : [];
    var cacheStringFunction = (fn2) => {
      const cache2 = /* @__PURE__ */ Object.create(null);
      return (str) => {
        const hit = cache2[str];
        return hit || (cache2[str] = fn2(str));
      };
    };
    var camelizeRE = /-(\w)/g;
    var camelize = cacheStringFunction((str) => {
      return str.replace(camelizeRE, (_2, c3) => c3 ? c3.toUpperCase() : "");
    });
    var transformSlotOutlet = (node2, context2) => {
      if (isSlotOutlet(node2)) {
        const { children, loc } = node2;
        const { slotName, slotProps } = processSlotOutlet(node2, context2);
        const slotArgs = [
          context2.prefixIdentifiers ? `_ctx.$slots` : `$slots`,
          slotName,
          "{}",
          "undefined",
          "true"
        ];
        let expectedLen = 2;
        if (slotProps) {
          slotArgs[2] = slotProps;
          expectedLen = 3;
        }
        if (children.length) {
          slotArgs[3] = createFunctionExpression([], children, false, false, loc);
          expectedLen = 4;
        }
        if (context2.scopeId && !context2.slotted) {
          expectedLen = 5;
        }
        slotArgs.splice(expectedLen);
        node2.codegenNode = createCallExpression(context2.helper(RENDER_SLOT), slotArgs, loc);
      }
    };
    function processSlotOutlet(node2, context2) {
      let slotName = `"default"`;
      let slotProps = void 0;
      const nonNameProps = [];
      for (let i2 = 0; i2 < node2.props.length; i2++) {
        const p2 = node2.props[i2];
        if (p2.type === 6) {
          if (p2.value) {
            if (p2.name === "name") {
              slotName = JSON.stringify(p2.value.content);
            } else {
              p2.name = camelize(p2.name);
              nonNameProps.push(p2);
            }
          }
        } else {
          if (p2.name === "bind" && isStaticArgOf(p2.arg, "name")) {
            if (p2.exp)
              slotName = p2.exp;
          } else {
            if (p2.name === "bind" && p2.arg && isStaticExp(p2.arg)) {
              p2.arg.content = camelize(p2.arg.content);
            }
            nonNameProps.push(p2);
          }
        }
      }
      if (nonNameProps.length > 0) {
        const { props, directives } = buildProps(node2, context2, nonNameProps);
        slotProps = props;
        if (directives.length) {
          context2.onError(createCompilerError(36, directives[0].loc));
        }
      }
      return {
        slotName,
        slotProps
      };
    }
    var fnExpRE = /^\s*([\w$_]+|(async\s*)?\([^)]*?\))\s*=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/;
    var transformOn = (dir, node2, context2, augmentor) => {
      const { loc, modifiers, arg } = dir;
      if (!dir.exp && !modifiers.length) {
        context2.onError(createCompilerError(35, loc));
      }
      let eventName;
      if (arg.type === 4) {
        if (arg.isStatic) {
          let rawName = arg.content;
          if (rawName.startsWith("vue:")) {
            rawName = `vnode-${rawName.slice(4)}`;
          }
          eventName = createSimpleExpression(toHandlerKey(camelize$1(rawName)), true, arg.loc);
        } else {
          eventName = createCompoundExpression([
            `${context2.helperString(TO_HANDLER_KEY)}(`,
            arg,
            `)`
          ]);
        }
      } else {
        eventName = arg;
        eventName.children.unshift(`${context2.helperString(TO_HANDLER_KEY)}(`);
        eventName.children.push(`)`);
      }
      let exp = dir.exp;
      if (exp && !exp.content.trim()) {
        exp = void 0;
      }
      let shouldCache = context2.cacheHandlers && !exp && !context2.inVOnce;
      if (exp) {
        const isMemberExp = isMemberExpression(exp.content);
        const isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content));
        const hasMultipleStatements = exp.content.includes(`;`);
        if (true) {
          validateBrowserExpression(exp, context2, false, hasMultipleStatements);
        }
        if (isInlineStatement || shouldCache && isMemberExp) {
          exp = createCompoundExpression([
            `${isInlineStatement ? `$event` : `${``}(...args)`} => ${hasMultipleStatements ? `{` : `(`}`,
            exp,
            hasMultipleStatements ? `}` : `)`
          ]);
        }
      }
      let ret = {
        props: [
          createObjectProperty(eventName, exp || createSimpleExpression(`() => {}`, false, loc))
        ]
      };
      if (augmentor) {
        ret = augmentor(ret);
      }
      if (shouldCache) {
        ret.props[0].value = context2.cache(ret.props[0].value);
      }
      ret.props.forEach((p2) => p2.key.isHandlerKey = true);
      return ret;
    };
    var transformBind = (dir, _node, context2) => {
      const { exp, modifiers, loc } = dir;
      const arg = dir.arg;
      if (arg.type !== 4) {
        arg.children.unshift(`(`);
        arg.children.push(`) || ""`);
      } else if (!arg.isStatic) {
        arg.content = `${arg.content} || ""`;
      }
      if (modifiers.includes("camel")) {
        if (arg.type === 4) {
          if (arg.isStatic) {
            arg.content = camelize$1(arg.content);
          } else {
            arg.content = `${context2.helperString(CAMELIZE)}(${arg.content})`;
          }
        } else {
          arg.children.unshift(`${context2.helperString(CAMELIZE)}(`);
          arg.children.push(`)`);
        }
      }
      if (!context2.inSSR) {
        if (modifiers.includes("prop")) {
          injectPrefix(arg, ".");
        }
        if (modifiers.includes("attr")) {
          injectPrefix(arg, "^");
        }
      }
      if (!exp || exp.type === 4 && !exp.content.trim()) {
        context2.onError(createCompilerError(34, loc));
        return {
          props: [createObjectProperty(arg, createSimpleExpression("", true, loc))]
        };
      }
      return {
        props: [createObjectProperty(arg, exp)]
      };
    };
    var injectPrefix = (arg, prefix) => {
      if (arg.type === 4) {
        if (arg.isStatic) {
          arg.content = prefix + arg.content;
        } else {
          arg.content = `\`${prefix}\${${arg.content}}\``;
        }
      } else {
        arg.children.unshift(`'${prefix}' + (`);
        arg.children.push(`)`);
      }
    };
    var transformText = (node2, context2) => {
      if (node2.type === 0 || node2.type === 1 || node2.type === 11 || node2.type === 10) {
        return () => {
          const children = node2.children;
          let currentContainer = void 0;
          let hasText = false;
          for (let i2 = 0; i2 < children.length; i2++) {
            const child = children[i2];
            if (isText(child)) {
              hasText = true;
              for (let j2 = i2 + 1; j2 < children.length; j2++) {
                const next = children[j2];
                if (isText(next)) {
                  if (!currentContainer) {
                    currentContainer = children[i2] = {
                      type: 8,
                      loc: child.loc,
                      children: [child]
                    };
                  }
                  currentContainer.children.push(` + `, next);
                  children.splice(j2, 1);
                  j2--;
                } else {
                  currentContainer = void 0;
                  break;
                }
              }
            }
          }
          if (!hasText || children.length === 1 && (node2.type === 0 || node2.type === 1 && node2.tagType === 0 && !node2.props.find((p2) => p2.type === 7 && !context2.directiveTransforms[p2.name]) && !(node2.tag === "template"))) {
            return;
          }
          for (let i2 = 0; i2 < children.length; i2++) {
            const child = children[i2];
            if (isText(child) || child.type === 8) {
              const callArgs = [];
              if (child.type !== 2 || child.content !== " ") {
                callArgs.push(child);
              }
              if (!context2.ssr && getConstantType(child, context2) === 0) {
                callArgs.push(1 + (true ? ` /* ${PatchFlagNames[1]} */` : ``));
              }
              children[i2] = {
                type: 12,
                content: child,
                loc: child.loc,
                codegenNode: createCallExpression(context2.helper(CREATE_TEXT), callArgs)
              };
            }
          }
        };
      }
    };
    var seen2 = /* @__PURE__ */ new WeakSet();
    var transformOnce = (node2, context2) => {
      if (node2.type === 1 && findDir(node2, "once", true)) {
        if (seen2.has(node2) || context2.inVOnce) {
          return;
        }
        seen2.add(node2);
        context2.inVOnce = true;
        context2.helper(SET_BLOCK_TRACKING);
        return () => {
          context2.inVOnce = false;
          const cur = context2.currentNode;
          if (cur.codegenNode) {
            cur.codegenNode = context2.cache(cur.codegenNode, true);
          }
        };
      }
    };
    var transformModel = (dir, node2, context2) => {
      const { exp, arg } = dir;
      if (!exp) {
        context2.onError(createCompilerError(41, dir.loc));
        return createTransformProps();
      }
      const rawExp = exp.loc.source;
      const expString = exp.type === 4 ? exp.content : rawExp;
      const maybeRef = false;
      if (!expString.trim() || !isMemberExpression(expString) && !maybeRef) {
        context2.onError(createCompilerError(42, exp.loc));
        return createTransformProps();
      }
      const propName = arg ? arg : createSimpleExpression("modelValue", true);
      const eventName = arg ? isStaticExp(arg) ? `onUpdate:${arg.content}` : createCompoundExpression(['"onUpdate:" + ', arg]) : `onUpdate:modelValue`;
      let assignmentExp;
      const eventArg = context2.isTS ? `($event: any)` : `$event`;
      {
        assignmentExp = createCompoundExpression([
          `${eventArg} => ((`,
          exp,
          `) = $event)`
        ]);
      }
      const props = [
        createObjectProperty(propName, dir.exp),
        createObjectProperty(eventName, assignmentExp)
      ];
      if (dir.modifiers.length && node2.tagType === 1) {
        const modifiers = dir.modifiers.map((m3) => (isSimpleIdentifier(m3) ? m3 : JSON.stringify(m3)) + `: true`).join(`, `);
        const modifiersKey = arg ? isStaticExp(arg) ? `${arg.content}Modifiers` : createCompoundExpression([arg, ' + "Modifiers"']) : `modelModifiers`;
        props.push(createObjectProperty(modifiersKey, createSimpleExpression(`{ ${modifiers} }`, false, dir.loc, 2)));
      }
      return createTransformProps(props);
    };
    function createTransformProps(props = []) {
      return { props };
    }
    var validDivisionCharRE = /[\w).+\-_$\]]/;
    var transformFilter = (node2, context2) => {
      if (!isCompatEnabled("COMPILER_FILTER", context2)) {
        return;
      }
      if (node2.type === 5) {
        rewriteFilter(node2.content, context2);
      }
      if (node2.type === 1) {
        node2.props.forEach((prop) => {
          if (prop.type === 7 && prop.name !== "for" && prop.exp) {
            rewriteFilter(prop.exp, context2);
          }
        });
      }
    };
    function rewriteFilter(node2, context2) {
      if (node2.type === 4) {
        parseFilter(node2, context2);
      } else {
        for (let i2 = 0; i2 < node2.children.length; i2++) {
          const child = node2.children[i2];
          if (typeof child !== "object")
            continue;
          if (child.type === 4) {
            parseFilter(child, context2);
          } else if (child.type === 8) {
            rewriteFilter(node2, context2);
          } else if (child.type === 5) {
            rewriteFilter(child.content, context2);
          }
        }
      }
    }
    function parseFilter(node2, context2) {
      const exp = node2.content;
      let inSingle = false;
      let inDouble = false;
      let inTemplateString = false;
      let inRegex = false;
      let curly = 0;
      let square = 0;
      let paren = 0;
      let lastFilterIndex = 0;
      let c3, prev, i2, expression, filters = [];
      for (i2 = 0; i2 < exp.length; i2++) {
        prev = c3;
        c3 = exp.charCodeAt(i2);
        if (inSingle) {
          if (c3 === 39 && prev !== 92)
            inSingle = false;
        } else if (inDouble) {
          if (c3 === 34 && prev !== 92)
            inDouble = false;
        } else if (inTemplateString) {
          if (c3 === 96 && prev !== 92)
            inTemplateString = false;
        } else if (inRegex) {
          if (c3 === 47 && prev !== 92)
            inRegex = false;
        } else if (c3 === 124 && exp.charCodeAt(i2 + 1) !== 124 && exp.charCodeAt(i2 - 1) !== 124 && !curly && !square && !paren) {
          if (expression === void 0) {
            lastFilterIndex = i2 + 1;
            expression = exp.slice(0, i2).trim();
          } else {
            pushFilter();
          }
        } else {
          switch (c3) {
            case 34:
              inDouble = true;
              break;
            case 39:
              inSingle = true;
              break;
            case 96:
              inTemplateString = true;
              break;
            case 40:
              paren++;
              break;
            case 41:
              paren--;
              break;
            case 91:
              square++;
              break;
            case 93:
              square--;
              break;
            case 123:
              curly++;
              break;
            case 125:
              curly--;
              break;
          }
          if (c3 === 47) {
            let j2 = i2 - 1;
            let p2;
            for (; j2 >= 0; j2--) {
              p2 = exp.charAt(j2);
              if (p2 !== " ")
                break;
            }
            if (!p2 || !validDivisionCharRE.test(p2)) {
              inRegex = true;
            }
          }
        }
      }
      if (expression === void 0) {
        expression = exp.slice(0, i2).trim();
      } else if (lastFilterIndex !== 0) {
        pushFilter();
      }
      function pushFilter() {
        filters.push(exp.slice(lastFilterIndex, i2).trim());
        lastFilterIndex = i2 + 1;
      }
      if (filters.length) {
        warnDeprecation("COMPILER_FILTER", context2, node2.loc);
        for (i2 = 0; i2 < filters.length; i2++) {
          expression = wrapFilter(expression, filters[i2], context2);
        }
        node2.content = expression;
      }
    }
    function wrapFilter(exp, filter2, context2) {
      context2.helper(RESOLVE_FILTER);
      const i2 = filter2.indexOf("(");
      if (i2 < 0) {
        context2.filters.add(filter2);
        return `${toValidAssetId(filter2, "filter")}(${exp})`;
      } else {
        const name = filter2.slice(0, i2);
        const args = filter2.slice(i2 + 1);
        context2.filters.add(name);
        return `${toValidAssetId(name, "filter")}(${exp}${args !== ")" ? "," + args : args}`;
      }
    }
    var seen$1 = /* @__PURE__ */ new WeakSet();
    var transformMemo = (node2, context2) => {
      if (node2.type === 1) {
        const dir = findDir(node2, "memo");
        if (!dir || seen$1.has(node2)) {
          return;
        }
        seen$1.add(node2);
        return () => {
          const codegenNode = node2.codegenNode || context2.currentNode.codegenNode;
          if (codegenNode && codegenNode.type === 13) {
            if (node2.tagType !== 1) {
              makeBlock(codegenNode, context2);
            }
            node2.codegenNode = createCallExpression(context2.helper(WITH_MEMO), [
              dir.exp,
              createFunctionExpression(void 0, codegenNode),
              `_cache`,
              String(context2.cached++)
            ]);
          }
        };
      }
    };
    function getBaseTransformPreset(prefixIdentifiers) {
      return [
        [
          transformOnce,
          transformIf,
          transformMemo,
          transformFor,
          ...[transformFilter],
          ...true ? [transformExpression] : [],
          transformSlotOutlet,
          transformElement,
          trackSlotScopes,
          transformText
        ],
        {
          on: transformOn,
          bind: transformBind,
          model: transformModel
        }
      ];
    }
    function baseCompile(template, options2 = {}) {
      const onError = options2.onError || defaultOnError;
      const isModuleMode = options2.mode === "module";
      {
        if (options2.prefixIdentifiers === true) {
          onError(createCompilerError(46));
        } else if (isModuleMode) {
          onError(createCompilerError(47));
        }
      }
      const prefixIdentifiers = false;
      if (options2.cacheHandlers) {
        onError(createCompilerError(48));
      }
      if (options2.scopeId && !isModuleMode) {
        onError(createCompilerError(49));
      }
      const ast = isString2(template) ? baseParse(template, options2) : template;
      const [nodeTransforms, directiveTransforms] = getBaseTransformPreset();
      transform2(ast, extend2({}, options2, {
        prefixIdentifiers,
        nodeTransforms: [
          ...nodeTransforms,
          ...options2.nodeTransforms || []
        ],
        directiveTransforms: extend2({}, directiveTransforms, options2.directiveTransforms || {})
      }));
      return generate2(ast, extend2({}, options2, {
        prefixIdentifiers
      }));
    }
    var noopDirectiveTransform = () => ({ props: [] });
    var compilerCore_esmBundler = {
      __proto__: null,
      BASE_TRANSITION,
      CAMELIZE,
      CAPITALIZE,
      CREATE_BLOCK,
      CREATE_COMMENT,
      CREATE_ELEMENT_BLOCK,
      CREATE_ELEMENT_VNODE,
      CREATE_SLOTS,
      CREATE_STATIC,
      CREATE_TEXT,
      CREATE_VNODE,
      FRAGMENT,
      GUARD_REACTIVE_PROPS,
      IS_MEMO_SAME,
      IS_REF,
      KEEP_ALIVE,
      MERGE_PROPS,
      NORMALIZE_CLASS,
      NORMALIZE_PROPS,
      NORMALIZE_STYLE,
      OPEN_BLOCK,
      POP_SCOPE_ID,
      PUSH_SCOPE_ID,
      RENDER_LIST,
      RENDER_SLOT,
      RESOLVE_COMPONENT,
      RESOLVE_DIRECTIVE,
      RESOLVE_DYNAMIC_COMPONENT,
      RESOLVE_FILTER,
      SET_BLOCK_TRACKING,
      SUSPENSE,
      TELEPORT,
      TO_DISPLAY_STRING,
      TO_HANDLERS,
      TO_HANDLER_KEY,
      UNREF,
      WITH_CTX,
      WITH_DIRECTIVES,
      WITH_MEMO,
      advancePositionWithClone,
      advancePositionWithMutation,
      assert: assert2,
      baseCompile,
      baseParse,
      buildDirectiveArgs,
      buildProps,
      buildSlots,
      checkCompatEnabled,
      createArrayExpression,
      createAssignmentExpression,
      createBlockStatement,
      createCacheExpression,
      createCallExpression,
      createCompilerError,
      createCompoundExpression,
      createConditionalExpression,
      createForLoopParams,
      createFunctionExpression,
      createIfStatement,
      createInterpolation,
      createObjectExpression,
      createObjectProperty,
      createReturnStatement,
      createRoot,
      createSequenceExpression,
      createSimpleExpression,
      createStructuralDirectiveTransform,
      createTemplateLiteral,
      createTransformContext,
      createVNodeCall,
      extractIdentifiers,
      findDir,
      findProp,
      generate: generate2,
      getBaseTransformPreset,
      getInnerRange,
      getMemoedVNodeCall,
      getVNodeBlockHelper,
      getVNodeHelper,
      hasDynamicKeyVBind,
      hasScopeRef,
      helperNameMap,
      injectProp,
      isBuiltInType,
      isCoreComponent,
      isFunctionType,
      isInDestructureAssignment,
      isMemberExpression,
      isMemberExpressionBrowser,
      isMemberExpressionNode,
      isReferencedIdentifier,
      isSimpleIdentifier,
      isSlotOutlet,
      isStaticArgOf,
      isStaticExp,
      isStaticProperty: isStaticProperty2,
      isStaticPropertyKey: isStaticPropertyKey2,
      isTemplateNode,
      isText,
      isVSlot,
      locStub,
      makeBlock,
      noopDirectiveTransform,
      processExpression,
      processFor,
      processIf,
      processSlotOutlet,
      registerRuntimeHelpers,
      resolveComponentType,
      toValidAssetId,
      trackSlotScopes,
      trackVForSlotScopes,
      transform: transform2,
      transformBind,
      transformElement,
      transformExpression,
      transformModel,
      transformOn,
      traverseNode,
      walkBlockDeclarations,
      walkFunctionParams,
      walkIdentifiers,
      warnDeprecation,
      generateCodeFrame: generateCodeFrame2
    };
    var require$$02 = index2.getAugmentedNamespace(compilerCore_esmBundler);
    var require$$12 = index2.getAugmentedNamespace(shared_esmBundler);
    (function(exports3) {
      Object.defineProperty(exports3, "__esModule", { value: true });
      var compilerCore = require$$02;
      var shared = require$$12;
      const V_MODEL_RADIO = Symbol(`vModelRadio`);
      const V_MODEL_CHECKBOX = Symbol(`vModelCheckbox`);
      const V_MODEL_TEXT = Symbol(`vModelText`);
      const V_MODEL_SELECT = Symbol(`vModelSelect`);
      const V_MODEL_DYNAMIC = Symbol(`vModelDynamic`);
      const V_ON_WITH_MODIFIERS = Symbol(`vOnModifiersGuard`);
      const V_ON_WITH_KEYS = Symbol(`vOnKeysGuard`);
      const V_SHOW = Symbol(`vShow`);
      const TRANSITION = Symbol(`Transition`);
      const TRANSITION_GROUP = Symbol(`TransitionGroup`);
      compilerCore.registerRuntimeHelpers({
        [V_MODEL_RADIO]: `vModelRadio`,
        [V_MODEL_CHECKBOX]: `vModelCheckbox`,
        [V_MODEL_TEXT]: `vModelText`,
        [V_MODEL_SELECT]: `vModelSelect`,
        [V_MODEL_DYNAMIC]: `vModelDynamic`,
        [V_ON_WITH_MODIFIERS]: `withModifiers`,
        [V_ON_WITH_KEYS]: `withKeys`,
        [V_SHOW]: `vShow`,
        [TRANSITION]: `Transition`,
        [TRANSITION_GROUP]: `TransitionGroup`
      });
      var namedCharacterReferences = {
        GT: ">",
        gt: ">",
        LT: "<",
        lt: "<",
        "ac;": "\u223E",
        "af;": "\u2061",
        AMP: "&",
        amp: "&",
        "ap;": "\u2248",
        "DD;": "\u2145",
        "dd;": "\u2146",
        deg: "\xB0",
        "ee;": "\u2147",
        "eg;": "\u2A9A",
        "el;": "\u2A99",
        ETH: "\xD0",
        eth: "\xF0",
        "gE;": "\u2267",
        "ge;": "\u2265",
        "Gg;": "\u22D9",
        "gg;": "\u226B",
        "gl;": "\u2277",
        "GT;": ">",
        "Gt;": "\u226B",
        "gt;": ">",
        "ic;": "\u2063",
        "ii;": "\u2148",
        "Im;": "\u2111",
        "in;": "\u2208",
        "it;": "\u2062",
        "lE;": "\u2266",
        "le;": "\u2264",
        "lg;": "\u2276",
        "Ll;": "\u22D8",
        "ll;": "\u226A",
        "LT;": "<",
        "Lt;": "\u226A",
        "lt;": "<",
        "mp;": "\u2213",
        "Mu;": "\u039C",
        "mu;": "\u03BC",
        "ne;": "\u2260",
        "ni;": "\u220B",
        not: "\xAC",
        "Nu;": "\u039D",
        "nu;": "\u03BD",
        "Or;": "\u2A54",
        "or;": "\u2228",
        "oS;": "\u24C8",
        "Pi;": "\u03A0",
        "pi;": "\u03C0",
        "pm;": "\xB1",
        "Pr;": "\u2ABB",
        "pr;": "\u227A",
        "Re;": "\u211C",
        REG: "\xAE",
        reg: "\xAE",
        "rx;": "\u211E",
        "Sc;": "\u2ABC",
        "sc;": "\u227B",
        shy: "\xAD",
        uml: "\xA8",
        "wp;": "\u2118",
        "wr;": "\u2240",
        "Xi;": "\u039E",
        "xi;": "\u03BE",
        yen: "\xA5",
        "acd;": "\u223F",
        "acE;": "\u223E\u0333",
        "Acy;": "\u0410",
        "acy;": "\u0430",
        "Afr;": "\u{1D504}",
        "afr;": "\u{1D51E}",
        "AMP;": "&",
        "amp;": "&",
        "And;": "\u2A53",
        "and;": "\u2227",
        "ang;": "\u2220",
        "apE;": "\u2A70",
        "ape;": "\u224A",
        "ast;": "*",
        Auml: "\xC4",
        auml: "\xE4",
        "Bcy;": "\u0411",
        "bcy;": "\u0431",
        "Bfr;": "\u{1D505}",
        "bfr;": "\u{1D51F}",
        "bne;": "=\u20E5",
        "bot;": "\u22A5",
        "Cap;": "\u22D2",
        "cap;": "\u2229",
        cent: "\xA2",
        "Cfr;": "\u212D",
        "cfr;": "\u{1D520}",
        "Chi;": "\u03A7",
        "chi;": "\u03C7",
        "cir;": "\u25CB",
        COPY: "\xA9",
        copy: "\xA9",
        "Cup;": "\u22D3",
        "cup;": "\u222A",
        "Dcy;": "\u0414",
        "dcy;": "\u0434",
        "deg;": "\xB0",
        "Del;": "\u2207",
        "Dfr;": "\u{1D507}",
        "dfr;": "\u{1D521}",
        "die;": "\xA8",
        "div;": "\xF7",
        "Dot;": "\xA8",
        "dot;": "\u02D9",
        "Ecy;": "\u042D",
        "ecy;": "\u044D",
        "Efr;": "\u{1D508}",
        "efr;": "\u{1D522}",
        "egs;": "\u2A96",
        "ell;": "\u2113",
        "els;": "\u2A95",
        "ENG;": "\u014A",
        "eng;": "\u014B",
        "Eta;": "\u0397",
        "eta;": "\u03B7",
        "ETH;": "\xD0",
        "eth;": "\xF0",
        Euml: "\xCB",
        euml: "\xEB",
        "Fcy;": "\u0424",
        "fcy;": "\u0444",
        "Ffr;": "\u{1D509}",
        "ffr;": "\u{1D523}",
        "gap;": "\u2A86",
        "Gcy;": "\u0413",
        "gcy;": "\u0433",
        "gEl;": "\u2A8C",
        "gel;": "\u22DB",
        "geq;": "\u2265",
        "ges;": "\u2A7E",
        "Gfr;": "\u{1D50A}",
        "gfr;": "\u{1D524}",
        "ggg;": "\u22D9",
        "gla;": "\u2AA5",
        "glE;": "\u2A92",
        "glj;": "\u2AA4",
        "gnE;": "\u2269",
        "gne;": "\u2A88",
        "Hat;": "^",
        "Hfr;": "\u210C",
        "hfr;": "\u{1D525}",
        "Icy;": "\u0418",
        "icy;": "\u0438",
        "iff;": "\u21D4",
        "Ifr;": "\u2111",
        "ifr;": "\u{1D526}",
        "Int;": "\u222C",
        "int;": "\u222B",
        Iuml: "\xCF",
        iuml: "\xEF",
        "Jcy;": "\u0419",
        "jcy;": "\u0439",
        "Jfr;": "\u{1D50D}",
        "jfr;": "\u{1D527}",
        "Kcy;": "\u041A",
        "kcy;": "\u043A",
        "Kfr;": "\u{1D50E}",
        "kfr;": "\u{1D528}",
        "lap;": "\u2A85",
        "lat;": "\u2AAB",
        "Lcy;": "\u041B",
        "lcy;": "\u043B",
        "lEg;": "\u2A8B",
        "leg;": "\u22DA",
        "leq;": "\u2264",
        "les;": "\u2A7D",
        "Lfr;": "\u{1D50F}",
        "lfr;": "\u{1D529}",
        "lgE;": "\u2A91",
        "lnE;": "\u2268",
        "lne;": "\u2A87",
        "loz;": "\u25CA",
        "lrm;": "\u200E",
        "Lsh;": "\u21B0",
        "lsh;": "\u21B0",
        macr: "\xAF",
        "Map;": "\u2905",
        "map;": "\u21A6",
        "Mcy;": "\u041C",
        "mcy;": "\u043C",
        "Mfr;": "\u{1D510}",
        "mfr;": "\u{1D52A}",
        "mho;": "\u2127",
        "mid;": "\u2223",
        "nap;": "\u2249",
        nbsp: "\xA0",
        "Ncy;": "\u041D",
        "ncy;": "\u043D",
        "Nfr;": "\u{1D511}",
        "nfr;": "\u{1D52B}",
        "ngE;": "\u2267\u0338",
        "nge;": "\u2271",
        "nGg;": "\u22D9\u0338",
        "nGt;": "\u226B\u20D2",
        "ngt;": "\u226F",
        "nis;": "\u22FC",
        "niv;": "\u220B",
        "nlE;": "\u2266\u0338",
        "nle;": "\u2270",
        "nLl;": "\u22D8\u0338",
        "nLt;": "\u226A\u20D2",
        "nlt;": "\u226E",
        "Not;": "\u2AEC",
        "not;": "\xAC",
        "npr;": "\u2280",
        "nsc;": "\u2281",
        "num;": "#",
        "Ocy;": "\u041E",
        "ocy;": "\u043E",
        "Ofr;": "\u{1D512}",
        "ofr;": "\u{1D52C}",
        "ogt;": "\u29C1",
        "ohm;": "\u03A9",
        "olt;": "\u29C0",
        "ord;": "\u2A5D",
        ordf: "\xAA",
        ordm: "\xBA",
        "orv;": "\u2A5B",
        Ouml: "\xD6",
        ouml: "\xF6",
        "par;": "\u2225",
        para: "\xB6",
        "Pcy;": "\u041F",
        "pcy;": "\u043F",
        "Pfr;": "\u{1D513}",
        "pfr;": "\u{1D52D}",
        "Phi;": "\u03A6",
        "phi;": "\u03C6",
        "piv;": "\u03D6",
        "prE;": "\u2AB3",
        "pre;": "\u2AAF",
        "Psi;": "\u03A8",
        "psi;": "\u03C8",
        "Qfr;": "\u{1D514}",
        "qfr;": "\u{1D52E}",
        QUOT: '"',
        quot: '"',
        "Rcy;": "\u0420",
        "rcy;": "\u0440",
        "REG;": "\xAE",
        "reg;": "\xAE",
        "Rfr;": "\u211C",
        "rfr;": "\u{1D52F}",
        "Rho;": "\u03A1",
        "rho;": "\u03C1",
        "rlm;": "\u200F",
        "Rsh;": "\u21B1",
        "rsh;": "\u21B1",
        "scE;": "\u2AB4",
        "sce;": "\u2AB0",
        "Scy;": "\u0421",
        "scy;": "\u0441",
        sect: "\xA7",
        "Sfr;": "\u{1D516}",
        "sfr;": "\u{1D530}",
        "shy;": "\xAD",
        "sim;": "\u223C",
        "smt;": "\u2AAA",
        "sol;": "/",
        "squ;": "\u25A1",
        "Sub;": "\u22D0",
        "sub;": "\u2282",
        "Sum;": "\u2211",
        "sum;": "\u2211",
        "Sup;": "\u22D1",
        "sup;": "\u2283",
        sup1: "\xB9",
        sup2: "\xB2",
        sup3: "\xB3",
        "Tab;": "	",
        "Tau;": "\u03A4",
        "tau;": "\u03C4",
        "Tcy;": "\u0422",
        "tcy;": "\u0442",
        "Tfr;": "\u{1D517}",
        "tfr;": "\u{1D531}",
        "top;": "\u22A4",
        "Ucy;": "\u0423",
        "ucy;": "\u0443",
        "Ufr;": "\u{1D518}",
        "ufr;": "\u{1D532}",
        "uml;": "\xA8",
        Uuml: "\xDC",
        uuml: "\xFC",
        "Vcy;": "\u0412",
        "vcy;": "\u0432",
        "Vee;": "\u22C1",
        "vee;": "\u2228",
        "Vfr;": "\u{1D519}",
        "vfr;": "\u{1D533}",
        "Wfr;": "\u{1D51A}",
        "wfr;": "\u{1D534}",
        "Xfr;": "\u{1D51B}",
        "xfr;": "\u{1D535}",
        "Ycy;": "\u042B",
        "ycy;": "\u044B",
        "yen;": "\xA5",
        "Yfr;": "\u{1D51C}",
        "yfr;": "\u{1D536}",
        yuml: "\xFF",
        "Zcy;": "\u0417",
        "zcy;": "\u0437",
        "Zfr;": "\u2128",
        "zfr;": "\u{1D537}",
        "zwj;": "\u200D",
        Acirc: "\xC2",
        acirc: "\xE2",
        acute: "\xB4",
        AElig: "\xC6",
        aelig: "\xE6",
        "andd;": "\u2A5C",
        "andv;": "\u2A5A",
        "ange;": "\u29A4",
        "Aopf;": "\u{1D538}",
        "aopf;": "\u{1D552}",
        "apid;": "\u224B",
        "apos;": "'",
        Aring: "\xC5",
        aring: "\xE5",
        "Ascr;": "\u{1D49C}",
        "ascr;": "\u{1D4B6}",
        "Auml;": "\xC4",
        "auml;": "\xE4",
        "Barv;": "\u2AE7",
        "bbrk;": "\u23B5",
        "Beta;": "\u0392",
        "beta;": "\u03B2",
        "beth;": "\u2136",
        "bNot;": "\u2AED",
        "bnot;": "\u2310",
        "Bopf;": "\u{1D539}",
        "bopf;": "\u{1D553}",
        "boxH;": "\u2550",
        "boxh;": "\u2500",
        "boxV;": "\u2551",
        "boxv;": "\u2502",
        "Bscr;": "\u212C",
        "bscr;": "\u{1D4B7}",
        "bsim;": "\u223D",
        "bsol;": "\\",
        "bull;": "\u2022",
        "bump;": "\u224E",
        "caps;": "\u2229\uFE00",
        "Cdot;": "\u010A",
        "cdot;": "\u010B",
        cedil: "\xB8",
        "cent;": "\xA2",
        "CHcy;": "\u0427",
        "chcy;": "\u0447",
        "circ;": "\u02C6",
        "cirE;": "\u29C3",
        "cire;": "\u2257",
        "comp;": "\u2201",
        "cong;": "\u2245",
        "Copf;": "\u2102",
        "copf;": "\u{1D554}",
        "COPY;": "\xA9",
        "copy;": "\xA9",
        "Cscr;": "\u{1D49E}",
        "cscr;": "\u{1D4B8}",
        "csub;": "\u2ACF",
        "csup;": "\u2AD0",
        "cups;": "\u222A\uFE00",
        "Darr;": "\u21A1",
        "dArr;": "\u21D3",
        "darr;": "\u2193",
        "dash;": "\u2010",
        "dHar;": "\u2965",
        "diam;": "\u22C4",
        "DJcy;": "\u0402",
        "djcy;": "\u0452",
        "Dopf;": "\u{1D53B}",
        "dopf;": "\u{1D555}",
        "Dscr;": "\u{1D49F}",
        "dscr;": "\u{1D4B9}",
        "DScy;": "\u0405",
        "dscy;": "\u0455",
        "dsol;": "\u29F6",
        "dtri;": "\u25BF",
        "DZcy;": "\u040F",
        "dzcy;": "\u045F",
        "ecir;": "\u2256",
        Ecirc: "\xCA",
        ecirc: "\xEA",
        "Edot;": "\u0116",
        "eDot;": "\u2251",
        "edot;": "\u0117",
        "emsp;": "\u2003",
        "ensp;": "\u2002",
        "Eopf;": "\u{1D53C}",
        "eopf;": "\u{1D556}",
        "epar;": "\u22D5",
        "epsi;": "\u03B5",
        "Escr;": "\u2130",
        "escr;": "\u212F",
        "Esim;": "\u2A73",
        "esim;": "\u2242",
        "Euml;": "\xCB",
        "euml;": "\xEB",
        "euro;": "\u20AC",
        "excl;": "!",
        "flat;": "\u266D",
        "fnof;": "\u0192",
        "Fopf;": "\u{1D53D}",
        "fopf;": "\u{1D557}",
        "fork;": "\u22D4",
        "Fscr;": "\u2131",
        "fscr;": "\u{1D4BB}",
        "Gdot;": "\u0120",
        "gdot;": "\u0121",
        "geqq;": "\u2267",
        "gesl;": "\u22DB\uFE00",
        "GJcy;": "\u0403",
        "gjcy;": "\u0453",
        "gnap;": "\u2A8A",
        "gneq;": "\u2A88",
        "Gopf;": "\u{1D53E}",
        "gopf;": "\u{1D558}",
        "Gscr;": "\u{1D4A2}",
        "gscr;": "\u210A",
        "gsim;": "\u2273",
        "gtcc;": "\u2AA7",
        "gvnE;": "\u2269\uFE00",
        "half;": "\xBD",
        "hArr;": "\u21D4",
        "harr;": "\u2194",
        "hbar;": "\u210F",
        "Hopf;": "\u210D",
        "hopf;": "\u{1D559}",
        "Hscr;": "\u210B",
        "hscr;": "\u{1D4BD}",
        Icirc: "\xCE",
        icirc: "\xEE",
        "Idot;": "\u0130",
        "IEcy;": "\u0415",
        "iecy;": "\u0435",
        iexcl: "\xA1",
        "imof;": "\u22B7",
        "IOcy;": "\u0401",
        "iocy;": "\u0451",
        "Iopf;": "\u{1D540}",
        "iopf;": "\u{1D55A}",
        "Iota;": "\u0399",
        "iota;": "\u03B9",
        "Iscr;": "\u2110",
        "iscr;": "\u{1D4BE}",
        "isin;": "\u2208",
        "Iuml;": "\xCF",
        "iuml;": "\xEF",
        "Jopf;": "\u{1D541}",
        "jopf;": "\u{1D55B}",
        "Jscr;": "\u{1D4A5}",
        "jscr;": "\u{1D4BF}",
        "KHcy;": "\u0425",
        "khcy;": "\u0445",
        "KJcy;": "\u040C",
        "kjcy;": "\u045C",
        "Kopf;": "\u{1D542}",
        "kopf;": "\u{1D55C}",
        "Kscr;": "\u{1D4A6}",
        "kscr;": "\u{1D4C0}",
        "Lang;": "\u27EA",
        "lang;": "\u27E8",
        laquo: "\xAB",
        "Larr;": "\u219E",
        "lArr;": "\u21D0",
        "larr;": "\u2190",
        "late;": "\u2AAD",
        "lcub;": "{",
        "ldca;": "\u2936",
        "ldsh;": "\u21B2",
        "leqq;": "\u2266",
        "lesg;": "\u22DA\uFE00",
        "lHar;": "\u2962",
        "LJcy;": "\u0409",
        "ljcy;": "\u0459",
        "lnap;": "\u2A89",
        "lneq;": "\u2A87",
        "Lopf;": "\u{1D543}",
        "lopf;": "\u{1D55D}",
        "lozf;": "\u29EB",
        "lpar;": "(",
        "Lscr;": "\u2112",
        "lscr;": "\u{1D4C1}",
        "lsim;": "\u2272",
        "lsqb;": "[",
        "ltcc;": "\u2AA6",
        "ltri;": "\u25C3",
        "lvnE;": "\u2268\uFE00",
        "macr;": "\xAF",
        "male;": "\u2642",
        "malt;": "\u2720",
        micro: "\xB5",
        "mlcp;": "\u2ADB",
        "mldr;": "\u2026",
        "Mopf;": "\u{1D544}",
        "mopf;": "\u{1D55E}",
        "Mscr;": "\u2133",
        "mscr;": "\u{1D4C2}",
        "nang;": "\u2220\u20D2",
        "napE;": "\u2A70\u0338",
        "nbsp;": "\xA0",
        "ncap;": "\u2A43",
        "ncup;": "\u2A42",
        "ngeq;": "\u2271",
        "nges;": "\u2A7E\u0338",
        "ngtr;": "\u226F",
        "nGtv;": "\u226B\u0338",
        "nisd;": "\u22FA",
        "NJcy;": "\u040A",
        "njcy;": "\u045A",
        "nldr;": "\u2025",
        "nleq;": "\u2270",
        "nles;": "\u2A7D\u0338",
        "nLtv;": "\u226A\u0338",
        "nmid;": "\u2224",
        "Nopf;": "\u2115",
        "nopf;": "\u{1D55F}",
        "npar;": "\u2226",
        "npre;": "\u2AAF\u0338",
        "nsce;": "\u2AB0\u0338",
        "Nscr;": "\u{1D4A9}",
        "nscr;": "\u{1D4C3}",
        "nsim;": "\u2241",
        "nsub;": "\u2284",
        "nsup;": "\u2285",
        "ntgl;": "\u2279",
        "ntlg;": "\u2278",
        "nvap;": "\u224D\u20D2",
        "nvge;": "\u2265\u20D2",
        "nvgt;": ">\u20D2",
        "nvle;": "\u2264\u20D2",
        "nvlt;": "<\u20D2",
        "oast;": "\u229B",
        "ocir;": "\u229A",
        Ocirc: "\xD4",
        ocirc: "\xF4",
        "odiv;": "\u2A38",
        "odot;": "\u2299",
        "ogon;": "\u02DB",
        "oint;": "\u222E",
        "omid;": "\u29B6",
        "Oopf;": "\u{1D546}",
        "oopf;": "\u{1D560}",
        "opar;": "\u29B7",
        "ordf;": "\xAA",
        "ordm;": "\xBA",
        "oror;": "\u2A56",
        "Oscr;": "\u{1D4AA}",
        "oscr;": "\u2134",
        "osol;": "\u2298",
        "Ouml;": "\xD6",
        "ouml;": "\xF6",
        "para;": "\xB6",
        "part;": "\u2202",
        "perp;": "\u22A5",
        "phiv;": "\u03D5",
        "plus;": "+",
        "Popf;": "\u2119",
        "popf;": "\u{1D561}",
        pound: "\xA3",
        "prap;": "\u2AB7",
        "prec;": "\u227A",
        "prnE;": "\u2AB5",
        "prod;": "\u220F",
        "prop;": "\u221D",
        "Pscr;": "\u{1D4AB}",
        "pscr;": "\u{1D4C5}",
        "qint;": "\u2A0C",
        "Qopf;": "\u211A",
        "qopf;": "\u{1D562}",
        "Qscr;": "\u{1D4AC}",
        "qscr;": "\u{1D4C6}",
        "QUOT;": '"',
        "quot;": '"',
        "race;": "\u223D\u0331",
        "Rang;": "\u27EB",
        "rang;": "\u27E9",
        raquo: "\xBB",
        "Rarr;": "\u21A0",
        "rArr;": "\u21D2",
        "rarr;": "\u2192",
        "rcub;": "}",
        "rdca;": "\u2937",
        "rdsh;": "\u21B3",
        "real;": "\u211C",
        "rect;": "\u25AD",
        "rHar;": "\u2964",
        "rhov;": "\u03F1",
        "ring;": "\u02DA",
        "Ropf;": "\u211D",
        "ropf;": "\u{1D563}",
        "rpar;": ")",
        "Rscr;": "\u211B",
        "rscr;": "\u{1D4C7}",
        "rsqb;": "]",
        "rtri;": "\u25B9",
        "scap;": "\u2AB8",
        "scnE;": "\u2AB6",
        "sdot;": "\u22C5",
        "sect;": "\xA7",
        "semi;": ";",
        "sext;": "\u2736",
        "SHcy;": "\u0428",
        "shcy;": "\u0448",
        "sime;": "\u2243",
        "simg;": "\u2A9E",
        "siml;": "\u2A9D",
        "smid;": "\u2223",
        "smte;": "\u2AAC",
        "solb;": "\u29C4",
        "Sopf;": "\u{1D54A}",
        "sopf;": "\u{1D564}",
        "spar;": "\u2225",
        "Sqrt;": "\u221A",
        "squf;": "\u25AA",
        "Sscr;": "\u{1D4AE}",
        "sscr;": "\u{1D4C8}",
        "Star;": "\u22C6",
        "star;": "\u2606",
        "subE;": "\u2AC5",
        "sube;": "\u2286",
        "succ;": "\u227B",
        "sung;": "\u266A",
        "sup1;": "\xB9",
        "sup2;": "\xB2",
        "sup3;": "\xB3",
        "supE;": "\u2AC6",
        "supe;": "\u2287",
        szlig: "\xDF",
        "tbrk;": "\u23B4",
        "tdot;": "\u20DB",
        THORN: "\xDE",
        thorn: "\xFE",
        times: "\xD7",
        "tint;": "\u222D",
        "toea;": "\u2928",
        "Topf;": "\u{1D54B}",
        "topf;": "\u{1D565}",
        "tosa;": "\u2929",
        "trie;": "\u225C",
        "Tscr;": "\u{1D4AF}",
        "tscr;": "\u{1D4C9}",
        "TScy;": "\u0426",
        "tscy;": "\u0446",
        "Uarr;": "\u219F",
        "uArr;": "\u21D1",
        "uarr;": "\u2191",
        Ucirc: "\xDB",
        ucirc: "\xFB",
        "uHar;": "\u2963",
        "Uopf;": "\u{1D54C}",
        "uopf;": "\u{1D566}",
        "Upsi;": "\u03D2",
        "upsi;": "\u03C5",
        "Uscr;": "\u{1D4B0}",
        "uscr;": "\u{1D4CA}",
        "utri;": "\u25B5",
        "Uuml;": "\xDC",
        "uuml;": "\xFC",
        "vArr;": "\u21D5",
        "varr;": "\u2195",
        "Vbar;": "\u2AEB",
        "vBar;": "\u2AE8",
        "Vert;": "\u2016",
        "vert;": "|",
        "Vopf;": "\u{1D54D}",
        "vopf;": "\u{1D567}",
        "Vscr;": "\u{1D4B1}",
        "vscr;": "\u{1D4CB}",
        "Wopf;": "\u{1D54E}",
        "wopf;": "\u{1D568}",
        "Wscr;": "\u{1D4B2}",
        "wscr;": "\u{1D4CC}",
        "xcap;": "\u22C2",
        "xcup;": "\u22C3",
        "xmap;": "\u27FC",
        "xnis;": "\u22FB",
        "Xopf;": "\u{1D54F}",
        "xopf;": "\u{1D569}",
        "Xscr;": "\u{1D4B3}",
        "xscr;": "\u{1D4CD}",
        "xvee;": "\u22C1",
        "YAcy;": "\u042F",
        "yacy;": "\u044F",
        "YIcy;": "\u0407",
        "yicy;": "\u0457",
        "Yopf;": "\u{1D550}",
        "yopf;": "\u{1D56A}",
        "Yscr;": "\u{1D4B4}",
        "yscr;": "\u{1D4CE}",
        "YUcy;": "\u042E",
        "yucy;": "\u044E",
        "Yuml;": "\u0178",
        "yuml;": "\xFF",
        "Zdot;": "\u017B",
        "zdot;": "\u017C",
        "Zeta;": "\u0396",
        "zeta;": "\u03B6",
        "ZHcy;": "\u0416",
        "zhcy;": "\u0436",
        "Zopf;": "\u2124",
        "zopf;": "\u{1D56B}",
        "Zscr;": "\u{1D4B5}",
        "zscr;": "\u{1D4CF}",
        "zwnj;": "\u200C",
        Aacute: "\xC1",
        aacute: "\xE1",
        "Acirc;": "\xC2",
        "acirc;": "\xE2",
        "acute;": "\xB4",
        "AElig;": "\xC6",
        "aelig;": "\xE6",
        Agrave: "\xC0",
        agrave: "\xE0",
        "aleph;": "\u2135",
        "Alpha;": "\u0391",
        "alpha;": "\u03B1",
        "Amacr;": "\u0100",
        "amacr;": "\u0101",
        "amalg;": "\u2A3F",
        "angle;": "\u2220",
        "angrt;": "\u221F",
        "angst;": "\xC5",
        "Aogon;": "\u0104",
        "aogon;": "\u0105",
        "Aring;": "\xC5",
        "aring;": "\xE5",
        "asymp;": "\u2248",
        Atilde: "\xC3",
        atilde: "\xE3",
        "awint;": "\u2A11",
        "bcong;": "\u224C",
        "bdquo;": "\u201E",
        "bepsi;": "\u03F6",
        "blank;": "\u2423",
        "blk12;": "\u2592",
        "blk14;": "\u2591",
        "blk34;": "\u2593",
        "block;": "\u2588",
        "boxDL;": "\u2557",
        "boxDl;": "\u2556",
        "boxdL;": "\u2555",
        "boxdl;": "\u2510",
        "boxDR;": "\u2554",
        "boxDr;": "\u2553",
        "boxdR;": "\u2552",
        "boxdr;": "\u250C",
        "boxHD;": "\u2566",
        "boxHd;": "\u2564",
        "boxhD;": "\u2565",
        "boxhd;": "\u252C",
        "boxHU;": "\u2569",
        "boxHu;": "\u2567",
        "boxhU;": "\u2568",
        "boxhu;": "\u2534",
        "boxUL;": "\u255D",
        "boxUl;": "\u255C",
        "boxuL;": "\u255B",
        "boxul;": "\u2518",
        "boxUR;": "\u255A",
        "boxUr;": "\u2559",
        "boxuR;": "\u2558",
        "boxur;": "\u2514",
        "boxVH;": "\u256C",
        "boxVh;": "\u256B",
        "boxvH;": "\u256A",
        "boxvh;": "\u253C",
        "boxVL;": "\u2563",
        "boxVl;": "\u2562",
        "boxvL;": "\u2561",
        "boxvl;": "\u2524",
        "boxVR;": "\u2560",
        "boxVr;": "\u255F",
        "boxvR;": "\u255E",
        "boxvr;": "\u251C",
        "Breve;": "\u02D8",
        "breve;": "\u02D8",
        brvbar: "\xA6",
        "bsemi;": "\u204F",
        "bsime;": "\u22CD",
        "bsolb;": "\u29C5",
        "bumpE;": "\u2AAE",
        "bumpe;": "\u224F",
        "caret;": "\u2041",
        "caron;": "\u02C7",
        "ccaps;": "\u2A4D",
        Ccedil: "\xC7",
        ccedil: "\xE7",
        "Ccirc;": "\u0108",
        "ccirc;": "\u0109",
        "ccups;": "\u2A4C",
        "cedil;": "\xB8",
        "check;": "\u2713",
        "clubs;": "\u2663",
        "Colon;": "\u2237",
        "colon;": ":",
        "comma;": ",",
        "crarr;": "\u21B5",
        "Cross;": "\u2A2F",
        "cross;": "\u2717",
        "csube;": "\u2AD1",
        "csupe;": "\u2AD2",
        "ctdot;": "\u22EF",
        "cuepr;": "\u22DE",
        "cuesc;": "\u22DF",
        "cupor;": "\u2A45",
        curren: "\xA4",
        "cuvee;": "\u22CE",
        "cuwed;": "\u22CF",
        "cwint;": "\u2231",
        "Dashv;": "\u2AE4",
        "dashv;": "\u22A3",
        "dblac;": "\u02DD",
        "ddarr;": "\u21CA",
        "Delta;": "\u0394",
        "delta;": "\u03B4",
        "dharl;": "\u21C3",
        "dharr;": "\u21C2",
        "diams;": "\u2666",
        "disin;": "\u22F2",
        divide: "\xF7",
        "doteq;": "\u2250",
        "dtdot;": "\u22F1",
        "dtrif;": "\u25BE",
        "duarr;": "\u21F5",
        "duhar;": "\u296F",
        Eacute: "\xC9",
        eacute: "\xE9",
        "Ecirc;": "\xCA",
        "ecirc;": "\xEA",
        "eDDot;": "\u2A77",
        "efDot;": "\u2252",
        Egrave: "\xC8",
        egrave: "\xE8",
        "Emacr;": "\u0112",
        "emacr;": "\u0113",
        "empty;": "\u2205",
        "Eogon;": "\u0118",
        "eogon;": "\u0119",
        "eplus;": "\u2A71",
        "epsiv;": "\u03F5",
        "eqsim;": "\u2242",
        "Equal;": "\u2A75",
        "equiv;": "\u2261",
        "erarr;": "\u2971",
        "erDot;": "\u2253",
        "esdot;": "\u2250",
        "exist;": "\u2203",
        "fflig;": "\uFB00",
        "filig;": "\uFB01",
        "fjlig;": "fj",
        "fllig;": "\uFB02",
        "fltns;": "\u25B1",
        "forkv;": "\u2AD9",
        frac12: "\xBD",
        frac14: "\xBC",
        frac34: "\xBE",
        "frasl;": "\u2044",
        "frown;": "\u2322",
        "Gamma;": "\u0393",
        "gamma;": "\u03B3",
        "Gcirc;": "\u011C",
        "gcirc;": "\u011D",
        "gescc;": "\u2AA9",
        "gimel;": "\u2137",
        "gneqq;": "\u2269",
        "gnsim;": "\u22E7",
        "grave;": "`",
        "gsime;": "\u2A8E",
        "gsiml;": "\u2A90",
        "gtcir;": "\u2A7A",
        "gtdot;": "\u22D7",
        "Hacek;": "\u02C7",
        "harrw;": "\u21AD",
        "Hcirc;": "\u0124",
        "hcirc;": "\u0125",
        "hoarr;": "\u21FF",
        Iacute: "\xCD",
        iacute: "\xED",
        "Icirc;": "\xCE",
        "icirc;": "\xEE",
        "iexcl;": "\xA1",
        Igrave: "\xCC",
        igrave: "\xEC",
        "iiint;": "\u222D",
        "iiota;": "\u2129",
        "IJlig;": "\u0132",
        "ijlig;": "\u0133",
        "Imacr;": "\u012A",
        "imacr;": "\u012B",
        "image;": "\u2111",
        "imath;": "\u0131",
        "imped;": "\u01B5",
        "infin;": "\u221E",
        "Iogon;": "\u012E",
        "iogon;": "\u012F",
        "iprod;": "\u2A3C",
        iquest: "\xBF",
        "isinE;": "\u22F9",
        "isins;": "\u22F4",
        "isinv;": "\u2208",
        "Iukcy;": "\u0406",
        "iukcy;": "\u0456",
        "Jcirc;": "\u0134",
        "jcirc;": "\u0135",
        "jmath;": "\u0237",
        "Jukcy;": "\u0404",
        "jukcy;": "\u0454",
        "Kappa;": "\u039A",
        "kappa;": "\u03BA",
        "lAarr;": "\u21DA",
        "langd;": "\u2991",
        "laquo;": "\xAB",
        "larrb;": "\u21E4",
        "lates;": "\u2AAD\uFE00",
        "lBarr;": "\u290E",
        "lbarr;": "\u290C",
        "lbbrk;": "\u2772",
        "lbrke;": "\u298B",
        "lceil;": "\u2308",
        "ldquo;": "\u201C",
        "lescc;": "\u2AA8",
        "lhard;": "\u21BD",
        "lharu;": "\u21BC",
        "lhblk;": "\u2584",
        "llarr;": "\u21C7",
        "lltri;": "\u25FA",
        "lneqq;": "\u2268",
        "lnsim;": "\u22E6",
        "loang;": "\u27EC",
        "loarr;": "\u21FD",
        "lobrk;": "\u27E6",
        "lopar;": "\u2985",
        "lrarr;": "\u21C6",
        "lrhar;": "\u21CB",
        "lrtri;": "\u22BF",
        "lsime;": "\u2A8D",
        "lsimg;": "\u2A8F",
        "lsquo;": "\u2018",
        "ltcir;": "\u2A79",
        "ltdot;": "\u22D6",
        "ltrie;": "\u22B4",
        "ltrif;": "\u25C2",
        "mdash;": "\u2014",
        "mDDot;": "\u223A",
        "micro;": "\xB5",
        middot: "\xB7",
        "minus;": "\u2212",
        "mumap;": "\u22B8",
        "nabla;": "\u2207",
        "napid;": "\u224B\u0338",
        "napos;": "\u0149",
        "natur;": "\u266E",
        "nbump;": "\u224E\u0338",
        "ncong;": "\u2247",
        "ndash;": "\u2013",
        "neArr;": "\u21D7",
        "nearr;": "\u2197",
        "nedot;": "\u2250\u0338",
        "nesim;": "\u2242\u0338",
        "ngeqq;": "\u2267\u0338",
        "ngsim;": "\u2275",
        "nhArr;": "\u21CE",
        "nharr;": "\u21AE",
        "nhpar;": "\u2AF2",
        "nlArr;": "\u21CD",
        "nlarr;": "\u219A",
        "nleqq;": "\u2266\u0338",
        "nless;": "\u226E",
        "nlsim;": "\u2274",
        "nltri;": "\u22EA",
        "notin;": "\u2209",
        "notni;": "\u220C",
        "npart;": "\u2202\u0338",
        "nprec;": "\u2280",
        "nrArr;": "\u21CF",
        "nrarr;": "\u219B",
        "nrtri;": "\u22EB",
        "nsime;": "\u2244",
        "nsmid;": "\u2224",
        "nspar;": "\u2226",
        "nsubE;": "\u2AC5\u0338",
        "nsube;": "\u2288",
        "nsucc;": "\u2281",
        "nsupE;": "\u2AC6\u0338",
        "nsupe;": "\u2289",
        Ntilde: "\xD1",
        ntilde: "\xF1",
        "numsp;": "\u2007",
        "nvsim;": "\u223C\u20D2",
        "nwArr;": "\u21D6",
        "nwarr;": "\u2196",
        Oacute: "\xD3",
        oacute: "\xF3",
        "Ocirc;": "\xD4",
        "ocirc;": "\xF4",
        "odash;": "\u229D",
        "OElig;": "\u0152",
        "oelig;": "\u0153",
        "ofcir;": "\u29BF",
        Ograve: "\xD2",
        ograve: "\xF2",
        "ohbar;": "\u29B5",
        "olarr;": "\u21BA",
        "olcir;": "\u29BE",
        "oline;": "\u203E",
        "Omacr;": "\u014C",
        "omacr;": "\u014D",
        "Omega;": "\u03A9",
        "omega;": "\u03C9",
        "operp;": "\u29B9",
        "oplus;": "\u2295",
        "orarr;": "\u21BB",
        "order;": "\u2134",
        Oslash: "\xD8",
        oslash: "\xF8",
        Otilde: "\xD5",
        otilde: "\xF5",
        "ovbar;": "\u233D",
        "parsl;": "\u2AFD",
        "phone;": "\u260E",
        "plusb;": "\u229E",
        "pluse;": "\u2A72",
        plusmn: "\xB1",
        "pound;": "\xA3",
        "prcue;": "\u227C",
        "Prime;": "\u2033",
        "prime;": "\u2032",
        "prnap;": "\u2AB9",
        "prsim;": "\u227E",
        "quest;": "?",
        "rAarr;": "\u21DB",
        "radic;": "\u221A",
        "rangd;": "\u2992",
        "range;": "\u29A5",
        "raquo;": "\xBB",
        "rarrb;": "\u21E5",
        "rarrc;": "\u2933",
        "rarrw;": "\u219D",
        "ratio;": "\u2236",
        "RBarr;": "\u2910",
        "rBarr;": "\u290F",
        "rbarr;": "\u290D",
        "rbbrk;": "\u2773",
        "rbrke;": "\u298C",
        "rceil;": "\u2309",
        "rdquo;": "\u201D",
        "reals;": "\u211D",
        "rhard;": "\u21C1",
        "rharu;": "\u21C0",
        "rlarr;": "\u21C4",
        "rlhar;": "\u21CC",
        "rnmid;": "\u2AEE",
        "roang;": "\u27ED",
        "roarr;": "\u21FE",
        "robrk;": "\u27E7",
        "ropar;": "\u2986",
        "rrarr;": "\u21C9",
        "rsquo;": "\u2019",
        "rtrie;": "\u22B5",
        "rtrif;": "\u25B8",
        "sbquo;": "\u201A",
        "sccue;": "\u227D",
        "Scirc;": "\u015C",
        "scirc;": "\u015D",
        "scnap;": "\u2ABA",
        "scsim;": "\u227F",
        "sdotb;": "\u22A1",
        "sdote;": "\u2A66",
        "seArr;": "\u21D8",
        "searr;": "\u2198",
        "setmn;": "\u2216",
        "sharp;": "\u266F",
        "Sigma;": "\u03A3",
        "sigma;": "\u03C3",
        "simeq;": "\u2243",
        "simgE;": "\u2AA0",
        "simlE;": "\u2A9F",
        "simne;": "\u2246",
        "slarr;": "\u2190",
        "smile;": "\u2323",
        "smtes;": "\u2AAC\uFE00",
        "sqcap;": "\u2293",
        "sqcup;": "\u2294",
        "sqsub;": "\u228F",
        "sqsup;": "\u2290",
        "srarr;": "\u2192",
        "starf;": "\u2605",
        "strns;": "\xAF",
        "subnE;": "\u2ACB",
        "subne;": "\u228A",
        "supnE;": "\u2ACC",
        "supne;": "\u228B",
        "swArr;": "\u21D9",
        "swarr;": "\u2199",
        "szlig;": "\xDF",
        "Theta;": "\u0398",
        "theta;": "\u03B8",
        "thkap;": "\u2248",
        "THORN;": "\xDE",
        "thorn;": "\xFE",
        "Tilde;": "\u223C",
        "tilde;": "\u02DC",
        "times;": "\xD7",
        "TRADE;": "\u2122",
        "trade;": "\u2122",
        "trisb;": "\u29CD",
        "TSHcy;": "\u040B",
        "tshcy;": "\u045B",
        "twixt;": "\u226C",
        Uacute: "\xDA",
        uacute: "\xFA",
        "Ubrcy;": "\u040E",
        "ubrcy;": "\u045E",
        "Ucirc;": "\xDB",
        "ucirc;": "\xFB",
        "udarr;": "\u21C5",
        "udhar;": "\u296E",
        Ugrave: "\xD9",
        ugrave: "\xF9",
        "uharl;": "\u21BF",
        "uharr;": "\u21BE",
        "uhblk;": "\u2580",
        "ultri;": "\u25F8",
        "Umacr;": "\u016A",
        "umacr;": "\u016B",
        "Union;": "\u22C3",
        "Uogon;": "\u0172",
        "uogon;": "\u0173",
        "uplus;": "\u228E",
        "upsih;": "\u03D2",
        "UpTee;": "\u22A5",
        "Uring;": "\u016E",
        "uring;": "\u016F",
        "urtri;": "\u25F9",
        "utdot;": "\u22F0",
        "utrif;": "\u25B4",
        "uuarr;": "\u21C8",
        "varpi;": "\u03D6",
        "vBarv;": "\u2AE9",
        "VDash;": "\u22AB",
        "Vdash;": "\u22A9",
        "vDash;": "\u22A8",
        "vdash;": "\u22A2",
        "veeeq;": "\u225A",
        "vltri;": "\u22B2",
        "vnsub;": "\u2282\u20D2",
        "vnsup;": "\u2283\u20D2",
        "vprop;": "\u221D",
        "vrtri;": "\u22B3",
        "Wcirc;": "\u0174",
        "wcirc;": "\u0175",
        "Wedge;": "\u22C0",
        "wedge;": "\u2227",
        "xcirc;": "\u25EF",
        "xdtri;": "\u25BD",
        "xhArr;": "\u27FA",
        "xharr;": "\u27F7",
        "xlArr;": "\u27F8",
        "xlarr;": "\u27F5",
        "xodot;": "\u2A00",
        "xrArr;": "\u27F9",
        "xrarr;": "\u27F6",
        "xutri;": "\u25B3",
        Yacute: "\xDD",
        yacute: "\xFD",
        "Ycirc;": "\u0176",
        "ycirc;": "\u0177",
        "Aacute;": "\xC1",
        "aacute;": "\xE1",
        "Abreve;": "\u0102",
        "abreve;": "\u0103",
        "Agrave;": "\xC0",
        "agrave;": "\xE0",
        "andand;": "\u2A55",
        "angmsd;": "\u2221",
        "angsph;": "\u2222",
        "apacir;": "\u2A6F",
        "approx;": "\u2248",
        "Assign;": "\u2254",
        "Atilde;": "\xC3",
        "atilde;": "\xE3",
        "barvee;": "\u22BD",
        "Barwed;": "\u2306",
        "barwed;": "\u2305",
        "becaus;": "\u2235",
        "bernou;": "\u212C",
        "bigcap;": "\u22C2",
        "bigcup;": "\u22C3",
        "bigvee;": "\u22C1",
        "bkarow;": "\u290D",
        "bottom;": "\u22A5",
        "bowtie;": "\u22C8",
        "boxbox;": "\u29C9",
        "bprime;": "\u2035",
        "brvbar;": "\xA6",
        "bullet;": "\u2022",
        "Bumpeq;": "\u224E",
        "bumpeq;": "\u224F",
        "Cacute;": "\u0106",
        "cacute;": "\u0107",
        "capand;": "\u2A44",
        "capcap;": "\u2A4B",
        "capcup;": "\u2A47",
        "capdot;": "\u2A40",
        "Ccaron;": "\u010C",
        "ccaron;": "\u010D",
        "Ccedil;": "\xC7",
        "ccedil;": "\xE7",
        "circeq;": "\u2257",
        "cirmid;": "\u2AEF",
        "Colone;": "\u2A74",
        "colone;": "\u2254",
        "commat;": "@",
        "compfn;": "\u2218",
        "Conint;": "\u222F",
        "conint;": "\u222E",
        "coprod;": "\u2210",
        "copysr;": "\u2117",
        "cularr;": "\u21B6",
        "CupCap;": "\u224D",
        "cupcap;": "\u2A46",
        "cupcup;": "\u2A4A",
        "cupdot;": "\u228D",
        "curarr;": "\u21B7",
        "curren;": "\xA4",
        "cylcty;": "\u232D",
        "Dagger;": "\u2021",
        "dagger;": "\u2020",
        "daleth;": "\u2138",
        "Dcaron;": "\u010E",
        "dcaron;": "\u010F",
        "dfisht;": "\u297F",
        "divide;": "\xF7",
        "divonx;": "\u22C7",
        "dlcorn;": "\u231E",
        "dlcrop;": "\u230D",
        "dollar;": "$",
        "DotDot;": "\u20DC",
        "drcorn;": "\u231F",
        "drcrop;": "\u230C",
        "Dstrok;": "\u0110",
        "dstrok;": "\u0111",
        "Eacute;": "\xC9",
        "eacute;": "\xE9",
        "easter;": "\u2A6E",
        "Ecaron;": "\u011A",
        "ecaron;": "\u011B",
        "ecolon;": "\u2255",
        "Egrave;": "\xC8",
        "egrave;": "\xE8",
        "egsdot;": "\u2A98",
        "elsdot;": "\u2A97",
        "emptyv;": "\u2205",
        "emsp13;": "\u2004",
        "emsp14;": "\u2005",
        "eparsl;": "\u29E3",
        "eqcirc;": "\u2256",
        "equals;": "=",
        "equest;": "\u225F",
        "Exists;": "\u2203",
        "female;": "\u2640",
        "ffilig;": "\uFB03",
        "ffllig;": "\uFB04",
        "ForAll;": "\u2200",
        "forall;": "\u2200",
        "frac12;": "\xBD",
        "frac13;": "\u2153",
        "frac14;": "\xBC",
        "frac15;": "\u2155",
        "frac16;": "\u2159",
        "frac18;": "\u215B",
        "frac23;": "\u2154",
        "frac25;": "\u2156",
        "frac34;": "\xBE",
        "frac35;": "\u2157",
        "frac38;": "\u215C",
        "frac45;": "\u2158",
        "frac56;": "\u215A",
        "frac58;": "\u215D",
        "frac78;": "\u215E",
        "gacute;": "\u01F5",
        "Gammad;": "\u03DC",
        "gammad;": "\u03DD",
        "Gbreve;": "\u011E",
        "gbreve;": "\u011F",
        "Gcedil;": "\u0122",
        "gesdot;": "\u2A80",
        "gesles;": "\u2A94",
        "gtlPar;": "\u2995",
        "gtrarr;": "\u2978",
        "gtrdot;": "\u22D7",
        "gtrsim;": "\u2273",
        "hairsp;": "\u200A",
        "hamilt;": "\u210B",
        "HARDcy;": "\u042A",
        "hardcy;": "\u044A",
        "hearts;": "\u2665",
        "hellip;": "\u2026",
        "hercon;": "\u22B9",
        "homtht;": "\u223B",
        "horbar;": "\u2015",
        "hslash;": "\u210F",
        "Hstrok;": "\u0126",
        "hstrok;": "\u0127",
        "hybull;": "\u2043",
        "hyphen;": "\u2010",
        "Iacute;": "\xCD",
        "iacute;": "\xED",
        "Igrave;": "\xCC",
        "igrave;": "\xEC",
        "iiiint;": "\u2A0C",
        "iinfin;": "\u29DC",
        "incare;": "\u2105",
        "inodot;": "\u0131",
        "intcal;": "\u22BA",
        "iquest;": "\xBF",
        "isinsv;": "\u22F3",
        "Itilde;": "\u0128",
        "itilde;": "\u0129",
        "Jsercy;": "\u0408",
        "jsercy;": "\u0458",
        "kappav;": "\u03F0",
        "Kcedil;": "\u0136",
        "kcedil;": "\u0137",
        "kgreen;": "\u0138",
        "Lacute;": "\u0139",
        "lacute;": "\u013A",
        "lagran;": "\u2112",
        "Lambda;": "\u039B",
        "lambda;": "\u03BB",
        "langle;": "\u27E8",
        "larrfs;": "\u291D",
        "larrhk;": "\u21A9",
        "larrlp;": "\u21AB",
        "larrpl;": "\u2939",
        "larrtl;": "\u21A2",
        "lAtail;": "\u291B",
        "latail;": "\u2919",
        "lbrace;": "{",
        "lbrack;": "[",
        "Lcaron;": "\u013D",
        "lcaron;": "\u013E",
        "Lcedil;": "\u013B",
        "lcedil;": "\u013C",
        "ldquor;": "\u201E",
        "lesdot;": "\u2A7F",
        "lesges;": "\u2A93",
        "lfisht;": "\u297C",
        "lfloor;": "\u230A",
        "lharul;": "\u296A",
        "llhard;": "\u296B",
        "Lmidot;": "\u013F",
        "lmidot;": "\u0140",
        "lmoust;": "\u23B0",
        "loplus;": "\u2A2D",
        "lowast;": "\u2217",
        "lowbar;": "_",
        "lparlt;": "\u2993",
        "lrhard;": "\u296D",
        "lsaquo;": "\u2039",
        "lsquor;": "\u201A",
        "Lstrok;": "\u0141",
        "lstrok;": "\u0142",
        "lthree;": "\u22CB",
        "ltimes;": "\u22C9",
        "ltlarr;": "\u2976",
        "ltrPar;": "\u2996",
        "mapsto;": "\u21A6",
        "marker;": "\u25AE",
        "mcomma;": "\u2A29",
        "midast;": "*",
        "midcir;": "\u2AF0",
        "middot;": "\xB7",
        "minusb;": "\u229F",
        "minusd;": "\u2238",
        "mnplus;": "\u2213",
        "models;": "\u22A7",
        "mstpos;": "\u223E",
        "Nacute;": "\u0143",
        "nacute;": "\u0144",
        "nbumpe;": "\u224F\u0338",
        "Ncaron;": "\u0147",
        "ncaron;": "\u0148",
        "Ncedil;": "\u0145",
        "ncedil;": "\u0146",
        "nearhk;": "\u2924",
        "nequiv;": "\u2262",
        "nesear;": "\u2928",
        "nexist;": "\u2204",
        "nltrie;": "\u22EC",
        "notinE;": "\u22F9\u0338",
        "nparsl;": "\u2AFD\u20E5",
        "nprcue;": "\u22E0",
        "nrarrc;": "\u2933\u0338",
        "nrarrw;": "\u219D\u0338",
        "nrtrie;": "\u22ED",
        "nsccue;": "\u22E1",
        "nsimeq;": "\u2244",
        "Ntilde;": "\xD1",
        "ntilde;": "\xF1",
        "numero;": "\u2116",
        "nVDash;": "\u22AF",
        "nVdash;": "\u22AE",
        "nvDash;": "\u22AD",
        "nvdash;": "\u22AC",
        "nvHarr;": "\u2904",
        "nvlArr;": "\u2902",
        "nvrArr;": "\u2903",
        "nwarhk;": "\u2923",
        "nwnear;": "\u2927",
        "Oacute;": "\xD3",
        "oacute;": "\xF3",
        "Odblac;": "\u0150",
        "odblac;": "\u0151",
        "odsold;": "\u29BC",
        "Ograve;": "\xD2",
        "ograve;": "\xF2",
        "ominus;": "\u2296",
        "origof;": "\u22B6",
        "Oslash;": "\xD8",
        "oslash;": "\xF8",
        "Otilde;": "\xD5",
        "otilde;": "\xF5",
        "Otimes;": "\u2A37",
        "otimes;": "\u2297",
        "parsim;": "\u2AF3",
        "percnt;": "%",
        "period;": ".",
        "permil;": "\u2030",
        "phmmat;": "\u2133",
        "planck;": "\u210F",
        "plankv;": "\u210F",
        "plusdo;": "\u2214",
        "plusdu;": "\u2A25",
        "plusmn;": "\xB1",
        "preceq;": "\u2AAF",
        "primes;": "\u2119",
        "prnsim;": "\u22E8",
        "propto;": "\u221D",
        "prurel;": "\u22B0",
        "puncsp;": "\u2008",
        "qprime;": "\u2057",
        "Racute;": "\u0154",
        "racute;": "\u0155",
        "rangle;": "\u27E9",
        "rarrap;": "\u2975",
        "rarrfs;": "\u291E",
        "rarrhk;": "\u21AA",
        "rarrlp;": "\u21AC",
        "rarrpl;": "\u2945",
        "Rarrtl;": "\u2916",
        "rarrtl;": "\u21A3",
        "rAtail;": "\u291C",
        "ratail;": "\u291A",
        "rbrace;": "}",
        "rbrack;": "]",
        "Rcaron;": "\u0158",
        "rcaron;": "\u0159",
        "Rcedil;": "\u0156",
        "rcedil;": "\u0157",
        "rdquor;": "\u201D",
        "rfisht;": "\u297D",
        "rfloor;": "\u230B",
        "rharul;": "\u296C",
        "rmoust;": "\u23B1",
        "roplus;": "\u2A2E",
        "rpargt;": "\u2994",
        "rsaquo;": "\u203A",
        "rsquor;": "\u2019",
        "rthree;": "\u22CC",
        "rtimes;": "\u22CA",
        "Sacute;": "\u015A",
        "sacute;": "\u015B",
        "Scaron;": "\u0160",
        "scaron;": "\u0161",
        "Scedil;": "\u015E",
        "scedil;": "\u015F",
        "scnsim;": "\u22E9",
        "searhk;": "\u2925",
        "seswar;": "\u2929",
        "sfrown;": "\u2322",
        "SHCHcy;": "\u0429",
        "shchcy;": "\u0449",
        "sigmaf;": "\u03C2",
        "sigmav;": "\u03C2",
        "simdot;": "\u2A6A",
        "smashp;": "\u2A33",
        "SOFTcy;": "\u042C",
        "softcy;": "\u044C",
        "solbar;": "\u233F",
        "spades;": "\u2660",
        "sqcaps;": "\u2293\uFE00",
        "sqcups;": "\u2294\uFE00",
        "sqsube;": "\u2291",
        "sqsupe;": "\u2292",
        "Square;": "\u25A1",
        "square;": "\u25A1",
        "squarf;": "\u25AA",
        "ssetmn;": "\u2216",
        "ssmile;": "\u2323",
        "sstarf;": "\u22C6",
        "subdot;": "\u2ABD",
        "Subset;": "\u22D0",
        "subset;": "\u2282",
        "subsim;": "\u2AC7",
        "subsub;": "\u2AD5",
        "subsup;": "\u2AD3",
        "succeq;": "\u2AB0",
        "supdot;": "\u2ABE",
        "Supset;": "\u22D1",
        "supset;": "\u2283",
        "supsim;": "\u2AC8",
        "supsub;": "\u2AD4",
        "supsup;": "\u2AD6",
        "swarhk;": "\u2926",
        "swnwar;": "\u292A",
        "target;": "\u2316",
        "Tcaron;": "\u0164",
        "tcaron;": "\u0165",
        "Tcedil;": "\u0162",
        "tcedil;": "\u0163",
        "telrec;": "\u2315",
        "there4;": "\u2234",
        "thetav;": "\u03D1",
        "thinsp;": "\u2009",
        "thksim;": "\u223C",
        "timesb;": "\u22A0",
        "timesd;": "\u2A30",
        "topbot;": "\u2336",
        "topcir;": "\u2AF1",
        "tprime;": "\u2034",
        "tridot;": "\u25EC",
        "Tstrok;": "\u0166",
        "tstrok;": "\u0167",
        "Uacute;": "\xDA",
        "uacute;": "\xFA",
        "Ubreve;": "\u016C",
        "ubreve;": "\u016D",
        "Udblac;": "\u0170",
        "udblac;": "\u0171",
        "ufisht;": "\u297E",
        "Ugrave;": "\xD9",
        "ugrave;": "\xF9",
        "ulcorn;": "\u231C",
        "ulcrop;": "\u230F",
        "urcorn;": "\u231D",
        "urcrop;": "\u230E",
        "Utilde;": "\u0168",
        "utilde;": "\u0169",
        "vangrt;": "\u299C",
        "varphi;": "\u03D5",
        "varrho;": "\u03F1",
        "Vdashl;": "\u2AE6",
        "veebar;": "\u22BB",
        "vellip;": "\u22EE",
        "Verbar;": "\u2016",
        "verbar;": "|",
        "vsubnE;": "\u2ACB\uFE00",
        "vsubne;": "\u228A\uFE00",
        "vsupnE;": "\u2ACC\uFE00",
        "vsupne;": "\u228B\uFE00",
        "Vvdash;": "\u22AA",
        "wedbar;": "\u2A5F",
        "wedgeq;": "\u2259",
        "weierp;": "\u2118",
        "wreath;": "\u2240",
        "xoplus;": "\u2A01",
        "xotime;": "\u2A02",
        "xsqcup;": "\u2A06",
        "xuplus;": "\u2A04",
        "xwedge;": "\u22C0",
        "Yacute;": "\xDD",
        "yacute;": "\xFD",
        "Zacute;": "\u0179",
        "zacute;": "\u017A",
        "Zcaron;": "\u017D",
        "zcaron;": "\u017E",
        "zeetrf;": "\u2128",
        "alefsym;": "\u2135",
        "angrtvb;": "\u22BE",
        "angzarr;": "\u237C",
        "asympeq;": "\u224D",
        "backsim;": "\u223D",
        "Because;": "\u2235",
        "because;": "\u2235",
        "bemptyv;": "\u29B0",
        "between;": "\u226C",
        "bigcirc;": "\u25EF",
        "bigodot;": "\u2A00",
        "bigstar;": "\u2605",
        "bnequiv;": "\u2261\u20E5",
        "boxplus;": "\u229E",
        "Cayleys;": "\u212D",
        "Cconint;": "\u2230",
        "ccupssm;": "\u2A50",
        "Cedilla;": "\xB8",
        "cemptyv;": "\u29B2",
        "cirscir;": "\u29C2",
        "coloneq;": "\u2254",
        "congdot;": "\u2A6D",
        "cudarrl;": "\u2938",
        "cudarrr;": "\u2935",
        "cularrp;": "\u293D",
        "curarrm;": "\u293C",
        "dbkarow;": "\u290F",
        "ddagger;": "\u2021",
        "ddotseq;": "\u2A77",
        "demptyv;": "\u29B1",
        "Diamond;": "\u22C4",
        "diamond;": "\u22C4",
        "digamma;": "\u03DD",
        "dotplus;": "\u2214",
        "DownTee;": "\u22A4",
        "dwangle;": "\u29A6",
        "Element;": "\u2208",
        "Epsilon;": "\u0395",
        "epsilon;": "\u03B5",
        "eqcolon;": "\u2255",
        "equivDD;": "\u2A78",
        "gesdoto;": "\u2A82",
        "gtquest;": "\u2A7C",
        "gtrless;": "\u2277",
        "harrcir;": "\u2948",
        "Implies;": "\u21D2",
        "intprod;": "\u2A3C",
        "isindot;": "\u22F5",
        "larrbfs;": "\u291F",
        "larrsim;": "\u2973",
        "lbrksld;": "\u298F",
        "lbrkslu;": "\u298D",
        "ldrdhar;": "\u2967",
        "LeftTee;": "\u22A3",
        "lesdoto;": "\u2A81",
        "lessdot;": "\u22D6",
        "lessgtr;": "\u2276",
        "lesssim;": "\u2272",
        "lotimes;": "\u2A34",
        "lozenge;": "\u25CA",
        "ltquest;": "\u2A7B",
        "luruhar;": "\u2966",
        "maltese;": "\u2720",
        "minusdu;": "\u2A2A",
        "napprox;": "\u2249",
        "natural;": "\u266E",
        "nearrow;": "\u2197",
        "NewLine;": "\n",
        "nexists;": "\u2204",
        "NoBreak;": "\u2060",
        "notinva;": "\u2209",
        "notinvb;": "\u22F7",
        "notinvc;": "\u22F6",
        "NotLess;": "\u226E",
        "notniva;": "\u220C",
        "notnivb;": "\u22FE",
        "notnivc;": "\u22FD",
        "npolint;": "\u2A14",
        "npreceq;": "\u2AAF\u0338",
        "nsqsube;": "\u22E2",
        "nsqsupe;": "\u22E3",
        "nsubset;": "\u2282\u20D2",
        "nsucceq;": "\u2AB0\u0338",
        "nsupset;": "\u2283\u20D2",
        "nvinfin;": "\u29DE",
        "nvltrie;": "\u22B4\u20D2",
        "nvrtrie;": "\u22B5\u20D2",
        "nwarrow;": "\u2196",
        "olcross;": "\u29BB",
        "Omicron;": "\u039F",
        "omicron;": "\u03BF",
        "orderof;": "\u2134",
        "orslope;": "\u2A57",
        "OverBar;": "\u203E",
        "pertenk;": "\u2031",
        "planckh;": "\u210E",
        "pluscir;": "\u2A22",
        "plussim;": "\u2A26",
        "plustwo;": "\u2A27",
        "precsim;": "\u227E",
        "Product;": "\u220F",
        "quatint;": "\u2A16",
        "questeq;": "\u225F",
        "rarrbfs;": "\u2920",
        "rarrsim;": "\u2974",
        "rbrksld;": "\u298E",
        "rbrkslu;": "\u2990",
        "rdldhar;": "\u2969",
        "realine;": "\u211B",
        "rotimes;": "\u2A35",
        "ruluhar;": "\u2968",
        "searrow;": "\u2198",
        "simplus;": "\u2A24",
        "simrarr;": "\u2972",
        "subedot;": "\u2AC3",
        "submult;": "\u2AC1",
        "subplus;": "\u2ABF",
        "subrarr;": "\u2979",
        "succsim;": "\u227F",
        "supdsub;": "\u2AD8",
        "supedot;": "\u2AC4",
        "suphsol;": "\u27C9",
        "suphsub;": "\u2AD7",
        "suplarr;": "\u297B",
        "supmult;": "\u2AC2",
        "supplus;": "\u2AC0",
        "swarrow;": "\u2199",
        "topfork;": "\u2ADA",
        "triplus;": "\u2A39",
        "tritime;": "\u2A3B",
        "UpArrow;": "\u2191",
        "Uparrow;": "\u21D1",
        "uparrow;": "\u2191",
        "Upsilon;": "\u03A5",
        "upsilon;": "\u03C5",
        "uwangle;": "\u29A7",
        "vzigzag;": "\u299A",
        "zigrarr;": "\u21DD",
        "andslope;": "\u2A58",
        "angmsdaa;": "\u29A8",
        "angmsdab;": "\u29A9",
        "angmsdac;": "\u29AA",
        "angmsdad;": "\u29AB",
        "angmsdae;": "\u29AC",
        "angmsdaf;": "\u29AD",
        "angmsdag;": "\u29AE",
        "angmsdah;": "\u29AF",
        "angrtvbd;": "\u299D",
        "approxeq;": "\u224A",
        "awconint;": "\u2233",
        "backcong;": "\u224C",
        "barwedge;": "\u2305",
        "bbrktbrk;": "\u23B6",
        "bigoplus;": "\u2A01",
        "bigsqcup;": "\u2A06",
        "biguplus;": "\u2A04",
        "bigwedge;": "\u22C0",
        "boxminus;": "\u229F",
        "boxtimes;": "\u22A0",
        "bsolhsub;": "\u27C8",
        "capbrcup;": "\u2A49",
        "circledR;": "\xAE",
        "circledS;": "\u24C8",
        "cirfnint;": "\u2A10",
        "clubsuit;": "\u2663",
        "cupbrcap;": "\u2A48",
        "curlyvee;": "\u22CE",
        "cwconint;": "\u2232",
        "DDotrahd;": "\u2911",
        "doteqdot;": "\u2251",
        "DotEqual;": "\u2250",
        "dotminus;": "\u2238",
        "drbkarow;": "\u2910",
        "dzigrarr;": "\u27FF",
        "elinters;": "\u23E7",
        "emptyset;": "\u2205",
        "eqvparsl;": "\u29E5",
        "fpartint;": "\u2A0D",
        "geqslant;": "\u2A7E",
        "gesdotol;": "\u2A84",
        "gnapprox;": "\u2A8A",
        "hksearow;": "\u2925",
        "hkswarow;": "\u2926",
        "imagline;": "\u2110",
        "imagpart;": "\u2111",
        "infintie;": "\u29DD",
        "integers;": "\u2124",
        "Integral;": "\u222B",
        "intercal;": "\u22BA",
        "intlarhk;": "\u2A17",
        "laemptyv;": "\u29B4",
        "ldrushar;": "\u294B",
        "leqslant;": "\u2A7D",
        "lesdotor;": "\u2A83",
        "LessLess;": "\u2AA1",
        "llcorner;": "\u231E",
        "lnapprox;": "\u2A89",
        "lrcorner;": "\u231F",
        "lurdshar;": "\u294A",
        "mapstoup;": "\u21A5",
        "multimap;": "\u22B8",
        "naturals;": "\u2115",
        "ncongdot;": "\u2A6D\u0338",
        "NotEqual;": "\u2260",
        "notindot;": "\u22F5\u0338",
        "NotTilde;": "\u2241",
        "otimesas;": "\u2A36",
        "parallel;": "\u2225",
        "PartialD;": "\u2202",
        "plusacir;": "\u2A23",
        "pointint;": "\u2A15",
        "Precedes;": "\u227A",
        "precneqq;": "\u2AB5",
        "precnsim;": "\u22E8",
        "profalar;": "\u232E",
        "profline;": "\u2312",
        "profsurf;": "\u2313",
        "raemptyv;": "\u29B3",
        "realpart;": "\u211C",
        "RightTee;": "\u22A2",
        "rppolint;": "\u2A12",
        "rtriltri;": "\u29CE",
        "scpolint;": "\u2A13",
        "setminus;": "\u2216",
        "shortmid;": "\u2223",
        "smeparsl;": "\u29E4",
        "sqsubset;": "\u228F",
        "sqsupset;": "\u2290",
        "subseteq;": "\u2286",
        "Succeeds;": "\u227B",
        "succneqq;": "\u2AB6",
        "succnsim;": "\u22E9",
        "SuchThat;": "\u220B",
        "Superset;": "\u2283",
        "supseteq;": "\u2287",
        "thetasym;": "\u03D1",
        "thicksim;": "\u223C",
        "timesbar;": "\u2A31",
        "triangle;": "\u25B5",
        "triminus;": "\u2A3A",
        "trpezium;": "\u23E2",
        "Uarrocir;": "\u2949",
        "ulcorner;": "\u231C",
        "UnderBar;": "_",
        "urcorner;": "\u231D",
        "varkappa;": "\u03F0",
        "varsigma;": "\u03C2",
        "vartheta;": "\u03D1",
        "backprime;": "\u2035",
        "backsimeq;": "\u22CD",
        "Backslash;": "\u2216",
        "bigotimes;": "\u2A02",
        "CenterDot;": "\xB7",
        "centerdot;": "\xB7",
        "checkmark;": "\u2713",
        "CircleDot;": "\u2299",
        "complexes;": "\u2102",
        "Congruent;": "\u2261",
        "Coproduct;": "\u2210",
        "dotsquare;": "\u22A1",
        "DoubleDot;": "\xA8",
        "DownArrow;": "\u2193",
        "Downarrow;": "\u21D3",
        "downarrow;": "\u2193",
        "DownBreve;": "\u0311",
        "gtrapprox;": "\u2A86",
        "gtreqless;": "\u22DB",
        "gvertneqq;": "\u2269\uFE00",
        "heartsuit;": "\u2665",
        "HumpEqual;": "\u224F",
        "LeftArrow;": "\u2190",
        "Leftarrow;": "\u21D0",
        "leftarrow;": "\u2190",
        "LeftFloor;": "\u230A",
        "lesseqgtr;": "\u22DA",
        "LessTilde;": "\u2272",
        "lvertneqq;": "\u2268\uFE00",
        "Mellintrf;": "\u2133",
        "MinusPlus;": "\u2213",
        "ngeqslant;": "\u2A7E\u0338",
        "nleqslant;": "\u2A7D\u0338",
        "NotCupCap;": "\u226D",
        "NotExists;": "\u2204",
        "NotSubset;": "\u2282\u20D2",
        "nparallel;": "\u2226",
        "nshortmid;": "\u2224",
        "nsubseteq;": "\u2288",
        "nsupseteq;": "\u2289",
        "OverBrace;": "\u23DE",
        "pitchfork;": "\u22D4",
        "PlusMinus;": "\xB1",
        "rationals;": "\u211A",
        "spadesuit;": "\u2660",
        "subseteqq;": "\u2AC5",
        "subsetneq;": "\u228A",
        "supseteqq;": "\u2AC6",
        "supsetneq;": "\u228B",
        "Therefore;": "\u2234",
        "therefore;": "\u2234",
        "ThinSpace;": "\u2009",
        "triangleq;": "\u225C",
        "TripleDot;": "\u20DB",
        "UnionPlus;": "\u228E",
        "varpropto;": "\u221D",
        "Bernoullis;": "\u212C",
        "circledast;": "\u229B",
        "CirclePlus;": "\u2295",
        "complement;": "\u2201",
        "curlywedge;": "\u22CF",
        "eqslantgtr;": "\u2A96",
        "EqualTilde;": "\u2242",
        "Fouriertrf;": "\u2131",
        "gtreqqless;": "\u2A8C",
        "ImaginaryI;": "\u2148",
        "Laplacetrf;": "\u2112",
        "LeftVector;": "\u21BC",
        "lessapprox;": "\u2A85",
        "lesseqqgtr;": "\u2A8B",
        "Lleftarrow;": "\u21DA",
        "lmoustache;": "\u23B0",
        "longmapsto;": "\u27FC",
        "mapstodown;": "\u21A7",
        "mapstoleft;": "\u21A4",
        "nLeftarrow;": "\u21CD",
        "nleftarrow;": "\u219A",
        "NotElement;": "\u2209",
        "NotGreater;": "\u226F",
        "nsubseteqq;": "\u2AC5\u0338",
        "nsupseteqq;": "\u2AC6\u0338",
        "precapprox;": "\u2AB7",
        "Proportion;": "\u2237",
        "RightArrow;": "\u2192",
        "Rightarrow;": "\u21D2",
        "rightarrow;": "\u2192",
        "RightFloor;": "\u230B",
        "rmoustache;": "\u23B1",
        "sqsubseteq;": "\u2291",
        "sqsupseteq;": "\u2292",
        "subsetneqq;": "\u2ACB",
        "succapprox;": "\u2AB8",
        "supsetneqq;": "\u2ACC",
        "ThickSpace;": "\u205F\u200A",
        "TildeEqual;": "\u2243",
        "TildeTilde;": "\u2248",
        "UnderBrace;": "\u23DF",
        "UpArrowBar;": "\u2912",
        "UpTeeArrow;": "\u21A5",
        "upuparrows;": "\u21C8",
        "varepsilon;": "\u03F5",
        "varnothing;": "\u2205",
        "backepsilon;": "\u03F6",
        "blacksquare;": "\u25AA",
        "circledcirc;": "\u229A",
        "circleddash;": "\u229D",
        "CircleMinus;": "\u2296",
        "CircleTimes;": "\u2297",
        "curlyeqprec;": "\u22DE",
        "curlyeqsucc;": "\u22DF",
        "diamondsuit;": "\u2666",
        "eqslantless;": "\u2A95",
        "Equilibrium;": "\u21CC",
        "expectation;": "\u2130",
        "GreaterLess;": "\u2277",
        "LeftCeiling;": "\u2308",
        "LessGreater;": "\u2276",
        "MediumSpace;": "\u205F",
        "NotLessLess;": "\u226A\u0338",
        "NotPrecedes;": "\u2280",
        "NotSucceeds;": "\u2281",
        "NotSuperset;": "\u2283\u20D2",
        "nRightarrow;": "\u21CF",
        "nrightarrow;": "\u219B",
        "OverBracket;": "\u23B4",
        "preccurlyeq;": "\u227C",
        "precnapprox;": "\u2AB9",
        "quaternions;": "\u210D",
        "RightVector;": "\u21C0",
        "Rrightarrow;": "\u21DB",
        "RuleDelayed;": "\u29F4",
        "SmallCircle;": "\u2218",
        "SquareUnion;": "\u2294",
        "straightphi;": "\u03D5",
        "SubsetEqual;": "\u2286",
        "succcurlyeq;": "\u227D",
        "succnapprox;": "\u2ABA",
        "thickapprox;": "\u2248",
        "UpDownArrow;": "\u2195",
        "Updownarrow;": "\u21D5",
        "updownarrow;": "\u2195",
        "VerticalBar;": "\u2223",
        "blacklozenge;": "\u29EB",
        "DownArrowBar;": "\u2913",
        "DownTeeArrow;": "\u21A7",
        "ExponentialE;": "\u2147",
        "exponentiale;": "\u2147",
        "GreaterEqual;": "\u2265",
        "GreaterTilde;": "\u2273",
        "HilbertSpace;": "\u210B",
        "HumpDownHump;": "\u224E",
        "Intersection;": "\u22C2",
        "LeftArrowBar;": "\u21E4",
        "LeftTeeArrow;": "\u21A4",
        "LeftTriangle;": "\u22B2",
        "LeftUpVector;": "\u21BF",
        "NotCongruent;": "\u2262",
        "NotHumpEqual;": "\u224F\u0338",
        "NotLessEqual;": "\u2270",
        "NotLessTilde;": "\u2274",
        "Proportional;": "\u221D",
        "RightCeiling;": "\u2309",
        "risingdotseq;": "\u2253",
        "RoundImplies;": "\u2970",
        "ShortUpArrow;": "\u2191",
        "SquareSubset;": "\u228F",
        "triangledown;": "\u25BF",
        "triangleleft;": "\u25C3",
        "UnderBracket;": "\u23B5",
        "varsubsetneq;": "\u228A\uFE00",
        "varsupsetneq;": "\u228B\uFE00",
        "VerticalLine;": "|",
        "ApplyFunction;": "\u2061",
        "bigtriangleup;": "\u25B3",
        "blacktriangle;": "\u25B4",
        "DifferentialD;": "\u2146",
        "divideontimes;": "\u22C7",
        "DoubleLeftTee;": "\u2AE4",
        "DoubleUpArrow;": "\u21D1",
        "fallingdotseq;": "\u2252",
        "hookleftarrow;": "\u21A9",
        "leftarrowtail;": "\u21A2",
        "leftharpoonup;": "\u21BC",
        "LeftTeeVector;": "\u295A",
        "LeftVectorBar;": "\u2952",
        "LessFullEqual;": "\u2266",
        "LongLeftArrow;": "\u27F5",
        "Longleftarrow;": "\u27F8",
        "longleftarrow;": "\u27F5",
        "looparrowleft;": "\u21AB",
        "measuredangle;": "\u2221",
        "NotEqualTilde;": "\u2242\u0338",
        "NotTildeEqual;": "\u2244",
        "NotTildeTilde;": "\u2249",
        "ntriangleleft;": "\u22EA",
        "Poincareplane;": "\u210C",
        "PrecedesEqual;": "\u2AAF",
        "PrecedesTilde;": "\u227E",
        "RightArrowBar;": "\u21E5",
        "RightTeeArrow;": "\u21A6",
        "RightTriangle;": "\u22B3",
        "RightUpVector;": "\u21BE",
        "shortparallel;": "\u2225",
        "smallsetminus;": "\u2216",
        "SucceedsEqual;": "\u2AB0",
        "SucceedsTilde;": "\u227F",
        "SupersetEqual;": "\u2287",
        "triangleright;": "\u25B9",
        "UpEquilibrium;": "\u296E",
        "upharpoonleft;": "\u21BF",
        "varsubsetneqq;": "\u2ACB\uFE00",
        "varsupsetneqq;": "\u2ACC\uFE00",
        "VerticalTilde;": "\u2240",
        "VeryThinSpace;": "\u200A",
        "curvearrowleft;": "\u21B6",
        "DiacriticalDot;": "\u02D9",
        "doublebarwedge;": "\u2306",
        "DoubleRightTee;": "\u22A8",
        "downdownarrows;": "\u21CA",
        "DownLeftVector;": "\u21BD",
        "GreaterGreater;": "\u2AA2",
        "hookrightarrow;": "\u21AA",
        "HorizontalLine;": "\u2500",
        "InvisibleComma;": "\u2063",
        "InvisibleTimes;": "\u2062",
        "LeftDownVector;": "\u21C3",
        "leftleftarrows;": "\u21C7",
        "LeftRightArrow;": "\u2194",
        "Leftrightarrow;": "\u21D4",
        "leftrightarrow;": "\u2194",
        "leftthreetimes;": "\u22CB",
        "LessSlantEqual;": "\u2A7D",
        "LongRightArrow;": "\u27F6",
        "Longrightarrow;": "\u27F9",
        "longrightarrow;": "\u27F6",
        "looparrowright;": "\u21AC",
        "LowerLeftArrow;": "\u2199",
        "NestedLessLess;": "\u226A",
        "NotGreaterLess;": "\u2279",
        "NotLessGreater;": "\u2278",
        "NotSubsetEqual;": "\u2288",
        "NotVerticalBar;": "\u2224",
        "nshortparallel;": "\u2226",
        "ntriangleright;": "\u22EB",
        "OpenCurlyQuote;": "\u2018",
        "ReverseElement;": "\u220B",
        "rightarrowtail;": "\u21A3",
        "rightharpoonup;": "\u21C0",
        "RightTeeVector;": "\u295B",
        "RightVectorBar;": "\u2953",
        "ShortDownArrow;": "\u2193",
        "ShortLeftArrow;": "\u2190",
        "SquareSuperset;": "\u2290",
        "TildeFullEqual;": "\u2245",
        "trianglelefteq;": "\u22B4",
        "upharpoonright;": "\u21BE",
        "UpperLeftArrow;": "\u2196",
        "ZeroWidthSpace;": "\u200B",
        "bigtriangledown;": "\u25BD",
        "circlearrowleft;": "\u21BA",
        "CloseCurlyQuote;": "\u2019",
        "ContourIntegral;": "\u222E",
        "curvearrowright;": "\u21B7",
        "DoubleDownArrow;": "\u21D3",
        "DoubleLeftArrow;": "\u21D0",
        "downharpoonleft;": "\u21C3",
        "DownRightVector;": "\u21C1",
        "leftharpoondown;": "\u21BD",
        "leftrightarrows;": "\u21C6",
        "LeftRightVector;": "\u294E",
        "LeftTriangleBar;": "\u29CF",
        "LeftUpTeeVector;": "\u2960",
        "LeftUpVectorBar;": "\u2958",
        "LowerRightArrow;": "\u2198",
        "nLeftrightarrow;": "\u21CE",
        "nleftrightarrow;": "\u21AE",
        "NotGreaterEqual;": "\u2271",
        "NotGreaterTilde;": "\u2275",
        "NotHumpDownHump;": "\u224E\u0338",
        "NotLeftTriangle;": "\u22EA",
        "NotSquareSubset;": "\u228F\u0338",
        "ntrianglelefteq;": "\u22EC",
        "OverParenthesis;": "\u23DC",
        "RightDownVector;": "\u21C2",
        "rightleftarrows;": "\u21C4",
        "rightsquigarrow;": "\u219D",
        "rightthreetimes;": "\u22CC",
        "ShortRightArrow;": "\u2192",
        "straightepsilon;": "\u03F5",
        "trianglerighteq;": "\u22B5",
        "UpperRightArrow;": "\u2197",
        "vartriangleleft;": "\u22B2",
        "circlearrowright;": "\u21BB",
        "DiacriticalAcute;": "\xB4",
        "DiacriticalGrave;": "`",
        "DiacriticalTilde;": "\u02DC",
        "DoubleRightArrow;": "\u21D2",
        "DownArrowUpArrow;": "\u21F5",
        "downharpoonright;": "\u21C2",
        "EmptySmallSquare;": "\u25FB",
        "GreaterEqualLess;": "\u22DB",
        "GreaterFullEqual;": "\u2267",
        "LeftAngleBracket;": "\u27E8",
        "LeftUpDownVector;": "\u2951",
        "LessEqualGreater;": "\u22DA",
        "NonBreakingSpace;": "\xA0",
        "NotPrecedesEqual;": "\u2AAF\u0338",
        "NotRightTriangle;": "\u22EB",
        "NotSucceedsEqual;": "\u2AB0\u0338",
        "NotSucceedsTilde;": "\u227F\u0338",
        "NotSupersetEqual;": "\u2289",
        "ntrianglerighteq;": "\u22ED",
        "rightharpoondown;": "\u21C1",
        "rightrightarrows;": "\u21C9",
        "RightTriangleBar;": "\u29D0",
        "RightUpTeeVector;": "\u295C",
        "RightUpVectorBar;": "\u2954",
        "twoheadleftarrow;": "\u219E",
        "UnderParenthesis;": "\u23DD",
        "UpArrowDownArrow;": "\u21C5",
        "vartriangleright;": "\u22B3",
        "blacktriangledown;": "\u25BE",
        "blacktriangleleft;": "\u25C2",
        "DoubleUpDownArrow;": "\u21D5",
        "DoubleVerticalBar;": "\u2225",
        "DownLeftTeeVector;": "\u295E",
        "DownLeftVectorBar;": "\u2956",
        "FilledSmallSquare;": "\u25FC",
        "GreaterSlantEqual;": "\u2A7E",
        "LeftDoubleBracket;": "\u27E6",
        "LeftDownTeeVector;": "\u2961",
        "LeftDownVectorBar;": "\u2959",
        "leftrightharpoons;": "\u21CB",
        "LeftTriangleEqual;": "\u22B4",
        "NegativeThinSpace;": "\u200B",
        "NotGreaterGreater;": "\u226B\u0338",
        "NotLessSlantEqual;": "\u2A7D\u0338",
        "NotNestedLessLess;": "\u2AA1\u0338",
        "NotReverseElement;": "\u220C",
        "NotSquareSuperset;": "\u2290\u0338",
        "NotTildeFullEqual;": "\u2247",
        "RightAngleBracket;": "\u27E9",
        "rightleftharpoons;": "\u21CC",
        "RightUpDownVector;": "\u294F",
        "SquareSubsetEqual;": "\u2291",
        "twoheadrightarrow;": "\u21A0",
        "VerticalSeparator;": "\u2758",
        "blacktriangleright;": "\u25B8",
        "DownRightTeeVector;": "\u295F",
        "DownRightVectorBar;": "\u2957",
        "LongLeftRightArrow;": "\u27F7",
        "Longleftrightarrow;": "\u27FA",
        "longleftrightarrow;": "\u27F7",
        "NegativeThickSpace;": "\u200B",
        "NotLeftTriangleBar;": "\u29CF\u0338",
        "PrecedesSlantEqual;": "\u227C",
        "ReverseEquilibrium;": "\u21CB",
        "RightDoubleBracket;": "\u27E7",
        "RightDownTeeVector;": "\u295D",
        "RightDownVectorBar;": "\u2955",
        "RightTriangleEqual;": "\u22B5",
        "SquareIntersection;": "\u2293",
        "SucceedsSlantEqual;": "\u227D",
        "DoubleLongLeftArrow;": "\u27F8",
        "DownLeftRightVector;": "\u2950",
        "LeftArrowRightArrow;": "\u21C6",
        "leftrightsquigarrow;": "\u21AD",
        "NegativeMediumSpace;": "\u200B",
        "NotGreaterFullEqual;": "\u2267\u0338",
        "NotRightTriangleBar;": "\u29D0\u0338",
        "RightArrowLeftArrow;": "\u21C4",
        "SquareSupersetEqual;": "\u2292",
        "CapitalDifferentialD;": "\u2145",
        "DoubleLeftRightArrow;": "\u21D4",
        "DoubleLongRightArrow;": "\u27F9",
        "EmptyVerySmallSquare;": "\u25AB",
        "NestedGreaterGreater;": "\u226B",
        "NotDoubleVerticalBar;": "\u2226",
        "NotGreaterSlantEqual;": "\u2A7E\u0338",
        "NotLeftTriangleEqual;": "\u22EC",
        "NotSquareSubsetEqual;": "\u22E2",
        "OpenCurlyDoubleQuote;": "\u201C",
        "ReverseUpEquilibrium;": "\u296F",
        "CloseCurlyDoubleQuote;": "\u201D",
        "DoubleContourIntegral;": "\u222F",
        "FilledVerySmallSquare;": "\u25AA",
        "NegativeVeryThinSpace;": "\u200B",
        "NotPrecedesSlantEqual;": "\u22E0",
        "NotRightTriangleEqual;": "\u22ED",
        "NotSucceedsSlantEqual;": "\u22E1",
        "DiacriticalDoubleAcute;": "\u02DD",
        "NotSquareSupersetEqual;": "\u22E3",
        "NotNestedGreaterGreater;": "\u2AA2\u0338",
        "ClockwiseContourIntegral;": "\u2232",
        "DoubleLongLeftRightArrow;": "\u27FA",
        "CounterClockwiseContourIntegral;": "\u2233"
      };
      let maxCRNameLength;
      const decodeHtml = (rawText, asAttr) => {
        let offset2 = 0;
        const end = rawText.length;
        let decodedText = "";
        function advance(length) {
          offset2 += length;
          rawText = rawText.slice(length);
        }
        while (offset2 < end) {
          const head = /&(?:#x?)?/i.exec(rawText);
          if (!head || offset2 + head.index >= end) {
            const remaining = end - offset2;
            decodedText += rawText.slice(0, remaining);
            advance(remaining);
            break;
          }
          decodedText += rawText.slice(0, head.index);
          advance(head.index);
          if (head[0] === "&") {
            let name = "";
            let value = void 0;
            if (/[0-9a-z]/i.test(rawText[1])) {
              if (!maxCRNameLength) {
                maxCRNameLength = Object.keys(namedCharacterReferences).reduce((max, name2) => Math.max(max, name2.length), 0);
              }
              for (let length = maxCRNameLength; !value && length > 0; --length) {
                name = rawText.slice(1, 1 + length);
                value = namedCharacterReferences[name];
              }
              if (value) {
                const semi = name.endsWith(";");
                if (asAttr && !semi && /[=a-z0-9]/i.test(rawText[name.length + 1] || "")) {
                  decodedText += "&" + name;
                  advance(1 + name.length);
                } else {
                  decodedText += value;
                  advance(1 + name.length);
                }
              } else {
                decodedText += "&" + name;
                advance(1 + name.length);
              }
            } else {
              decodedText += "&";
              advance(1);
            }
          } else {
            const hex = head[0] === "&#x";
            const pattern2 = hex ? /^&#x([0-9a-f]+);?/i : /^&#([0-9]+);?/;
            const body = pattern2.exec(rawText);
            if (!body) {
              decodedText += head[0];
              advance(head[0].length);
            } else {
              let cp2 = Number.parseInt(body[1], hex ? 16 : 10);
              if (cp2 === 0) {
                cp2 = 65533;
              } else if (cp2 > 1114111) {
                cp2 = 65533;
              } else if (cp2 >= 55296 && cp2 <= 57343) {
                cp2 = 65533;
              } else if (cp2 >= 64976 && cp2 <= 65007 || (cp2 & 65534) === 65534)
                ;
              else if (cp2 >= 1 && cp2 <= 8 || cp2 === 11 || cp2 >= 13 && cp2 <= 31 || cp2 >= 127 && cp2 <= 159) {
                cp2 = CCR_REPLACEMENTS[cp2] || cp2;
              }
              decodedText += String.fromCodePoint(cp2);
              advance(body[0].length);
            }
          }
        }
        return decodedText;
      };
      const CCR_REPLACEMENTS = {
        128: 8364,
        130: 8218,
        131: 402,
        132: 8222,
        133: 8230,
        134: 8224,
        135: 8225,
        136: 710,
        137: 8240,
        138: 352,
        139: 8249,
        140: 338,
        142: 381,
        145: 8216,
        146: 8217,
        147: 8220,
        148: 8221,
        149: 8226,
        150: 8211,
        151: 8212,
        152: 732,
        153: 8482,
        154: 353,
        155: 8250,
        156: 339,
        158: 382,
        159: 376
      };
      const isRawTextContainer = shared.makeMap("style,iframe,script,noscript", true);
      const parserOptions = {
        isVoidTag: shared.isVoidTag,
        isNativeTag: (tag) => shared.isHTMLTag(tag) || shared.isSVGTag(tag),
        isPreTag: (tag) => tag === "pre",
        decodeEntities: decodeHtml,
        isBuiltInComponent: (tag) => {
          if (compilerCore.isBuiltInType(tag, `Transition`)) {
            return TRANSITION;
          } else if (compilerCore.isBuiltInType(tag, `TransitionGroup`)) {
            return TRANSITION_GROUP;
          }
        },
        getNamespace(tag, parent) {
          let ns2 = parent ? parent.ns : 0;
          if (parent && ns2 === 2) {
            if (parent.tag === "annotation-xml") {
              if (tag === "svg") {
                return 1;
              }
              if (parent.props.some((a2) => a2.type === 6 && a2.name === "encoding" && a2.value != null && (a2.value.content === "text/html" || a2.value.content === "application/xhtml+xml"))) {
                ns2 = 0;
              }
            } else if (/^m(?:[ions]|text)$/.test(parent.tag) && tag !== "mglyph" && tag !== "malignmark") {
              ns2 = 0;
            }
          } else if (parent && ns2 === 1) {
            if (parent.tag === "foreignObject" || parent.tag === "desc" || parent.tag === "title") {
              ns2 = 0;
            }
          }
          if (ns2 === 0) {
            if (tag === "svg") {
              return 1;
            }
            if (tag === "math") {
              return 2;
            }
          }
          return ns2;
        },
        getTextMode({ tag, ns: ns2 }) {
          if (ns2 === 0) {
            if (tag === "textarea" || tag === "title") {
              return 1;
            }
            if (isRawTextContainer(tag)) {
              return 2;
            }
          }
          return 0;
        }
      };
      const transformStyle = (node2) => {
        if (node2.type === 1) {
          node2.props.forEach((p2, i2) => {
            if (p2.type === 6 && p2.name === "style" && p2.value) {
              node2.props[i2] = {
                type: 7,
                name: `bind`,
                arg: compilerCore.createSimpleExpression(`style`, true, p2.loc),
                exp: parseInlineCSS(p2.value.content, p2.loc),
                modifiers: [],
                loc: p2.loc
              };
            }
          });
        }
      };
      const parseInlineCSS = (cssText, loc) => {
        const normalized = shared.parseStringStyle(cssText);
        return compilerCore.createSimpleExpression(JSON.stringify(normalized), false, loc, 3);
      };
      function createDOMCompilerError(code, loc) {
        return compilerCore.createCompilerError(code, loc, DOMErrorMessages);
      }
      const DOMErrorMessages = {
        [50]: `v-html is missing expression.`,
        [51]: `v-html will override element children.`,
        [52]: `v-text is missing expression.`,
        [53]: `v-text will override element children.`,
        [54]: `v-model can only be used on <input>, <textarea> and <select> elements.`,
        [55]: `v-model argument is not supported on plain elements.`,
        [56]: `v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`,
        [57]: `Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.`,
        [58]: `v-show is missing expression.`,
        [59]: `<Transition> expects exactly one child element or component.`,
        [60]: `Tags with side effect (<script> and <style>) are ignored in client component templates.`
      };
      const transformVHtml = (dir, node2, context2) => {
        const { exp, loc } = dir;
        if (!exp) {
          context2.onError(createDOMCompilerError(50, loc));
        }
        if (node2.children.length) {
          context2.onError(createDOMCompilerError(51, loc));
          node2.children.length = 0;
        }
        return {
          props: [
            compilerCore.createObjectProperty(compilerCore.createSimpleExpression(`innerHTML`, true, loc), exp || compilerCore.createSimpleExpression("", true))
          ]
        };
      };
      const transformVText = (dir, node2, context2) => {
        const { exp, loc } = dir;
        if (!exp) {
          context2.onError(createDOMCompilerError(52, loc));
        }
        if (node2.children.length) {
          context2.onError(createDOMCompilerError(53, loc));
          node2.children.length = 0;
        }
        return {
          props: [
            compilerCore.createObjectProperty(compilerCore.createSimpleExpression(`textContent`, true), exp ? compilerCore.createCallExpression(context2.helperString(compilerCore.TO_DISPLAY_STRING), [exp], loc) : compilerCore.createSimpleExpression("", true))
          ]
        };
      };
      const transformModel2 = (dir, node2, context2) => {
        const baseResult = compilerCore.transformModel(dir, node2, context2);
        if (!baseResult.props.length || node2.tagType === 1) {
          return baseResult;
        }
        if (dir.arg) {
          context2.onError(createDOMCompilerError(55, dir.arg.loc));
        }
        function checkDuplicatedValue() {
          const value = compilerCore.findProp(node2, "value");
          if (value) {
            context2.onError(createDOMCompilerError(57, value.loc));
          }
        }
        const { tag } = node2;
        const isCustomElement = context2.isCustomElement(tag);
        if (tag === "input" || tag === "textarea" || tag === "select" || isCustomElement) {
          let directiveToUse = V_MODEL_TEXT;
          let isInvalidType = false;
          if (tag === "input" || isCustomElement) {
            const type = compilerCore.findProp(node2, `type`);
            if (type) {
              if (type.type === 7) {
                directiveToUse = V_MODEL_DYNAMIC;
              } else if (type.value) {
                switch (type.value.content) {
                  case "radio":
                    directiveToUse = V_MODEL_RADIO;
                    break;
                  case "checkbox":
                    directiveToUse = V_MODEL_CHECKBOX;
                    break;
                  case "file":
                    isInvalidType = true;
                    context2.onError(createDOMCompilerError(56, dir.loc));
                    break;
                  default:
                    checkDuplicatedValue();
                    break;
                }
              }
            } else if (compilerCore.hasDynamicKeyVBind(node2)) {
              directiveToUse = V_MODEL_DYNAMIC;
            } else {
              checkDuplicatedValue();
            }
          } else if (tag === "select") {
            directiveToUse = V_MODEL_SELECT;
          } else {
            checkDuplicatedValue();
          }
          if (!isInvalidType) {
            baseResult.needRuntime = context2.helper(directiveToUse);
          }
        } else {
          context2.onError(createDOMCompilerError(54, dir.loc));
        }
        baseResult.props = baseResult.props.filter((p2) => !(p2.key.type === 4 && p2.key.content === "modelValue"));
        return baseResult;
      };
      const isEventOptionModifier = shared.makeMap(`passive,once,capture`);
      const isNonKeyModifier = shared.makeMap(`stop,prevent,self,ctrl,shift,alt,meta,exact,middle`);
      const maybeKeyModifier = shared.makeMap("left,right");
      const isKeyboardEvent = shared.makeMap(`onkeyup,onkeydown,onkeypress`, true);
      const resolveModifiers = (key2, modifiers, context2, loc) => {
        const keyModifiers = [];
        const nonKeyModifiers = [];
        const eventOptionModifiers = [];
        for (let i2 = 0; i2 < modifiers.length; i2++) {
          const modifier = modifiers[i2];
          if (modifier === "native" && compilerCore.checkCompatEnabled("COMPILER_V_ON_NATIVE", context2, loc)) {
            eventOptionModifiers.push(modifier);
          } else if (isEventOptionModifier(modifier)) {
            eventOptionModifiers.push(modifier);
          } else {
            if (maybeKeyModifier(modifier)) {
              if (compilerCore.isStaticExp(key2)) {
                if (isKeyboardEvent(key2.content)) {
                  keyModifiers.push(modifier);
                } else {
                  nonKeyModifiers.push(modifier);
                }
              } else {
                keyModifiers.push(modifier);
                nonKeyModifiers.push(modifier);
              }
            } else {
              if (isNonKeyModifier(modifier)) {
                nonKeyModifiers.push(modifier);
              } else {
                keyModifiers.push(modifier);
              }
            }
          }
        }
        return {
          keyModifiers,
          nonKeyModifiers,
          eventOptionModifiers
        };
      };
      const transformClick = (key2, event) => {
        const isStaticClick = compilerCore.isStaticExp(key2) && key2.content.toLowerCase() === "onclick";
        return isStaticClick ? compilerCore.createSimpleExpression(event, true) : key2.type !== 4 ? compilerCore.createCompoundExpression([
          `(`,
          key2,
          `) === "onClick" ? "${event}" : (`,
          key2,
          `)`
        ]) : key2;
      };
      const transformOn2 = (dir, node2, context2) => {
        return compilerCore.transformOn(dir, node2, context2, (baseResult) => {
          const { modifiers } = dir;
          if (!modifiers.length)
            return baseResult;
          let { key: key2, value: handlerExp } = baseResult.props[0];
          const { keyModifiers, nonKeyModifiers, eventOptionModifiers } = resolveModifiers(key2, modifiers, context2, dir.loc);
          if (nonKeyModifiers.includes("right")) {
            key2 = transformClick(key2, `onContextmenu`);
          }
          if (nonKeyModifiers.includes("middle")) {
            key2 = transformClick(key2, `onMouseup`);
          }
          if (nonKeyModifiers.length) {
            handlerExp = compilerCore.createCallExpression(context2.helper(V_ON_WITH_MODIFIERS), [
              handlerExp,
              JSON.stringify(nonKeyModifiers)
            ]);
          }
          if (keyModifiers.length && (!compilerCore.isStaticExp(key2) || isKeyboardEvent(key2.content))) {
            handlerExp = compilerCore.createCallExpression(context2.helper(V_ON_WITH_KEYS), [
              handlerExp,
              JSON.stringify(keyModifiers)
            ]);
          }
          if (eventOptionModifiers.length) {
            const modifierPostfix = eventOptionModifiers.map(shared.capitalize).join("");
            key2 = compilerCore.isStaticExp(key2) ? compilerCore.createSimpleExpression(`${key2.content}${modifierPostfix}`, true) : compilerCore.createCompoundExpression([`(`, key2, `) + "${modifierPostfix}"`]);
          }
          return {
            props: [compilerCore.createObjectProperty(key2, handlerExp)]
          };
        });
      };
      const transformShow = (dir, node2, context2) => {
        const { exp, loc } = dir;
        if (!exp) {
          context2.onError(createDOMCompilerError(58, loc));
        }
        return {
          props: [],
          needRuntime: context2.helper(V_SHOW)
        };
      };
      const warnTransitionChildren = (node2, context2) => {
        if (node2.type === 1 && node2.tagType === 1) {
          const component = context2.isBuiltInComponent(node2.tag);
          if (component === TRANSITION) {
            return () => {
              if (node2.children.length && hasMultipleChildren(node2)) {
                context2.onError(createDOMCompilerError(59, {
                  start: node2.children[0].loc.start,
                  end: node2.children[node2.children.length - 1].loc.end,
                  source: ""
                }));
              }
            };
          }
        }
      };
      function hasMultipleChildren(node2) {
        const children = node2.children = node2.children.filter((c3) => c3.type !== 3 && !(c3.type === 2 && !c3.content.trim()));
        const child = children[0];
        return children.length !== 1 || child.type === 11 || child.type === 9 && child.branches.some(hasMultipleChildren);
      }
      const expReplaceRE = /__VUE_EXP_START__(.*?)__VUE_EXP_END__/g;
      const stringifyStatic = (children, context2, parent) => {
        if (context2.scopes.vSlot > 0) {
          return;
        }
        let nc = 0;
        let ec = 0;
        const currentChunk = [];
        const stringifyCurrentChunk = (currentIndex) => {
          if (nc >= 20 || ec >= 5) {
            const staticCall = compilerCore.createCallExpression(context2.helper(compilerCore.CREATE_STATIC), [
              JSON.stringify(currentChunk.map((node2) => stringifyNode(node2, context2)).join("")).replace(expReplaceRE, `" + $1 + "`),
              String(currentChunk.length)
            ]);
            replaceHoist(currentChunk[0], staticCall, context2);
            if (currentChunk.length > 1) {
              for (let i3 = 1; i3 < currentChunk.length; i3++) {
                replaceHoist(currentChunk[i3], null, context2);
              }
              const deleteCount = currentChunk.length - 1;
              children.splice(currentIndex - currentChunk.length + 1, deleteCount);
              return deleteCount;
            }
          }
          return 0;
        };
        let i2 = 0;
        for (; i2 < children.length; i2++) {
          const child = children[i2];
          const hoisted = getHoistedNode(child);
          if (hoisted) {
            const node2 = child;
            const result2 = analyzeNode(node2);
            if (result2) {
              nc += result2[0];
              ec += result2[1];
              currentChunk.push(node2);
              continue;
            }
          }
          i2 -= stringifyCurrentChunk(i2);
          nc = 0;
          ec = 0;
          currentChunk.length = 0;
        }
        stringifyCurrentChunk(i2);
      };
      const getHoistedNode = (node2) => (node2.type === 1 && node2.tagType === 0 || node2.type == 12) && node2.codegenNode && node2.codegenNode.type === 4 && node2.codegenNode.hoisted;
      const dataAriaRE = /^(data|aria)-/;
      const isStringifiableAttr = (name, ns2) => {
        return (ns2 === 0 ? shared.isKnownHtmlAttr(name) : ns2 === 1 ? shared.isKnownSvgAttr(name) : false) || dataAriaRE.test(name);
      };
      const replaceHoist = (node2, replacement2, context2) => {
        const hoistToReplace = node2.codegenNode.hoisted;
        context2.hoists[context2.hoists.indexOf(hoistToReplace)] = replacement2;
      };
      const isNonStringifiable = shared.makeMap(`caption,thead,tr,th,tbody,td,tfoot,colgroup,col`);
      function analyzeNode(node2) {
        if (node2.type === 1 && isNonStringifiable(node2.tag)) {
          return false;
        }
        if (node2.type === 12) {
          return [1, 0];
        }
        let nc = 1;
        let ec = node2.props.length > 0 ? 1 : 0;
        let bailed = false;
        const bail2 = () => {
          bailed = true;
          return false;
        };
        function walk3(node3) {
          for (let i2 = 0; i2 < node3.props.length; i2++) {
            const p2 = node3.props[i2];
            if (p2.type === 6 && !isStringifiableAttr(p2.name, node3.ns)) {
              return bail2();
            }
            if (p2.type === 7 && p2.name === "bind") {
              if (p2.arg && (p2.arg.type === 8 || p2.arg.isStatic && !isStringifiableAttr(p2.arg.content, node3.ns))) {
                return bail2();
              }
              if (p2.exp && (p2.exp.type === 8 || p2.exp.constType < 3)) {
                return bail2();
              }
            }
          }
          for (let i2 = 0; i2 < node3.children.length; i2++) {
            nc++;
            const child = node3.children[i2];
            if (child.type === 1) {
              if (child.props.length > 0) {
                ec++;
              }
              walk3(child);
              if (bailed) {
                return false;
              }
            }
          }
          return true;
        }
        return walk3(node2) ? [nc, ec] : false;
      }
      function stringifyNode(node2, context2) {
        if (shared.isString(node2)) {
          return node2;
        }
        if (shared.isSymbol(node2)) {
          return ``;
        }
        switch (node2.type) {
          case 1:
            return stringifyElement(node2, context2);
          case 2:
            return shared.escapeHtml(node2.content);
          case 3:
            return `<!--${shared.escapeHtml(node2.content)}-->`;
          case 5:
            return shared.escapeHtml(shared.toDisplayString(evaluateConstant(node2.content)));
          case 8:
            return shared.escapeHtml(evaluateConstant(node2));
          case 12:
            return stringifyNode(node2.content, context2);
          default:
            return "";
        }
      }
      function stringifyElement(node2, context2) {
        let res = `<${node2.tag}`;
        for (let i2 = 0; i2 < node2.props.length; i2++) {
          const p2 = node2.props[i2];
          if (p2.type === 6) {
            res += ` ${p2.name}`;
            if (p2.value) {
              res += `="${shared.escapeHtml(p2.value.content)}"`;
            }
          } else if (p2.type === 7 && p2.name === "bind") {
            const exp = p2.exp;
            if (exp.content[0] === "_") {
              res += ` ${p2.arg.content}="__VUE_EXP_START__${exp.content}__VUE_EXP_END__"`;
              continue;
            }
            let evaluated = evaluateConstant(exp);
            if (evaluated != null) {
              const arg = p2.arg && p2.arg.content;
              if (arg === "class") {
                evaluated = shared.normalizeClass(evaluated);
              } else if (arg === "style") {
                evaluated = shared.stringifyStyle(shared.normalizeStyle(evaluated));
              }
              res += ` ${p2.arg.content}="${shared.escapeHtml(evaluated)}"`;
            }
          }
        }
        if (context2.scopeId) {
          res += ` ${context2.scopeId}`;
        }
        res += `>`;
        for (let i2 = 0; i2 < node2.children.length; i2++) {
          res += stringifyNode(node2.children[i2], context2);
        }
        if (!shared.isVoidTag(node2.tag)) {
          res += `</${node2.tag}>`;
        }
        return res;
      }
      function evaluateConstant(exp) {
        if (exp.type === 4) {
          return new Function(`return ${exp.content}`)();
        } else {
          let res = ``;
          exp.children.forEach((c3) => {
            if (shared.isString(c3) || shared.isSymbol(c3)) {
              return;
            }
            if (c3.type === 2) {
              res += c3.content;
            } else if (c3.type === 5) {
              res += shared.toDisplayString(evaluateConstant(c3.content));
            } else {
              res += evaluateConstant(c3);
            }
          });
          return res;
        }
      }
      const ignoreSideEffectTags = (node2, context2) => {
        if (node2.type === 1 && node2.tagType === 0 && (node2.tag === "script" || node2.tag === "style")) {
          context2.onError(createDOMCompilerError(60, node2.loc));
          context2.removeNode();
        }
      };
      const DOMNodeTransforms = [
        transformStyle,
        ...[warnTransitionChildren]
      ];
      const DOMDirectiveTransforms = {
        cloak: compilerCore.noopDirectiveTransform,
        html: transformVHtml,
        text: transformVText,
        model: transformModel2,
        on: transformOn2,
        show: transformShow
      };
      function compile2(template, options2 = {}) {
        return compilerCore.baseCompile(template, shared.extend({}, parserOptions, options2, {
          nodeTransforms: [
            ignoreSideEffectTags,
            ...DOMNodeTransforms,
            ...options2.nodeTransforms || []
          ],
          directiveTransforms: shared.extend({}, DOMDirectiveTransforms, options2.directiveTransforms || {}),
          transformHoist: stringifyStatic
        }));
      }
      function parse2(template, options2 = {}) {
        return compilerCore.baseParse(template, shared.extend({}, parserOptions, options2));
      }
      Object.keys(compilerCore).forEach(function(k2) {
        if (k2 !== "default")
          exports3[k2] = compilerCore[k2];
      });
      exports3.DOMDirectiveTransforms = DOMDirectiveTransforms;
      exports3.DOMNodeTransforms = DOMNodeTransforms;
      exports3.TRANSITION = TRANSITION;
      exports3.TRANSITION_GROUP = TRANSITION_GROUP;
      exports3.V_MODEL_CHECKBOX = V_MODEL_CHECKBOX;
      exports3.V_MODEL_DYNAMIC = V_MODEL_DYNAMIC;
      exports3.V_MODEL_RADIO = V_MODEL_RADIO;
      exports3.V_MODEL_SELECT = V_MODEL_SELECT;
      exports3.V_MODEL_TEXT = V_MODEL_TEXT;
      exports3.V_ON_WITH_KEYS = V_ON_WITH_KEYS;
      exports3.V_ON_WITH_MODIFIERS = V_ON_WITH_MODIFIERS;
      exports3.V_SHOW = V_SHOW;
      exports3.compile = compile2;
      exports3.createDOMCompilerError = createDOMCompilerError;
      exports3.parse = parse2;
      exports3.parserOptions = parserOptions;
      exports3.transformStyle = transformStyle;
    })(compilerDom_cjs$2);
    var compilerDom_cjs = index2.getDefaultExportFromCjs(compilerDom_cjs$2);
    var compilerDom_cjs$1 = _mergeNamespaces2({
      __proto__: null,
      "default": compilerDom_cjs
    }, [compilerDom_cjs$2]);
    exports2.compilerDom_cjs = compilerDom_cjs$1;
  }
});

// node_modules/vite/dist/node/chunks/dep-2056ae8a.js
var require_dep_2056ae8a = __commonJS({
  "node_modules/vite/dist/node/chunks/dep-2056ae8a.js"(exports2) {
    "use strict";
    var openParentheses = "(".charCodeAt(0);
    var closeParentheses = ")".charCodeAt(0);
    var singleQuote = "'".charCodeAt(0);
    var doubleQuote2 = '"'.charCodeAt(0);
    var backslash2 = "\\".charCodeAt(0);
    var slash2 = "/".charCodeAt(0);
    var comma2 = ",".charCodeAt(0);
    var colon = ":".charCodeAt(0);
    var star2 = "*".charCodeAt(0);
    var uLower = "u".charCodeAt(0);
    var uUpper = "U".charCodeAt(0);
    var plus$1 = "+".charCodeAt(0);
    var isUnicodeRange = /^[a-f0-9?-]+$/i;
    var parse$12 = function(input) {
      var tokens = [];
      var value = input;
      var next, quote, prev, token2, escape2, escapePos, whitespacePos, parenthesesOpenPos;
      var pos2 = 0;
      var code = value.charCodeAt(pos2);
      var max = value.length;
      var stack2 = [{ nodes: tokens }];
      var balanced2 = 0;
      var parent;
      var name = "";
      var before = "";
      var after = "";
      while (pos2 < max) {
        if (code <= 32) {
          next = pos2;
          do {
            next += 1;
            code = value.charCodeAt(next);
          } while (code <= 32);
          token2 = value.slice(pos2, next);
          prev = tokens[tokens.length - 1];
          if (code === closeParentheses && balanced2) {
            after = token2;
          } else if (prev && prev.type === "div") {
            prev.after = token2;
            prev.sourceEndIndex += token2.length;
          } else if (code === comma2 || code === colon || code === slash2 && value.charCodeAt(next + 1) !== star2 && (!parent || parent && parent.type === "function" && parent.value !== "calc")) {
            before = token2;
          } else {
            tokens.push({
              type: "space",
              sourceIndex: pos2,
              sourceEndIndex: next,
              value: token2
            });
          }
          pos2 = next;
        } else if (code === singleQuote || code === doubleQuote2) {
          next = pos2;
          quote = code === singleQuote ? "'" : '"';
          token2 = {
            type: "string",
            sourceIndex: pos2,
            quote
          };
          do {
            escape2 = false;
            next = value.indexOf(quote, next + 1);
            if (~next) {
              escapePos = next;
              while (value.charCodeAt(escapePos - 1) === backslash2) {
                escapePos -= 1;
                escape2 = !escape2;
              }
            } else {
              value += quote;
              next = value.length - 1;
              token2.unclosed = true;
            }
          } while (escape2);
          token2.value = value.slice(pos2 + 1, next);
          token2.sourceEndIndex = token2.unclosed ? next : next + 1;
          tokens.push(token2);
          pos2 = next + 1;
          code = value.charCodeAt(pos2);
        } else if (code === slash2 && value.charCodeAt(pos2 + 1) === star2) {
          next = value.indexOf("*/", pos2);
          token2 = {
            type: "comment",
            sourceIndex: pos2,
            sourceEndIndex: next + 2
          };
          if (next === -1) {
            token2.unclosed = true;
            next = value.length;
            token2.sourceEndIndex = next;
          }
          token2.value = value.slice(pos2 + 2, next);
          tokens.push(token2);
          pos2 = next + 2;
          code = value.charCodeAt(pos2);
        } else if ((code === slash2 || code === star2) && parent && parent.type === "function" && parent.value === "calc") {
          token2 = value[pos2];
          tokens.push({
            type: "word",
            sourceIndex: pos2 - before.length,
            sourceEndIndex: pos2 + token2.length,
            value: token2
          });
          pos2 += 1;
          code = value.charCodeAt(pos2);
        } else if (code === slash2 || code === comma2 || code === colon) {
          token2 = value[pos2];
          tokens.push({
            type: "div",
            sourceIndex: pos2 - before.length,
            sourceEndIndex: pos2 + token2.length,
            value: token2,
            before,
            after: ""
          });
          before = "";
          pos2 += 1;
          code = value.charCodeAt(pos2);
        } else if (openParentheses === code) {
          next = pos2;
          do {
            next += 1;
            code = value.charCodeAt(next);
          } while (code <= 32);
          parenthesesOpenPos = pos2;
          token2 = {
            type: "function",
            sourceIndex: pos2 - name.length,
            value: name,
            before: value.slice(parenthesesOpenPos + 1, next)
          };
          pos2 = next;
          if (name === "url" && code !== singleQuote && code !== doubleQuote2) {
            next -= 1;
            do {
              escape2 = false;
              next = value.indexOf(")", next + 1);
              if (~next) {
                escapePos = next;
                while (value.charCodeAt(escapePos - 1) === backslash2) {
                  escapePos -= 1;
                  escape2 = !escape2;
                }
              } else {
                value += ")";
                next = value.length - 1;
                token2.unclosed = true;
              }
            } while (escape2);
            whitespacePos = next;
            do {
              whitespacePos -= 1;
              code = value.charCodeAt(whitespacePos);
            } while (code <= 32);
            if (parenthesesOpenPos < whitespacePos) {
              if (pos2 !== whitespacePos + 1) {
                token2.nodes = [
                  {
                    type: "word",
                    sourceIndex: pos2,
                    sourceEndIndex: whitespacePos + 1,
                    value: value.slice(pos2, whitespacePos + 1)
                  }
                ];
              } else {
                token2.nodes = [];
              }
              if (token2.unclosed && whitespacePos + 1 !== next) {
                token2.after = "";
                token2.nodes.push({
                  type: "space",
                  sourceIndex: whitespacePos + 1,
                  sourceEndIndex: next,
                  value: value.slice(whitespacePos + 1, next)
                });
              } else {
                token2.after = value.slice(whitespacePos + 1, next);
                token2.sourceEndIndex = next;
              }
            } else {
              token2.after = "";
              token2.nodes = [];
            }
            pos2 = next + 1;
            token2.sourceEndIndex = token2.unclosed ? next : pos2;
            code = value.charCodeAt(pos2);
            tokens.push(token2);
          } else {
            balanced2 += 1;
            token2.after = "";
            token2.sourceEndIndex = pos2 + 1;
            tokens.push(token2);
            stack2.push(token2);
            tokens = token2.nodes = [];
            parent = token2;
          }
          name = "";
        } else if (closeParentheses === code && balanced2) {
          pos2 += 1;
          code = value.charCodeAt(pos2);
          parent.after = after;
          parent.sourceEndIndex += after.length;
          after = "";
          balanced2 -= 1;
          stack2[stack2.length - 1].sourceEndIndex = pos2;
          stack2.pop();
          parent = stack2[balanced2];
          tokens = parent.nodes;
        } else {
          next = pos2;
          do {
            if (code === backslash2) {
              next += 1;
            }
            next += 1;
            code = value.charCodeAt(next);
          } while (next < max && !(code <= 32 || code === singleQuote || code === doubleQuote2 || code === comma2 || code === colon || code === slash2 || code === openParentheses || code === star2 && parent && parent.type === "function" && parent.value === "calc" || code === slash2 && parent.type === "function" && parent.value === "calc" || code === closeParentheses && balanced2));
          token2 = value.slice(pos2, next);
          if (openParentheses === code) {
            name = token2;
          } else if ((uLower === token2.charCodeAt(0) || uUpper === token2.charCodeAt(0)) && plus$1 === token2.charCodeAt(1) && isUnicodeRange.test(token2.slice(2))) {
            tokens.push({
              type: "unicode-range",
              sourceIndex: pos2,
              sourceEndIndex: next,
              value: token2
            });
          } else {
            tokens.push({
              type: "word",
              sourceIndex: pos2,
              sourceEndIndex: next,
              value: token2
            });
          }
          pos2 = next;
        }
      }
      for (pos2 = stack2.length - 1; pos2; pos2 -= 1) {
        stack2[pos2].unclosed = true;
        stack2[pos2].sourceEndIndex = value.length;
      }
      return stack2[0].nodes;
    };
    var walk$12 = function walk3(nodes, cb, bubble) {
      var i2, max, node2, result2;
      for (i2 = 0, max = nodes.length; i2 < max; i2 += 1) {
        node2 = nodes[i2];
        if (!bubble) {
          result2 = cb(node2, i2, nodes);
        }
        if (result2 !== false && node2.type === "function" && Array.isArray(node2.nodes)) {
          walk3(node2.nodes, cb, bubble);
        }
        if (bubble) {
          cb(node2, i2, nodes);
        }
      }
    };
    function stringifyNode(node2, custom) {
      var type = node2.type;
      var value = node2.value;
      var buf;
      var customResult;
      if (custom && (customResult = custom(node2)) !== void 0) {
        return customResult;
      } else if (type === "word" || type === "space") {
        return value;
      } else if (type === "string") {
        buf = node2.quote || "";
        return buf + value + (node2.unclosed ? "" : buf);
      } else if (type === "comment") {
        return "/*" + value + (node2.unclosed ? "" : "*/");
      } else if (type === "div") {
        return (node2.before || "") + value + (node2.after || "");
      } else if (Array.isArray(node2.nodes)) {
        buf = stringify$12(node2.nodes, custom);
        if (type !== "function") {
          return buf;
        }
        return value + "(" + (node2.before || "") + buf + (node2.after || "") + (node2.unclosed ? "" : ")");
      }
      return value;
    }
    function stringify$12(nodes, custom) {
      var result2, i2;
      if (Array.isArray(nodes)) {
        result2 = "";
        for (i2 = nodes.length - 1; ~i2; i2 -= 1) {
          result2 = stringifyNode(nodes[i2], custom) + result2;
        }
        return result2;
      }
      return stringifyNode(nodes, custom);
    }
    var stringify_1 = stringify$12;
    var minus = "-".charCodeAt(0);
    var plus = "+".charCodeAt(0);
    var dot = ".".charCodeAt(0);
    var exp = "e".charCodeAt(0);
    var EXP = "E".charCodeAt(0);
    function likeNumber(value) {
      var code = value.charCodeAt(0);
      var nextCode;
      if (code === plus || code === minus) {
        nextCode = value.charCodeAt(1);
        if (nextCode >= 48 && nextCode <= 57) {
          return true;
        }
        var nextNextCode = value.charCodeAt(2);
        if (nextCode === dot && nextNextCode >= 48 && nextNextCode <= 57) {
          return true;
        }
        return false;
      }
      if (code === dot) {
        nextCode = value.charCodeAt(1);
        if (nextCode >= 48 && nextCode <= 57) {
          return true;
        }
        return false;
      }
      if (code >= 48 && code <= 57) {
        return true;
      }
      return false;
    }
    var unit = function(value) {
      var pos2 = 0;
      var length = value.length;
      var code;
      var nextCode;
      var nextNextCode;
      if (length === 0 || !likeNumber(value)) {
        return false;
      }
      code = value.charCodeAt(pos2);
      if (code === plus || code === minus) {
        pos2++;
      }
      while (pos2 < length) {
        code = value.charCodeAt(pos2);
        if (code < 48 || code > 57) {
          break;
        }
        pos2 += 1;
      }
      code = value.charCodeAt(pos2);
      nextCode = value.charCodeAt(pos2 + 1);
      if (code === dot && nextCode >= 48 && nextCode <= 57) {
        pos2 += 2;
        while (pos2 < length) {
          code = value.charCodeAt(pos2);
          if (code < 48 || code > 57) {
            break;
          }
          pos2 += 1;
        }
      }
      code = value.charCodeAt(pos2);
      nextCode = value.charCodeAt(pos2 + 1);
      nextNextCode = value.charCodeAt(pos2 + 2);
      if ((code === exp || code === EXP) && (nextCode >= 48 && nextCode <= 57 || (nextCode === plus || nextCode === minus) && nextNextCode >= 48 && nextNextCode <= 57)) {
        pos2 += nextCode === plus || nextCode === minus ? 3 : 2;
        while (pos2 < length) {
          code = value.charCodeAt(pos2);
          if (code < 48 || code > 57) {
            break;
          }
          pos2 += 1;
        }
      }
      return {
        number: value.slice(0, pos2),
        unit: value.slice(pos2)
      };
    };
    var parse2 = parse$12;
    var walk2 = walk$12;
    var stringify2 = stringify_1;
    function ValueParser(value) {
      if (this instanceof ValueParser) {
        this.nodes = parse2(value);
        return this;
      }
      return new ValueParser(value);
    }
    ValueParser.prototype.toString = function() {
      return Array.isArray(this.nodes) ? stringify2(this.nodes) : "";
    };
    ValueParser.prototype.walk = function(cb, bubble) {
      walk2(this.nodes, cb, bubble);
      return this;
    };
    ValueParser.unit = unit;
    ValueParser.walk = walk2;
    ValueParser.stringify = stringify2;
    var lib2 = ValueParser;
    exports2.lib = lib2;
  }
});

// node_modules/vite/dist/node/chunks/dep-bcc0af00.js
var require_dep_bcc0af00 = __commonJS({
  "node_modules/vite/dist/node/chunks/dep-bcc0af00.js"(exports, module) {
    "use strict";
    var path$3 = (init_path(), __toCommonJS(path_exports));
    var resolve$2 = require_resolve();
    var fs$1 = (init_fs(), __toCommonJS(fs_exports));
    var index$1 = require_dep_2056ae8a();
    function _interopDefaultLegacy(e2) {
      return e2 && typeof e2 === "object" && "default" in e2 ? e2["default"] : e2;
    }
    function _mergeNamespaces(n3, m3) {
      for (var i2 = 0; i2 < m3.length; i2++) {
        var e2 = m3[i2];
        if (typeof e2 !== "string" && !Array.isArray(e2)) {
          for (var k2 in e2) {
            if (k2 !== "default" && !(k2 in n3)) {
              n3[k2] = e2[k2];
            }
          }
        }
      }
      return n3;
    }
    var path__default = _interopDefaultLegacy(path$3);
    var resolve__default = _interopDefaultLegacy(resolve$2);
    var fs__default = _interopDefaultLegacy(fs$1);
    var joinMedia$1 = function(parentMedia, childMedia) {
      if (!parentMedia.length && childMedia.length)
        return childMedia;
      if (parentMedia.length && !childMedia.length)
        return parentMedia;
      if (!parentMedia.length && !childMedia.length)
        return [];
      const media = [];
      parentMedia.forEach((parentItem) => {
        childMedia.forEach((childItem) => {
          if (parentItem !== childItem)
            media.push(`${parentItem} and ${childItem}`);
        });
      });
      return media;
    };
    var joinLayer$1 = function(parentLayer, childLayer) {
      if (!parentLayer.length && childLayer.length)
        return childLayer;
      if (parentLayer.length && !childLayer.length)
        return parentLayer;
      if (!parentLayer.length && !childLayer.length)
        return [];
      return parentLayer.concat(childLayer);
    };
    var resolve$1 = resolve__default;
    var moduleDirectories = ["web_modules", "node_modules"];
    function resolveModule(id, opts) {
      return new Promise((res, rej) => {
        resolve$1(id, opts, (err, path2) => err ? rej(err) : res(path2));
      });
    }
    var resolveId$1 = function(id, base2, options2) {
      const paths = options2.path;
      const resolveOpts = {
        basedir: base2,
        moduleDirectory: moduleDirectories.concat(options2.addModulesDirectories),
        paths,
        extensions: [".css"],
        packageFilter: function processPackage(pkg) {
          if (pkg.style)
            pkg.main = pkg.style;
          else if (!pkg.main || !/\.css$/.test(pkg.main))
            pkg.main = "index.css";
          return pkg;
        },
        preserveSymlinks: false
      };
      return resolveModule(`./${id}`, resolveOpts).catch(() => resolveModule(id, resolveOpts)).catch(() => {
        if (paths.indexOf(base2) === -1)
          paths.unshift(base2);
        throw new Error(`Failed to find '${id}'
  in [
    ${paths.join(",\n        ")}
  ]`);
      });
    };
    var readCache$1 = { exports: {} };
    var pify$2 = { exports: {} };
    var processFn = function(fn2, P2, opts) {
      return function() {
        var that = this;
        var args = new Array(arguments.length);
        for (var i2 = 0; i2 < arguments.length; i2++) {
          args[i2] = arguments[i2];
        }
        return new P2(function(resolve2, reject) {
          args.push(function(err, result2) {
            if (err) {
              reject(err);
            } else if (opts.multiArgs) {
              var results = new Array(arguments.length - 1);
              for (var i3 = 1; i3 < arguments.length; i3++) {
                results[i3 - 1] = arguments[i3];
              }
              resolve2(results);
            } else {
              resolve2(result2);
            }
          });
          fn2.apply(that, args);
        });
      };
    };
    var pify$1 = pify$2.exports = function(obj, P2, opts) {
      if (typeof P2 !== "function") {
        opts = P2;
        P2 = Promise;
      }
      opts = opts || {};
      opts.exclude = opts.exclude || [/.+Sync$/];
      var filter2 = function(key2) {
        var match2 = function(pattern2) {
          return typeof pattern2 === "string" ? key2 === pattern2 : pattern2.test(key2);
        };
        return opts.include ? opts.include.some(match2) : !opts.exclude.some(match2);
      };
      var ret = typeof obj === "function" ? function() {
        if (opts.excludeMain) {
          return obj.apply(this, arguments);
        }
        return processFn(obj, P2, opts).apply(this, arguments);
      } : {};
      return Object.keys(obj).reduce(function(ret2, key2) {
        var x2 = obj[key2];
        ret2[key2] = typeof x2 === "function" && filter2(key2) ? processFn(x2, P2, opts) : x2;
        return ret2;
      }, ret);
    };
    pify$1.all = pify$1;
    var fs = fs__default;
    var path$2 = path__default;
    var pify = pify$2.exports;
    var stat = pify(fs.stat);
    var readFile = pify(fs.readFile);
    var resolve = path$2.resolve;
    var cache = /* @__PURE__ */ Object.create(null);
    function convert(content2, encoding) {
      if (Buffer.isEncoding(encoding)) {
        return content2.toString(encoding);
      }
      return content2;
    }
    readCache$1.exports = function(path2, encoding) {
      path2 = resolve(path2);
      return stat(path2).then(function(stats) {
        var item = cache[path2];
        if (item && item.mtime.getTime() === stats.mtime.getTime()) {
          return convert(item.content, encoding);
        }
        return readFile(path2).then(function(data2) {
          cache[path2] = {
            mtime: stats.mtime,
            content: data2
          };
          return convert(data2, encoding);
        });
      }).catch(function(err) {
        cache[path2] = null;
        return Promise.reject(err);
      });
    };
    readCache$1.exports.sync = function(path2, encoding) {
      path2 = resolve(path2);
      try {
        var stats = fs.statSync(path2);
        var item = cache[path2];
        if (item && item.mtime.getTime() === stats.mtime.getTime()) {
          return convert(item.content, encoding);
        }
        var data2 = fs.readFileSync(path2);
        cache[path2] = {
          mtime: stats.mtime,
          content: data2
        };
        return convert(data2, encoding);
      } catch (err) {
        cache[path2] = null;
        throw err;
      }
    };
    readCache$1.exports.get = function(path2, encoding) {
      path2 = resolve(path2);
      if (cache[path2]) {
        return convert(cache[path2].content, encoding);
      }
      return null;
    };
    readCache$1.exports.clear = function() {
      cache = /* @__PURE__ */ Object.create(null);
    };
    var readCache = readCache$1.exports;
    var loadContent$1 = (filename2) => readCache(filename2, "utf-8");
    var path$1 = path__default;
    var sugarss;
    var processContent$1 = function processContent(result, content, filename, options, postcss) {
      const { plugins } = options;
      const ext = path$1.extname(filename);
      const parserList = [];
      if (ext === ".sss") {
        if (!sugarss) {
          try {
            sugarss = eval("require")("sugarss");
          } catch {
          }
        }
        if (sugarss)
          return runPostcss(postcss, content, filename, plugins, [sugarss]);
      }
      if (result.opts.syntax && result.opts.syntax.parse) {
        parserList.push(result.opts.syntax.parse);
      }
      if (result.opts.parser)
        parserList.push(result.opts.parser);
      parserList.push(null);
      return runPostcss(postcss, content, filename, plugins, parserList);
    };
    function runPostcss(postcss2, content2, filename2, plugins2, parsers, index2) {
      if (!index2)
        index2 = 0;
      return postcss2(plugins2).process(content2, {
        from: filename2,
        parser: parsers[index2]
      }).catch((err) => {
        index2++;
        if (index2 === parsers.length)
          throw err;
        return runPostcss(postcss2, content2, filename2, plugins2, parsers, index2);
      });
    }
    var valueParser = index$1.lib;
    var { stringify } = valueParser;
    function split(params, start) {
      const list2 = [];
      const last = params.reduce((item, node2, index2) => {
        if (index2 < start)
          return "";
        if (node2.type === "div" && node2.value === ",") {
          list2.push(item);
          return "";
        }
        return item + stringify(node2);
      }, "");
      list2.push(last);
      return list2;
    }
    var parseStatements$1 = function(result2, styles) {
      const statements = [];
      let nodes = [];
      styles.each((node2) => {
        let stmt;
        if (node2.type === "atrule") {
          if (node2.name === "import")
            stmt = parseImport(result2, node2);
          else if (node2.name === "media")
            stmt = parseMedia(result2, node2);
          else if (node2.name === "charset")
            stmt = parseCharset(result2, node2);
        }
        if (stmt) {
          if (nodes.length) {
            statements.push({
              type: "nodes",
              nodes,
              media: [],
              layer: []
            });
            nodes = [];
          }
          statements.push(stmt);
        } else
          nodes.push(node2);
      });
      if (nodes.length) {
        statements.push({
          type: "nodes",
          nodes,
          media: [],
          layer: []
        });
      }
      return statements;
    };
    function parseMedia(result2, atRule) {
      const params = valueParser(atRule.params).nodes;
      return {
        type: "media",
        node: atRule,
        media: split(params, 0),
        layer: []
      };
    }
    function parseCharset(result2, atRule) {
      if (atRule.prev()) {
        return result2.warn("@charset must precede all other statements", {
          node: atRule
        });
      }
      return {
        type: "charset",
        node: atRule,
        media: [],
        layer: []
      };
    }
    function parseImport(result2, atRule) {
      let prev = atRule.prev();
      if (prev) {
        do {
          if (prev.type !== "comment" && (prev.type !== "atrule" || prev.name !== "import" && prev.name !== "charset" && !(prev.name === "layer" && !prev.nodes))) {
            return result2.warn("@import must precede all other statements (besides @charset or empty @layer)", { node: atRule });
          }
          prev = prev.prev();
        } while (prev);
      }
      if (atRule.nodes) {
        return result2.warn("It looks like you didn't end your @import statement correctly. Child nodes are attached to it.", { node: atRule });
      }
      const params = valueParser(atRule.params).nodes;
      const stmt = {
        type: "import",
        node: atRule,
        media: [],
        layer: []
      };
      if (!params.length || (params[0].type !== "string" || !params[0].value) && (params[0].type !== "function" || params[0].value !== "url" || !params[0].nodes.length || !params[0].nodes[0].value)) {
        return result2.warn(`Unable to find uri in '${atRule.toString()}'`, {
          node: atRule
        });
      }
      if (params[0].type === "string")
        stmt.uri = params[0].value;
      else
        stmt.uri = params[0].nodes[0].value;
      stmt.fullUri = stringify(params[0]);
      let remainder = params;
      if (remainder.length > 2) {
        if ((remainder[2].type === "word" || remainder[2].type === "function") && remainder[2].value === "layer") {
          if (remainder[1].type !== "space") {
            return result2.warn("Invalid import layer statement", { node: atRule });
          }
          if (remainder[2].nodes) {
            stmt.layer = [stringify(remainder[2].nodes)];
          } else {
            stmt.layer = [""];
          }
          remainder = remainder.slice(2);
        }
      }
      if (remainder.length > 2) {
        if (remainder[1].type !== "space") {
          return result2.warn("Invalid import media statement", { node: atRule });
        }
        stmt.media = split(remainder, 2);
      }
      return stmt;
    }
    var path = path__default;
    var joinMedia = joinMedia$1;
    var joinLayer = joinLayer$1;
    var resolveId = resolveId$1;
    var loadContent = loadContent$1;
    var processContent = processContent$1;
    var parseStatements = parseStatements$1;
    function AtImport(options2) {
      options2 = __spreadValues2({
        root: process.cwd(),
        path: [],
        skipDuplicates: true,
        resolve: resolveId,
        load: loadContent,
        plugins: [],
        addModulesDirectories: []
      }, options2);
      options2.root = path.resolve(options2.root);
      if (typeof options2.path === "string")
        options2.path = [options2.path];
      if (!Array.isArray(options2.path))
        options2.path = [];
      options2.path = options2.path.map((p2) => path.resolve(options2.root, p2));
      return {
        postcssPlugin: "postcss-import",
        Once(styles, { result: result2, atRule, postcss: postcss2 }) {
          const state = {
            importedFiles: {},
            hashFiles: {}
          };
          if (styles.source && styles.source.input && styles.source.input.file) {
            state.importedFiles[styles.source.input.file] = {};
          }
          if (options2.plugins && !Array.isArray(options2.plugins)) {
            throw new Error("plugins option must be an array");
          }
          return parseStyles(result2, styles, options2, state, [], []).then((bundle) => {
            applyRaws(bundle);
            applyMedia(bundle);
            applyStyles(bundle, styles);
          });
          function applyRaws(bundle) {
            bundle.forEach((stmt, index2) => {
              if (index2 === 0)
                return;
              if (stmt.parent) {
                const { before } = stmt.parent.node.raws;
                if (stmt.type === "nodes")
                  stmt.nodes[0].raws.before = before;
                else
                  stmt.node.raws.before = before;
              } else if (stmt.type === "nodes") {
                stmt.nodes[0].raws.before = stmt.nodes[0].raws.before || "\n";
              }
            });
          }
          function applyMedia(bundle) {
            bundle.forEach((stmt) => {
              if (!stmt.media.length && !stmt.layer.length || stmt.type === "charset") {
                return;
              }
              if (stmt.type === "import") {
                stmt.node.params = `${stmt.fullUri} ${stmt.media.join(", ")}`;
              } else if (stmt.type === "media") {
                stmt.node.params = stmt.media.join(", ");
              } else {
                const { nodes } = stmt;
                const { parent } = nodes[0];
                let outerAtRule;
                let innerAtRule;
                if (stmt.media.length && stmt.layer.length) {
                  const mediaNode = atRule({
                    name: "media",
                    params: stmt.media.join(", "),
                    source: parent.source
                  });
                  const layerNode = atRule({
                    name: "layer",
                    params: stmt.layer.filter((layer) => layer !== "").join("."),
                    source: parent.source
                  });
                  mediaNode.append(layerNode);
                  innerAtRule = layerNode;
                  outerAtRule = mediaNode;
                } else if (stmt.media.length) {
                  const mediaNode = atRule({
                    name: "media",
                    params: stmt.media.join(", "),
                    source: parent.source
                  });
                  innerAtRule = mediaNode;
                  outerAtRule = mediaNode;
                } else if (stmt.layer.length) {
                  const layerNode = atRule({
                    name: "layer",
                    params: stmt.layer.filter((layer) => layer !== "").join("."),
                    source: parent.source
                  });
                  innerAtRule = layerNode;
                  outerAtRule = layerNode;
                }
                parent.insertBefore(nodes[0], outerAtRule);
                nodes.forEach((node2) => {
                  node2.parent = void 0;
                });
                nodes[0].raws.before = nodes[0].raws.before || "\n";
                innerAtRule.append(nodes);
                stmt.type = "media";
                stmt.node = outerAtRule;
                delete stmt.nodes;
              }
            });
          }
          function applyStyles(bundle, styles2) {
            styles2.nodes = [];
            bundle.forEach((stmt) => {
              if (["charset", "import", "media"].includes(stmt.type)) {
                stmt.node.parent = void 0;
                styles2.append(stmt.node);
              } else if (stmt.type === "nodes") {
                stmt.nodes.forEach((node2) => {
                  node2.parent = void 0;
                  styles2.append(node2);
                });
              }
            });
          }
          function parseStyles(result3, styles2, options3, state2, media, layer) {
            const statements = parseStatements(result3, styles2);
            return Promise.resolve(statements).then((stmts) => {
              return stmts.reduce((promise2, stmt) => {
                return promise2.then(() => {
                  stmt.media = joinMedia(media, stmt.media || []);
                  stmt.layer = joinLayer(layer, stmt.layer || []);
                  if (stmt.type !== "import" || /^(?:[a-z]+:)?\/\//i.test(stmt.uri)) {
                    return;
                  }
                  if (options3.filter && !options3.filter(stmt.uri)) {
                    return;
                  }
                  return resolveImportId(result3, stmt, options3, state2);
                });
              }, Promise.resolve());
            }).then(() => {
              let charset;
              const imports = [];
              const bundle = [];
              function handleCharset(stmt) {
                if (!charset)
                  charset = stmt;
                else if (stmt.node.params.toLowerCase() !== charset.node.params.toLowerCase()) {
                  throw new Error(`Incompatable @charset statements:
  ${stmt.node.params} specified in ${stmt.node.source.input.file}
  ${charset.node.params} specified in ${charset.node.source.input.file}`);
                }
              }
              statements.forEach((stmt) => {
                if (stmt.type === "charset")
                  handleCharset(stmt);
                else if (stmt.type === "import") {
                  if (stmt.children) {
                    stmt.children.forEach((child, index2) => {
                      if (child.type === "import")
                        imports.push(child);
                      else if (child.type === "charset")
                        handleCharset(child);
                      else
                        bundle.push(child);
                      if (index2 === 0)
                        child.parent = stmt;
                    });
                  } else
                    imports.push(stmt);
                } else if (stmt.type === "media" || stmt.type === "nodes") {
                  bundle.push(stmt);
                }
              });
              return charset ? [charset, ...imports.concat(bundle)] : imports.concat(bundle);
            });
          }
          function resolveImportId(result3, stmt, options3, state2) {
            const atRule2 = stmt.node;
            let sourceFile;
            if (atRule2.source && atRule2.source.input && atRule2.source.input.file) {
              sourceFile = atRule2.source.input.file;
            }
            const base2 = sourceFile ? path.dirname(atRule2.source.input.file) : options3.root;
            return Promise.resolve(options3.resolve(stmt.uri, base2, options3)).then((paths) => {
              if (!Array.isArray(paths))
                paths = [paths];
              return Promise.all(paths.map((file) => {
                return !path.isAbsolute(file) ? resolveId(file, base2, options3) : file;
              }));
            }).then((resolved) => {
              resolved.forEach((file) => {
                result3.messages.push({
                  type: "dependency",
                  plugin: "postcss-import",
                  file,
                  parent: sourceFile
                });
              });
              return Promise.all(resolved.map((file) => {
                return loadImportContent(result3, stmt, file, options3, state2);
              }));
            }).then((result4) => {
              stmt.children = result4.reduce((result5, statements) => {
                return statements ? result5.concat(statements) : result5;
              }, []);
            });
          }
          function loadImportContent(result3, stmt, filename2, options3, state2) {
            const atRule2 = stmt.node;
            const { media, layer } = stmt;
            if (options3.skipDuplicates) {
              if (state2.importedFiles[filename2] && state2.importedFiles[filename2][media]) {
                return;
              }
              if (!state2.importedFiles[filename2])
                state2.importedFiles[filename2] = {};
              state2.importedFiles[filename2][media] = true;
            }
            return Promise.resolve(options3.load(filename2, options3)).then((content2) => {
              if (content2.trim() === "") {
                result3.warn(`${filename2} is empty`, { node: atRule2 });
                return;
              }
              if (state2.hashFiles[content2] && state2.hashFiles[content2][media])
                return;
              return processContent(result3, content2, filename2, options3, postcss2).then((importedResult) => {
                const styles2 = importedResult.root;
                result3.messages = result3.messages.concat(importedResult.messages);
                if (options3.skipDuplicates) {
                  const hasImport = styles2.some((child) => {
                    return child.type === "atrule" && child.name === "import";
                  });
                  if (!hasImport) {
                    if (!state2.hashFiles[content2])
                      state2.hashFiles[content2] = {};
                    state2.hashFiles[content2][media] = true;
                  }
                }
                return parseStyles(result3, styles2, options3, state2, media, layer);
              });
            });
          }
        }
      };
    }
    AtImport.postcss = true;
    var postcssImport = AtImport;
    var index = _mergeNamespaces({
      __proto__: null,
      "default": postcssImport
    }, [postcssImport]);
    exports.index = index;
  }
});

// node_modules/picocolors/picocolors.browser.js
var require_picocolors_browser = __commonJS({
  "node_modules/picocolors/picocolors.browser.js"(exports2, module2) {
    var x2 = String;
    var create = function() {
      return { isColorSupported: false, reset: x2, bold: x2, dim: x2, italic: x2, underline: x2, inverse: x2, hidden: x2, strikethrough: x2, black: x2, red: x2, green: x2, yellow: x2, blue: x2, magenta: x2, cyan: x2, white: x2, gray: x2, bgBlack: x2, bgRed: x2, bgGreen: x2, bgYellow: x2, bgBlue: x2, bgMagenta: x2, bgCyan: x2, bgWhite: x2 };
    };
    module2.exports = create();
    module2.exports.createColors = create;
  }
});

// (disabled):node_modules/postcss/lib/terminal-highlight
var require_terminal_highlight = __commonJS({
  "(disabled):node_modules/postcss/lib/terminal-highlight"() {
  }
});

// node_modules/postcss/lib/css-syntax-error.js
var require_css_syntax_error = __commonJS({
  "node_modules/postcss/lib/css-syntax-error.js"(exports2, module2) {
    "use strict";
    var pico = require_picocolors_browser();
    var terminalHighlight = require_terminal_highlight();
    var CssSyntaxError = class extends Error {
      constructor(message, line2, column2, source2, file, plugin) {
        super(message);
        this.name = "CssSyntaxError";
        this.reason = message;
        if (file) {
          this.file = file;
        }
        if (source2) {
          this.source = source2;
        }
        if (plugin) {
          this.plugin = plugin;
        }
        if (typeof line2 !== "undefined" && typeof column2 !== "undefined") {
          if (typeof line2 === "number") {
            this.line = line2;
            this.column = column2;
          } else {
            this.line = line2.line;
            this.column = line2.column;
            this.endLine = column2.line;
            this.endColumn = column2.column;
          }
        }
        this.setMessage();
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, CssSyntaxError);
        }
      }
      setMessage() {
        this.message = this.plugin ? this.plugin + ": " : "";
        this.message += this.file ? this.file : "<css input>";
        if (typeof this.line !== "undefined") {
          this.message += ":" + this.line + ":" + this.column;
        }
        this.message += ": " + this.reason;
      }
      showSourceCode(color) {
        if (!this.source)
          return "";
        let css = this.source;
        if (color == null)
          color = pico.isColorSupported;
        if (terminalHighlight) {
          if (color)
            css = terminalHighlight(css);
        }
        let lines = css.split(/\r?\n/);
        let start = Math.max(this.line - 3, 0);
        let end = Math.min(this.line + 2, lines.length);
        let maxWidth = String(end).length;
        let mark2, aside;
        if (color) {
          let { bold, red, gray } = pico.createColors(true);
          mark2 = (text) => bold(red(text));
          aside = (text) => gray(text);
        } else {
          mark2 = aside = (str) => str;
        }
        return lines.slice(start, end).map((line2, index2) => {
          let number = start + 1 + index2;
          let gutter = " " + (" " + number).slice(-maxWidth) + " | ";
          if (number === this.line) {
            let spacing = aside(gutter.replace(/\d/g, " ")) + line2.slice(0, this.column - 1).replace(/[^\t]/g, " ");
            return mark2(">") + aside(gutter) + line2 + "\n " + spacing + mark2("^");
          }
          return " " + aside(gutter) + line2;
        }).join("\n");
      }
      toString() {
        let code = this.showSourceCode();
        if (code) {
          code = "\n\n" + code + "\n";
        }
        return this.name + ": " + this.message + code;
      }
    };
    module2.exports = CssSyntaxError;
    CssSyntaxError.default = CssSyntaxError;
  }
});

// node_modules/postcss/lib/symbols.js
var require_symbols = __commonJS({
  "node_modules/postcss/lib/symbols.js"(exports2, module2) {
    "use strict";
    module2.exports.isClean = Symbol("isClean");
    module2.exports.my = Symbol("my");
  }
});

// node_modules/postcss/lib/stringifier.js
var require_stringifier = __commonJS({
  "node_modules/postcss/lib/stringifier.js"(exports2, module2) {
    "use strict";
    var DEFAULT_RAW = {
      colon: ": ",
      indent: "    ",
      beforeDecl: "\n",
      beforeRule: "\n",
      beforeOpen: " ",
      beforeClose: "\n",
      beforeComment: "\n",
      after: "\n",
      emptyBody: "",
      commentLeft: " ",
      commentRight: " ",
      semicolon: false
    };
    function capitalize(str) {
      return str[0].toUpperCase() + str.slice(1);
    }
    var Stringifier = class {
      constructor(builder) {
        this.builder = builder;
      }
      stringify(node2, semicolon2) {
        if (!this[node2.type]) {
          throw new Error("Unknown AST node type " + node2.type + ". Maybe you need to change PostCSS stringifier.");
        }
        this[node2.type](node2, semicolon2);
      }
      document(node2) {
        this.body(node2);
      }
      root(node2) {
        this.body(node2);
        if (node2.raws.after)
          this.builder(node2.raws.after);
      }
      comment(node2) {
        let left = this.raw(node2, "left", "commentLeft");
        let right = this.raw(node2, "right", "commentRight");
        this.builder("/*" + left + node2.text + right + "*/", node2);
      }
      decl(node2, semicolon2) {
        let between = this.raw(node2, "between", "colon");
        let string2 = node2.prop + between + this.rawValue(node2, "value");
        if (node2.important) {
          string2 += node2.raws.important || " !important";
        }
        if (semicolon2)
          string2 += ";";
        this.builder(string2, node2);
      }
      rule(node2) {
        this.block(node2, this.rawValue(node2, "selector"));
        if (node2.raws.ownSemicolon) {
          this.builder(node2.raws.ownSemicolon, node2, "end");
        }
      }
      atrule(node2, semicolon2) {
        let name = "@" + node2.name;
        let params = node2.params ? this.rawValue(node2, "params") : "";
        if (typeof node2.raws.afterName !== "undefined") {
          name += node2.raws.afterName;
        } else if (params) {
          name += " ";
        }
        if (node2.nodes) {
          this.block(node2, name + params);
        } else {
          let end = (node2.raws.between || "") + (semicolon2 ? ";" : "");
          this.builder(name + params + end, node2);
        }
      }
      body(node2) {
        let last = node2.nodes.length - 1;
        while (last > 0) {
          if (node2.nodes[last].type !== "comment")
            break;
          last -= 1;
        }
        let semicolon2 = this.raw(node2, "semicolon");
        for (let i2 = 0; i2 < node2.nodes.length; i2++) {
          let child = node2.nodes[i2];
          let before = this.raw(child, "before");
          if (before)
            this.builder(before);
          this.stringify(child, last !== i2 || semicolon2);
        }
      }
      block(node2, start) {
        let between = this.raw(node2, "between", "beforeOpen");
        this.builder(start + between + "{", node2, "start");
        let after;
        if (node2.nodes && node2.nodes.length) {
          this.body(node2);
          after = this.raw(node2, "after");
        } else {
          after = this.raw(node2, "after", "emptyBody");
        }
        if (after)
          this.builder(after);
        this.builder("}", node2, "end");
      }
      raw(node2, own, detect) {
        let value;
        if (!detect)
          detect = own;
        if (own) {
          value = node2.raws[own];
          if (typeof value !== "undefined")
            return value;
        }
        let parent = node2.parent;
        if (detect === "before") {
          if (!parent || parent.type === "root" && parent.first === node2) {
            return "";
          }
          if (parent && parent.type === "document") {
            return "";
          }
        }
        if (!parent)
          return DEFAULT_RAW[detect];
        let root2 = node2.root();
        if (!root2.rawCache)
          root2.rawCache = {};
        if (typeof root2.rawCache[detect] !== "undefined") {
          return root2.rawCache[detect];
        }
        if (detect === "before" || detect === "after") {
          return this.beforeAfter(node2, detect);
        } else {
          let method = "raw" + capitalize(detect);
          if (this[method]) {
            value = this[method](root2, node2);
          } else {
            root2.walk((i2) => {
              value = i2.raws[own];
              if (typeof value !== "undefined")
                return false;
            });
          }
        }
        if (typeof value === "undefined")
          value = DEFAULT_RAW[detect];
        root2.rawCache[detect] = value;
        return value;
      }
      rawSemicolon(root2) {
        let value;
        root2.walk((i2) => {
          if (i2.nodes && i2.nodes.length && i2.last.type === "decl") {
            value = i2.raws.semicolon;
            if (typeof value !== "undefined")
              return false;
          }
        });
        return value;
      }
      rawEmptyBody(root2) {
        let value;
        root2.walk((i2) => {
          if (i2.nodes && i2.nodes.length === 0) {
            value = i2.raws.after;
            if (typeof value !== "undefined")
              return false;
          }
        });
        return value;
      }
      rawIndent(root2) {
        if (root2.raws.indent)
          return root2.raws.indent;
        let value;
        root2.walk((i2) => {
          let p2 = i2.parent;
          if (p2 && p2 !== root2 && p2.parent && p2.parent === root2) {
            if (typeof i2.raws.before !== "undefined") {
              let parts = i2.raws.before.split("\n");
              value = parts[parts.length - 1];
              value = value.replace(/\S/g, "");
              return false;
            }
          }
        });
        return value;
      }
      rawBeforeComment(root2, node2) {
        let value;
        root2.walkComments((i2) => {
          if (typeof i2.raws.before !== "undefined") {
            value = i2.raws.before;
            if (value.includes("\n")) {
              value = value.replace(/[^\n]+$/, "");
            }
            return false;
          }
        });
        if (typeof value === "undefined") {
          value = this.raw(node2, null, "beforeDecl");
        } else if (value) {
          value = value.replace(/\S/g, "");
        }
        return value;
      }
      rawBeforeDecl(root2, node2) {
        let value;
        root2.walkDecls((i2) => {
          if (typeof i2.raws.before !== "undefined") {
            value = i2.raws.before;
            if (value.includes("\n")) {
              value = value.replace(/[^\n]+$/, "");
            }
            return false;
          }
        });
        if (typeof value === "undefined") {
          value = this.raw(node2, null, "beforeRule");
        } else if (value) {
          value = value.replace(/\S/g, "");
        }
        return value;
      }
      rawBeforeRule(root2) {
        let value;
        root2.walk((i2) => {
          if (i2.nodes && (i2.parent !== root2 || root2.first !== i2)) {
            if (typeof i2.raws.before !== "undefined") {
              value = i2.raws.before;
              if (value.includes("\n")) {
                value = value.replace(/[^\n]+$/, "");
              }
              return false;
            }
          }
        });
        if (value)
          value = value.replace(/\S/g, "");
        return value;
      }
      rawBeforeClose(root2) {
        let value;
        root2.walk((i2) => {
          if (i2.nodes && i2.nodes.length > 0) {
            if (typeof i2.raws.after !== "undefined") {
              value = i2.raws.after;
              if (value.includes("\n")) {
                value = value.replace(/[^\n]+$/, "");
              }
              return false;
            }
          }
        });
        if (value)
          value = value.replace(/\S/g, "");
        return value;
      }
      rawBeforeOpen(root2) {
        let value;
        root2.walk((i2) => {
          if (i2.type !== "decl") {
            value = i2.raws.between;
            if (typeof value !== "undefined")
              return false;
          }
        });
        return value;
      }
      rawColon(root2) {
        let value;
        root2.walkDecls((i2) => {
          if (typeof i2.raws.between !== "undefined") {
            value = i2.raws.between.replace(/[^\s:]/g, "");
            return false;
          }
        });
        return value;
      }
      beforeAfter(node2, detect) {
        let value;
        if (node2.type === "decl") {
          value = this.raw(node2, null, "beforeDecl");
        } else if (node2.type === "comment") {
          value = this.raw(node2, null, "beforeComment");
        } else if (detect === "before") {
          value = this.raw(node2, null, "beforeRule");
        } else {
          value = this.raw(node2, null, "beforeClose");
        }
        let buf = node2.parent;
        let depth2 = 0;
        while (buf && buf.type !== "root") {
          depth2 += 1;
          buf = buf.parent;
        }
        if (value.includes("\n")) {
          let indent = this.raw(node2, null, "indent");
          if (indent.length) {
            for (let step = 0; step < depth2; step++)
              value += indent;
          }
        }
        return value;
      }
      rawValue(node2, prop) {
        let value = node2[prop];
        let raw = node2.raws[prop];
        if (raw && raw.value === value) {
          return raw.raw;
        }
        return value;
      }
    };
    module2.exports = Stringifier;
    Stringifier.default = Stringifier;
  }
});

// node_modules/postcss/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/postcss/lib/stringify.js"(exports2, module2) {
    "use strict";
    var Stringifier = require_stringifier();
    function stringify2(node2, builder) {
      let str = new Stringifier(builder);
      str.stringify(node2);
    }
    module2.exports = stringify2;
    stringify2.default = stringify2;
  }
});

// node_modules/postcss/lib/node.js
var require_node = __commonJS({
  "node_modules/postcss/lib/node.js"(exports2, module2) {
    "use strict";
    var { isClean, my } = require_symbols();
    var CssSyntaxError = require_css_syntax_error();
    var Stringifier = require_stringifier();
    var stringify2 = require_stringify();
    function cloneNode(obj, parent) {
      let cloned = new obj.constructor();
      for (let i2 in obj) {
        if (!Object.prototype.hasOwnProperty.call(obj, i2)) {
          continue;
        }
        if (i2 === "proxyCache")
          continue;
        let value = obj[i2];
        let type = typeof value;
        if (i2 === "parent" && type === "object") {
          if (parent)
            cloned[i2] = parent;
        } else if (i2 === "source") {
          cloned[i2] = value;
        } else if (Array.isArray(value)) {
          cloned[i2] = value.map((j2) => cloneNode(j2, cloned));
        } else {
          if (type === "object" && value !== null)
            value = cloneNode(value);
          cloned[i2] = value;
        }
      }
      return cloned;
    }
    var Node2 = class {
      constructor(defaults = {}) {
        this.raws = {};
        this[isClean] = false;
        this[my] = true;
        for (let name in defaults) {
          if (name === "nodes") {
            this.nodes = [];
            for (let node2 of defaults[name]) {
              if (typeof node2.clone === "function") {
                this.append(node2.clone());
              } else {
                this.append(node2);
              }
            }
          } else {
            this[name] = defaults[name];
          }
        }
      }
      error(message, opts = {}) {
        if (this.source) {
          let { start, end } = this.rangeBy(opts);
          return this.source.input.error(message, { line: start.line, column: start.column }, { line: end.line, column: end.column }, opts);
        }
        return new CssSyntaxError(message);
      }
      warn(result2, text, opts) {
        let data2 = { node: this };
        for (let i2 in opts)
          data2[i2] = opts[i2];
        return result2.warn(text, data2);
      }
      remove() {
        if (this.parent) {
          this.parent.removeChild(this);
        }
        this.parent = void 0;
        return this;
      }
      toString(stringifier = stringify2) {
        if (stringifier.stringify)
          stringifier = stringifier.stringify;
        let result2 = "";
        stringifier(this, (i2) => {
          result2 += i2;
        });
        return result2;
      }
      assign(overrides = {}) {
        for (let name in overrides) {
          this[name] = overrides[name];
        }
        return this;
      }
      clone(overrides = {}) {
        let cloned = cloneNode(this);
        for (let name in overrides) {
          cloned[name] = overrides[name];
        }
        return cloned;
      }
      cloneBefore(overrides = {}) {
        let cloned = this.clone(overrides);
        this.parent.insertBefore(this, cloned);
        return cloned;
      }
      cloneAfter(overrides = {}) {
        let cloned = this.clone(overrides);
        this.parent.insertAfter(this, cloned);
        return cloned;
      }
      replaceWith(...nodes) {
        if (this.parent) {
          let bookmark = this;
          let foundSelf = false;
          for (let node2 of nodes) {
            if (node2 === this) {
              foundSelf = true;
            } else if (foundSelf) {
              this.parent.insertAfter(bookmark, node2);
              bookmark = node2;
            } else {
              this.parent.insertBefore(bookmark, node2);
            }
          }
          if (!foundSelf) {
            this.remove();
          }
        }
        return this;
      }
      next() {
        if (!this.parent)
          return void 0;
        let index2 = this.parent.index(this);
        return this.parent.nodes[index2 + 1];
      }
      prev() {
        if (!this.parent)
          return void 0;
        let index2 = this.parent.index(this);
        return this.parent.nodes[index2 - 1];
      }
      before(add) {
        this.parent.insertBefore(this, add);
        return this;
      }
      after(add) {
        this.parent.insertAfter(this, add);
        return this;
      }
      root() {
        let result2 = this;
        while (result2.parent && result2.parent.type !== "document") {
          result2 = result2.parent;
        }
        return result2;
      }
      raw(prop, defaultType) {
        let str = new Stringifier();
        return str.raw(this, prop, defaultType);
      }
      cleanRaws(keepBetween) {
        delete this.raws.before;
        delete this.raws.after;
        if (!keepBetween)
          delete this.raws.between;
      }
      toJSON(_2, inputs) {
        let fixed = {};
        let emitInputs = inputs == null;
        inputs = inputs || /* @__PURE__ */ new Map();
        let inputsNextIndex = 0;
        for (let name in this) {
          if (!Object.prototype.hasOwnProperty.call(this, name)) {
            continue;
          }
          if (name === "parent" || name === "proxyCache")
            continue;
          let value = this[name];
          if (Array.isArray(value)) {
            fixed[name] = value.map((i2) => {
              if (typeof i2 === "object" && i2.toJSON) {
                return i2.toJSON(null, inputs);
              } else {
                return i2;
              }
            });
          } else if (typeof value === "object" && value.toJSON) {
            fixed[name] = value.toJSON(null, inputs);
          } else if (name === "source") {
            let inputId = inputs.get(value.input);
            if (inputId == null) {
              inputId = inputsNextIndex;
              inputs.set(value.input, inputsNextIndex);
              inputsNextIndex++;
            }
            fixed[name] = {
              inputId,
              start: value.start,
              end: value.end
            };
          } else {
            fixed[name] = value;
          }
        }
        if (emitInputs) {
          fixed.inputs = [...inputs.keys()].map((input) => input.toJSON());
        }
        return fixed;
      }
      positionInside(index2) {
        let string2 = this.toString();
        let column2 = this.source.start.column;
        let line2 = this.source.start.line;
        for (let i2 = 0; i2 < index2; i2++) {
          if (string2[i2] === "\n") {
            column2 = 1;
            line2 += 1;
          } else {
            column2 += 1;
          }
        }
        return { line: line2, column: column2 };
      }
      positionBy(opts) {
        let pos2 = this.source.start;
        if (opts.index) {
          pos2 = this.positionInside(opts.index);
        } else if (opts.word) {
          let index2 = this.toString().indexOf(opts.word);
          if (index2 !== -1)
            pos2 = this.positionInside(index2);
        }
        return pos2;
      }
      rangeBy(opts) {
        let start = {
          line: this.source.start.line,
          column: this.source.start.column
        };
        let end = this.source.end ? {
          line: this.source.end.line,
          column: this.source.end.column + 1
        } : {
          line: start.line,
          column: start.column + 1
        };
        if (opts.word) {
          let index2 = this.toString().indexOf(opts.word);
          if (index2 !== -1) {
            start = this.positionInside(index2);
            end = this.positionInside(index2 + opts.word.length);
          }
        } else {
          if (opts.start) {
            start = {
              line: opts.start.line,
              column: opts.start.column
            };
          } else if (opts.index) {
            start = this.positionInside(opts.index);
          }
          if (opts.end) {
            end = {
              line: opts.end.line,
              column: opts.end.column
            };
          } else if (opts.endIndex) {
            end = this.positionInside(opts.endIndex);
          } else if (opts.index) {
            end = this.positionInside(opts.index + 1);
          }
        }
        if (end.line < start.line || end.line === start.line && end.column <= start.column) {
          end = { line: start.line, column: start.column + 1 };
        }
        return { start, end };
      }
      getProxyProcessor() {
        return {
          set(node2, prop, value) {
            if (node2[prop] === value)
              return true;
            node2[prop] = value;
            if (prop === "prop" || prop === "value" || prop === "name" || prop === "params" || prop === "important" || prop === "text") {
              node2.markDirty();
            }
            return true;
          },
          get(node2, prop) {
            if (prop === "proxyOf") {
              return node2;
            } else if (prop === "root") {
              return () => node2.root().toProxy();
            } else {
              return node2[prop];
            }
          }
        };
      }
      toProxy() {
        if (!this.proxyCache) {
          this.proxyCache = new Proxy(this, this.getProxyProcessor());
        }
        return this.proxyCache;
      }
      addToError(error2) {
        error2.postcssNode = this;
        if (error2.stack && this.source && /\n\s{4}at /.test(error2.stack)) {
          let s2 = this.source;
          error2.stack = error2.stack.replace(/\n\s{4}at /, `$&${s2.input.from}:${s2.start.line}:${s2.start.column}$&`);
        }
        return error2;
      }
      markDirty() {
        if (this[isClean]) {
          this[isClean] = false;
          let next = this;
          while (next = next.parent) {
            next[isClean] = false;
          }
        }
      }
      get proxyOf() {
        return this;
      }
    };
    module2.exports = Node2;
    Node2.default = Node2;
  }
});

// node_modules/postcss/lib/declaration.js
var require_declaration = __commonJS({
  "node_modules/postcss/lib/declaration.js"(exports2, module2) {
    "use strict";
    var Node2 = require_node();
    var Declaration = class extends Node2 {
      constructor(defaults) {
        if (defaults && typeof defaults.value !== "undefined" && typeof defaults.value !== "string") {
          defaults = __spreadProps2(__spreadValues2({}, defaults), { value: String(defaults.value) });
        }
        super(defaults);
        this.type = "decl";
      }
      get variable() {
        return this.prop.startsWith("--") || this.prop[0] === "$";
      }
    };
    module2.exports = Declaration;
    Declaration.default = Declaration;
  }
});

// node_modules/source-map-js/lib/base64.js
var require_base64 = __commonJS({
  "node_modules/source-map-js/lib/base64.js"(exports2) {
    var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
    exports2.encode = function(number) {
      if (0 <= number && number < intToCharMap.length) {
        return intToCharMap[number];
      }
      throw new TypeError("Must be between 0 and 63: " + number);
    };
    exports2.decode = function(charCode) {
      var bigA = 65;
      var bigZ = 90;
      var littleA = 97;
      var littleZ = 122;
      var zero = 48;
      var nine = 57;
      var plus = 43;
      var slash2 = 47;
      var littleOffset = 26;
      var numberOffset = 52;
      if (bigA <= charCode && charCode <= bigZ) {
        return charCode - bigA;
      }
      if (littleA <= charCode && charCode <= littleZ) {
        return charCode - littleA + littleOffset;
      }
      if (zero <= charCode && charCode <= nine) {
        return charCode - zero + numberOffset;
      }
      if (charCode == plus) {
        return 62;
      }
      if (charCode == slash2) {
        return 63;
      }
      return -1;
    };
  }
});

// node_modules/source-map-js/lib/base64-vlq.js
var require_base64_vlq = __commonJS({
  "node_modules/source-map-js/lib/base64-vlq.js"(exports2) {
    var base64 = require_base64();
    var VLQ_BASE_SHIFT = 5;
    var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
    var VLQ_BASE_MASK = VLQ_BASE - 1;
    var VLQ_CONTINUATION_BIT = VLQ_BASE;
    function toVLQSigned(aValue) {
      return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
    }
    function fromVLQSigned(aValue) {
      var isNegative = (aValue & 1) === 1;
      var shifted = aValue >> 1;
      return isNegative ? -shifted : shifted;
    }
    exports2.encode = function base64VLQ_encode(aValue) {
      var encoded = "";
      var digit;
      var vlq = toVLQSigned(aValue);
      do {
        digit = vlq & VLQ_BASE_MASK;
        vlq >>>= VLQ_BASE_SHIFT;
        if (vlq > 0) {
          digit |= VLQ_CONTINUATION_BIT;
        }
        encoded += base64.encode(digit);
      } while (vlq > 0);
      return encoded;
    };
    exports2.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
      var strLen = aStr.length;
      var result2 = 0;
      var shift = 0;
      var continuation, digit;
      do {
        if (aIndex >= strLen) {
          throw new Error("Expected more digits in base 64 VLQ value.");
        }
        digit = base64.decode(aStr.charCodeAt(aIndex++));
        if (digit === -1) {
          throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
        }
        continuation = !!(digit & VLQ_CONTINUATION_BIT);
        digit &= VLQ_BASE_MASK;
        result2 = result2 + (digit << shift);
        shift += VLQ_BASE_SHIFT;
      } while (continuation);
      aOutParam.value = fromVLQSigned(result2);
      aOutParam.rest = aIndex;
    };
  }
});

// node_modules/source-map-js/lib/util.js
var require_util = __commonJS({
  "node_modules/source-map-js/lib/util.js"(exports2) {
    function getArg(aArgs, aName, aDefaultValue) {
      if (aName in aArgs) {
        return aArgs[aName];
      } else if (arguments.length === 3) {
        return aDefaultValue;
      } else {
        throw new Error('"' + aName + '" is a required argument.');
      }
    }
    exports2.getArg = getArg;
    var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
    var dataUrlRegexp = /^data:.+\,.+$/;
    function urlParse(aUrl) {
      var match2 = aUrl.match(urlRegexp);
      if (!match2) {
        return null;
      }
      return {
        scheme: match2[1],
        auth: match2[2],
        host: match2[3],
        port: match2[4],
        path: match2[5]
      };
    }
    exports2.urlParse = urlParse;
    function urlGenerate(aParsedUrl) {
      var url2 = "";
      if (aParsedUrl.scheme) {
        url2 += aParsedUrl.scheme + ":";
      }
      url2 += "//";
      if (aParsedUrl.auth) {
        url2 += aParsedUrl.auth + "@";
      }
      if (aParsedUrl.host) {
        url2 += aParsedUrl.host;
      }
      if (aParsedUrl.port) {
        url2 += ":" + aParsedUrl.port;
      }
      if (aParsedUrl.path) {
        url2 += aParsedUrl.path;
      }
      return url2;
    }
    exports2.urlGenerate = urlGenerate;
    var MAX_CACHED_INPUTS = 32;
    function lruMemoize(f2) {
      var cache2 = [];
      return function(input) {
        for (var i2 = 0; i2 < cache2.length; i2++) {
          if (cache2[i2].input === input) {
            var temp = cache2[0];
            cache2[0] = cache2[i2];
            cache2[i2] = temp;
            return cache2[0].result;
          }
        }
        var result2 = f2(input);
        cache2.unshift({
          input,
          result: result2
        });
        if (cache2.length > MAX_CACHED_INPUTS) {
          cache2.pop();
        }
        return result2;
      };
    }
    var normalize = lruMemoize(function normalize2(aPath) {
      var path2 = aPath;
      var url2 = urlParse(aPath);
      if (url2) {
        if (!url2.path) {
          return aPath;
        }
        path2 = url2.path;
      }
      var isAbsolute2 = exports2.isAbsolute(path2);
      var parts = [];
      var start = 0;
      var i2 = 0;
      while (true) {
        start = i2;
        i2 = path2.indexOf("/", start);
        if (i2 === -1) {
          parts.push(path2.slice(start));
          break;
        } else {
          parts.push(path2.slice(start, i2));
          while (i2 < path2.length && path2[i2] === "/") {
            i2++;
          }
        }
      }
      for (var part, up = 0, i2 = parts.length - 1; i2 >= 0; i2--) {
        part = parts[i2];
        if (part === ".") {
          parts.splice(i2, 1);
        } else if (part === "..") {
          up++;
        } else if (up > 0) {
          if (part === "") {
            parts.splice(i2 + 1, up);
            up = 0;
          } else {
            parts.splice(i2, 2);
            up--;
          }
        }
      }
      path2 = parts.join("/");
      if (path2 === "") {
        path2 = isAbsolute2 ? "/" : ".";
      }
      if (url2) {
        url2.path = path2;
        return urlGenerate(url2);
      }
      return path2;
    });
    exports2.normalize = normalize;
    function join(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      if (aPath === "") {
        aPath = ".";
      }
      var aPathUrl = urlParse(aPath);
      var aRootUrl = urlParse(aRoot);
      if (aRootUrl) {
        aRoot = aRootUrl.path || "/";
      }
      if (aPathUrl && !aPathUrl.scheme) {
        if (aRootUrl) {
          aPathUrl.scheme = aRootUrl.scheme;
        }
        return urlGenerate(aPathUrl);
      }
      if (aPathUrl || aPath.match(dataUrlRegexp)) {
        return aPath;
      }
      if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
        aRootUrl.host = aPath;
        return urlGenerate(aRootUrl);
      }
      var joined = aPath.charAt(0) === "/" ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
      if (aRootUrl) {
        aRootUrl.path = joined;
        return urlGenerate(aRootUrl);
      }
      return joined;
    }
    exports2.join = join;
    exports2.isAbsolute = function(aPath) {
      return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
    };
    function relative(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      aRoot = aRoot.replace(/\/$/, "");
      var level2 = 0;
      while (aPath.indexOf(aRoot + "/") !== 0) {
        var index2 = aRoot.lastIndexOf("/");
        if (index2 < 0) {
          return aPath;
        }
        aRoot = aRoot.slice(0, index2);
        if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
          return aPath;
        }
        ++level2;
      }
      return Array(level2 + 1).join("../") + aPath.substr(aRoot.length + 1);
    }
    exports2.relative = relative;
    var supportsNullProto = function() {
      var obj = /* @__PURE__ */ Object.create(null);
      return !("__proto__" in obj);
    }();
    function identity(s2) {
      return s2;
    }
    function toSetString(aStr) {
      if (isProtoString(aStr)) {
        return "$" + aStr;
      }
      return aStr;
    }
    exports2.toSetString = supportsNullProto ? identity : toSetString;
    function fromSetString(aStr) {
      if (isProtoString(aStr)) {
        return aStr.slice(1);
      }
      return aStr;
    }
    exports2.fromSetString = supportsNullProto ? identity : fromSetString;
    function isProtoString(s2) {
      if (!s2) {
        return false;
      }
      var length = s2.length;
      if (length < 9) {
        return false;
      }
      if (s2.charCodeAt(length - 1) !== 95 || s2.charCodeAt(length - 2) !== 95 || s2.charCodeAt(length - 3) !== 111 || s2.charCodeAt(length - 4) !== 116 || s2.charCodeAt(length - 5) !== 111 || s2.charCodeAt(length - 6) !== 114 || s2.charCodeAt(length - 7) !== 112 || s2.charCodeAt(length - 8) !== 95 || s2.charCodeAt(length - 9) !== 95) {
        return false;
      }
      for (var i2 = length - 10; i2 >= 0; i2--) {
        if (s2.charCodeAt(i2) !== 36) {
          return false;
        }
      }
      return true;
    }
    function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
      var cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports2.compareByOriginalPositions = compareByOriginalPositions;
    function compareByOriginalPositionsNoSource(mappingA, mappingB, onlyCompareOriginal) {
      var cmp;
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports2.compareByOriginalPositionsNoSource = compareByOriginalPositionsNoSource;
    function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports2.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
    function compareByGeneratedPositionsDeflatedNoLine(mappingA, mappingB, onlyCompareGenerated) {
      var cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports2.compareByGeneratedPositionsDeflatedNoLine = compareByGeneratedPositionsDeflatedNoLine;
    function strcmp(aStr1, aStr2) {
      if (aStr1 === aStr2) {
        return 0;
      }
      if (aStr1 === null) {
        return 1;
      }
      if (aStr2 === null) {
        return -1;
      }
      if (aStr1 > aStr2) {
        return 1;
      }
      return -1;
    }
    function compareByGeneratedPositionsInflated(mappingA, mappingB) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports2.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
    function parseSourceMapInput(str) {
      return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
    }
    exports2.parseSourceMapInput = parseSourceMapInput;
    function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
      sourceURL = sourceURL || "";
      if (sourceRoot) {
        if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
          sourceRoot += "/";
        }
        sourceURL = sourceRoot + sourceURL;
      }
      if (sourceMapURL) {
        var parsed = urlParse(sourceMapURL);
        if (!parsed) {
          throw new Error("sourceMapURL could not be parsed");
        }
        if (parsed.path) {
          var index2 = parsed.path.lastIndexOf("/");
          if (index2 >= 0) {
            parsed.path = parsed.path.substring(0, index2 + 1);
          }
        }
        sourceURL = join(urlGenerate(parsed), sourceURL);
      }
      return normalize(sourceURL);
    }
    exports2.computeSourceURL = computeSourceURL;
  }
});

// node_modules/source-map-js/lib/array-set.js
var require_array_set = __commonJS({
  "node_modules/source-map-js/lib/array-set.js"(exports2) {
    var util2 = require_util();
    var has = Object.prototype.hasOwnProperty;
    var hasNativeMap = typeof Map !== "undefined";
    function ArraySet() {
      this._array = [];
      this._set = hasNativeMap ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
    }
    ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
      var set2 = new ArraySet();
      for (var i2 = 0, len = aArray.length; i2 < len; i2++) {
        set2.add(aArray[i2], aAllowDuplicates);
      }
      return set2;
    };
    ArraySet.prototype.size = function ArraySet_size() {
      return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
    };
    ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
      var sStr = hasNativeMap ? aStr : util2.toSetString(aStr);
      var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
      var idx = this._array.length;
      if (!isDuplicate || aAllowDuplicates) {
        this._array.push(aStr);
      }
      if (!isDuplicate) {
        if (hasNativeMap) {
          this._set.set(aStr, idx);
        } else {
          this._set[sStr] = idx;
        }
      }
    };
    ArraySet.prototype.has = function ArraySet_has(aStr) {
      if (hasNativeMap) {
        return this._set.has(aStr);
      } else {
        var sStr = util2.toSetString(aStr);
        return has.call(this._set, sStr);
      }
    };
    ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
      if (hasNativeMap) {
        var idx = this._set.get(aStr);
        if (idx >= 0) {
          return idx;
        }
      } else {
        var sStr = util2.toSetString(aStr);
        if (has.call(this._set, sStr)) {
          return this._set[sStr];
        }
      }
      throw new Error('"' + aStr + '" is not in the set.');
    };
    ArraySet.prototype.at = function ArraySet_at(aIdx) {
      if (aIdx >= 0 && aIdx < this._array.length) {
        return this._array[aIdx];
      }
      throw new Error("No element indexed by " + aIdx);
    };
    ArraySet.prototype.toArray = function ArraySet_toArray() {
      return this._array.slice();
    };
    exports2.ArraySet = ArraySet;
  }
});

// node_modules/source-map-js/lib/mapping-list.js
var require_mapping_list = __commonJS({
  "node_modules/source-map-js/lib/mapping-list.js"(exports2) {
    var util2 = require_util();
    function generatedPositionAfter(mappingA, mappingB) {
      var lineA = mappingA.generatedLine;
      var lineB = mappingB.generatedLine;
      var columnA = mappingA.generatedColumn;
      var columnB = mappingB.generatedColumn;
      return lineB > lineA || lineB == lineA && columnB >= columnA || util2.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
    }
    function MappingList() {
      this._array = [];
      this._sorted = true;
      this._last = { generatedLine: -1, generatedColumn: 0 };
    }
    MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
      this._array.forEach(aCallback, aThisArg);
    };
    MappingList.prototype.add = function MappingList_add(aMapping) {
      if (generatedPositionAfter(this._last, aMapping)) {
        this._last = aMapping;
        this._array.push(aMapping);
      } else {
        this._sorted = false;
        this._array.push(aMapping);
      }
    };
    MappingList.prototype.toArray = function MappingList_toArray() {
      if (!this._sorted) {
        this._array.sort(util2.compareByGeneratedPositionsInflated);
        this._sorted = true;
      }
      return this._array;
    };
    exports2.MappingList = MappingList;
  }
});

// node_modules/source-map-js/lib/source-map-generator.js
var require_source_map_generator = __commonJS({
  "node_modules/source-map-js/lib/source-map-generator.js"(exports2) {
    var base64VLQ = require_base64_vlq();
    var util2 = require_util();
    var ArraySet = require_array_set().ArraySet;
    var MappingList = require_mapping_list().MappingList;
    function SourceMapGenerator(aArgs) {
      if (!aArgs) {
        aArgs = {};
      }
      this._file = util2.getArg(aArgs, "file", null);
      this._sourceRoot = util2.getArg(aArgs, "sourceRoot", null);
      this._skipValidation = util2.getArg(aArgs, "skipValidation", false);
      this._sources = new ArraySet();
      this._names = new ArraySet();
      this._mappings = new MappingList();
      this._sourcesContents = null;
    }
    SourceMapGenerator.prototype._version = 3;
    SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
      var sourceRoot = aSourceMapConsumer.sourceRoot;
      var generator = new SourceMapGenerator({
        file: aSourceMapConsumer.file,
        sourceRoot
      });
      aSourceMapConsumer.eachMapping(function(mapping) {
        var newMapping = {
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          }
        };
        if (mapping.source != null) {
          newMapping.source = mapping.source;
          if (sourceRoot != null) {
            newMapping.source = util2.relative(sourceRoot, newMapping.source);
          }
          newMapping.original = {
            line: mapping.originalLine,
            column: mapping.originalColumn
          };
          if (mapping.name != null) {
            newMapping.name = mapping.name;
          }
        }
        generator.addMapping(newMapping);
      });
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var sourceRelative = sourceFile;
        if (sourceRoot !== null) {
          sourceRelative = util2.relative(sourceRoot, sourceFile);
        }
        if (!generator._sources.has(sourceRelative)) {
          generator._sources.add(sourceRelative);
        }
        var content2 = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content2 != null) {
          generator.setSourceContent(sourceFile, content2);
        }
      });
      return generator;
    };
    SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
      var generated = util2.getArg(aArgs, "generated");
      var original = util2.getArg(aArgs, "original", null);
      var source2 = util2.getArg(aArgs, "source", null);
      var name = util2.getArg(aArgs, "name", null);
      if (!this._skipValidation) {
        this._validateMapping(generated, original, source2, name);
      }
      if (source2 != null) {
        source2 = String(source2);
        if (!this._sources.has(source2)) {
          this._sources.add(source2);
        }
      }
      if (name != null) {
        name = String(name);
        if (!this._names.has(name)) {
          this._names.add(name);
        }
      }
      this._mappings.add({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source: source2,
        name
      });
    };
    SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
      var source2 = aSourceFile;
      if (this._sourceRoot != null) {
        source2 = util2.relative(this._sourceRoot, source2);
      }
      if (aSourceContent != null) {
        if (!this._sourcesContents) {
          this._sourcesContents = /* @__PURE__ */ Object.create(null);
        }
        this._sourcesContents[util2.toSetString(source2)] = aSourceContent;
      } else if (this._sourcesContents) {
        delete this._sourcesContents[util2.toSetString(source2)];
        if (Object.keys(this._sourcesContents).length === 0) {
          this._sourcesContents = null;
        }
      }
    };
    SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
      var sourceFile = aSourceFile;
      if (aSourceFile == null) {
        if (aSourceMapConsumer.file == null) {
          throw new Error(`SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`);
        }
        sourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      if (sourceRoot != null) {
        sourceFile = util2.relative(sourceRoot, sourceFile);
      }
      var newSources = new ArraySet();
      var newNames = new ArraySet();
      this._mappings.unsortedForEach(function(mapping) {
        if (mapping.source === sourceFile && mapping.originalLine != null) {
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
          });
          if (original.source != null) {
            mapping.source = original.source;
            if (aSourceMapPath != null) {
              mapping.source = util2.join(aSourceMapPath, mapping.source);
            }
            if (sourceRoot != null) {
              mapping.source = util2.relative(sourceRoot, mapping.source);
            }
            mapping.originalLine = original.line;
            mapping.originalColumn = original.column;
            if (original.name != null) {
              mapping.name = original.name;
            }
          }
        }
        var source2 = mapping.source;
        if (source2 != null && !newSources.has(source2)) {
          newSources.add(source2);
        }
        var name = mapping.name;
        if (name != null && !newNames.has(name)) {
          newNames.add(name);
        }
      }, this);
      this._sources = newSources;
      this._names = newNames;
      aSourceMapConsumer.sources.forEach(function(sourceFile2) {
        var content2 = aSourceMapConsumer.sourceContentFor(sourceFile2);
        if (content2 != null) {
          if (aSourceMapPath != null) {
            sourceFile2 = util2.join(aSourceMapPath, sourceFile2);
          }
          if (sourceRoot != null) {
            sourceFile2 = util2.relative(sourceRoot, sourceFile2);
          }
          this.setSourceContent(sourceFile2, content2);
        }
      }, this);
    };
    SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
      if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
        throw new Error("original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.");
      }
      if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
        return;
      } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
        return;
      } else {
        throw new Error("Invalid mapping: " + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          original: aOriginal,
          name: aName
        }));
      }
    };
    SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
      var previousGeneratedColumn = 0;
      var previousGeneratedLine = 1;
      var previousOriginalColumn = 0;
      var previousOriginalLine = 0;
      var previousName = 0;
      var previousSource = 0;
      var result2 = "";
      var next;
      var mapping;
      var nameIdx;
      var sourceIdx;
      var mappings = this._mappings.toArray();
      for (var i2 = 0, len = mappings.length; i2 < len; i2++) {
        mapping = mappings[i2];
        next = "";
        if (mapping.generatedLine !== previousGeneratedLine) {
          previousGeneratedColumn = 0;
          while (mapping.generatedLine !== previousGeneratedLine) {
            next += ";";
            previousGeneratedLine++;
          }
        } else {
          if (i2 > 0) {
            if (!util2.compareByGeneratedPositionsInflated(mapping, mappings[i2 - 1])) {
              continue;
            }
            next += ",";
          }
        }
        next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;
        if (mapping.source != null) {
          sourceIdx = this._sources.indexOf(mapping.source);
          next += base64VLQ.encode(sourceIdx - previousSource);
          previousSource = sourceIdx;
          next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
          previousOriginalLine = mapping.originalLine - 1;
          next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
          previousOriginalColumn = mapping.originalColumn;
          if (mapping.name != null) {
            nameIdx = this._names.indexOf(mapping.name);
            next += base64VLQ.encode(nameIdx - previousName);
            previousName = nameIdx;
          }
        }
        result2 += next;
      }
      return result2;
    };
    SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
      return aSources.map(function(source2) {
        if (!this._sourcesContents) {
          return null;
        }
        if (aSourceRoot != null) {
          source2 = util2.relative(aSourceRoot, source2);
        }
        var key2 = util2.toSetString(source2);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents, key2) ? this._sourcesContents[key2] : null;
      }, this);
    };
    SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
      var map2 = {
        version: this._version,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      if (this._file != null) {
        map2.file = this._file;
      }
      if (this._sourceRoot != null) {
        map2.sourceRoot = this._sourceRoot;
      }
      if (this._sourcesContents) {
        map2.sourcesContent = this._generateSourcesContent(map2.sources, map2.sourceRoot);
      }
      return map2;
    };
    SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
      return JSON.stringify(this.toJSON());
    };
    exports2.SourceMapGenerator = SourceMapGenerator;
  }
});

// node_modules/source-map-js/lib/binary-search.js
var require_binary_search = __commonJS({
  "node_modules/source-map-js/lib/binary-search.js"(exports2) {
    exports2.GREATEST_LOWER_BOUND = 1;
    exports2.LEAST_UPPER_BOUND = 2;
    function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
      var mid = Math.floor((aHigh - aLow) / 2) + aLow;
      var cmp = aCompare(aNeedle, aHaystack[mid], true);
      if (cmp === 0) {
        return mid;
      } else if (cmp > 0) {
        if (aHigh - mid > 1) {
          return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
        }
        if (aBias == exports2.LEAST_UPPER_BOUND) {
          return aHigh < aHaystack.length ? aHigh : -1;
        } else {
          return mid;
        }
      } else {
        if (mid - aLow > 1) {
          return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
        }
        if (aBias == exports2.LEAST_UPPER_BOUND) {
          return mid;
        } else {
          return aLow < 0 ? -1 : aLow;
        }
      }
    }
    exports2.search = function search(aNeedle, aHaystack, aCompare, aBias) {
      if (aHaystack.length === 0) {
        return -1;
      }
      var index2 = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports2.GREATEST_LOWER_BOUND);
      if (index2 < 0) {
        return -1;
      }
      while (index2 - 1 >= 0) {
        if (aCompare(aHaystack[index2], aHaystack[index2 - 1], true) !== 0) {
          break;
        }
        --index2;
      }
      return index2;
    };
  }
});

// node_modules/source-map-js/lib/quick-sort.js
var require_quick_sort = __commonJS({
  "node_modules/source-map-js/lib/quick-sort.js"(exports2) {
    function SortTemplate(comparator) {
      function swap(ary, x2, y3) {
        var temp = ary[x2];
        ary[x2] = ary[y3];
        ary[y3] = temp;
      }
      function randomIntInRange(low, high) {
        return Math.round(low + Math.random() * (high - low));
      }
      function doQuickSort(ary, comparator2, p2, r2) {
        if (p2 < r2) {
          var pivotIndex = randomIntInRange(p2, r2);
          var i2 = p2 - 1;
          swap(ary, pivotIndex, r2);
          var pivot = ary[r2];
          for (var j2 = p2; j2 < r2; j2++) {
            if (comparator2(ary[j2], pivot, false) <= 0) {
              i2 += 1;
              swap(ary, i2, j2);
            }
          }
          swap(ary, i2 + 1, j2);
          var q2 = i2 + 1;
          doQuickSort(ary, comparator2, p2, q2 - 1);
          doQuickSort(ary, comparator2, q2 + 1, r2);
        }
      }
      return doQuickSort;
    }
    function cloneSort(comparator) {
      let template = SortTemplate.toString();
      let templateFn = new Function(`return ${template}`)();
      return templateFn(comparator);
    }
    var sortCache = /* @__PURE__ */ new WeakMap();
    exports2.quickSort = function(ary, comparator, start = 0) {
      let doQuickSort = sortCache.get(comparator);
      if (doQuickSort === void 0) {
        doQuickSort = cloneSort(comparator);
        sortCache.set(comparator, doQuickSort);
      }
      doQuickSort(ary, comparator, start, ary.length - 1);
    };
  }
});

// node_modules/source-map-js/lib/source-map-consumer.js
var require_source_map_consumer = __commonJS({
  "node_modules/source-map-js/lib/source-map-consumer.js"(exports2) {
    var util2 = require_util();
    var binarySearch2 = require_binary_search();
    var ArraySet = require_array_set().ArraySet;
    var base64VLQ = require_base64_vlq();
    var quickSort = require_quick_sort().quickSort;
    function SourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util2.parseSourceMapInput(aSourceMap);
      }
      return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
    }
    SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
      return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
    };
    SourceMapConsumer.prototype._version = 3;
    SourceMapConsumer.prototype.__generatedMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", {
      configurable: true,
      enumerable: true,
      get: function() {
        if (!this.__generatedMappings) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__generatedMappings;
      }
    });
    SourceMapConsumer.prototype.__originalMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", {
      configurable: true,
      enumerable: true,
      get: function() {
        if (!this.__originalMappings) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__originalMappings;
      }
    });
    SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index2) {
      var c3 = aStr.charAt(index2);
      return c3 === ";" || c3 === ",";
    };
    SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      throw new Error("Subclasses must implement _parseMappings");
    };
    SourceMapConsumer.GENERATED_ORDER = 1;
    SourceMapConsumer.ORIGINAL_ORDER = 2;
    SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
    SourceMapConsumer.LEAST_UPPER_BOUND = 2;
    SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
      var context2 = aContext || null;
      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
      var mappings;
      switch (order) {
        case SourceMapConsumer.GENERATED_ORDER:
          mappings = this._generatedMappings;
          break;
        case SourceMapConsumer.ORIGINAL_ORDER:
          mappings = this._originalMappings;
          break;
        default:
          throw new Error("Unknown order of iteration.");
      }
      var sourceRoot = this.sourceRoot;
      var boundCallback = aCallback.bind(context2);
      var names = this._names;
      var sources = this._sources;
      var sourceMapURL = this._sourceMapURL;
      for (var i2 = 0, n3 = mappings.length; i2 < n3; i2++) {
        var mapping = mappings[i2];
        var source2 = mapping.source === null ? null : sources.at(mapping.source);
        source2 = util2.computeSourceURL(sourceRoot, source2, sourceMapURL);
        boundCallback({
          source: source2,
          generatedLine: mapping.generatedLine,
          generatedColumn: mapping.generatedColumn,
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: mapping.name === null ? null : names.at(mapping.name)
        });
      }
    };
    SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
      var line2 = util2.getArg(aArgs, "line");
      var needle = {
        source: util2.getArg(aArgs, "source"),
        originalLine: line2,
        originalColumn: util2.getArg(aArgs, "column", 0)
      };
      needle.source = this._findSourceIndex(needle.source);
      if (needle.source < 0) {
        return [];
      }
      var mappings = [];
      var index2 = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util2.compareByOriginalPositions, binarySearch2.LEAST_UPPER_BOUND);
      if (index2 >= 0) {
        var mapping = this._originalMappings[index2];
        if (aArgs.column === void 0) {
          var originalLine = mapping.originalLine;
          while (mapping && mapping.originalLine === originalLine) {
            mappings.push({
              line: util2.getArg(mapping, "generatedLine", null),
              column: util2.getArg(mapping, "generatedColumn", null),
              lastColumn: util2.getArg(mapping, "lastGeneratedColumn", null)
            });
            mapping = this._originalMappings[++index2];
          }
        } else {
          var originalColumn = mapping.originalColumn;
          while (mapping && mapping.originalLine === line2 && mapping.originalColumn == originalColumn) {
            mappings.push({
              line: util2.getArg(mapping, "generatedLine", null),
              column: util2.getArg(mapping, "generatedColumn", null),
              lastColumn: util2.getArg(mapping, "lastGeneratedColumn", null)
            });
            mapping = this._originalMappings[++index2];
          }
        }
      }
      return mappings;
    };
    exports2.SourceMapConsumer = SourceMapConsumer;
    function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util2.parseSourceMapInput(aSourceMap);
      }
      var version2 = util2.getArg(sourceMap, "version");
      var sources = util2.getArg(sourceMap, "sources");
      var names = util2.getArg(sourceMap, "names", []);
      var sourceRoot = util2.getArg(sourceMap, "sourceRoot", null);
      var sourcesContent = util2.getArg(sourceMap, "sourcesContent", null);
      var mappings = util2.getArg(sourceMap, "mappings");
      var file = util2.getArg(sourceMap, "file", null);
      if (version2 != this._version) {
        throw new Error("Unsupported version: " + version2);
      }
      if (sourceRoot) {
        sourceRoot = util2.normalize(sourceRoot);
      }
      sources = sources.map(String).map(util2.normalize).map(function(source2) {
        return sourceRoot && util2.isAbsolute(sourceRoot) && util2.isAbsolute(source2) ? util2.relative(sourceRoot, source2) : source2;
      });
      this._names = ArraySet.fromArray(names.map(String), true);
      this._sources = ArraySet.fromArray(sources, true);
      this._absoluteSources = this._sources.toArray().map(function(s2) {
        return util2.computeSourceURL(sourceRoot, s2, aSourceMapURL);
      });
      this.sourceRoot = sourceRoot;
      this.sourcesContent = sourcesContent;
      this._mappings = mappings;
      this._sourceMapURL = aSourceMapURL;
      this.file = file;
    }
    BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
    BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
      var relativeSource = aSource;
      if (this.sourceRoot != null) {
        relativeSource = util2.relative(this.sourceRoot, relativeSource);
      }
      if (this._sources.has(relativeSource)) {
        return this._sources.indexOf(relativeSource);
      }
      var i2;
      for (i2 = 0; i2 < this._absoluteSources.length; ++i2) {
        if (this._absoluteSources[i2] == aSource) {
          return i2;
        }
      }
      return -1;
    };
    BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
      var smc = Object.create(BasicSourceMapConsumer.prototype);
      var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
      var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
      smc.sourceRoot = aSourceMap._sourceRoot;
      smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
      smc.file = aSourceMap._file;
      smc._sourceMapURL = aSourceMapURL;
      smc._absoluteSources = smc._sources.toArray().map(function(s2) {
        return util2.computeSourceURL(smc.sourceRoot, s2, aSourceMapURL);
      });
      var generatedMappings = aSourceMap._mappings.toArray().slice();
      var destGeneratedMappings = smc.__generatedMappings = [];
      var destOriginalMappings = smc.__originalMappings = [];
      for (var i2 = 0, length = generatedMappings.length; i2 < length; i2++) {
        var srcMapping = generatedMappings[i2];
        var destMapping = new Mapping();
        destMapping.generatedLine = srcMapping.generatedLine;
        destMapping.generatedColumn = srcMapping.generatedColumn;
        if (srcMapping.source) {
          destMapping.source = sources.indexOf(srcMapping.source);
          destMapping.originalLine = srcMapping.originalLine;
          destMapping.originalColumn = srcMapping.originalColumn;
          if (srcMapping.name) {
            destMapping.name = names.indexOf(srcMapping.name);
          }
          destOriginalMappings.push(destMapping);
        }
        destGeneratedMappings.push(destMapping);
      }
      quickSort(smc.__originalMappings, util2.compareByOriginalPositions);
      return smc;
    };
    BasicSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
      get: function() {
        return this._absoluteSources.slice();
      }
    });
    function Mapping() {
      this.generatedLine = 0;
      this.generatedColumn = 0;
      this.source = null;
      this.originalLine = null;
      this.originalColumn = null;
      this.name = null;
    }
    var compareGenerated = util2.compareByGeneratedPositionsDeflatedNoLine;
    function sortGenerated(array2, start) {
      let l2 = array2.length;
      let n3 = array2.length - start;
      if (n3 <= 1) {
        return;
      } else if (n3 == 2) {
        let a2 = array2[start];
        let b2 = array2[start + 1];
        if (compareGenerated(a2, b2) > 0) {
          array2[start] = b2;
          array2[start + 1] = a2;
        }
      } else if (n3 < 20) {
        for (let i2 = start; i2 < l2; i2++) {
          for (let j2 = i2; j2 > start; j2--) {
            let a2 = array2[j2 - 1];
            let b2 = array2[j2];
            if (compareGenerated(a2, b2) <= 0) {
              break;
            }
            array2[j2 - 1] = b2;
            array2[j2] = a2;
          }
        }
      } else {
        quickSort(array2, compareGenerated, start);
      }
    }
    BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      var generatedLine = 1;
      var previousGeneratedColumn = 0;
      var previousOriginalLine = 0;
      var previousOriginalColumn = 0;
      var previousSource = 0;
      var previousName = 0;
      var length = aStr.length;
      var index2 = 0;
      var cachedSegments = {};
      var temp = {};
      var originalMappings = [];
      var generatedMappings = [];
      var mapping, str, segment, end, value;
      let subarrayStart = 0;
      while (index2 < length) {
        if (aStr.charAt(index2) === ";") {
          generatedLine++;
          index2++;
          previousGeneratedColumn = 0;
          sortGenerated(generatedMappings, subarrayStart);
          subarrayStart = generatedMappings.length;
        } else if (aStr.charAt(index2) === ",") {
          index2++;
        } else {
          mapping = new Mapping();
          mapping.generatedLine = generatedLine;
          for (end = index2; end < length; end++) {
            if (this._charIsMappingSeparator(aStr, end)) {
              break;
            }
          }
          str = aStr.slice(index2, end);
          segment = [];
          while (index2 < end) {
            base64VLQ.decode(aStr, index2, temp);
            value = temp.value;
            index2 = temp.rest;
            segment.push(value);
          }
          if (segment.length === 2) {
            throw new Error("Found a source, but no line and column");
          }
          if (segment.length === 3) {
            throw new Error("Found a source and line, but no column");
          }
          mapping.generatedColumn = previousGeneratedColumn + segment[0];
          previousGeneratedColumn = mapping.generatedColumn;
          if (segment.length > 1) {
            mapping.source = previousSource + segment[1];
            previousSource += segment[1];
            mapping.originalLine = previousOriginalLine + segment[2];
            previousOriginalLine = mapping.originalLine;
            mapping.originalLine += 1;
            mapping.originalColumn = previousOriginalColumn + segment[3];
            previousOriginalColumn = mapping.originalColumn;
            if (segment.length > 4) {
              mapping.name = previousName + segment[4];
              previousName += segment[4];
            }
          }
          generatedMappings.push(mapping);
          if (typeof mapping.originalLine === "number") {
            let currentSource = mapping.source;
            while (originalMappings.length <= currentSource) {
              originalMappings.push(null);
            }
            if (originalMappings[currentSource] === null) {
              originalMappings[currentSource] = [];
            }
            originalMappings[currentSource].push(mapping);
          }
        }
      }
      sortGenerated(generatedMappings, subarrayStart);
      this.__generatedMappings = generatedMappings;
      for (var i2 = 0; i2 < originalMappings.length; i2++) {
        if (originalMappings[i2] != null) {
          quickSort(originalMappings[i2], util2.compareByOriginalPositionsNoSource);
        }
      }
      this.__originalMappings = [].concat(...originalMappings);
    };
    BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
      if (aNeedle[aLineName] <= 0) {
        throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
      }
      if (aNeedle[aColumnName] < 0) {
        throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
      }
      return binarySearch2.search(aNeedle, aMappings, aComparator, aBias);
    };
    BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
      for (var index2 = 0; index2 < this._generatedMappings.length; ++index2) {
        var mapping = this._generatedMappings[index2];
        if (index2 + 1 < this._generatedMappings.length) {
          var nextMapping = this._generatedMappings[index2 + 1];
          if (mapping.generatedLine === nextMapping.generatedLine) {
            mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
            continue;
          }
        }
        mapping.lastGeneratedColumn = Infinity;
      }
    };
    BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util2.getArg(aArgs, "line"),
        generatedColumn: util2.getArg(aArgs, "column")
      };
      var index2 = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util2.compareByGeneratedPositionsDeflated, util2.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND));
      if (index2 >= 0) {
        var mapping = this._generatedMappings[index2];
        if (mapping.generatedLine === needle.generatedLine) {
          var source2 = util2.getArg(mapping, "source", null);
          if (source2 !== null) {
            source2 = this._sources.at(source2);
            source2 = util2.computeSourceURL(this.sourceRoot, source2, this._sourceMapURL);
          }
          var name = util2.getArg(mapping, "name", null);
          if (name !== null) {
            name = this._names.at(name);
          }
          return {
            source: source2,
            line: util2.getArg(mapping, "originalLine", null),
            column: util2.getArg(mapping, "originalColumn", null),
            name
          };
        }
      }
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    };
    BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
      if (!this.sourcesContent) {
        return false;
      }
      return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
        return sc == null;
      });
    };
    BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      if (!this.sourcesContent) {
        return null;
      }
      var index2 = this._findSourceIndex(aSource);
      if (index2 >= 0) {
        return this.sourcesContent[index2];
      }
      var relativeSource = aSource;
      if (this.sourceRoot != null) {
        relativeSource = util2.relative(this.sourceRoot, relativeSource);
      }
      var url2;
      if (this.sourceRoot != null && (url2 = util2.urlParse(this.sourceRoot))) {
        var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
        if (url2.scheme == "file" && this._sources.has(fileUriAbsPath)) {
          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
        }
        if ((!url2.path || url2.path == "/") && this._sources.has("/" + relativeSource)) {
          return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
        }
      }
      if (nullOnMissing) {
        return null;
      } else {
        throw new Error('"' + relativeSource + '" is not in the SourceMap.');
      }
    };
    BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
      var source2 = util2.getArg(aArgs, "source");
      source2 = this._findSourceIndex(source2);
      if (source2 < 0) {
        return {
          line: null,
          column: null,
          lastColumn: null
        };
      }
      var needle = {
        source: source2,
        originalLine: util2.getArg(aArgs, "line"),
        originalColumn: util2.getArg(aArgs, "column")
      };
      var index2 = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util2.compareByOriginalPositions, util2.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND));
      if (index2 >= 0) {
        var mapping = this._originalMappings[index2];
        if (mapping.source === needle.source) {
          return {
            line: util2.getArg(mapping, "generatedLine", null),
            column: util2.getArg(mapping, "generatedColumn", null),
            lastColumn: util2.getArg(mapping, "lastGeneratedColumn", null)
          };
        }
      }
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    };
    exports2.BasicSourceMapConsumer = BasicSourceMapConsumer;
    function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util2.parseSourceMapInput(aSourceMap);
      }
      var version2 = util2.getArg(sourceMap, "version");
      var sections = util2.getArg(sourceMap, "sections");
      if (version2 != this._version) {
        throw new Error("Unsupported version: " + version2);
      }
      this._sources = new ArraySet();
      this._names = new ArraySet();
      var lastOffset = {
        line: -1,
        column: 0
      };
      this._sections = sections.map(function(s2) {
        if (s2.url) {
          throw new Error("Support for url field in sections not implemented.");
        }
        var offset2 = util2.getArg(s2, "offset");
        var offsetLine = util2.getArg(offset2, "line");
        var offsetColumn = util2.getArg(offset2, "column");
        if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
          throw new Error("Section offsets must be ordered and non-overlapping.");
        }
        lastOffset = offset2;
        return {
          generatedOffset: {
            generatedLine: offsetLine + 1,
            generatedColumn: offsetColumn + 1
          },
          consumer: new SourceMapConsumer(util2.getArg(s2, "map"), aSourceMapURL)
        };
      });
    }
    IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
    IndexedSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
      get: function() {
        var sources = [];
        for (var i2 = 0; i2 < this._sections.length; i2++) {
          for (var j2 = 0; j2 < this._sections[i2].consumer.sources.length; j2++) {
            sources.push(this._sections[i2].consumer.sources[j2]);
          }
        }
        return sources;
      }
    });
    IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util2.getArg(aArgs, "line"),
        generatedColumn: util2.getArg(aArgs, "column")
      };
      var sectionIndex = binarySearch2.search(needle, this._sections, function(needle2, section2) {
        var cmp = needle2.generatedLine - section2.generatedOffset.generatedLine;
        if (cmp) {
          return cmp;
        }
        return needle2.generatedColumn - section2.generatedOffset.generatedColumn;
      });
      var section = this._sections[sectionIndex];
      if (!section) {
        return {
          source: null,
          line: null,
          column: null,
          name: null
        };
      }
      return section.consumer.originalPositionFor({
        line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
        column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
        bias: aArgs.bias
      });
    };
    IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
      return this._sections.every(function(s2) {
        return s2.consumer.hasContentsOfAllSources();
      });
    };
    IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      for (var i2 = 0; i2 < this._sections.length; i2++) {
        var section = this._sections[i2];
        var content2 = section.consumer.sourceContentFor(aSource, true);
        if (content2) {
          return content2;
        }
      }
      if (nullOnMissing) {
        return null;
      } else {
        throw new Error('"' + aSource + '" is not in the SourceMap.');
      }
    };
    IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
      for (var i2 = 0; i2 < this._sections.length; i2++) {
        var section = this._sections[i2];
        if (section.consumer._findSourceIndex(util2.getArg(aArgs, "source")) === -1) {
          continue;
        }
        var generatedPosition = section.consumer.generatedPositionFor(aArgs);
        if (generatedPosition) {
          var ret = {
            line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
            column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
          };
          return ret;
        }
      }
      return {
        line: null,
        column: null
      };
    };
    IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      this.__generatedMappings = [];
      this.__originalMappings = [];
      for (var i2 = 0; i2 < this._sections.length; i2++) {
        var section = this._sections[i2];
        var sectionMappings = section.consumer._generatedMappings;
        for (var j2 = 0; j2 < sectionMappings.length; j2++) {
          var mapping = sectionMappings[j2];
          var source2 = section.consumer._sources.at(mapping.source);
          source2 = util2.computeSourceURL(section.consumer.sourceRoot, source2, this._sourceMapURL);
          this._sources.add(source2);
          source2 = this._sources.indexOf(source2);
          var name = null;
          if (mapping.name) {
            name = section.consumer._names.at(mapping.name);
            this._names.add(name);
            name = this._names.indexOf(name);
          }
          var adjustedMapping = {
            source: source2,
            generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
            generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name
          };
          this.__generatedMappings.push(adjustedMapping);
          if (typeof adjustedMapping.originalLine === "number") {
            this.__originalMappings.push(adjustedMapping);
          }
        }
      }
      quickSort(this.__generatedMappings, util2.compareByGeneratedPositionsDeflated);
      quickSort(this.__originalMappings, util2.compareByOriginalPositions);
    };
    exports2.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
  }
});

// node_modules/source-map-js/lib/source-node.js
var require_source_node = __commonJS({
  "node_modules/source-map-js/lib/source-node.js"(exports2) {
    var SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
    var util2 = require_util();
    var REGEX_NEWLINE = /(\r?\n)/;
    var NEWLINE_CODE = 10;
    var isSourceNode = "$$$isSourceNode$$$";
    function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
      this.children = [];
      this.sourceContents = {};
      this.line = aLine == null ? null : aLine;
      this.column = aColumn == null ? null : aColumn;
      this.source = aSource == null ? null : aSource;
      this.name = aName == null ? null : aName;
      this[isSourceNode] = true;
      if (aChunks != null)
        this.add(aChunks);
    }
    SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
      var node2 = new SourceNode();
      var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
      var remainingLinesIndex = 0;
      var shiftNextLine = function() {
        var lineContents = getNextLine();
        var newLine = getNextLine() || "";
        return lineContents + newLine;
        function getNextLine() {
          return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
        }
      };
      var lastGeneratedLine = 1, lastGeneratedColumn = 0;
      var lastMapping = null;
      aSourceMapConsumer.eachMapping(function(mapping) {
        if (lastMapping !== null) {
          if (lastGeneratedLine < mapping.generatedLine) {
            addMappingWithCode(lastMapping, shiftNextLine());
            lastGeneratedLine++;
            lastGeneratedColumn = 0;
          } else {
            var nextLine = remainingLines[remainingLinesIndex] || "";
            var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
            addMappingWithCode(lastMapping, code);
            lastMapping = mapping;
            return;
          }
        }
        while (lastGeneratedLine < mapping.generatedLine) {
          node2.add(shiftNextLine());
          lastGeneratedLine++;
        }
        if (lastGeneratedColumn < mapping.generatedColumn) {
          var nextLine = remainingLines[remainingLinesIndex] || "";
          node2.add(nextLine.substr(0, mapping.generatedColumn));
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
        }
        lastMapping = mapping;
      }, this);
      if (remainingLinesIndex < remainingLines.length) {
        if (lastMapping) {
          addMappingWithCode(lastMapping, shiftNextLine());
        }
        node2.add(remainingLines.splice(remainingLinesIndex).join(""));
      }
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var content2 = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content2 != null) {
          if (aRelativePath != null) {
            sourceFile = util2.join(aRelativePath, sourceFile);
          }
          node2.setSourceContent(sourceFile, content2);
        }
      });
      return node2;
      function addMappingWithCode(mapping, code) {
        if (mapping === null || mapping.source === void 0) {
          node2.add(code);
        } else {
          var source2 = aRelativePath ? util2.join(aRelativePath, mapping.source) : mapping.source;
          node2.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source2, code, mapping.name));
        }
      }
    };
    SourceNode.prototype.add = function SourceNode_add(aChunk) {
      if (Array.isArray(aChunk)) {
        aChunk.forEach(function(chunk) {
          this.add(chunk);
        }, this);
      } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        if (aChunk) {
          this.children.push(aChunk);
        }
      } else {
        throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
      }
      return this;
    };
    SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
      if (Array.isArray(aChunk)) {
        for (var i2 = aChunk.length - 1; i2 >= 0; i2--) {
          this.prepend(aChunk[i2]);
        }
      } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        this.children.unshift(aChunk);
      } else {
        throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
      }
      return this;
    };
    SourceNode.prototype.walk = function SourceNode_walk(aFn) {
      var chunk;
      for (var i2 = 0, len = this.children.length; i2 < len; i2++) {
        chunk = this.children[i2];
        if (chunk[isSourceNode]) {
          chunk.walk(aFn);
        } else {
          if (chunk !== "") {
            aFn(chunk, {
              source: this.source,
              line: this.line,
              column: this.column,
              name: this.name
            });
          }
        }
      }
    };
    SourceNode.prototype.join = function SourceNode_join(aSep) {
      var newChildren;
      var i2;
      var len = this.children.length;
      if (len > 0) {
        newChildren = [];
        for (i2 = 0; i2 < len - 1; i2++) {
          newChildren.push(this.children[i2]);
          newChildren.push(aSep);
        }
        newChildren.push(this.children[i2]);
        this.children = newChildren;
      }
      return this;
    };
    SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
      var lastChild = this.children[this.children.length - 1];
      if (lastChild[isSourceNode]) {
        lastChild.replaceRight(aPattern, aReplacement);
      } else if (typeof lastChild === "string") {
        this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
      } else {
        this.children.push("".replace(aPattern, aReplacement));
      }
      return this;
    };
    SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
      this.sourceContents[util2.toSetString(aSourceFile)] = aSourceContent;
    };
    SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
      for (var i2 = 0, len = this.children.length; i2 < len; i2++) {
        if (this.children[i2][isSourceNode]) {
          this.children[i2].walkSourceContents(aFn);
        }
      }
      var sources = Object.keys(this.sourceContents);
      for (var i2 = 0, len = sources.length; i2 < len; i2++) {
        aFn(util2.fromSetString(sources[i2]), this.sourceContents[sources[i2]]);
      }
    };
    SourceNode.prototype.toString = function SourceNode_toString() {
      var str = "";
      this.walk(function(chunk) {
        str += chunk;
      });
      return str;
    };
    SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
      var generated = {
        code: "",
        line: 1,
        column: 0
      };
      var map2 = new SourceMapGenerator(aArgs);
      var sourceMappingActive = false;
      var lastOriginalSource = null;
      var lastOriginalLine = null;
      var lastOriginalColumn = null;
      var lastOriginalName = null;
      this.walk(function(chunk, original) {
        generated.code += chunk;
        if (original.source !== null && original.line !== null && original.column !== null) {
          if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
            map2.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
          lastOriginalSource = original.source;
          lastOriginalLine = original.line;
          lastOriginalColumn = original.column;
          lastOriginalName = original.name;
          sourceMappingActive = true;
        } else if (sourceMappingActive) {
          map2.addMapping({
            generated: {
              line: generated.line,
              column: generated.column
            }
          });
          lastOriginalSource = null;
          sourceMappingActive = false;
        }
        for (var idx = 0, length = chunk.length; idx < length; idx++) {
          if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
            generated.line++;
            generated.column = 0;
            if (idx + 1 === length) {
              lastOriginalSource = null;
              sourceMappingActive = false;
            } else if (sourceMappingActive) {
              map2.addMapping({
                source: original.source,
                original: {
                  line: original.line,
                  column: original.column
                },
                generated: {
                  line: generated.line,
                  column: generated.column
                },
                name: original.name
              });
            }
          } else {
            generated.column++;
          }
        }
      });
      this.walkSourceContents(function(sourceFile, sourceContent) {
        map2.setSourceContent(sourceFile, sourceContent);
      });
      return { code: generated.code, map: map2 };
    };
    exports2.SourceNode = SourceNode;
  }
});

// node_modules/source-map-js/source-map.js
var require_source_map = __commonJS({
  "node_modules/source-map-js/source-map.js"(exports2) {
    exports2.SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
    exports2.SourceMapConsumer = require_source_map_consumer().SourceMapConsumer;
    exports2.SourceNode = require_source_node().SourceNode;
  }
});

// node_modules/nanoid/non-secure/index.js
var non_secure_exports = {};
__export(non_secure_exports, {
  customAlphabet: () => customAlphabet,
  nanoid: () => nanoid
});
var urlAlphabet, customAlphabet, nanoid;
var init_non_secure = __esm({
  "node_modules/nanoid/non-secure/index.js"() {
    urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
    customAlphabet = (alphabet, defaultSize = 21) => {
      return (size = defaultSize) => {
        let id = "";
        let i2 = size;
        while (i2--) {
          id += alphabet[Math.random() * alphabet.length | 0];
        }
        return id;
      };
    };
    nanoid = (size = 21) => {
      let id = "";
      let i2 = size;
      while (i2--) {
        id += urlAlphabet[Math.random() * 64 | 0];
      }
      return id;
    };
  }
});

// node_modules/postcss/lib/previous-map.js
var require_previous_map = __commonJS({
  "node_modules/postcss/lib/previous-map.js"(exports2, module2) {
    "use strict";
    var { SourceMapConsumer, SourceMapGenerator } = require_source_map();
    var { existsSync, readFileSync } = (init_fs(), __toCommonJS(fs_exports));
    var { dirname, join } = (init_path(), __toCommonJS(path_exports));
    function fromBase64(str) {
      if (Buffer) {
        return Buffer.from(str, "base64").toString();
      } else {
        return window.atob(str);
      }
    }
    var PreviousMap = class {
      constructor(css, opts) {
        if (opts.map === false)
          return;
        this.loadAnnotation(css);
        this.inline = this.startWith(this.annotation, "data:");
        let prev = opts.map ? opts.map.prev : void 0;
        let text = this.loadMap(opts.from, prev);
        if (!this.mapFile && opts.from) {
          this.mapFile = opts.from;
        }
        if (this.mapFile)
          this.root = dirname(this.mapFile);
        if (text)
          this.text = text;
      }
      consumer() {
        if (!this.consumerCache) {
          this.consumerCache = new SourceMapConsumer(this.text);
        }
        return this.consumerCache;
      }
      withContent() {
        return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
      }
      startWith(string2, start) {
        if (!string2)
          return false;
        return string2.substr(0, start.length) === start;
      }
      getAnnotationURL(sourceMapString) {
        return sourceMapString.replace(/^\/\*\s*# sourceMappingURL=/, "").trim();
      }
      loadAnnotation(css) {
        let comments = css.match(/\/\*\s*# sourceMappingURL=/gm);
        if (!comments)
          return;
        let start = css.lastIndexOf(comments.pop());
        let end = css.indexOf("*/", start);
        if (start > -1 && end > -1) {
          this.annotation = this.getAnnotationURL(css.substring(start, end));
        }
      }
      decodeInline(text) {
        let baseCharsetUri = /^data:application\/json;charset=utf-?8;base64,/;
        let baseUri = /^data:application\/json;base64,/;
        let charsetUri = /^data:application\/json;charset=utf-?8,/;
        let uri = /^data:application\/json,/;
        if (charsetUri.test(text) || uri.test(text)) {
          return decodeURIComponent(text.substr(RegExp.lastMatch.length));
        }
        if (baseCharsetUri.test(text) || baseUri.test(text)) {
          return fromBase64(text.substr(RegExp.lastMatch.length));
        }
        let encoding = text.match(/data:application\/json;([^,]+),/)[1];
        throw new Error("Unsupported source map encoding " + encoding);
      }
      loadFile(path2) {
        this.root = dirname(path2);
        if (existsSync(path2)) {
          this.mapFile = path2;
          return readFileSync(path2, "utf-8").toString().trim();
        }
      }
      loadMap(file, prev) {
        if (prev === false)
          return false;
        if (prev) {
          if (typeof prev === "string") {
            return prev;
          } else if (typeof prev === "function") {
            let prevPath = prev(file);
            if (prevPath) {
              let map2 = this.loadFile(prevPath);
              if (!map2) {
                throw new Error("Unable to load previous source map: " + prevPath.toString());
              }
              return map2;
            }
          } else if (prev instanceof SourceMapConsumer) {
            return SourceMapGenerator.fromSourceMap(prev).toString();
          } else if (prev instanceof SourceMapGenerator) {
            return prev.toString();
          } else if (this.isMap(prev)) {
            return JSON.stringify(prev);
          } else {
            throw new Error("Unsupported previous source map format: " + prev.toString());
          }
        } else if (this.inline) {
          return this.decodeInline(this.annotation);
        } else if (this.annotation) {
          let map2 = this.annotation;
          if (file)
            map2 = join(dirname(file), map2);
          return this.loadFile(map2);
        }
      }
      isMap(map2) {
        if (typeof map2 !== "object")
          return false;
        return typeof map2.mappings === "string" || typeof map2._mappings === "string" || Array.isArray(map2.sections);
      }
    };
    module2.exports = PreviousMap;
    PreviousMap.default = PreviousMap;
  }
});

// node_modules/postcss/lib/input.js
var require_input = __commonJS({
  "node_modules/postcss/lib/input.js"(exports2, module2) {
    "use strict";
    var { SourceMapConsumer, SourceMapGenerator } = require_source_map();
    var { fileURLToPath, pathToFileURL } = (init_url(), __toCommonJS(url_exports));
    var { resolve: resolve2, isAbsolute: isAbsolute2 } = (init_path(), __toCommonJS(path_exports));
    var { nanoid: nanoid2 } = (init_non_secure(), __toCommonJS(non_secure_exports));
    var terminalHighlight = require_terminal_highlight();
    var CssSyntaxError = require_css_syntax_error();
    var PreviousMap = require_previous_map();
    var fromOffsetCache = Symbol("fromOffsetCache");
    var sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);
    var pathAvailable = Boolean(resolve2 && isAbsolute2);
    var Input = class {
      constructor(css, opts = {}) {
        if (css === null || typeof css === "undefined" || typeof css === "object" && !css.toString) {
          throw new Error(`PostCSS received ${css} instead of CSS string`);
        }
        this.css = css.toString();
        if (this.css[0] === "\uFEFF" || this.css[0] === "\uFFFE") {
          this.hasBOM = true;
          this.css = this.css.slice(1);
        } else {
          this.hasBOM = false;
        }
        if (opts.from) {
          if (!pathAvailable || /^\w+:\/\//.test(opts.from) || isAbsolute2(opts.from)) {
            this.file = opts.from;
          } else {
            this.file = resolve2(opts.from);
          }
        }
        if (pathAvailable && sourceMapAvailable) {
          let map2 = new PreviousMap(this.css, opts);
          if (map2.text) {
            this.map = map2;
            let file = map2.consumer().file;
            if (!this.file && file)
              this.file = this.mapResolve(file);
          }
        }
        if (!this.file) {
          this.id = "<input css " + nanoid2(6) + ">";
        }
        if (this.map)
          this.map.file = this.from;
      }
      fromOffset(offset2) {
        let lastLine, lineToIndex;
        if (!this[fromOffsetCache]) {
          let lines = this.css.split("\n");
          lineToIndex = new Array(lines.length);
          let prevIndex = 0;
          for (let i2 = 0, l2 = lines.length; i2 < l2; i2++) {
            lineToIndex[i2] = prevIndex;
            prevIndex += lines[i2].length + 1;
          }
          this[fromOffsetCache] = lineToIndex;
        } else {
          lineToIndex = this[fromOffsetCache];
        }
        lastLine = lineToIndex[lineToIndex.length - 1];
        let min2 = 0;
        if (offset2 >= lastLine) {
          min2 = lineToIndex.length - 1;
        } else {
          let max = lineToIndex.length - 2;
          let mid;
          while (min2 < max) {
            mid = min2 + (max - min2 >> 1);
            if (offset2 < lineToIndex[mid]) {
              max = mid - 1;
            } else if (offset2 >= lineToIndex[mid + 1]) {
              min2 = mid + 1;
            } else {
              min2 = mid;
              break;
            }
          }
        }
        return {
          line: min2 + 1,
          col: offset2 - lineToIndex[min2] + 1
        };
      }
      error(message, line2, column2, opts = {}) {
        let result2, endLine, endColumn;
        if (line2 && typeof line2 === "object") {
          let start = line2;
          let end = column2;
          if (typeof line2.offset === "number") {
            let pos2 = this.fromOffset(start.offset);
            line2 = pos2.line;
            column2 = pos2.col;
          } else {
            line2 = start.line;
            column2 = start.column;
          }
          if (typeof end.offset === "number") {
            let pos2 = this.fromOffset(end.offset);
            endLine = pos2.line;
            endColumn = pos2.col;
          } else {
            endLine = end.line;
            endColumn = end.column;
          }
        } else if (!column2) {
          let pos2 = this.fromOffset(line2);
          line2 = pos2.line;
          column2 = pos2.col;
        }
        let origin = this.origin(line2, column2, endLine, endColumn);
        if (origin) {
          result2 = new CssSyntaxError(message, origin.endLine === void 0 ? origin.line : { line: origin.line, column: origin.column }, origin.endLine === void 0 ? origin.column : { line: origin.endLine, column: origin.endColumn }, origin.source, origin.file, opts.plugin);
        } else {
          result2 = new CssSyntaxError(message, endLine === void 0 ? line2 : { line: line2, column: column2 }, endLine === void 0 ? column2 : { line: endLine, column: endColumn }, this.css, this.file, opts.plugin);
        }
        result2.input = { line: line2, column: column2, endLine, endColumn, source: this.css };
        if (this.file) {
          if (pathToFileURL) {
            result2.input.url = pathToFileURL(this.file).toString();
          }
          result2.input.file = this.file;
        }
        return result2;
      }
      origin(line2, column2, endLine, endColumn) {
        if (!this.map)
          return false;
        let consumer = this.map.consumer();
        let from = consumer.originalPositionFor({ line: line2, column: column2 });
        if (!from.source)
          return false;
        let to2;
        if (typeof endLine === "number") {
          to2 = consumer.originalPositionFor({ line: endLine, column: endColumn });
        }
        let fromUrl;
        if (isAbsolute2(from.source)) {
          fromUrl = pathToFileURL(from.source);
        } else {
          fromUrl = new URL(from.source, this.map.consumer().sourceRoot || pathToFileURL(this.map.mapFile));
        }
        let result2 = {
          url: fromUrl.toString(),
          line: from.line,
          column: from.column,
          endLine: to2 && to2.line,
          endColumn: to2 && to2.column
        };
        if (fromUrl.protocol === "file:") {
          if (fileURLToPath) {
            result2.file = fileURLToPath(fromUrl);
          } else {
            throw new Error(`file: protocol is not available in this PostCSS build`);
          }
        }
        let source2 = consumer.sourceContentFor(from.source);
        if (source2)
          result2.source = source2;
        return result2;
      }
      mapResolve(file) {
        if (/^\w+:\/\//.test(file)) {
          return file;
        }
        return resolve2(this.map.consumer().sourceRoot || this.map.root || ".", file);
      }
      get from() {
        return this.file || this.id;
      }
      toJSON() {
        let json2 = {};
        for (let name of ["hasBOM", "css", "file", "id"]) {
          if (this[name] != null) {
            json2[name] = this[name];
          }
        }
        if (this.map) {
          json2.map = __spreadValues2({}, this.map);
          if (json2.map.consumerCache) {
            json2.map.consumerCache = void 0;
          }
        }
        return json2;
      }
    };
    module2.exports = Input;
    Input.default = Input;
    if (terminalHighlight && terminalHighlight.registerInput) {
      terminalHighlight.registerInput(Input);
    }
  }
});

// node_modules/postcss/lib/map-generator.js
var require_map_generator = __commonJS({
  "node_modules/postcss/lib/map-generator.js"(exports2, module2) {
    "use strict";
    var { SourceMapConsumer, SourceMapGenerator } = require_source_map();
    var { dirname, resolve: resolve2, relative, sep } = (init_path(), __toCommonJS(path_exports));
    var { pathToFileURL } = (init_url(), __toCommonJS(url_exports));
    var Input = require_input();
    var sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);
    var pathAvailable = Boolean(dirname && resolve2 && relative && sep);
    var MapGenerator = class {
      constructor(stringify2, root2, opts, cssString) {
        this.stringify = stringify2;
        this.mapOpts = opts.map || {};
        this.root = root2;
        this.opts = opts;
        this.css = cssString;
      }
      isMap() {
        if (typeof this.opts.map !== "undefined") {
          return !!this.opts.map;
        }
        return this.previous().length > 0;
      }
      previous() {
        if (!this.previousMaps) {
          this.previousMaps = [];
          if (this.root) {
            this.root.walk((node2) => {
              if (node2.source && node2.source.input.map) {
                let map2 = node2.source.input.map;
                if (!this.previousMaps.includes(map2)) {
                  this.previousMaps.push(map2);
                }
              }
            });
          } else {
            let input = new Input(this.css, this.opts);
            if (input.map)
              this.previousMaps.push(input.map);
          }
        }
        return this.previousMaps;
      }
      isInline() {
        if (typeof this.mapOpts.inline !== "undefined") {
          return this.mapOpts.inline;
        }
        let annotation = this.mapOpts.annotation;
        if (typeof annotation !== "undefined" && annotation !== true) {
          return false;
        }
        if (this.previous().length) {
          return this.previous().some((i2) => i2.inline);
        }
        return true;
      }
      isSourcesContent() {
        if (typeof this.mapOpts.sourcesContent !== "undefined") {
          return this.mapOpts.sourcesContent;
        }
        if (this.previous().length) {
          return this.previous().some((i2) => i2.withContent());
        }
        return true;
      }
      clearAnnotation() {
        if (this.mapOpts.annotation === false)
          return;
        if (this.root) {
          let node2;
          for (let i2 = this.root.nodes.length - 1; i2 >= 0; i2--) {
            node2 = this.root.nodes[i2];
            if (node2.type !== "comment")
              continue;
            if (node2.text.indexOf("# sourceMappingURL=") === 0) {
              this.root.removeChild(i2);
            }
          }
        } else if (this.css) {
          this.css = this.css.replace(/(\n)?\/\*#[\S\s]*?\*\/$/gm, "");
        }
      }
      setSourcesContent() {
        let already = {};
        if (this.root) {
          this.root.walk((node2) => {
            if (node2.source) {
              let from = node2.source.input.from;
              if (from && !already[from]) {
                already[from] = true;
                this.map.setSourceContent(this.toUrl(this.path(from)), node2.source.input.css);
              }
            }
          });
        } else if (this.css) {
          let from = this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>";
          this.map.setSourceContent(from, this.css);
        }
      }
      applyPrevMaps() {
        for (let prev of this.previous()) {
          let from = this.toUrl(this.path(prev.file));
          let root2 = prev.root || dirname(prev.file);
          let map2;
          if (this.mapOpts.sourcesContent === false) {
            map2 = new SourceMapConsumer(prev.text);
            if (map2.sourcesContent) {
              map2.sourcesContent = map2.sourcesContent.map(() => null);
            }
          } else {
            map2 = prev.consumer();
          }
          this.map.applySourceMap(map2, from, this.toUrl(this.path(root2)));
        }
      }
      isAnnotation() {
        if (this.isInline()) {
          return true;
        }
        if (typeof this.mapOpts.annotation !== "undefined") {
          return this.mapOpts.annotation;
        }
        if (this.previous().length) {
          return this.previous().some((i2) => i2.annotation);
        }
        return true;
      }
      toBase64(str) {
        if (Buffer) {
          return Buffer.from(str).toString("base64");
        } else {
          return window.btoa(unescape(encodeURIComponent(str)));
        }
      }
      addAnnotation() {
        let content2;
        if (this.isInline()) {
          content2 = "data:application/json;base64," + this.toBase64(this.map.toString());
        } else if (typeof this.mapOpts.annotation === "string") {
          content2 = this.mapOpts.annotation;
        } else if (typeof this.mapOpts.annotation === "function") {
          content2 = this.mapOpts.annotation(this.opts.to, this.root);
        } else {
          content2 = this.outputFile() + ".map";
        }
        let eol = "\n";
        if (this.css.includes("\r\n"))
          eol = "\r\n";
        this.css += eol + "/*# sourceMappingURL=" + content2 + " */";
      }
      outputFile() {
        if (this.opts.to) {
          return this.path(this.opts.to);
        } else if (this.opts.from) {
          return this.path(this.opts.from);
        } else {
          return "to.css";
        }
      }
      generateMap() {
        if (this.root) {
          this.generateString();
        } else if (this.previous().length === 1) {
          let prev = this.previous()[0].consumer();
          prev.file = this.outputFile();
          this.map = SourceMapGenerator.fromSourceMap(prev);
        } else {
          this.map = new SourceMapGenerator({ file: this.outputFile() });
          this.map.addMapping({
            source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>",
            generated: { line: 1, column: 0 },
            original: { line: 1, column: 0 }
          });
        }
        if (this.isSourcesContent())
          this.setSourcesContent();
        if (this.root && this.previous().length > 0)
          this.applyPrevMaps();
        if (this.isAnnotation())
          this.addAnnotation();
        if (this.isInline()) {
          return [this.css];
        } else {
          return [this.css, this.map];
        }
      }
      path(file) {
        if (file.indexOf("<") === 0)
          return file;
        if (/^\w+:\/\//.test(file))
          return file;
        if (this.mapOpts.absolute)
          return file;
        let from = this.opts.to ? dirname(this.opts.to) : ".";
        if (typeof this.mapOpts.annotation === "string") {
          from = dirname(resolve2(from, this.mapOpts.annotation));
        }
        file = relative(from, file);
        return file;
      }
      toUrl(path2) {
        if (sep === "\\") {
          path2 = path2.replace(/\\/g, "/");
        }
        return encodeURI(path2).replace(/[#?]/g, encodeURIComponent);
      }
      sourcePath(node2) {
        if (this.mapOpts.from) {
          return this.toUrl(this.mapOpts.from);
        } else if (this.mapOpts.absolute) {
          if (pathToFileURL) {
            return pathToFileURL(node2.source.input.from).toString();
          } else {
            throw new Error("`map.absolute` option is not available in this PostCSS build");
          }
        } else {
          return this.toUrl(this.path(node2.source.input.from));
        }
      }
      generateString() {
        this.css = "";
        this.map = new SourceMapGenerator({ file: this.outputFile() });
        let line2 = 1;
        let column2 = 1;
        let noSource = "<no source>";
        let mapping = {
          source: "",
          generated: { line: 0, column: 0 },
          original: { line: 0, column: 0 }
        };
        let lines, last;
        this.stringify(this.root, (str, node2, type) => {
          this.css += str;
          if (node2 && type !== "end") {
            mapping.generated.line = line2;
            mapping.generated.column = column2 - 1;
            if (node2.source && node2.source.start) {
              mapping.source = this.sourcePath(node2);
              mapping.original.line = node2.source.start.line;
              mapping.original.column = node2.source.start.column - 1;
              this.map.addMapping(mapping);
            } else {
              mapping.source = noSource;
              mapping.original.line = 1;
              mapping.original.column = 0;
              this.map.addMapping(mapping);
            }
          }
          lines = str.match(/\n/g);
          if (lines) {
            line2 += lines.length;
            last = str.lastIndexOf("\n");
            column2 = str.length - last;
          } else {
            column2 += str.length;
          }
          if (node2 && type !== "start") {
            let p2 = node2.parent || { raws: {} };
            if (node2.type !== "decl" || node2 !== p2.last || p2.raws.semicolon) {
              if (node2.source && node2.source.end) {
                mapping.source = this.sourcePath(node2);
                mapping.original.line = node2.source.end.line;
                mapping.original.column = node2.source.end.column - 1;
                mapping.generated.line = line2;
                mapping.generated.column = column2 - 2;
                this.map.addMapping(mapping);
              } else {
                mapping.source = noSource;
                mapping.original.line = 1;
                mapping.original.column = 0;
                mapping.generated.line = line2;
                mapping.generated.column = column2 - 1;
                this.map.addMapping(mapping);
              }
            }
          }
        });
      }
      generate() {
        this.clearAnnotation();
        if (pathAvailable && sourceMapAvailable && this.isMap()) {
          return this.generateMap();
        } else {
          let result2 = "";
          this.stringify(this.root, (i2) => {
            result2 += i2;
          });
          return [result2];
        }
      }
    };
    module2.exports = MapGenerator;
  }
});

// node_modules/postcss/lib/comment.js
var require_comment = __commonJS({
  "node_modules/postcss/lib/comment.js"(exports2, module2) {
    "use strict";
    var Node2 = require_node();
    var Comment2 = class extends Node2 {
      constructor(defaults) {
        super(defaults);
        this.type = "comment";
      }
    };
    module2.exports = Comment2;
    Comment2.default = Comment2;
  }
});

// node_modules/postcss/lib/container.js
var require_container = __commonJS({
  "node_modules/postcss/lib/container.js"(exports2, module2) {
    "use strict";
    var { isClean, my } = require_symbols();
    var Declaration = require_declaration();
    var Comment2 = require_comment();
    var Node2 = require_node();
    var parse2;
    var Rule;
    var AtRule;
    function cleanSource(nodes) {
      return nodes.map((i2) => {
        if (i2.nodes)
          i2.nodes = cleanSource(i2.nodes);
        delete i2.source;
        return i2;
      });
    }
    function markDirtyUp(node2) {
      node2[isClean] = false;
      if (node2.proxyOf.nodes) {
        for (let i2 of node2.proxyOf.nodes) {
          markDirtyUp(i2);
        }
      }
    }
    var Container = class extends Node2 {
      push(child) {
        child.parent = this;
        this.proxyOf.nodes.push(child);
        return this;
      }
      each(callback) {
        if (!this.proxyOf.nodes)
          return void 0;
        let iterator = this.getIterator();
        let index2, result2;
        while (this.indexes[iterator] < this.proxyOf.nodes.length) {
          index2 = this.indexes[iterator];
          result2 = callback(this.proxyOf.nodes[index2], index2);
          if (result2 === false)
            break;
          this.indexes[iterator] += 1;
        }
        delete this.indexes[iterator];
        return result2;
      }
      walk(callback) {
        return this.each((child, i2) => {
          let result2;
          try {
            result2 = callback(child, i2);
          } catch (e2) {
            throw child.addToError(e2);
          }
          if (result2 !== false && child.walk) {
            result2 = child.walk(callback);
          }
          return result2;
        });
      }
      walkDecls(prop, callback) {
        if (!callback) {
          callback = prop;
          return this.walk((child, i2) => {
            if (child.type === "decl") {
              return callback(child, i2);
            }
          });
        }
        if (prop instanceof RegExp) {
          return this.walk((child, i2) => {
            if (child.type === "decl" && prop.test(child.prop)) {
              return callback(child, i2);
            }
          });
        }
        return this.walk((child, i2) => {
          if (child.type === "decl" && child.prop === prop) {
            return callback(child, i2);
          }
        });
      }
      walkRules(selector, callback) {
        if (!callback) {
          callback = selector;
          return this.walk((child, i2) => {
            if (child.type === "rule") {
              return callback(child, i2);
            }
          });
        }
        if (selector instanceof RegExp) {
          return this.walk((child, i2) => {
            if (child.type === "rule" && selector.test(child.selector)) {
              return callback(child, i2);
            }
          });
        }
        return this.walk((child, i2) => {
          if (child.type === "rule" && child.selector === selector) {
            return callback(child, i2);
          }
        });
      }
      walkAtRules(name, callback) {
        if (!callback) {
          callback = name;
          return this.walk((child, i2) => {
            if (child.type === "atrule") {
              return callback(child, i2);
            }
          });
        }
        if (name instanceof RegExp) {
          return this.walk((child, i2) => {
            if (child.type === "atrule" && name.test(child.name)) {
              return callback(child, i2);
            }
          });
        }
        return this.walk((child, i2) => {
          if (child.type === "atrule" && child.name === name) {
            return callback(child, i2);
          }
        });
      }
      walkComments(callback) {
        return this.walk((child, i2) => {
          if (child.type === "comment") {
            return callback(child, i2);
          }
        });
      }
      append(...children) {
        for (let child of children) {
          let nodes = this.normalize(child, this.last);
          for (let node2 of nodes)
            this.proxyOf.nodes.push(node2);
        }
        this.markDirty();
        return this;
      }
      prepend(...children) {
        children = children.reverse();
        for (let child of children) {
          let nodes = this.normalize(child, this.first, "prepend").reverse();
          for (let node2 of nodes)
            this.proxyOf.nodes.unshift(node2);
          for (let id in this.indexes) {
            this.indexes[id] = this.indexes[id] + nodes.length;
          }
        }
        this.markDirty();
        return this;
      }
      cleanRaws(keepBetween) {
        super.cleanRaws(keepBetween);
        if (this.nodes) {
          for (let node2 of this.nodes)
            node2.cleanRaws(keepBetween);
        }
      }
      insertBefore(exist, add) {
        exist = this.index(exist);
        let type = exist === 0 ? "prepend" : false;
        let nodes = this.normalize(add, this.proxyOf.nodes[exist], type).reverse();
        for (let node2 of nodes)
          this.proxyOf.nodes.splice(exist, 0, node2);
        let index2;
        for (let id in this.indexes) {
          index2 = this.indexes[id];
          if (exist <= index2) {
            this.indexes[id] = index2 + nodes.length;
          }
        }
        this.markDirty();
        return this;
      }
      insertAfter(exist, add) {
        exist = this.index(exist);
        let nodes = this.normalize(add, this.proxyOf.nodes[exist]).reverse();
        for (let node2 of nodes)
          this.proxyOf.nodes.splice(exist + 1, 0, node2);
        let index2;
        for (let id in this.indexes) {
          index2 = this.indexes[id];
          if (exist < index2) {
            this.indexes[id] = index2 + nodes.length;
          }
        }
        this.markDirty();
        return this;
      }
      removeChild(child) {
        child = this.index(child);
        this.proxyOf.nodes[child].parent = void 0;
        this.proxyOf.nodes.splice(child, 1);
        let index2;
        for (let id in this.indexes) {
          index2 = this.indexes[id];
          if (index2 >= child) {
            this.indexes[id] = index2 - 1;
          }
        }
        this.markDirty();
        return this;
      }
      removeAll() {
        for (let node2 of this.proxyOf.nodes)
          node2.parent = void 0;
        this.proxyOf.nodes = [];
        this.markDirty();
        return this;
      }
      replaceValues(pattern2, opts, callback) {
        if (!callback) {
          callback = opts;
          opts = {};
        }
        this.walkDecls((decl) => {
          if (opts.props && !opts.props.includes(decl.prop))
            return;
          if (opts.fast && !decl.value.includes(opts.fast))
            return;
          decl.value = decl.value.replace(pattern2, callback);
        });
        this.markDirty();
        return this;
      }
      every(condition) {
        return this.nodes.every(condition);
      }
      some(condition) {
        return this.nodes.some(condition);
      }
      index(child) {
        if (typeof child === "number")
          return child;
        if (child.proxyOf)
          child = child.proxyOf;
        return this.proxyOf.nodes.indexOf(child);
      }
      get first() {
        if (!this.proxyOf.nodes)
          return void 0;
        return this.proxyOf.nodes[0];
      }
      get last() {
        if (!this.proxyOf.nodes)
          return void 0;
        return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
      }
      normalize(nodes, sample) {
        if (typeof nodes === "string") {
          nodes = cleanSource(parse2(nodes).nodes);
        } else if (Array.isArray(nodes)) {
          nodes = nodes.slice(0);
          for (let i2 of nodes) {
            if (i2.parent)
              i2.parent.removeChild(i2, "ignore");
          }
        } else if (nodes.type === "root" && this.type !== "document") {
          nodes = nodes.nodes.slice(0);
          for (let i2 of nodes) {
            if (i2.parent)
              i2.parent.removeChild(i2, "ignore");
          }
        } else if (nodes.type) {
          nodes = [nodes];
        } else if (nodes.prop) {
          if (typeof nodes.value === "undefined") {
            throw new Error("Value field is missed in node creation");
          } else if (typeof nodes.value !== "string") {
            nodes.value = String(nodes.value);
          }
          nodes = [new Declaration(nodes)];
        } else if (nodes.selector) {
          nodes = [new Rule(nodes)];
        } else if (nodes.name) {
          nodes = [new AtRule(nodes)];
        } else if (nodes.text) {
          nodes = [new Comment2(nodes)];
        } else {
          throw new Error("Unknown node type in node creation");
        }
        let processed = nodes.map((i2) => {
          if (!i2[my])
            Container.rebuild(i2);
          i2 = i2.proxyOf;
          if (i2.parent)
            i2.parent.removeChild(i2);
          if (i2[isClean])
            markDirtyUp(i2);
          if (typeof i2.raws.before === "undefined") {
            if (sample && typeof sample.raws.before !== "undefined") {
              i2.raws.before = sample.raws.before.replace(/\S/g, "");
            }
          }
          i2.parent = this;
          return i2;
        });
        return processed;
      }
      getProxyProcessor() {
        return {
          set(node2, prop, value) {
            if (node2[prop] === value)
              return true;
            node2[prop] = value;
            if (prop === "name" || prop === "params" || prop === "selector") {
              node2.markDirty();
            }
            return true;
          },
          get(node2, prop) {
            if (prop === "proxyOf") {
              return node2;
            } else if (!node2[prop]) {
              return node2[prop];
            } else if (prop === "each" || typeof prop === "string" && prop.startsWith("walk")) {
              return (...args) => {
                return node2[prop](...args.map((i2) => {
                  if (typeof i2 === "function") {
                    return (child, index2) => i2(child.toProxy(), index2);
                  } else {
                    return i2;
                  }
                }));
              };
            } else if (prop === "every" || prop === "some") {
              return (cb) => {
                return node2[prop]((child, ...other) => cb(child.toProxy(), ...other));
              };
            } else if (prop === "root") {
              return () => node2.root().toProxy();
            } else if (prop === "nodes") {
              return node2.nodes.map((i2) => i2.toProxy());
            } else if (prop === "first" || prop === "last") {
              return node2[prop].toProxy();
            } else {
              return node2[prop];
            }
          }
        };
      }
      getIterator() {
        if (!this.lastEach)
          this.lastEach = 0;
        if (!this.indexes)
          this.indexes = {};
        this.lastEach += 1;
        let iterator = this.lastEach;
        this.indexes[iterator] = 0;
        return iterator;
      }
    };
    Container.registerParse = (dependant) => {
      parse2 = dependant;
    };
    Container.registerRule = (dependant) => {
      Rule = dependant;
    };
    Container.registerAtRule = (dependant) => {
      AtRule = dependant;
    };
    module2.exports = Container;
    Container.default = Container;
    Container.rebuild = (node2) => {
      if (node2.type === "atrule") {
        Object.setPrototypeOf(node2, AtRule.prototype);
      } else if (node2.type === "rule") {
        Object.setPrototypeOf(node2, Rule.prototype);
      } else if (node2.type === "decl") {
        Object.setPrototypeOf(node2, Declaration.prototype);
      } else if (node2.type === "comment") {
        Object.setPrototypeOf(node2, Comment2.prototype);
      }
      node2[my] = true;
      if (node2.nodes) {
        node2.nodes.forEach((child) => {
          Container.rebuild(child);
        });
      }
    };
  }
});

// node_modules/postcss/lib/document.js
var require_document = __commonJS({
  "node_modules/postcss/lib/document.js"(exports2, module2) {
    "use strict";
    var Container = require_container();
    var LazyResult;
    var Processor;
    var Document2 = class extends Container {
      constructor(defaults) {
        super(__spreadValues2({ type: "document" }, defaults));
        if (!this.nodes) {
          this.nodes = [];
        }
      }
      toResult(opts = {}) {
        let lazy = new LazyResult(new Processor(), this, opts);
        return lazy.stringify();
      }
    };
    Document2.registerLazyResult = (dependant) => {
      LazyResult = dependant;
    };
    Document2.registerProcessor = (dependant) => {
      Processor = dependant;
    };
    module2.exports = Document2;
    Document2.default = Document2;
  }
});

// node_modules/postcss/lib/warn-once.js
var require_warn_once = __commonJS({
  "node_modules/postcss/lib/warn-once.js"(exports2, module2) {
    "use strict";
    var printed = {};
    module2.exports = function warnOnce(message) {
      if (printed[message])
        return;
      printed[message] = true;
      if (typeof console !== "undefined" && console.warn) {
        console.warn(message);
      }
    };
  }
});

// node_modules/postcss/lib/warning.js
var require_warning = __commonJS({
  "node_modules/postcss/lib/warning.js"(exports2, module2) {
    "use strict";
    var Warning = class {
      constructor(text, opts = {}) {
        this.type = "warning";
        this.text = text;
        if (opts.node && opts.node.source) {
          let range2 = opts.node.rangeBy(opts);
          this.line = range2.start.line;
          this.column = range2.start.column;
          this.endLine = range2.end.line;
          this.endColumn = range2.end.column;
        }
        for (let opt in opts)
          this[opt] = opts[opt];
      }
      toString() {
        if (this.node) {
          return this.node.error(this.text, {
            plugin: this.plugin,
            index: this.index,
            word: this.word
          }).message;
        }
        if (this.plugin) {
          return this.plugin + ": " + this.text;
        }
        return this.text;
      }
    };
    module2.exports = Warning;
    Warning.default = Warning;
  }
});

// node_modules/postcss/lib/result.js
var require_result = __commonJS({
  "node_modules/postcss/lib/result.js"(exports2, module2) {
    "use strict";
    var Warning = require_warning();
    var Result = class {
      constructor(processor, root2, opts) {
        this.processor = processor;
        this.messages = [];
        this.root = root2;
        this.opts = opts;
        this.css = void 0;
        this.map = void 0;
      }
      toString() {
        return this.css;
      }
      warn(text, opts = {}) {
        if (!opts.plugin) {
          if (this.lastPlugin && this.lastPlugin.postcssPlugin) {
            opts.plugin = this.lastPlugin.postcssPlugin;
          }
        }
        let warning = new Warning(text, opts);
        this.messages.push(warning);
        return warning;
      }
      warnings() {
        return this.messages.filter((i2) => i2.type === "warning");
      }
      get content() {
        return this.css;
      }
    };
    module2.exports = Result;
    Result.default = Result;
  }
});

// node_modules/postcss/lib/tokenize.js
var require_tokenize = __commonJS({
  "node_modules/postcss/lib/tokenize.js"(exports2, module2) {
    "use strict";
    var SINGLE_QUOTE2 = "'".charCodeAt(0);
    var DOUBLE_QUOTE2 = '"'.charCodeAt(0);
    var BACKSLASH = "\\".charCodeAt(0);
    var SLASH2 = "/".charCodeAt(0);
    var NEWLINE2 = "\n".charCodeAt(0);
    var SPACE = " ".charCodeAt(0);
    var FEED = "\f".charCodeAt(0);
    var TAB = "	".charCodeAt(0);
    var CR = "\r".charCodeAt(0);
    var OPEN_SQUARE = "[".charCodeAt(0);
    var CLOSE_SQUARE = "]".charCodeAt(0);
    var OPEN_PARENTHESES = "(".charCodeAt(0);
    var CLOSE_PARENTHESES = ")".charCodeAt(0);
    var OPEN_CURLY = "{".charCodeAt(0);
    var CLOSE_CURLY = "}".charCodeAt(0);
    var SEMICOLON = ";".charCodeAt(0);
    var ASTERISK = "*".charCodeAt(0);
    var COLON2 = ":".charCodeAt(0);
    var AT = "@".charCodeAt(0);
    var RE_AT_END = /[\t\n\f\r "#'()/;[\\\]{}]/g;
    var RE_WORD_END = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g;
    var RE_BAD_BRACKET = /.[\n"'(/\\]/;
    var RE_HEX_ESCAPE = /[\da-f]/i;
    module2.exports = function tokenizer2(input, options2 = {}) {
      let css = input.css.valueOf();
      let ignore = options2.ignoreErrors;
      let code, next, quote, content2, escape2;
      let escaped2, escapePos, prev, n3, currentToken;
      let length = css.length;
      let pos2 = 0;
      let buffer2 = [];
      let returned = [];
      function position() {
        return pos2;
      }
      function unclosed(what) {
        throw input.error("Unclosed " + what, pos2);
      }
      function endOfFile() {
        return returned.length === 0 && pos2 >= length;
      }
      function nextToken(opts) {
        if (returned.length)
          return returned.pop();
        if (pos2 >= length)
          return;
        let ignoreUnclosed = opts ? opts.ignoreUnclosed : false;
        code = css.charCodeAt(pos2);
        switch (code) {
          case NEWLINE2:
          case SPACE:
          case TAB:
          case CR:
          case FEED: {
            next = pos2;
            do {
              next += 1;
              code = css.charCodeAt(next);
            } while (code === SPACE || code === NEWLINE2 || code === TAB || code === CR || code === FEED);
            currentToken = ["space", css.slice(pos2, next)];
            pos2 = next - 1;
            break;
          }
          case OPEN_SQUARE:
          case CLOSE_SQUARE:
          case OPEN_CURLY:
          case CLOSE_CURLY:
          case COLON2:
          case SEMICOLON:
          case CLOSE_PARENTHESES: {
            let controlChar = String.fromCharCode(code);
            currentToken = [controlChar, controlChar, pos2];
            break;
          }
          case OPEN_PARENTHESES: {
            prev = buffer2.length ? buffer2.pop()[1] : "";
            n3 = css.charCodeAt(pos2 + 1);
            if (prev === "url" && n3 !== SINGLE_QUOTE2 && n3 !== DOUBLE_QUOTE2 && n3 !== SPACE && n3 !== NEWLINE2 && n3 !== TAB && n3 !== FEED && n3 !== CR) {
              next = pos2;
              do {
                escaped2 = false;
                next = css.indexOf(")", next + 1);
                if (next === -1) {
                  if (ignore || ignoreUnclosed) {
                    next = pos2;
                    break;
                  } else {
                    unclosed("bracket");
                  }
                }
                escapePos = next;
                while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
                  escapePos -= 1;
                  escaped2 = !escaped2;
                }
              } while (escaped2);
              currentToken = ["brackets", css.slice(pos2, next + 1), pos2, next];
              pos2 = next;
            } else {
              next = css.indexOf(")", pos2 + 1);
              content2 = css.slice(pos2, next + 1);
              if (next === -1 || RE_BAD_BRACKET.test(content2)) {
                currentToken = ["(", "(", pos2];
              } else {
                currentToken = ["brackets", content2, pos2, next];
                pos2 = next;
              }
            }
            break;
          }
          case SINGLE_QUOTE2:
          case DOUBLE_QUOTE2: {
            quote = code === SINGLE_QUOTE2 ? "'" : '"';
            next = pos2;
            do {
              escaped2 = false;
              next = css.indexOf(quote, next + 1);
              if (next === -1) {
                if (ignore || ignoreUnclosed) {
                  next = pos2 + 1;
                  break;
                } else {
                  unclosed("string");
                }
              }
              escapePos = next;
              while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
                escapePos -= 1;
                escaped2 = !escaped2;
              }
            } while (escaped2);
            currentToken = ["string", css.slice(pos2, next + 1), pos2, next];
            pos2 = next;
            break;
          }
          case AT: {
            RE_AT_END.lastIndex = pos2 + 1;
            RE_AT_END.test(css);
            if (RE_AT_END.lastIndex === 0) {
              next = css.length - 1;
            } else {
              next = RE_AT_END.lastIndex - 2;
            }
            currentToken = ["at-word", css.slice(pos2, next + 1), pos2, next];
            pos2 = next;
            break;
          }
          case BACKSLASH: {
            next = pos2;
            escape2 = true;
            while (css.charCodeAt(next + 1) === BACKSLASH) {
              next += 1;
              escape2 = !escape2;
            }
            code = css.charCodeAt(next + 1);
            if (escape2 && code !== SLASH2 && code !== SPACE && code !== NEWLINE2 && code !== TAB && code !== CR && code !== FEED) {
              next += 1;
              if (RE_HEX_ESCAPE.test(css.charAt(next))) {
                while (RE_HEX_ESCAPE.test(css.charAt(next + 1))) {
                  next += 1;
                }
                if (css.charCodeAt(next + 1) === SPACE) {
                  next += 1;
                }
              }
            }
            currentToken = ["word", css.slice(pos2, next + 1), pos2, next];
            pos2 = next;
            break;
          }
          default: {
            if (code === SLASH2 && css.charCodeAt(pos2 + 1) === ASTERISK) {
              next = css.indexOf("*/", pos2 + 2) + 1;
              if (next === 0) {
                if (ignore || ignoreUnclosed) {
                  next = css.length;
                } else {
                  unclosed("comment");
                }
              }
              currentToken = ["comment", css.slice(pos2, next + 1), pos2, next];
              pos2 = next;
            } else {
              RE_WORD_END.lastIndex = pos2 + 1;
              RE_WORD_END.test(css);
              if (RE_WORD_END.lastIndex === 0) {
                next = css.length - 1;
              } else {
                next = RE_WORD_END.lastIndex - 2;
              }
              currentToken = ["word", css.slice(pos2, next + 1), pos2, next];
              buffer2.push(currentToken);
              pos2 = next;
            }
            break;
          }
        }
        pos2++;
        return currentToken;
      }
      function back(token2) {
        returned.push(token2);
      }
      return {
        back,
        nextToken,
        endOfFile,
        position
      };
    };
  }
});

// node_modules/postcss/lib/at-rule.js
var require_at_rule = __commonJS({
  "node_modules/postcss/lib/at-rule.js"(exports2, module2) {
    "use strict";
    var Container = require_container();
    var AtRule = class extends Container {
      constructor(defaults) {
        super(defaults);
        this.type = "atrule";
      }
      append(...children) {
        if (!this.proxyOf.nodes)
          this.nodes = [];
        return super.append(...children);
      }
      prepend(...children) {
        if (!this.proxyOf.nodes)
          this.nodes = [];
        return super.prepend(...children);
      }
    };
    module2.exports = AtRule;
    AtRule.default = AtRule;
    Container.registerAtRule(AtRule);
  }
});

// node_modules/postcss/lib/root.js
var require_root = __commonJS({
  "node_modules/postcss/lib/root.js"(exports2, module2) {
    "use strict";
    var Container = require_container();
    var LazyResult;
    var Processor;
    var Root = class extends Container {
      constructor(defaults) {
        super(defaults);
        this.type = "root";
        if (!this.nodes)
          this.nodes = [];
      }
      removeChild(child, ignore) {
        let index2 = this.index(child);
        if (!ignore && index2 === 0 && this.nodes.length > 1) {
          this.nodes[1].raws.before = this.nodes[index2].raws.before;
        }
        return super.removeChild(child);
      }
      normalize(child, sample, type) {
        let nodes = super.normalize(child);
        if (sample) {
          if (type === "prepend") {
            if (this.nodes.length > 1) {
              sample.raws.before = this.nodes[1].raws.before;
            } else {
              delete sample.raws.before;
            }
          } else if (this.first !== sample) {
            for (let node2 of nodes) {
              node2.raws.before = sample.raws.before;
            }
          }
        }
        return nodes;
      }
      toResult(opts = {}) {
        let lazy = new LazyResult(new Processor(), this, opts);
        return lazy.stringify();
      }
    };
    Root.registerLazyResult = (dependant) => {
      LazyResult = dependant;
    };
    Root.registerProcessor = (dependant) => {
      Processor = dependant;
    };
    module2.exports = Root;
    Root.default = Root;
  }
});

// node_modules/postcss/lib/list.js
var require_list = __commonJS({
  "node_modules/postcss/lib/list.js"(exports2, module2) {
    "use strict";
    var list2 = {
      split(string2, separators, last) {
        let array2 = [];
        let current = "";
        let split2 = false;
        let func = 0;
        let quote = false;
        let escape2 = false;
        for (let letter of string2) {
          if (escape2) {
            escape2 = false;
          } else if (letter === "\\") {
            escape2 = true;
          } else if (quote) {
            if (letter === quote) {
              quote = false;
            }
          } else if (letter === '"' || letter === "'") {
            quote = letter;
          } else if (letter === "(") {
            func += 1;
          } else if (letter === ")") {
            if (func > 0)
              func -= 1;
          } else if (func === 0) {
            if (separators.includes(letter))
              split2 = true;
          }
          if (split2) {
            if (current !== "")
              array2.push(current.trim());
            current = "";
            split2 = false;
          } else {
            current += letter;
          }
        }
        if (last || current !== "")
          array2.push(current.trim());
        return array2;
      },
      space(string2) {
        let spaces = [" ", "\n", "	"];
        return list2.split(string2, spaces);
      },
      comma(string2) {
        return list2.split(string2, [","], true);
      }
    };
    module2.exports = list2;
    list2.default = list2;
  }
});

// node_modules/postcss/lib/rule.js
var require_rule = __commonJS({
  "node_modules/postcss/lib/rule.js"(exports2, module2) {
    "use strict";
    var Container = require_container();
    var list2 = require_list();
    var Rule = class extends Container {
      constructor(defaults) {
        super(defaults);
        this.type = "rule";
        if (!this.nodes)
          this.nodes = [];
      }
      get selectors() {
        return list2.comma(this.selector);
      }
      set selectors(values) {
        let match2 = this.selector ? this.selector.match(/,\s*/) : null;
        let sep = match2 ? match2[0] : "," + this.raw("between", "beforeOpen");
        this.selector = values.join(sep);
      }
    };
    module2.exports = Rule;
    Rule.default = Rule;
    Container.registerRule(Rule);
  }
});

// node_modules/postcss/lib/parser.js
var require_parser = __commonJS({
  "node_modules/postcss/lib/parser.js"(exports2, module2) {
    "use strict";
    var Declaration = require_declaration();
    var tokenizer2 = require_tokenize();
    var Comment2 = require_comment();
    var AtRule = require_at_rule();
    var Root = require_root();
    var Rule = require_rule();
    var SAFE_COMMENT_NEIGHBOR = {
      empty: true,
      space: true
    };
    function findLastWithPosition(tokens) {
      for (let i2 = tokens.length - 1; i2 >= 0; i2--) {
        let token2 = tokens[i2];
        let pos2 = token2[3] || token2[2];
        if (pos2)
          return pos2;
      }
    }
    var Parser2 = class {
      constructor(input) {
        this.input = input;
        this.root = new Root();
        this.current = this.root;
        this.spaces = "";
        this.semicolon = false;
        this.customProperty = false;
        this.createTokenizer();
        this.root.source = { input, start: { offset: 0, line: 1, column: 1 } };
      }
      createTokenizer() {
        this.tokenizer = tokenizer2(this.input);
      }
      parse() {
        let token2;
        while (!this.tokenizer.endOfFile()) {
          token2 = this.tokenizer.nextToken();
          switch (token2[0]) {
            case "space":
              this.spaces += token2[1];
              break;
            case ";":
              this.freeSemicolon(token2);
              break;
            case "}":
              this.end(token2);
              break;
            case "comment":
              this.comment(token2);
              break;
            case "at-word":
              this.atrule(token2);
              break;
            case "{":
              this.emptyRule(token2);
              break;
            default:
              this.other(token2);
              break;
          }
        }
        this.endFile();
      }
      comment(token2) {
        let node2 = new Comment2();
        this.init(node2, token2[2]);
        node2.source.end = this.getPosition(token2[3] || token2[2]);
        let text = token2[1].slice(2, -2);
        if (/^\s*$/.test(text)) {
          node2.text = "";
          node2.raws.left = text;
          node2.raws.right = "";
        } else {
          let match2 = text.match(/^(\s*)([^]*\S)(\s*)$/);
          node2.text = match2[2];
          node2.raws.left = match2[1];
          node2.raws.right = match2[3];
        }
      }
      emptyRule(token2) {
        let node2 = new Rule();
        this.init(node2, token2[2]);
        node2.selector = "";
        node2.raws.between = "";
        this.current = node2;
      }
      other(start) {
        let end = false;
        let type = null;
        let colon = false;
        let bracket = null;
        let brackets = [];
        let customProperty = start[1].startsWith("--");
        let tokens = [];
        let token2 = start;
        while (token2) {
          type = token2[0];
          tokens.push(token2);
          if (type === "(" || type === "[") {
            if (!bracket)
              bracket = token2;
            brackets.push(type === "(" ? ")" : "]");
          } else if (customProperty && colon && type === "{") {
            if (!bracket)
              bracket = token2;
            brackets.push("}");
          } else if (brackets.length === 0) {
            if (type === ";") {
              if (colon) {
                this.decl(tokens, customProperty);
                return;
              } else {
                break;
              }
            } else if (type === "{") {
              this.rule(tokens);
              return;
            } else if (type === "}") {
              this.tokenizer.back(tokens.pop());
              end = true;
              break;
            } else if (type === ":") {
              colon = true;
            }
          } else if (type === brackets[brackets.length - 1]) {
            brackets.pop();
            if (brackets.length === 0)
              bracket = null;
          }
          token2 = this.tokenizer.nextToken();
        }
        if (this.tokenizer.endOfFile())
          end = true;
        if (brackets.length > 0)
          this.unclosedBracket(bracket);
        if (end && colon) {
          if (!customProperty) {
            while (tokens.length) {
              token2 = tokens[tokens.length - 1][0];
              if (token2 !== "space" && token2 !== "comment")
                break;
              this.tokenizer.back(tokens.pop());
            }
          }
          this.decl(tokens, customProperty);
        } else {
          this.unknownWord(tokens);
        }
      }
      rule(tokens) {
        tokens.pop();
        let node2 = new Rule();
        this.init(node2, tokens[0][2]);
        node2.raws.between = this.spacesAndCommentsFromEnd(tokens);
        this.raw(node2, "selector", tokens);
        this.current = node2;
      }
      decl(tokens, customProperty) {
        let node2 = new Declaration();
        this.init(node2, tokens[0][2]);
        let last = tokens[tokens.length - 1];
        if (last[0] === ";") {
          this.semicolon = true;
          tokens.pop();
        }
        node2.source.end = this.getPosition(last[3] || last[2] || findLastWithPosition(tokens));
        while (tokens[0][0] !== "word") {
          if (tokens.length === 1)
            this.unknownWord(tokens);
          node2.raws.before += tokens.shift()[1];
        }
        node2.source.start = this.getPosition(tokens[0][2]);
        node2.prop = "";
        while (tokens.length) {
          let type = tokens[0][0];
          if (type === ":" || type === "space" || type === "comment") {
            break;
          }
          node2.prop += tokens.shift()[1];
        }
        node2.raws.between = "";
        let token2;
        while (tokens.length) {
          token2 = tokens.shift();
          if (token2[0] === ":") {
            node2.raws.between += token2[1];
            break;
          } else {
            if (token2[0] === "word" && /\w/.test(token2[1])) {
              this.unknownWord([token2]);
            }
            node2.raws.between += token2[1];
          }
        }
        if (node2.prop[0] === "_" || node2.prop[0] === "*") {
          node2.raws.before += node2.prop[0];
          node2.prop = node2.prop.slice(1);
        }
        let firstSpaces = [];
        let next;
        while (tokens.length) {
          next = tokens[0][0];
          if (next !== "space" && next !== "comment")
            break;
          firstSpaces.push(tokens.shift());
        }
        this.precheckMissedSemicolon(tokens);
        for (let i2 = tokens.length - 1; i2 >= 0; i2--) {
          token2 = tokens[i2];
          if (token2[1].toLowerCase() === "!important") {
            node2.important = true;
            let string2 = this.stringFrom(tokens, i2);
            string2 = this.spacesFromEnd(tokens) + string2;
            if (string2 !== " !important")
              node2.raws.important = string2;
            break;
          } else if (token2[1].toLowerCase() === "important") {
            let cache2 = tokens.slice(0);
            let str = "";
            for (let j2 = i2; j2 > 0; j2--) {
              let type = cache2[j2][0];
              if (str.trim().indexOf("!") === 0 && type !== "space") {
                break;
              }
              str = cache2.pop()[1] + str;
            }
            if (str.trim().indexOf("!") === 0) {
              node2.important = true;
              node2.raws.important = str;
              tokens = cache2;
            }
          }
          if (token2[0] !== "space" && token2[0] !== "comment") {
            break;
          }
        }
        let hasWord = tokens.some((i2) => i2[0] !== "space" && i2[0] !== "comment");
        if (hasWord) {
          node2.raws.between += firstSpaces.map((i2) => i2[1]).join("");
          firstSpaces = [];
        }
        this.raw(node2, "value", firstSpaces.concat(tokens), customProperty);
        if (node2.value.includes(":") && !customProperty) {
          this.checkMissedSemicolon(tokens);
        }
      }
      atrule(token2) {
        let node2 = new AtRule();
        node2.name = token2[1].slice(1);
        if (node2.name === "") {
          this.unnamedAtrule(node2, token2);
        }
        this.init(node2, token2[2]);
        let type;
        let prev;
        let shift;
        let last = false;
        let open2 = false;
        let params = [];
        let brackets = [];
        while (!this.tokenizer.endOfFile()) {
          token2 = this.tokenizer.nextToken();
          type = token2[0];
          if (type === "(" || type === "[") {
            brackets.push(type === "(" ? ")" : "]");
          } else if (type === "{" && brackets.length > 0) {
            brackets.push("}");
          } else if (type === brackets[brackets.length - 1]) {
            brackets.pop();
          }
          if (brackets.length === 0) {
            if (type === ";") {
              node2.source.end = this.getPosition(token2[2]);
              this.semicolon = true;
              break;
            } else if (type === "{") {
              open2 = true;
              break;
            } else if (type === "}") {
              if (params.length > 0) {
                shift = params.length - 1;
                prev = params[shift];
                while (prev && prev[0] === "space") {
                  prev = params[--shift];
                }
                if (prev) {
                  node2.source.end = this.getPosition(prev[3] || prev[2]);
                }
              }
              this.end(token2);
              break;
            } else {
              params.push(token2);
            }
          } else {
            params.push(token2);
          }
          if (this.tokenizer.endOfFile()) {
            last = true;
            break;
          }
        }
        node2.raws.between = this.spacesAndCommentsFromEnd(params);
        if (params.length) {
          node2.raws.afterName = this.spacesAndCommentsFromStart(params);
          this.raw(node2, "params", params);
          if (last) {
            token2 = params[params.length - 1];
            node2.source.end = this.getPosition(token2[3] || token2[2]);
            this.spaces = node2.raws.between;
            node2.raws.between = "";
          }
        } else {
          node2.raws.afterName = "";
          node2.params = "";
        }
        if (open2) {
          node2.nodes = [];
          this.current = node2;
        }
      }
      end(token2) {
        if (this.current.nodes && this.current.nodes.length) {
          this.current.raws.semicolon = this.semicolon;
        }
        this.semicolon = false;
        this.current.raws.after = (this.current.raws.after || "") + this.spaces;
        this.spaces = "";
        if (this.current.parent) {
          this.current.source.end = this.getPosition(token2[2]);
          this.current = this.current.parent;
        } else {
          this.unexpectedClose(token2);
        }
      }
      endFile() {
        if (this.current.parent)
          this.unclosedBlock();
        if (this.current.nodes && this.current.nodes.length) {
          this.current.raws.semicolon = this.semicolon;
        }
        this.current.raws.after = (this.current.raws.after || "") + this.spaces;
      }
      freeSemicolon(token2) {
        this.spaces += token2[1];
        if (this.current.nodes) {
          let prev = this.current.nodes[this.current.nodes.length - 1];
          if (prev && prev.type === "rule" && !prev.raws.ownSemicolon) {
            prev.raws.ownSemicolon = this.spaces;
            this.spaces = "";
          }
        }
      }
      getPosition(offset2) {
        let pos2 = this.input.fromOffset(offset2);
        return {
          offset: offset2,
          line: pos2.line,
          column: pos2.col
        };
      }
      init(node2, offset2) {
        this.current.push(node2);
        node2.source = {
          start: this.getPosition(offset2),
          input: this.input
        };
        node2.raws.before = this.spaces;
        this.spaces = "";
        if (node2.type !== "comment")
          this.semicolon = false;
      }
      raw(node2, prop, tokens, customProperty) {
        let token2, type;
        let length = tokens.length;
        let value = "";
        let clean = true;
        let next, prev;
        for (let i2 = 0; i2 < length; i2 += 1) {
          token2 = tokens[i2];
          type = token2[0];
          if (type === "space" && i2 === length - 1 && !customProperty) {
            clean = false;
          } else if (type === "comment") {
            prev = tokens[i2 - 1] ? tokens[i2 - 1][0] : "empty";
            next = tokens[i2 + 1] ? tokens[i2 + 1][0] : "empty";
            if (!SAFE_COMMENT_NEIGHBOR[prev] && !SAFE_COMMENT_NEIGHBOR[next]) {
              if (value.slice(-1) === ",") {
                clean = false;
              } else {
                value += token2[1];
              }
            } else {
              clean = false;
            }
          } else {
            value += token2[1];
          }
        }
        if (!clean) {
          let raw = tokens.reduce((all, i2) => all + i2[1], "");
          node2.raws[prop] = { value, raw };
        }
        node2[prop] = value;
      }
      spacesAndCommentsFromEnd(tokens) {
        let lastTokenType;
        let spaces = "";
        while (tokens.length) {
          lastTokenType = tokens[tokens.length - 1][0];
          if (lastTokenType !== "space" && lastTokenType !== "comment")
            break;
          spaces = tokens.pop()[1] + spaces;
        }
        return spaces;
      }
      spacesAndCommentsFromStart(tokens) {
        let next;
        let spaces = "";
        while (tokens.length) {
          next = tokens[0][0];
          if (next !== "space" && next !== "comment")
            break;
          spaces += tokens.shift()[1];
        }
        return spaces;
      }
      spacesFromEnd(tokens) {
        let lastTokenType;
        let spaces = "";
        while (tokens.length) {
          lastTokenType = tokens[tokens.length - 1][0];
          if (lastTokenType !== "space")
            break;
          spaces = tokens.pop()[1] + spaces;
        }
        return spaces;
      }
      stringFrom(tokens, from) {
        let result2 = "";
        for (let i2 = from; i2 < tokens.length; i2++) {
          result2 += tokens[i2][1];
        }
        tokens.splice(from, tokens.length - from);
        return result2;
      }
      colon(tokens) {
        let brackets = 0;
        let token2, type, prev;
        for (let [i2, element] of tokens.entries()) {
          token2 = element;
          type = token2[0];
          if (type === "(") {
            brackets += 1;
          }
          if (type === ")") {
            brackets -= 1;
          }
          if (brackets === 0 && type === ":") {
            if (!prev) {
              this.doubleColon(token2);
            } else if (prev[0] === "word" && prev[1] === "progid") {
              continue;
            } else {
              return i2;
            }
          }
          prev = token2;
        }
        return false;
      }
      unclosedBracket(bracket) {
        throw this.input.error("Unclosed bracket", { offset: bracket[2] }, { offset: bracket[2] + 1 });
      }
      unknownWord(tokens) {
        throw this.input.error("Unknown word", { offset: tokens[0][2] }, { offset: tokens[0][2] + tokens[0][1].length });
      }
      unexpectedClose(token2) {
        throw this.input.error("Unexpected }", { offset: token2[2] }, { offset: token2[2] + 1 });
      }
      unclosedBlock() {
        let pos2 = this.current.source.start;
        throw this.input.error("Unclosed block", pos2.line, pos2.column);
      }
      doubleColon(token2) {
        throw this.input.error("Double colon", { offset: token2[2] }, { offset: token2[2] + token2[1].length });
      }
      unnamedAtrule(node2, token2) {
        throw this.input.error("At-rule without name", { offset: token2[2] }, { offset: token2[2] + token2[1].length });
      }
      precheckMissedSemicolon() {
      }
      checkMissedSemicolon(tokens) {
        let colon = this.colon(tokens);
        if (colon === false)
          return;
        let founded = 0;
        let token2;
        for (let j2 = colon - 1; j2 >= 0; j2--) {
          token2 = tokens[j2];
          if (token2[0] !== "space") {
            founded += 1;
            if (founded === 2)
              break;
          }
        }
        throw this.input.error("Missed semicolon", token2[0] === "word" ? token2[3] + 1 : token2[2]);
      }
    };
    module2.exports = Parser2;
  }
});

// node_modules/postcss/lib/parse.js
var require_parse = __commonJS({
  "node_modules/postcss/lib/parse.js"(exports2, module2) {
    "use strict";
    var Container = require_container();
    var Parser2 = require_parser();
    var Input = require_input();
    function parse2(css, opts) {
      let input = new Input(css, opts);
      let parser2 = new Parser2(input);
      try {
        parser2.parse();
      } catch (e2) {
        if (true) {
          if (e2.name === "CssSyntaxError" && opts && opts.from) {
            if (/\.scss$/i.test(opts.from)) {
              e2.message += "\nYou tried to parse SCSS with the standard CSS parser; try again with the postcss-scss parser";
            } else if (/\.sass/i.test(opts.from)) {
              e2.message += "\nYou tried to parse Sass with the standard CSS parser; try again with the postcss-sass parser";
            } else if (/\.less$/i.test(opts.from)) {
              e2.message += "\nYou tried to parse Less with the standard CSS parser; try again with the postcss-less parser";
            }
          }
        }
        throw e2;
      }
      return parser2.root;
    }
    module2.exports = parse2;
    parse2.default = parse2;
    Container.registerParse(parse2);
  }
});

// node_modules/postcss/lib/lazy-result.js
var require_lazy_result = __commonJS({
  "node_modules/postcss/lib/lazy-result.js"(exports2, module2) {
    "use strict";
    var { isClean, my } = require_symbols();
    var MapGenerator = require_map_generator();
    var stringify2 = require_stringify();
    var Container = require_container();
    var Document2 = require_document();
    var warnOnce = require_warn_once();
    var Result = require_result();
    var parse2 = require_parse();
    var Root = require_root();
    var TYPE_TO_CLASS_NAME = {
      document: "Document",
      root: "Root",
      atrule: "AtRule",
      rule: "Rule",
      decl: "Declaration",
      comment: "Comment"
    };
    var PLUGIN_PROPS = {
      postcssPlugin: true,
      prepare: true,
      Once: true,
      Document: true,
      Root: true,
      Declaration: true,
      Rule: true,
      AtRule: true,
      Comment: true,
      DeclarationExit: true,
      RuleExit: true,
      AtRuleExit: true,
      CommentExit: true,
      RootExit: true,
      DocumentExit: true,
      OnceExit: true
    };
    var NOT_VISITORS = {
      postcssPlugin: true,
      prepare: true,
      Once: true
    };
    var CHILDREN = 0;
    function isPromise(obj) {
      return typeof obj === "object" && typeof obj.then === "function";
    }
    function getEvents(node2) {
      let key2 = false;
      let type = TYPE_TO_CLASS_NAME[node2.type];
      if (node2.type === "decl") {
        key2 = node2.prop.toLowerCase();
      } else if (node2.type === "atrule") {
        key2 = node2.name.toLowerCase();
      }
      if (key2 && node2.append) {
        return [
          type,
          type + "-" + key2,
          CHILDREN,
          type + "Exit",
          type + "Exit-" + key2
        ];
      } else if (key2) {
        return [type, type + "-" + key2, type + "Exit", type + "Exit-" + key2];
      } else if (node2.append) {
        return [type, CHILDREN, type + "Exit"];
      } else {
        return [type, type + "Exit"];
      }
    }
    function toStack(node2) {
      let events2;
      if (node2.type === "document") {
        events2 = ["Document", CHILDREN, "DocumentExit"];
      } else if (node2.type === "root") {
        events2 = ["Root", CHILDREN, "RootExit"];
      } else {
        events2 = getEvents(node2);
      }
      return {
        node: node2,
        events: events2,
        eventIndex: 0,
        visitors: [],
        visitorIndex: 0,
        iterator: 0
      };
    }
    function cleanMarks(node2) {
      node2[isClean] = false;
      if (node2.nodes)
        node2.nodes.forEach((i2) => cleanMarks(i2));
      return node2;
    }
    var postcss2 = {};
    var LazyResult = class {
      constructor(processor, css, opts) {
        this.stringified = false;
        this.processed = false;
        let root2;
        if (typeof css === "object" && css !== null && (css.type === "root" || css.type === "document")) {
          root2 = cleanMarks(css);
        } else if (css instanceof LazyResult || css instanceof Result) {
          root2 = cleanMarks(css.root);
          if (css.map) {
            if (typeof opts.map === "undefined")
              opts.map = {};
            if (!opts.map.inline)
              opts.map.inline = false;
            opts.map.prev = css.map;
          }
        } else {
          let parser2 = parse2;
          if (opts.syntax)
            parser2 = opts.syntax.parse;
          if (opts.parser)
            parser2 = opts.parser;
          if (parser2.parse)
            parser2 = parser2.parse;
          try {
            root2 = parser2(css, opts);
          } catch (error2) {
            this.processed = true;
            this.error = error2;
          }
          if (root2 && !root2[my]) {
            Container.rebuild(root2);
          }
        }
        this.result = new Result(processor, root2, opts);
        this.helpers = __spreadProps2(__spreadValues2({}, postcss2), { result: this.result, postcss: postcss2 });
        this.plugins = this.processor.plugins.map((plugin) => {
          if (typeof plugin === "object" && plugin.prepare) {
            return __spreadValues2(__spreadValues2({}, plugin), plugin.prepare(this.result));
          } else {
            return plugin;
          }
        });
      }
      get [Symbol.toStringTag]() {
        return "LazyResult";
      }
      get processor() {
        return this.result.processor;
      }
      get opts() {
        return this.result.opts;
      }
      get css() {
        return this.stringify().css;
      }
      get content() {
        return this.stringify().content;
      }
      get map() {
        return this.stringify().map;
      }
      get root() {
        return this.sync().root;
      }
      get messages() {
        return this.sync().messages;
      }
      warnings() {
        return this.sync().warnings();
      }
      toString() {
        return this.css;
      }
      then(onFulfilled, onRejected) {
        if (true) {
          if (!("from" in this.opts)) {
            warnOnce("Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning.");
          }
        }
        return this.async().then(onFulfilled, onRejected);
      }
      catch(onRejected) {
        return this.async().catch(onRejected);
      }
      finally(onFinally) {
        return this.async().then(onFinally, onFinally);
      }
      async() {
        if (this.error)
          return Promise.reject(this.error);
        if (this.processed)
          return Promise.resolve(this.result);
        if (!this.processing) {
          this.processing = this.runAsync();
        }
        return this.processing;
      }
      sync() {
        if (this.error)
          throw this.error;
        if (this.processed)
          return this.result;
        this.processed = true;
        if (this.processing) {
          throw this.getAsyncError();
        }
        for (let plugin of this.plugins) {
          let promise2 = this.runOnRoot(plugin);
          if (isPromise(promise2)) {
            throw this.getAsyncError();
          }
        }
        this.prepareVisitors();
        if (this.hasListener) {
          let root2 = this.result.root;
          while (!root2[isClean]) {
            root2[isClean] = true;
            this.walkSync(root2);
          }
          if (this.listeners.OnceExit) {
            if (root2.type === "document") {
              for (let subRoot of root2.nodes) {
                this.visitSync(this.listeners.OnceExit, subRoot);
              }
            } else {
              this.visitSync(this.listeners.OnceExit, root2);
            }
          }
        }
        return this.result;
      }
      stringify() {
        if (this.error)
          throw this.error;
        if (this.stringified)
          return this.result;
        this.stringified = true;
        this.sync();
        let opts = this.result.opts;
        let str = stringify2;
        if (opts.syntax)
          str = opts.syntax.stringify;
        if (opts.stringifier)
          str = opts.stringifier;
        if (str.stringify)
          str = str.stringify;
        let map2 = new MapGenerator(str, this.result.root, this.result.opts);
        let data2 = map2.generate();
        this.result.css = data2[0];
        this.result.map = data2[1];
        return this.result;
      }
      walkSync(node2) {
        node2[isClean] = true;
        let events2 = getEvents(node2);
        for (let event of events2) {
          if (event === CHILDREN) {
            if (node2.nodes) {
              node2.each((child) => {
                if (!child[isClean])
                  this.walkSync(child);
              });
            }
          } else {
            let visitors = this.listeners[event];
            if (visitors) {
              if (this.visitSync(visitors, node2.toProxy()))
                return;
            }
          }
        }
      }
      visitSync(visitors, node2) {
        for (let [plugin, visitor] of visitors) {
          this.result.lastPlugin = plugin;
          let promise2;
          try {
            promise2 = visitor(node2, this.helpers);
          } catch (e2) {
            throw this.handleError(e2, node2.proxyOf);
          }
          if (node2.type !== "root" && node2.type !== "document" && !node2.parent) {
            return true;
          }
          if (isPromise(promise2)) {
            throw this.getAsyncError();
          }
        }
      }
      runOnRoot(plugin) {
        this.result.lastPlugin = plugin;
        try {
          if (typeof plugin === "object" && plugin.Once) {
            if (this.result.root.type === "document") {
              let roots = this.result.root.nodes.map((root2) => plugin.Once(root2, this.helpers));
              if (isPromise(roots[0])) {
                return Promise.all(roots);
              }
              return roots;
            }
            return plugin.Once(this.result.root, this.helpers);
          } else if (typeof plugin === "function") {
            return plugin(this.result.root, this.result);
          }
        } catch (error2) {
          throw this.handleError(error2);
        }
      }
      getAsyncError() {
        throw new Error("Use process(css).then(cb) to work with async plugins");
      }
      handleError(error2, node2) {
        let plugin = this.result.lastPlugin;
        try {
          if (node2)
            node2.addToError(error2);
          this.error = error2;
          if (error2.name === "CssSyntaxError" && !error2.plugin) {
            error2.plugin = plugin.postcssPlugin;
            error2.setMessage();
          } else if (plugin.postcssVersion) {
            if (true) {
              let pluginName = plugin.postcssPlugin;
              let pluginVer = plugin.postcssVersion;
              let runtimeVer = this.result.processor.version;
              let a2 = pluginVer.split(".");
              let b2 = runtimeVer.split(".");
              if (a2[0] !== b2[0] || parseInt(a2[1]) > parseInt(b2[1])) {
                console.error("Unknown error from PostCSS plugin. Your current PostCSS version is " + runtimeVer + ", but " + pluginName + " uses " + pluginVer + ". Perhaps this is the source of the error below.");
              }
            }
          }
        } catch (err) {
          if (console && console.error)
            console.error(err);
        }
        return error2;
      }
      async runAsync() {
        this.plugin = 0;
        for (let i2 = 0; i2 < this.plugins.length; i2++) {
          let plugin = this.plugins[i2];
          let promise2 = this.runOnRoot(plugin);
          if (isPromise(promise2)) {
            try {
              await promise2;
            } catch (error2) {
              throw this.handleError(error2);
            }
          }
        }
        this.prepareVisitors();
        if (this.hasListener) {
          let root2 = this.result.root;
          while (!root2[isClean]) {
            root2[isClean] = true;
            let stack2 = [toStack(root2)];
            while (stack2.length > 0) {
              let promise2 = this.visitTick(stack2);
              if (isPromise(promise2)) {
                try {
                  await promise2;
                } catch (e2) {
                  let node2 = stack2[stack2.length - 1].node;
                  throw this.handleError(e2, node2);
                }
              }
            }
          }
          if (this.listeners.OnceExit) {
            for (let [plugin, visitor] of this.listeners.OnceExit) {
              this.result.lastPlugin = plugin;
              try {
                if (root2.type === "document") {
                  let roots = root2.nodes.map((subRoot) => visitor(subRoot, this.helpers));
                  await Promise.all(roots);
                } else {
                  await visitor(root2, this.helpers);
                }
              } catch (e2) {
                throw this.handleError(e2);
              }
            }
          }
        }
        this.processed = true;
        return this.stringify();
      }
      prepareVisitors() {
        this.listeners = {};
        let add = (plugin, type, cb) => {
          if (!this.listeners[type])
            this.listeners[type] = [];
          this.listeners[type].push([plugin, cb]);
        };
        for (let plugin of this.plugins) {
          if (typeof plugin === "object") {
            for (let event in plugin) {
              if (!PLUGIN_PROPS[event] && /^[A-Z]/.test(event)) {
                throw new Error(`Unknown event ${event} in ${plugin.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`);
              }
              if (!NOT_VISITORS[event]) {
                if (typeof plugin[event] === "object") {
                  for (let filter2 in plugin[event]) {
                    if (filter2 === "*") {
                      add(plugin, event, plugin[event][filter2]);
                    } else {
                      add(plugin, event + "-" + filter2.toLowerCase(), plugin[event][filter2]);
                    }
                  }
                } else if (typeof plugin[event] === "function") {
                  add(plugin, event, plugin[event]);
                }
              }
            }
          }
        }
        this.hasListener = Object.keys(this.listeners).length > 0;
      }
      visitTick(stack2) {
        let visit2 = stack2[stack2.length - 1];
        let { node: node2, visitors } = visit2;
        if (node2.type !== "root" && node2.type !== "document" && !node2.parent) {
          stack2.pop();
          return;
        }
        if (visitors.length > 0 && visit2.visitorIndex < visitors.length) {
          let [plugin, visitor] = visitors[visit2.visitorIndex];
          visit2.visitorIndex += 1;
          if (visit2.visitorIndex === visitors.length) {
            visit2.visitors = [];
            visit2.visitorIndex = 0;
          }
          this.result.lastPlugin = plugin;
          try {
            return visitor(node2.toProxy(), this.helpers);
          } catch (e2) {
            throw this.handleError(e2, node2);
          }
        }
        if (visit2.iterator !== 0) {
          let iterator = visit2.iterator;
          let child;
          while (child = node2.nodes[node2.indexes[iterator]]) {
            node2.indexes[iterator] += 1;
            if (!child[isClean]) {
              child[isClean] = true;
              stack2.push(toStack(child));
              return;
            }
          }
          visit2.iterator = 0;
          delete node2.indexes[iterator];
        }
        let events2 = visit2.events;
        while (visit2.eventIndex < events2.length) {
          let event = events2[visit2.eventIndex];
          visit2.eventIndex += 1;
          if (event === CHILDREN) {
            if (node2.nodes && node2.nodes.length) {
              node2[isClean] = true;
              visit2.iterator = node2.getIterator();
            }
            return;
          } else if (this.listeners[event]) {
            visit2.visitors = this.listeners[event];
            return;
          }
        }
        stack2.pop();
      }
    };
    LazyResult.registerPostcss = (dependant) => {
      postcss2 = dependant;
    };
    module2.exports = LazyResult;
    LazyResult.default = LazyResult;
    Root.registerLazyResult(LazyResult);
    Document2.registerLazyResult(LazyResult);
  }
});

// node_modules/postcss/lib/no-work-result.js
var require_no_work_result = __commonJS({
  "node_modules/postcss/lib/no-work-result.js"(exports2, module2) {
    "use strict";
    var MapGenerator = require_map_generator();
    var stringify2 = require_stringify();
    var warnOnce = require_warn_once();
    var parse2 = require_parse();
    var Result = require_result();
    var NoWorkResult = class {
      constructor(processor, css, opts) {
        css = css.toString();
        this.stringified = false;
        this._processor = processor;
        this._css = css;
        this._opts = opts;
        this._map = void 0;
        let root2;
        let str = stringify2;
        this.result = new Result(this._processor, root2, this._opts);
        this.result.css = css;
        let self2 = this;
        Object.defineProperty(this.result, "root", {
          get() {
            return self2.root;
          }
        });
        let map2 = new MapGenerator(str, root2, this._opts, css);
        if (map2.isMap()) {
          let [generatedCSS, generatedMap] = map2.generate();
          if (generatedCSS) {
            this.result.css = generatedCSS;
          }
          if (generatedMap) {
            this.result.map = generatedMap;
          }
        }
      }
      get [Symbol.toStringTag]() {
        return "NoWorkResult";
      }
      get processor() {
        return this.result.processor;
      }
      get opts() {
        return this.result.opts;
      }
      get css() {
        return this.result.css;
      }
      get content() {
        return this.result.css;
      }
      get map() {
        return this.result.map;
      }
      get root() {
        if (this._root) {
          return this._root;
        }
        let root2;
        let parser2 = parse2;
        try {
          root2 = parser2(this._css, this._opts);
        } catch (error2) {
          this.error = error2;
        }
        if (this.error) {
          throw this.error;
        } else {
          this._root = root2;
          return root2;
        }
      }
      get messages() {
        return [];
      }
      warnings() {
        return [];
      }
      toString() {
        return this._css;
      }
      then(onFulfilled, onRejected) {
        if (true) {
          if (!("from" in this._opts)) {
            warnOnce("Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning.");
          }
        }
        return this.async().then(onFulfilled, onRejected);
      }
      catch(onRejected) {
        return this.async().catch(onRejected);
      }
      finally(onFinally) {
        return this.async().then(onFinally, onFinally);
      }
      async() {
        if (this.error)
          return Promise.reject(this.error);
        return Promise.resolve(this.result);
      }
      sync() {
        if (this.error)
          throw this.error;
        return this.result;
      }
    };
    module2.exports = NoWorkResult;
    NoWorkResult.default = NoWorkResult;
  }
});

// node_modules/postcss/lib/processor.js
var require_processor = __commonJS({
  "node_modules/postcss/lib/processor.js"(exports2, module2) {
    "use strict";
    var NoWorkResult = require_no_work_result();
    var LazyResult = require_lazy_result();
    var Document2 = require_document();
    var Root = require_root();
    var Processor = class {
      constructor(plugins2 = []) {
        this.version = "8.4.12";
        this.plugins = this.normalize(plugins2);
      }
      use(plugin) {
        this.plugins = this.plugins.concat(this.normalize([plugin]));
        return this;
      }
      process(css, opts = {}) {
        if (this.plugins.length === 0 && typeof opts.parser === "undefined" && typeof opts.stringifier === "undefined" && typeof opts.syntax === "undefined") {
          return new NoWorkResult(this, css, opts);
        } else {
          return new LazyResult(this, css, opts);
        }
      }
      normalize(plugins2) {
        let normalized = [];
        for (let i2 of plugins2) {
          if (i2.postcss === true) {
            i2 = i2();
          } else if (i2.postcss) {
            i2 = i2.postcss;
          }
          if (typeof i2 === "object" && Array.isArray(i2.plugins)) {
            normalized = normalized.concat(i2.plugins);
          } else if (typeof i2 === "object" && i2.postcssPlugin) {
            normalized.push(i2);
          } else if (typeof i2 === "function") {
            normalized.push(i2);
          } else if (typeof i2 === "object" && (i2.parse || i2.stringify)) {
            if (true) {
              throw new Error("PostCSS syntaxes cannot be used as plugins. Instead, please use one of the syntax/parser/stringifier options as outlined in your PostCSS runner documentation.");
            }
          } else {
            throw new Error(i2 + " is not a PostCSS plugin");
          }
        }
        return normalized;
      }
    };
    module2.exports = Processor;
    Processor.default = Processor;
    Root.registerProcessor(Processor);
    Document2.registerProcessor(Processor);
  }
});

// node_modules/postcss/lib/fromJSON.js
var require_fromJSON = __commonJS({
  "node_modules/postcss/lib/fromJSON.js"(exports2, module2) {
    "use strict";
    var Declaration = require_declaration();
    var PreviousMap = require_previous_map();
    var Comment2 = require_comment();
    var AtRule = require_at_rule();
    var Input = require_input();
    var Root = require_root();
    var Rule = require_rule();
    function fromJSON(json2, inputs) {
      if (Array.isArray(json2))
        return json2.map((n3) => fromJSON(n3));
      let _a2 = json2, { inputs: ownInputs } = _a2, defaults = __objRest(_a2, ["inputs"]);
      if (ownInputs) {
        inputs = [];
        for (let input of ownInputs) {
          let inputHydrated = __spreadProps2(__spreadValues2({}, input), { __proto__: Input.prototype });
          if (inputHydrated.map) {
            inputHydrated.map = __spreadProps2(__spreadValues2({}, inputHydrated.map), {
              __proto__: PreviousMap.prototype
            });
          }
          inputs.push(inputHydrated);
        }
      }
      if (defaults.nodes) {
        defaults.nodes = json2.nodes.map((n3) => fromJSON(n3, inputs));
      }
      if (defaults.source) {
        let _b = defaults.source, { inputId } = _b, source2 = __objRest(_b, ["inputId"]);
        defaults.source = source2;
        if (inputId != null) {
          defaults.source.input = inputs[inputId];
        }
      }
      if (defaults.type === "root") {
        return new Root(defaults);
      } else if (defaults.type === "decl") {
        return new Declaration(defaults);
      } else if (defaults.type === "rule") {
        return new Rule(defaults);
      } else if (defaults.type === "comment") {
        return new Comment2(defaults);
      } else if (defaults.type === "atrule") {
        return new AtRule(defaults);
      } else {
        throw new Error("Unknown node type: " + json2.type);
      }
    }
    module2.exports = fromJSON;
    fromJSON.default = fromJSON;
  }
});

// node_modules/postcss/lib/postcss.js
var require_postcss = __commonJS({
  "node_modules/postcss/lib/postcss.js"(exports2, module2) {
    "use strict";
    var CssSyntaxError = require_css_syntax_error();
    var Declaration = require_declaration();
    var LazyResult = require_lazy_result();
    var Container = require_container();
    var Processor = require_processor();
    var stringify2 = require_stringify();
    var fromJSON = require_fromJSON();
    var Document2 = require_document();
    var Warning = require_warning();
    var Comment2 = require_comment();
    var AtRule = require_at_rule();
    var Result = require_result();
    var Input = require_input();
    var parse2 = require_parse();
    var list2 = require_list();
    var Rule = require_rule();
    var Root = require_root();
    var Node2 = require_node();
    function postcss2(...plugins2) {
      if (plugins2.length === 1 && Array.isArray(plugins2[0])) {
        plugins2 = plugins2[0];
      }
      return new Processor(plugins2);
    }
    postcss2.plugin = function plugin(name, initializer) {
      if (console && console.warn) {
        console.warn(name + ": postcss.plugin was deprecated. Migration guide:\nhttps://evilmartians.com/chronicles/postcss-8-plugin-migration");
        if (process.env.LANG && process.env.LANG.startsWith("cn")) {
          console.warn(name + ": \u91CC\u9762 postcss.plugin \u88AB\u5F03\u7528. \u8FC1\u79FB\u6307\u5357:\nhttps://www.w3ctech.com/topic/2226");
        }
      }
      function creator(...args) {
        let transformer = initializer(...args);
        transformer.postcssPlugin = name;
        transformer.postcssVersion = new Processor().version;
        return transformer;
      }
      let cache2;
      Object.defineProperty(creator, "postcss", {
        get() {
          if (!cache2)
            cache2 = creator();
          return cache2;
        }
      });
      creator.process = function(css, processOpts, pluginOpts) {
        return postcss2([creator(pluginOpts)]).process(css, processOpts);
      };
      return creator;
    };
    postcss2.stringify = stringify2;
    postcss2.parse = parse2;
    postcss2.fromJSON = fromJSON;
    postcss2.list = list2;
    postcss2.comment = (defaults) => new Comment2(defaults);
    postcss2.atRule = (defaults) => new AtRule(defaults);
    postcss2.decl = (defaults) => new Declaration(defaults);
    postcss2.rule = (defaults) => new Rule(defaults);
    postcss2.root = (defaults) => new Root(defaults);
    postcss2.document = (defaults) => new Document2(defaults);
    postcss2.CssSyntaxError = CssSyntaxError;
    postcss2.Declaration = Declaration;
    postcss2.Container = Container;
    postcss2.Processor = Processor;
    postcss2.Document = Document2;
    postcss2.Comment = Comment2;
    postcss2.Warning = Warning;
    postcss2.AtRule = AtRule;
    postcss2.Result = Result;
    postcss2.Input = Input;
    postcss2.Rule = Rule;
    postcss2.Root = Root;
    postcss2.Node = Node2;
    LazyResult.registerPostcss(postcss2);
    module2.exports = postcss2;
    postcss2.default = postcss2;
  }
});

// node_modules/vite/dist/node/chunks/dep-ab7432fd.js
var require_dep_ab7432fd = __commonJS({
  "node_modules/vite/dist/node/chunks/dep-ab7432fd.js"(exports2) {
    "use strict";
    var require$$02 = require_postcss();
    var index$12 = require_dep_611778e0();
    var path$22 = (init_path(), __toCommonJS(path_exports));
    var require$$12 = (init_crypto(), __toCommonJS(crypto_exports));
    var fs3 = (init_fs(), __toCommonJS(fs_exports));
    var require$$0$12 = (init_util(), __toCommonJS(util_exports));
    var index$2 = require_dep_2056ae8a();
    function _interopDefaultLegacy2(e2) {
      return e2 && typeof e2 === "object" && "default" in e2 ? e2["default"] : e2;
    }
    function _mergeNamespaces2(n3, m3) {
      for (var i2 = 0; i2 < m3.length; i2++) {
        var e2 = m3[i2];
        if (typeof e2 !== "string" && !Array.isArray(e2)) {
          for (var k2 in e2) {
            if (k2 !== "default" && !(k2 in n3)) {
              n3[k2] = e2[k2];
            }
          }
        }
      }
      return n3;
    }
    var require$$0__default2 = _interopDefaultLegacy2(require$$02);
    var path__default2 = _interopDefaultLegacy2(path$22);
    var require$$1__default2 = _interopDefaultLegacy2(require$$12);
    var fs__default2 = _interopDefaultLegacy2(fs3);
    var require$$0__default$12 = _interopDefaultLegacy2(require$$0$12);
    var build$12 = { exports: {} };
    var INFINITY = 1 / 0;
    var symbolTag = "[object Symbol]";
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f\\ufe20-\\ufe23";
    var rsComboSymbolsRange = "\\u20d0-\\u20f0";
    var rsDingbatRange = "\\u2700-\\u27bf";
    var rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff";
    var rsMathOpRange = "\\xac\\xb1\\xd7\\xf7";
    var rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf";
    var rsPunctuationRange = "\\u2000-\\u206f";
    var rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000";
    var rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde";
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "['\u2019]";
    var rsAstral = "[" + rsAstralRange + "]";
    var rsBreak = "[" + rsBreakRange + "]";
    var rsCombo = "[" + rsComboMarksRange + rsComboSymbolsRange + "]";
    var rsDigits = "\\d+";
    var rsDingbat = "[" + rsDingbatRange + "]";
    var rsLower = "[" + rsLowerRange + "]";
    var rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]";
    var rsFitz = "\\ud83c[\\udffb-\\udfff]";
    var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
    var rsNonAstral = "[^" + rsAstralRange + "]";
    var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
    var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
    var rsUpper = "[" + rsUpperRange + "]";
    var rsZWJ = "\\u200d";
    var rsLowerMisc = "(?:" + rsLower + "|" + rsMisc + ")";
    var rsUpperMisc = "(?:" + rsUpper + "|" + rsMisc + ")";
    var rsOptLowerContr = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?";
    var rsOptUpperContr = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?";
    var reOptMod = rsModifier + "?";
    var rsOptVar = "[" + rsVarRange + "]?";
    var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
    var rsSeq = rsOptVar + reOptMod + rsOptJoin;
    var rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq;
    var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reApos = RegExp(rsApos, "g");
    var reComboMark = RegExp(rsCombo, "g");
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptLowerContr + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsUpperMisc + "+" + rsOptUpperContr + "(?=" + [rsBreak, rsUpper + rsLowerMisc, "$"].join("|") + ")",
      rsUpper + "?" + rsLowerMisc + "+" + rsOptLowerContr,
      rsUpper + "+" + rsOptUpperContr,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + "]");
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    var deburredLetters = {
      "\xC0": "A",
      "\xC1": "A",
      "\xC2": "A",
      "\xC3": "A",
      "\xC4": "A",
      "\xC5": "A",
      "\xE0": "a",
      "\xE1": "a",
      "\xE2": "a",
      "\xE3": "a",
      "\xE4": "a",
      "\xE5": "a",
      "\xC7": "C",
      "\xE7": "c",
      "\xD0": "D",
      "\xF0": "d",
      "\xC8": "E",
      "\xC9": "E",
      "\xCA": "E",
      "\xCB": "E",
      "\xE8": "e",
      "\xE9": "e",
      "\xEA": "e",
      "\xEB": "e",
      "\xCC": "I",
      "\xCD": "I",
      "\xCE": "I",
      "\xCF": "I",
      "\xEC": "i",
      "\xED": "i",
      "\xEE": "i",
      "\xEF": "i",
      "\xD1": "N",
      "\xF1": "n",
      "\xD2": "O",
      "\xD3": "O",
      "\xD4": "O",
      "\xD5": "O",
      "\xD6": "O",
      "\xD8": "O",
      "\xF2": "o",
      "\xF3": "o",
      "\xF4": "o",
      "\xF5": "o",
      "\xF6": "o",
      "\xF8": "o",
      "\xD9": "U",
      "\xDA": "U",
      "\xDB": "U",
      "\xDC": "U",
      "\xF9": "u",
      "\xFA": "u",
      "\xFB": "u",
      "\xFC": "u",
      "\xDD": "Y",
      "\xFD": "y",
      "\xFF": "y",
      "\xC6": "Ae",
      "\xE6": "ae",
      "\xDE": "Th",
      "\xFE": "th",
      "\xDF": "ss",
      "\u0100": "A",
      "\u0102": "A",
      "\u0104": "A",
      "\u0101": "a",
      "\u0103": "a",
      "\u0105": "a",
      "\u0106": "C",
      "\u0108": "C",
      "\u010A": "C",
      "\u010C": "C",
      "\u0107": "c",
      "\u0109": "c",
      "\u010B": "c",
      "\u010D": "c",
      "\u010E": "D",
      "\u0110": "D",
      "\u010F": "d",
      "\u0111": "d",
      "\u0112": "E",
      "\u0114": "E",
      "\u0116": "E",
      "\u0118": "E",
      "\u011A": "E",
      "\u0113": "e",
      "\u0115": "e",
      "\u0117": "e",
      "\u0119": "e",
      "\u011B": "e",
      "\u011C": "G",
      "\u011E": "G",
      "\u0120": "G",
      "\u0122": "G",
      "\u011D": "g",
      "\u011F": "g",
      "\u0121": "g",
      "\u0123": "g",
      "\u0124": "H",
      "\u0126": "H",
      "\u0125": "h",
      "\u0127": "h",
      "\u0128": "I",
      "\u012A": "I",
      "\u012C": "I",
      "\u012E": "I",
      "\u0130": "I",
      "\u0129": "i",
      "\u012B": "i",
      "\u012D": "i",
      "\u012F": "i",
      "\u0131": "i",
      "\u0134": "J",
      "\u0135": "j",
      "\u0136": "K",
      "\u0137": "k",
      "\u0138": "k",
      "\u0139": "L",
      "\u013B": "L",
      "\u013D": "L",
      "\u013F": "L",
      "\u0141": "L",
      "\u013A": "l",
      "\u013C": "l",
      "\u013E": "l",
      "\u0140": "l",
      "\u0142": "l",
      "\u0143": "N",
      "\u0145": "N",
      "\u0147": "N",
      "\u014A": "N",
      "\u0144": "n",
      "\u0146": "n",
      "\u0148": "n",
      "\u014B": "n",
      "\u014C": "O",
      "\u014E": "O",
      "\u0150": "O",
      "\u014D": "o",
      "\u014F": "o",
      "\u0151": "o",
      "\u0154": "R",
      "\u0156": "R",
      "\u0158": "R",
      "\u0155": "r",
      "\u0157": "r",
      "\u0159": "r",
      "\u015A": "S",
      "\u015C": "S",
      "\u015E": "S",
      "\u0160": "S",
      "\u015B": "s",
      "\u015D": "s",
      "\u015F": "s",
      "\u0161": "s",
      "\u0162": "T",
      "\u0164": "T",
      "\u0166": "T",
      "\u0163": "t",
      "\u0165": "t",
      "\u0167": "t",
      "\u0168": "U",
      "\u016A": "U",
      "\u016C": "U",
      "\u016E": "U",
      "\u0170": "U",
      "\u0172": "U",
      "\u0169": "u",
      "\u016B": "u",
      "\u016D": "u",
      "\u016F": "u",
      "\u0171": "u",
      "\u0173": "u",
      "\u0174": "W",
      "\u0175": "w",
      "\u0176": "Y",
      "\u0177": "y",
      "\u0178": "Y",
      "\u0179": "Z",
      "\u017B": "Z",
      "\u017D": "Z",
      "\u017A": "z",
      "\u017C": "z",
      "\u017E": "z",
      "\u0132": "IJ",
      "\u0133": "ij",
      "\u0152": "Oe",
      "\u0153": "oe",
      "\u0149": "'n",
      "\u017F": "ss"
    };
    var freeGlobal = typeof index$12.commonjsGlobal == "object" && index$12.commonjsGlobal && index$12.commonjsGlobal.Object === Object && index$12.commonjsGlobal;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root$2 = freeGlobal || freeSelf || Function("return this")();
    function arrayReduce(array2, iteratee, accumulator, initAccum) {
      var index3 = -1, length = array2 ? array2.length : 0;
      if (initAccum && length) {
        accumulator = array2[++index3];
      }
      while (++index3 < length) {
        accumulator = iteratee(accumulator, array2[index3], index3, array2);
      }
      return accumulator;
    }
    function asciiToArray(string3) {
      return string3.split("");
    }
    function asciiWords(string3) {
      return string3.match(reAsciiWord) || [];
    }
    function basePropertyOf(object2) {
      return function(key2) {
        return object2 == null ? void 0 : object2[key2];
      };
    }
    var deburrLetter = basePropertyOf(deburredLetters);
    function hasUnicode(string3) {
      return reHasUnicode.test(string3);
    }
    function hasUnicodeWord(string3) {
      return reHasUnicodeWord.test(string3);
    }
    function stringToArray(string3) {
      return hasUnicode(string3) ? unicodeToArray(string3) : asciiToArray(string3);
    }
    function unicodeToArray(string3) {
      return string3.match(reUnicode) || [];
    }
    function unicodeWords(string3) {
      return string3.match(reUnicodeWord) || [];
    }
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var Symbol$1 = root$2.Symbol;
    var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseSlice(array2, start, end) {
      var index3 = -1, length = array2.length;
      if (start < 0) {
        start = -start > length ? 0 : length + start;
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : end - start >>> 0;
      start >>>= 0;
      var result2 = Array(length);
      while (++index3 < length) {
        result2[index3] = array2[index3 + start];
      }
      return result2;
    }
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result2 = value + "";
      return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
    }
    function castSlice(array2, start, end) {
      var length = array2.length;
      end = end === void 0 ? length : end;
      return !start && end >= length ? array2 : baseSlice(array2, start, end);
    }
    function createCaseFirst(methodName) {
      return function(string3) {
        string3 = toString2(string3);
        var strSymbols = hasUnicode(string3) ? stringToArray(string3) : void 0;
        var chr = strSymbols ? strSymbols[0] : string3.charAt(0);
        var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string3.slice(1);
        return chr[methodName]() + trailing;
      };
    }
    function createCompounder(callback) {
      return function(string3) {
        return arrayReduce(words(deburr(string3).replace(reApos, "")), callback, "");
      };
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toString2(value) {
      return value == null ? "" : baseToString(value);
    }
    var camelCase = createCompounder(function(result2, word2, index3) {
      word2 = word2.toLowerCase();
      return result2 + (index3 ? capitalize(word2) : word2);
    });
    function capitalize(string3) {
      return upperFirst(toString2(string3).toLowerCase());
    }
    function deburr(string3) {
      string3 = toString2(string3);
      return string3 && string3.replace(reLatin, deburrLetter).replace(reComboMark, "");
    }
    var upperFirst = createCaseFirst("toUpperCase");
    function words(string3, pattern2, guard) {
      string3 = toString2(string3);
      pattern2 = guard ? void 0 : pattern2;
      if (pattern2 === void 0) {
        return hasUnicodeWord(string3) ? unicodeWords(string3) : asciiWords(string3);
      }
      return string3.match(pattern2) || [];
    }
    var lodash_camelcase = camelCase;
    var wasmHash = { exports: {} };
    var MAX_SHORT_STRING$1 = Math.floor((65536 - 64) / 4) & ~3;
    var WasmHash = class {
      constructor(instance, instancesPool, chunkSize, digestSize) {
        const exports3 = instance.exports;
        exports3.init();
        this.exports = exports3;
        this.mem = Buffer.from(exports3.memory.buffer, 0, 65536);
        this.buffered = 0;
        this.instancesPool = instancesPool;
        this.chunkSize = chunkSize;
        this.digestSize = digestSize;
      }
      reset() {
        this.buffered = 0;
        this.exports.init();
      }
      update(data2, encoding) {
        if (typeof data2 === "string") {
          while (data2.length > MAX_SHORT_STRING$1) {
            this._updateWithShortString(data2.slice(0, MAX_SHORT_STRING$1), encoding);
            data2 = data2.slice(MAX_SHORT_STRING$1);
          }
          this._updateWithShortString(data2, encoding);
          return this;
        }
        this._updateWithBuffer(data2);
        return this;
      }
      _updateWithShortString(data2, encoding) {
        const { exports: exports3, buffered, mem, chunkSize } = this;
        let endPos;
        if (data2.length < 70) {
          if (!encoding || encoding === "utf-8" || encoding === "utf8") {
            endPos = buffered;
            for (let i2 = 0; i2 < data2.length; i2++) {
              const cc = data2.charCodeAt(i2);
              if (cc < 128) {
                mem[endPos++] = cc;
              } else if (cc < 2048) {
                mem[endPos] = cc >> 6 | 192;
                mem[endPos + 1] = cc & 63 | 128;
                endPos += 2;
              } else {
                endPos += mem.write(data2.slice(i2), endPos, encoding);
                break;
              }
            }
          } else if (encoding === "latin1") {
            endPos = buffered;
            for (let i2 = 0; i2 < data2.length; i2++) {
              const cc = data2.charCodeAt(i2);
              mem[endPos++] = cc;
            }
          } else {
            endPos = buffered + mem.write(data2, buffered, encoding);
          }
        } else {
          endPos = buffered + mem.write(data2, buffered, encoding);
        }
        if (endPos < chunkSize) {
          this.buffered = endPos;
        } else {
          const l2 = endPos & ~(this.chunkSize - 1);
          exports3.update(l2);
          const newBuffered = endPos - l2;
          this.buffered = newBuffered;
          if (newBuffered > 0) {
            mem.copyWithin(0, l2, endPos);
          }
        }
      }
      _updateWithBuffer(data2) {
        const { exports: exports3, buffered, mem } = this;
        const length = data2.length;
        if (buffered + length < this.chunkSize) {
          data2.copy(mem, buffered, 0, length);
          this.buffered += length;
        } else {
          const l2 = buffered + length & ~(this.chunkSize - 1);
          if (l2 > 65536) {
            let i2 = 65536 - buffered;
            data2.copy(mem, buffered, 0, i2);
            exports3.update(65536);
            const stop = l2 - buffered - 65536;
            while (i2 < stop) {
              data2.copy(mem, 0, i2, i2 + 65536);
              exports3.update(65536);
              i2 += 65536;
            }
            data2.copy(mem, 0, i2, l2 - buffered);
            exports3.update(l2 - buffered - i2);
          } else {
            data2.copy(mem, buffered, 0, l2 - buffered);
            exports3.update(l2);
          }
          const newBuffered = length + buffered - l2;
          this.buffered = newBuffered;
          if (newBuffered > 0) {
            data2.copy(mem, 0, length - newBuffered, length);
          }
        }
      }
      digest(type) {
        const { exports: exports3, buffered, mem, digestSize } = this;
        exports3.final(buffered);
        this.instancesPool.push(this);
        const hex = mem.toString("latin1", 0, digestSize);
        if (type === "hex") {
          return hex;
        }
        if (type === "binary" || !type) {
          return Buffer.from(hex, "hex");
        }
        return Buffer.from(hex, "hex").toString(type);
      }
    };
    var create$2 = (wasmModule, instancesPool, chunkSize, digestSize) => {
      if (instancesPool.length > 0) {
        const old2 = instancesPool.pop();
        old2.reset();
        return old2;
      } else {
        return new WasmHash(new WebAssembly.Instance(wasmModule), instancesPool, chunkSize, digestSize);
      }
    };
    wasmHash.exports = create$2;
    wasmHash.exports.MAX_SHORT_STRING = MAX_SHORT_STRING$1;
    var create$1 = wasmHash.exports;
    var xxhash64 = new WebAssembly.Module(Buffer.from("AGFzbQEAAAABCAJgAX8AYAAAAwQDAQAABQMBAAEGGgV+AUIAC34BQgALfgFCAAt+AUIAC34BQgALByIEBGluaXQAAAZ1cGRhdGUAAQVmaW5hbAACBm1lbW9yeQIACrUIAzAAQtbrgu7q/Yn14AAkAELP1tO+0ser2UIkAUIAJAJC+erQ0OfJoeThACQDQgAkBAvUAQIBfwR+IABFBEAPCyMEIACtfCQEIwAhAiMBIQMjAiEEIwMhBQNAIAIgASkDAELP1tO+0ser2UJ+fEIfiUKHla+vmLbem55/fiECIAMgASkDCELP1tO+0ser2UJ+fEIfiUKHla+vmLbem55/fiEDIAQgASkDEELP1tO+0ser2UJ+fEIfiUKHla+vmLbem55/fiEEIAUgASkDGELP1tO+0ser2UJ+fEIfiUKHla+vmLbem55/fiEFIAAgAUEgaiIBSw0ACyACJAAgAyQBIAQkAiAFJAMLqwYCAX8EfiMEQgBSBH4jACICQgGJIwEiA0IHiXwjAiIEQgyJfCMDIgVCEol8IAJCz9bTvtLHq9lCfkIfiUKHla+vmLbem55/foVCh5Wvr5i23puef35CnaO16oOxjYr6AH0gA0LP1tO+0ser2UJ+Qh+JQoeVr6+Ytt6bnn9+hUKHla+vmLbem55/fkKdo7Xqg7GNivoAfSAEQs/W077Sx6vZQn5CH4lCh5Wvr5i23puef36FQoeVr6+Ytt6bnn9+Qp2jteqDsY2K+gB9IAVCz9bTvtLHq9lCfkIfiUKHla+vmLbem55/foVCh5Wvr5i23puef35CnaO16oOxjYr6AH0FQsXP2bLx5brqJwsjBCAArXx8IQIDQCABQQhqIABNBEAgAiABKQMAQs/W077Sx6vZQn5CH4lCh5Wvr5i23puef36FQhuJQoeVr6+Ytt6bnn9+Qp2jteqDsY2K+gB9IQIgAUEIaiEBDAELCyABQQRqIABNBEACfyACIAE1AgBCh5Wvr5i23puef36FQheJQs/W077Sx6vZQn5C+fPd8Zn2masWfCECIAFBBGoLIQELA0AgACABRwRAIAIgATEAAELFz9my8eW66id+hUILiUKHla+vmLbem55/fiECIAFBAWohAQwBCwtBACACIAJCIYiFQs/W077Sx6vZQn4iAiACQh2IhUL5893xmfaZqxZ+IgIgAkIgiIUiAkIgiCIDQv//A4NCIIYgA0KAgPz/D4NCEIiEIgNC/4GAgPAfg0IQhiADQoD+g4CA4D+DQgiIhCIDQo+AvIDwgcAHg0IIhiADQvCBwIeAnoD4AINCBIiEIgNChoyYsODAgYMGfEIEiEKBgoSIkKDAgAGDQid+IANCsODAgYOGjJgwhHw3AwBBCCACQv////8PgyICQv//A4NCIIYgAkKAgPz/D4NCEIiEIgJC/4GAgPAfg0IQhiACQoD+g4CA4D+DQgiIhCICQo+AvIDwgcAHg0IIhiACQvCBwIeAnoD4AINCBIiEIgJChoyYsODAgYMGfEIEiEKBgoSIkKDAgAGDQid+IAJCsODAgYOGjJgwhHw3AwAL", "base64"));
    var xxhash64_1 = create$1.bind(null, xxhash64, [], 32, 16);
    var MAX_SHORT_STRING = wasmHash.exports.MAX_SHORT_STRING;
    var BatchedHash$1 = class {
      constructor(hash2) {
        this.string = void 0;
        this.encoding = void 0;
        this.hash = hash2;
      }
      update(data2, inputEncoding) {
        if (this.string !== void 0) {
          if (typeof data2 === "string" && inputEncoding === this.encoding && this.string.length + data2.length < MAX_SHORT_STRING) {
            this.string += data2;
            return this;
          }
          this.hash.update(this.string, this.encoding);
          this.string = void 0;
        }
        if (typeof data2 === "string") {
          if (data2.length < MAX_SHORT_STRING && (!inputEncoding || !inputEncoding.startsWith("ba"))) {
            this.string = data2;
            this.encoding = inputEncoding;
          } else {
            this.hash.update(data2, inputEncoding);
          }
        } else {
          this.hash.update(data2);
        }
        return this;
      }
      digest(encoding) {
        if (this.string !== void 0) {
          this.hash.update(this.string, this.encoding);
        }
        return this.hash.digest(encoding);
      }
    };
    var BatchedHash_1 = BatchedHash$1;
    var create = wasmHash.exports;
    var md4 = new WebAssembly.Module(Buffer.from("AGFzbQEAAAABCAJgAX8AYAAAAwUEAQAAAAUDAQABBhoFfwFBAAt/AUEAC38BQQALfwFBAAt/AUEACwciBARpbml0AAAGdXBkYXRlAAIFZmluYWwAAwZtZW1vcnkCAAqFEAQmAEGBxpS6BiQBQYnXtv5+JAJB/rnrxXkkA0H2qMmBASQEQQAkAAvMCgEYfyMBIQojAiEGIwMhByMEIQgDQCAAIAVLBEAgBSgCCCINIAcgBiAFKAIEIgsgCCAHIAUoAgAiDCAKIAggBiAHIAhzcXNqakEDdyIDIAYgB3Nxc2pqQQd3IgEgAyAGc3FzampBC3chAiAFKAIUIg8gASACIAUoAhAiCSADIAEgBSgCDCIOIAYgAyACIAEgA3Nxc2pqQRN3IgQgASACc3FzampBA3ciAyACIARzcXNqakEHdyEBIAUoAiAiEiADIAEgBSgCHCIRIAQgAyAFKAIYIhAgAiAEIAEgAyAEc3FzampBC3ciAiABIANzcXNqakETdyIEIAEgAnNxc2pqQQN3IQMgBSgCLCIVIAQgAyAFKAIoIhQgAiAEIAUoAiQiEyABIAIgAyACIARzcXNqakEHdyIBIAMgBHNxc2pqQQt3IgIgASADc3FzampBE3chBCAPIBAgCSAVIBQgEyAFKAI4IhYgAiAEIAUoAjQiFyABIAIgBSgCMCIYIAMgASAEIAEgAnNxc2pqQQN3IgEgAiAEc3FzampBB3ciAiABIARzcXNqakELdyIDIAkgAiAMIAEgBSgCPCIJIAQgASADIAEgAnNxc2pqQRN3IgEgAiADcnEgAiADcXJqakGZ84nUBWpBA3ciAiABIANycSABIANxcmpqQZnzidQFakEFdyIEIAEgAnJxIAEgAnFyaiASakGZ84nUBWpBCXciAyAPIAQgCyACIBggASADIAIgBHJxIAIgBHFyampBmfOJ1AVqQQ13IgEgAyAEcnEgAyAEcXJqakGZ84nUBWpBA3ciAiABIANycSABIANxcmpqQZnzidQFakEFdyIEIAEgAnJxIAEgAnFyampBmfOJ1AVqQQl3IgMgECAEIAIgFyABIAMgAiAEcnEgAiAEcXJqakGZ84nUBWpBDXciASADIARycSADIARxcmogDWpBmfOJ1AVqQQN3IgIgASADcnEgASADcXJqakGZ84nUBWpBBXciBCABIAJycSABIAJxcmpqQZnzidQFakEJdyIDIBEgBCAOIAIgFiABIAMgAiAEcnEgAiAEcXJqakGZ84nUBWpBDXciASADIARycSADIARxcmpqQZnzidQFakEDdyICIAEgA3JxIAEgA3FyampBmfOJ1AVqQQV3IgQgASACcnEgASACcXJqakGZ84nUBWpBCXciAyAMIAIgAyAJIAEgAyACIARycSACIARxcmpqQZnzidQFakENdyIBcyAEc2pqQaHX5/YGakEDdyICIAQgASACcyADc2ogEmpBodfn9gZqQQl3IgRzIAFzampBodfn9gZqQQt3IgMgAiADIBggASADIARzIAJzampBodfn9gZqQQ93IgFzIARzaiANakGh1+f2BmpBA3ciAiAUIAQgASACcyADc2pqQaHX5/YGakEJdyIEcyABc2pqQaHX5/YGakELdyIDIAsgAiADIBYgASADIARzIAJzampBodfn9gZqQQ93IgFzIARzampBodfn9gZqQQN3IgIgEyAEIAEgAnMgA3NqakGh1+f2BmpBCXciBHMgAXNqakGh1+f2BmpBC3chAyAKIA4gAiADIBcgASADIARzIAJzampBodfn9gZqQQ93IgFzIARzampBodfn9gZqQQN3IgJqIQogBiAJIAEgESADIAIgFSAEIAEgAnMgA3NqakGh1+f2BmpBCXciBHMgAXNqakGh1+f2BmpBC3ciAyAEcyACc2pqQaHX5/YGakEPd2ohBiADIAdqIQcgBCAIaiEIIAVBQGshBQwBCwsgCiQBIAYkAiAHJAMgCCQECw0AIAAQASMAIABqJAAL/wQCA38BfiMAIABqrUIDhiEEIABByABqQUBxIgJBCGshAyAAIgFBAWohACABQYABOgAAA0AgACACSUEAIABBB3EbBEAgAEEAOgAAIABBAWohAAwBCwsDQCAAIAJJBEAgAEIANwMAIABBCGohAAwBCwsgAyAENwMAIAIQAUEAIwGtIgRC//8DgyAEQoCA/P8Pg0IQhoQiBEL/gYCA8B+DIARCgP6DgIDgP4NCCIaEIgRCj4C8gPCBwAeDQgiGIARC8IHAh4CegPgAg0IEiIQiBEKGjJiw4MCBgwZ8QgSIQoGChIiQoMCAAYNCJ34gBEKw4MCBg4aMmDCEfDcDAEEIIwKtIgRC//8DgyAEQoCA/P8Pg0IQhoQiBEL/gYCA8B+DIARCgP6DgIDgP4NCCIaEIgRCj4C8gPCBwAeDQgiGIARC8IHAh4CegPgAg0IEiIQiBEKGjJiw4MCBgwZ8QgSIQoGChIiQoMCAAYNCJ34gBEKw4MCBg4aMmDCEfDcDAEEQIwOtIgRC//8DgyAEQoCA/P8Pg0IQhoQiBEL/gYCA8B+DIARCgP6DgIDgP4NCCIaEIgRCj4C8gPCBwAeDQgiGIARC8IHAh4CegPgAg0IEiIQiBEKGjJiw4MCBgwZ8QgSIQoGChIiQoMCAAYNCJ34gBEKw4MCBg4aMmDCEfDcDAEEYIwStIgRC//8DgyAEQoCA/P8Pg0IQhoQiBEL/gYCA8B+DIARCgP6DgIDgP4NCCIaEIgRCj4C8gPCBwAeDQgiGIARC8IHAh4CegPgAg0IEiIQiBEKGjJiw4MCBgwZ8QgSIQoGChIiQoMCAAYNCJ34gBEKw4MCBg4aMmDCEfDcDAAs=", "base64"));
    var md4_1 = create.bind(null, md4, [], 64, 32);
    var BULK_SIZE = 2e3;
    var digestCaches = {};
    var BulkUpdateDecorator$1 = class {
      constructor(hashOrFactory, hashKey) {
        this.hashKey = hashKey;
        if (typeof hashOrFactory === "function") {
          this.hashFactory = hashOrFactory;
          this.hash = void 0;
        } else {
          this.hashFactory = void 0;
          this.hash = hashOrFactory;
        }
        this.buffer = "";
      }
      update(data2, inputEncoding) {
        if (inputEncoding !== void 0 || typeof data2 !== "string" || data2.length > BULK_SIZE) {
          if (this.hash === void 0) {
            this.hash = this.hashFactory();
          }
          if (this.buffer.length > 0) {
            this.hash.update(this.buffer);
            this.buffer = "";
          }
          this.hash.update(data2, inputEncoding);
        } else {
          this.buffer += data2;
          if (this.buffer.length > BULK_SIZE) {
            if (this.hash === void 0) {
              this.hash = this.hashFactory();
            }
            this.hash.update(this.buffer);
            this.buffer = "";
          }
        }
        return this;
      }
      digest(encoding) {
        let digestCache;
        const buffer2 = this.buffer;
        if (this.hash === void 0) {
          const cacheKey = `${this.hashKey}-${encoding}`;
          digestCache = digestCaches[cacheKey];
          if (digestCache === void 0) {
            digestCache = digestCaches[cacheKey] = /* @__PURE__ */ new Map();
          }
          const cacheEntry = digestCache.get(buffer2);
          if (cacheEntry !== void 0) {
            return cacheEntry;
          }
          this.hash = this.hashFactory();
        }
        if (buffer2.length > 0) {
          this.hash.update(buffer2);
        }
        const digestResult = this.hash.digest(encoding);
        if (digestCache !== void 0) {
          digestCache.set(buffer2, digestResult);
        }
        return digestResult;
      }
    };
    var BulkUpdateDecorator_1 = BulkUpdateDecorator$1;
    var baseEncodeTables = {
      26: "abcdefghijklmnopqrstuvwxyz",
      32: "123456789abcdefghjkmnpqrstuvwxyz",
      36: "0123456789abcdefghijklmnopqrstuvwxyz",
      49: "abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ",
      52: "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
      58: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ",
      62: "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
      64: "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_"
    };
    function divmod32(uint32Array, divisor) {
      let carry = 0;
      for (let i2 = uint32Array.length - 1; i2 >= 0; i2--) {
        const value = carry * 4294967296 + uint32Array[i2];
        carry = value % divisor;
        uint32Array[i2] = Math.floor(value / divisor);
      }
      return carry;
    }
    function encodeBufferToBase(buffer2, base2, length) {
      const encodeTable = baseEncodeTables[base2];
      if (!encodeTable) {
        throw new Error("Unknown encoding base" + base2);
      }
      const limit = Math.ceil(buffer2.length * 8 / Math.log2(base2));
      length = Math.min(length, limit);
      const uint32Array = new Uint32Array(Math.ceil(buffer2.length / 4));
      buffer2.copy(Buffer.from(uint32Array.buffer));
      let output = "";
      for (let i2 = 0; i2 < length; i2++) {
        output = encodeTable[divmod32(uint32Array, base2)] + output;
      }
      return output;
    }
    var crypto2 = void 0;
    var createXXHash64 = void 0;
    var createMd4 = void 0;
    var BatchedHash = void 0;
    var BulkUpdateDecorator = void 0;
    function getHashDigest$1(buffer2, algorithm, digestType, maxLength) {
      algorithm = algorithm || "xxhash64";
      maxLength = maxLength || 9999;
      let hash2;
      if (algorithm === "xxhash64") {
        if (createXXHash64 === void 0) {
          createXXHash64 = xxhash64_1;
          if (BatchedHash === void 0) {
            BatchedHash = BatchedHash_1;
          }
        }
        hash2 = new BatchedHash(createXXHash64());
      } else if (algorithm === "md4") {
        if (createMd4 === void 0) {
          createMd4 = md4_1;
          if (BatchedHash === void 0) {
            BatchedHash = BatchedHash_1;
          }
        }
        hash2 = new BatchedHash(createMd4());
      } else if (algorithm === "native-md4") {
        if (typeof crypto2 === "undefined") {
          crypto2 = require$$1__default2;
          if (BulkUpdateDecorator === void 0) {
            BulkUpdateDecorator = BulkUpdateDecorator_1;
          }
        }
        hash2 = new BulkUpdateDecorator(() => crypto2.createHash("md4"), "md4");
      } else {
        if (typeof crypto2 === "undefined") {
          crypto2 = require$$1__default2;
          if (BulkUpdateDecorator === void 0) {
            BulkUpdateDecorator = BulkUpdateDecorator_1;
          }
        }
        hash2 = new BulkUpdateDecorator(() => crypto2.createHash(algorithm), algorithm);
      }
      hash2.update(buffer2);
      if (digestType === "base26" || digestType === "base32" || digestType === "base36" || digestType === "base49" || digestType === "base52" || digestType === "base58" || digestType === "base62") {
        return encodeBufferToBase(hash2.digest(), digestType.substr(4), maxLength);
      } else {
        return hash2.digest(digestType || "hex").substr(0, maxLength);
      }
    }
    var getHashDigest_1 = getHashDigest$1;
    var path$12 = path__default2;
    var getHashDigest = getHashDigest_1;
    function interpolateName$1(loaderContext, name, options2 = {}) {
      let filename2;
      const hasQuery = loaderContext.resourceQuery && loaderContext.resourceQuery.length > 1;
      if (typeof name === "function") {
        filename2 = name(loaderContext.resourcePath, hasQuery ? loaderContext.resourceQuery : void 0);
      } else {
        filename2 = name || "[hash].[ext]";
      }
      const context2 = options2.context;
      const content2 = options2.content;
      const regExp = options2.regExp;
      let ext2 = "bin";
      let basename = "file";
      let directory = "";
      let folder = "";
      let query = "";
      if (loaderContext.resourcePath) {
        const parsed = path$12.parse(loaderContext.resourcePath);
        let resourcePath = loaderContext.resourcePath;
        if (parsed.ext) {
          ext2 = parsed.ext.substr(1);
        }
        if (parsed.dir) {
          basename = parsed.name;
          resourcePath = parsed.dir + path$12.sep;
        }
        if (typeof context2 !== "undefined") {
          directory = path$12.relative(context2, resourcePath + "_").replace(/\\/g, "/").replace(/\.\.(\/)?/g, "_$1");
          directory = directory.substr(0, directory.length - 1);
        } else {
          directory = resourcePath.replace(/\\/g, "/").replace(/\.\.(\/)?/g, "_$1");
        }
        if (directory.length === 1) {
          directory = "";
        } else if (directory.length > 1) {
          folder = path$12.basename(directory);
        }
      }
      if (loaderContext.resourceQuery && loaderContext.resourceQuery.length > 1) {
        query = loaderContext.resourceQuery;
        const hashIdx = query.indexOf("#");
        if (hashIdx >= 0) {
          query = query.substr(0, hashIdx);
        }
      }
      let url2 = filename2;
      if (content2) {
        url2 = url2.replace(/\[(?:([^:\]]+):)?(?:hash|contenthash)(?::([a-z]+\d*))?(?::(\d+))?\]/gi, (all, hashType, digestType, maxLength) => getHashDigest(content2, hashType, digestType, parseInt(maxLength, 10)));
      }
      url2 = url2.replace(/\[ext\]/gi, () => ext2).replace(/\[name\]/gi, () => basename).replace(/\[path\]/gi, () => directory).replace(/\[folder\]/gi, () => folder).replace(/\[query\]/gi, () => query);
      if (regExp && loaderContext.resourcePath) {
        const match2 = loaderContext.resourcePath.match(new RegExp(regExp));
        match2 && match2.forEach((matched, i2) => {
          url2 = url2.replace(new RegExp("\\[" + i2 + "\\]", "ig"), matched);
        });
      }
      if (typeof loaderContext.options === "object" && typeof loaderContext.options.customInterpolateName === "function") {
        url2 = loaderContext.options.customInterpolateName.call(loaderContext, url2, name, options2);
      }
      return url2;
    }
    var interpolateName_1 = interpolateName$1;
    var interpolateName = interpolateName_1;
    var path2 = path__default2;
    var genericNames = function createGenerator(pattern2, options2) {
      options2 = options2 || {};
      var context2 = options2 && typeof options2.context === "string" ? options2.context : process.cwd();
      var hashPrefix = options2 && typeof options2.hashPrefix === "string" ? options2.hashPrefix : "";
      return function generate2(localName, filepath) {
        var name = pattern2.replace(/\[local\]/gi, localName);
        var loaderContext = {
          resourcePath: filepath
        };
        var loaderOptions = {
          content: hashPrefix + path2.relative(context2, filepath).replace(/\\/g, "/") + "\0" + localName,
          context: context2
        };
        var genericName = interpolateName(loaderContext, name, loaderOptions);
        return genericName.replace(new RegExp("[^a-zA-Z0-9\\-_\xA0-\uFFFF]", "g"), "-").replace(/^((-?[0-9])|--)/, "_$1");
      };
    };
    var unquote$1 = {};
    Object.defineProperty(unquote$1, "__esModule", {
      value: true
    });
    unquote$1.default = unquote;
    var reg = /['"]/;
    function unquote(str2) {
      if (!str2) {
        return "";
      }
      if (reg.test(str2.charAt(0))) {
        str2 = str2.substr(1);
      }
      if (reg.test(str2.charAt(str2.length - 1))) {
        str2 = str2.substr(0, str2.length - 1);
      }
      return str2;
    }
    var parser$1 = {};
    var lib2 = {};
    Object.defineProperty(lib2, "__esModule", {
      value: true
    });
    lib2.replaceAll = replaceAll;
    var matchConstName = /[$#]?[\w-\.]+/g;
    function replaceAll(replacements, text) {
      var matches2 = void 0;
      while (matches2 = matchConstName.exec(text)) {
        var replacement2 = replacements[matches2[0]];
        if (replacement2) {
          text = text.slice(0, matches2.index) + replacement2 + text.slice(matchConstName.lastIndex);
          matchConstName.lastIndex -= matches2[0].length - replacement2.length;
        }
      }
      return text;
    }
    lib2.default = function(css, translations) {
      css.walkDecls(function(decl) {
        return decl.value = replaceAll(translations, decl.value);
      });
      css.walkAtRules("media", function(atRule) {
        return atRule.params = replaceAll(translations, atRule.params);
      });
    };
    Object.defineProperty(parser$1, "__esModule", {
      value: true
    });
    var _icssReplaceSymbols = lib2;
    var _icssReplaceSymbols2 = _interopRequireDefault$6(_icssReplaceSymbols);
    function _interopRequireDefault$6(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var importRegexp = /^:import\((.+)\)$/;
    var Parser2 = class {
      constructor(pathFetcher, trace) {
        this.pathFetcher = pathFetcher;
        this.plugin = this.plugin.bind(this);
        this.exportTokens = {};
        this.translations = {};
        this.trace = trace;
      }
      plugin() {
        const parser3 = this;
        return {
          postcssPlugin: "css-modules-parser",
          OnceExit(css) {
            return Promise.all(parser3.fetchAllImports(css)).then(() => parser3.linkImportedSymbols(css)).then(() => parser3.extractExports(css));
          }
        };
      }
      fetchAllImports(css) {
        let imports = [];
        css.each((node3) => {
          if (node3.type == "rule" && node3.selector.match(importRegexp)) {
            imports.push(this.fetchImport(node3, css.source.input.from, imports.length));
          }
        });
        return imports;
      }
      linkImportedSymbols(css) {
        (0, _icssReplaceSymbols2.default)(css, this.translations);
      }
      extractExports(css) {
        css.each((node3) => {
          if (node3.type == "rule" && node3.selector == ":export")
            this.handleExport(node3);
        });
      }
      handleExport(exportNode) {
        exportNode.each((decl) => {
          if (decl.type == "decl") {
            Object.keys(this.translations).forEach((translation) => {
              decl.value = decl.value.replace(translation, this.translations[translation]);
            });
            this.exportTokens[decl.prop] = decl.value;
          }
        });
        exportNode.remove();
      }
      fetchImport(importNode, relativeTo, depNr) {
        let file = importNode.selector.match(importRegexp)[1], depTrace = this.trace + String.fromCharCode(depNr);
        return this.pathFetcher(file, relativeTo, depTrace).then((exports3) => {
          importNode.each((decl) => {
            if (decl.type == "decl") {
              this.translations[decl.prop] = exports3[decl.value];
            }
          });
          importNode.remove();
        }, (err) => console.log(err));
      }
    };
    parser$1.default = Parser2;
    var loader = {};
    Object.defineProperty(loader, "__esModule", {
      value: true
    });
    var _postcss$1 = require$$0__default2;
    var _postcss2$1 = _interopRequireDefault$5(_postcss$1);
    var _fs$1 = fs__default2;
    var _fs2 = _interopRequireDefault$5(_fs$1);
    var _path = path__default2;
    var _path2 = _interopRequireDefault$5(_path);
    var _parser$1 = parser$1;
    var _parser2$1 = _interopRequireDefault$5(_parser$1);
    function _interopRequireDefault$5(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Core = class {
      constructor(plugins2) {
        this.plugins = plugins2 || Core.defaultPlugins;
      }
      load(sourceString, sourcePath, trace, pathFetcher) {
        let parser3 = new _parser2$1.default(pathFetcher, trace);
        return (0, _postcss2$1.default)(this.plugins.concat([parser3.plugin()])).process(sourceString, { from: "/" + sourcePath }).then((result2) => {
          return {
            injectableSource: result2.css,
            exportTokens: parser3.exportTokens
          };
        });
      }
    };
    var traceKeySorter = (a2, b2) => {
      if (a2.length < b2.length) {
        return a2 < b2.substring(0, a2.length) ? -1 : 1;
      } else if (a2.length > b2.length) {
        return a2.substring(0, b2.length) <= b2 ? -1 : 1;
      } else {
        return a2 < b2 ? -1 : 1;
      }
    };
    var FileSystemLoader = class {
      constructor(root3, plugins2) {
        this.root = root3;
        this.sources = {};
        this.traces = {};
        this.importNr = 0;
        this.core = new Core(plugins2);
        this.tokensByFile = {};
      }
      fetch(_newPath, relativeTo, _trace) {
        let newPath = _newPath.replace(/^["']|["']$/g, ""), trace = _trace || String.fromCharCode(this.importNr++);
        return new Promise((resolve2, reject) => {
          let relativeDir = _path2.default.dirname(relativeTo), rootRelativePath = _path2.default.resolve(relativeDir, newPath), fileRelativePath = _path2.default.resolve(_path2.default.join(this.root, relativeDir), newPath);
          if (newPath[0] !== "." && newPath[0] !== "/") {
            try {
              fileRelativePath = __require.resolve(newPath);
            } catch (e2) {
            }
          }
          const tokens = this.tokensByFile[fileRelativePath];
          if (tokens) {
            return resolve2(tokens);
          }
          _fs2.default.readFile(fileRelativePath, "utf-8", (err, source2) => {
            if (err)
              reject(err);
            this.core.load(source2, rootRelativePath, trace, this.fetch.bind(this)).then(({ injectableSource, exportTokens }) => {
              this.sources[fileRelativePath] = injectableSource;
              this.traces[trace] = fileRelativePath;
              this.tokensByFile[fileRelativePath] = exportTokens;
              resolve2(exportTokens);
            }, reject);
          });
        });
      }
      get finalSource() {
        const traces = this.traces;
        const sources = this.sources;
        let written = /* @__PURE__ */ new Set();
        return Object.keys(traces).sort(traceKeySorter).map((key2) => {
          const filename2 = traces[key2];
          if (written.has(filename2)) {
            return null;
          }
          written.add(filename2);
          return sources[filename2];
        }).join("");
      }
    };
    loader.default = FileSystemLoader;
    var generateScopedName$1 = {};
    function hash(str2) {
      var hash2 = 5381, i2 = str2.length;
      while (i2) {
        hash2 = hash2 * 33 ^ str2.charCodeAt(--i2);
      }
      return hash2 >>> 0;
    }
    var stringHash = hash;
    Object.defineProperty(generateScopedName$1, "__esModule", {
      value: true
    });
    generateScopedName$1.default = generateScopedName;
    var _stringHash = stringHash;
    var _stringHash2 = _interopRequireDefault$4(_stringHash);
    function _interopRequireDefault$4(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function generateScopedName(name, filename2, css) {
      const i2 = css.indexOf(`.${name}`);
      const lineNumber = css.substr(0, i2).split(/[\r\n]/).length;
      const hash2 = (0, _stringHash2.default)(css).toString(36).substr(0, 5);
      return `_${name}_${hash2}_${lineNumber}`;
    }
    var saveJSON$1 = {};
    Object.defineProperty(saveJSON$1, "__esModule", {
      value: true
    });
    saveJSON$1.default = saveJSON;
    var _fs = fs__default2;
    function saveJSON(cssFile, json2) {
      return new Promise((resolve2, reject) => {
        (0, _fs.writeFile)(`${cssFile}.json`, JSON.stringify(json2), (e2) => e2 ? reject(e2) : resolve2(json2));
      });
    }
    var behaviours$1 = {};
    var src$4 = { exports: {} };
    var dist2 = { exports: {} };
    var processor = { exports: {} };
    var parser2 = { exports: {} };
    var root$1 = { exports: {} };
    var container = { exports: {} };
    var node$12 = { exports: {} };
    var util2 = {};
    var unesc = { exports: {} };
    (function(module3, exports3) {
      exports3.__esModule = true;
      exports3["default"] = unesc2;
      function gobbleHex(str2) {
        var lower = str2.toLowerCase();
        var hex = "";
        var spaceTerminated = false;
        for (var i2 = 0; i2 < 6 && lower[i2] !== void 0; i2++) {
          var code = lower.charCodeAt(i2);
          var valid = code >= 97 && code <= 102 || code >= 48 && code <= 57;
          spaceTerminated = code === 32;
          if (!valid) {
            break;
          }
          hex += lower[i2];
        }
        if (hex.length === 0) {
          return void 0;
        }
        var codePoint = parseInt(hex, 16);
        var isSurrogate = codePoint >= 55296 && codePoint <= 57343;
        if (isSurrogate || codePoint === 0 || codePoint > 1114111) {
          return ["\uFFFD", hex.length + (spaceTerminated ? 1 : 0)];
        }
        return [String.fromCodePoint(codePoint), hex.length + (spaceTerminated ? 1 : 0)];
      }
      var CONTAINS_ESCAPE = /\\/;
      function unesc2(str2) {
        var needToProcess = CONTAINS_ESCAPE.test(str2);
        if (!needToProcess) {
          return str2;
        }
        var ret = "";
        for (var i2 = 0; i2 < str2.length; i2++) {
          if (str2[i2] === "\\") {
            var gobbled = gobbleHex(str2.slice(i2 + 1, i2 + 7));
            if (gobbled !== void 0) {
              ret += gobbled[0];
              i2 += gobbled[1];
              continue;
            }
            if (str2[i2 + 1] === "\\") {
              ret += "\\";
              i2++;
              continue;
            }
            if (str2.length === i2 + 1) {
              ret += str2[i2];
            }
            continue;
          }
          ret += str2[i2];
        }
        return ret;
      }
      module3.exports = exports3.default;
    })(unesc, unesc.exports);
    var getProp = { exports: {} };
    (function(module3, exports3) {
      exports3.__esModule = true;
      exports3["default"] = getProp2;
      function getProp2(obj) {
        for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          props[_key - 1] = arguments[_key];
        }
        while (props.length > 0) {
          var prop = props.shift();
          if (!obj[prop]) {
            return void 0;
          }
          obj = obj[prop];
        }
        return obj;
      }
      module3.exports = exports3.default;
    })(getProp, getProp.exports);
    var ensureObject = { exports: {} };
    (function(module3, exports3) {
      exports3.__esModule = true;
      exports3["default"] = ensureObject2;
      function ensureObject2(obj) {
        for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          props[_key - 1] = arguments[_key];
        }
        while (props.length > 0) {
          var prop = props.shift();
          if (!obj[prop]) {
            obj[prop] = {};
          }
          obj = obj[prop];
        }
      }
      module3.exports = exports3.default;
    })(ensureObject, ensureObject.exports);
    var stripComments = { exports: {} };
    (function(module3, exports3) {
      exports3.__esModule = true;
      exports3["default"] = stripComments2;
      function stripComments2(str2) {
        var s2 = "";
        var commentStart = str2.indexOf("/*");
        var lastEnd = 0;
        while (commentStart >= 0) {
          s2 = s2 + str2.slice(lastEnd, commentStart);
          var commentEnd = str2.indexOf("*/", commentStart + 2);
          if (commentEnd < 0) {
            return s2;
          }
          lastEnd = commentEnd + 2;
          commentStart = str2.indexOf("/*", lastEnd);
        }
        s2 = s2 + str2.slice(lastEnd);
        return s2;
      }
      module3.exports = exports3.default;
    })(stripComments, stripComments.exports);
    util2.__esModule = true;
    util2.stripComments = util2.ensureObject = util2.getProp = util2.unesc = void 0;
    var _unesc = _interopRequireDefault$3(unesc.exports);
    util2.unesc = _unesc["default"];
    var _getProp = _interopRequireDefault$3(getProp.exports);
    util2.getProp = _getProp["default"];
    var _ensureObject = _interopRequireDefault$3(ensureObject.exports);
    util2.ensureObject = _ensureObject["default"];
    var _stripComments = _interopRequireDefault$3(stripComments.exports);
    util2.stripComments = _stripComments["default"];
    function _interopRequireDefault$3(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    (function(module3, exports3) {
      exports3.__esModule = true;
      exports3["default"] = void 0;
      var _util = util2;
      function _defineProperties(target, props) {
        for (var i2 = 0; i2 < props.length; i2++) {
          var descriptor = props[i2];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      var cloneNode = function cloneNode2(obj, parent) {
        if (typeof obj !== "object" || obj === null) {
          return obj;
        }
        var cloned = new obj.constructor();
        for (var i2 in obj) {
          if (!obj.hasOwnProperty(i2)) {
            continue;
          }
          var value = obj[i2];
          var type = typeof value;
          if (i2 === "parent" && type === "object") {
            if (parent) {
              cloned[i2] = parent;
            }
          } else if (value instanceof Array) {
            cloned[i2] = value.map(function(j2) {
              return cloneNode2(j2, cloned);
            });
          } else {
            cloned[i2] = cloneNode2(value, cloned);
          }
        }
        return cloned;
      };
      var Node2 = function() {
        function Node3(opts) {
          if (opts === void 0) {
            opts = {};
          }
          Object.assign(this, opts);
          this.spaces = this.spaces || {};
          this.spaces.before = this.spaces.before || "";
          this.spaces.after = this.spaces.after || "";
        }
        var _proto = Node3.prototype;
        _proto.remove = function remove2() {
          if (this.parent) {
            this.parent.removeChild(this);
          }
          this.parent = void 0;
          return this;
        };
        _proto.replaceWith = function replaceWith() {
          if (this.parent) {
            for (var index3 in arguments) {
              this.parent.insertBefore(this, arguments[index3]);
            }
            this.remove();
          }
          return this;
        };
        _proto.next = function next() {
          return this.parent.at(this.parent.index(this) + 1);
        };
        _proto.prev = function prev() {
          return this.parent.at(this.parent.index(this) - 1);
        };
        _proto.clone = function clone(overrides) {
          if (overrides === void 0) {
            overrides = {};
          }
          var cloned = cloneNode(this);
          for (var name in overrides) {
            cloned[name] = overrides[name];
          }
          return cloned;
        };
        _proto.appendToPropertyAndEscape = function appendToPropertyAndEscape(name, value, valueEscaped) {
          if (!this.raws) {
            this.raws = {};
          }
          var originalValue = this[name];
          var originalEscaped = this.raws[name];
          this[name] = originalValue + value;
          if (originalEscaped || valueEscaped !== value) {
            this.raws[name] = (originalEscaped || originalValue) + valueEscaped;
          } else {
            delete this.raws[name];
          }
        };
        _proto.setPropertyAndEscape = function setPropertyAndEscape(name, value, valueEscaped) {
          if (!this.raws) {
            this.raws = {};
          }
          this[name] = value;
          this.raws[name] = valueEscaped;
        };
        _proto.setPropertyWithoutEscape = function setPropertyWithoutEscape(name, value) {
          this[name] = value;
          if (this.raws) {
            delete this.raws[name];
          }
        };
        _proto.isAtPosition = function isAtPosition(line2, column2) {
          if (this.source && this.source.start && this.source.end) {
            if (this.source.start.line > line2) {
              return false;
            }
            if (this.source.end.line < line2) {
              return false;
            }
            if (this.source.start.line === line2 && this.source.start.column > column2) {
              return false;
            }
            if (this.source.end.line === line2 && this.source.end.column < column2) {
              return false;
            }
            return true;
          }
          return void 0;
        };
        _proto.stringifyProperty = function stringifyProperty(name) {
          return this.raws && this.raws[name] || this[name];
        };
        _proto.valueToString = function valueToString() {
          return String(this.stringifyProperty("value"));
        };
        _proto.toString = function toString3() {
          return [this.rawSpaceBefore, this.valueToString(), this.rawSpaceAfter].join("");
        };
        _createClass(Node3, [{
          key: "rawSpaceBefore",
          get: function get() {
            var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.before;
            if (rawSpace === void 0) {
              rawSpace = this.spaces && this.spaces.before;
            }
            return rawSpace || "";
          },
          set: function set2(raw) {
            (0, _util.ensureObject)(this, "raws", "spaces");
            this.raws.spaces.before = raw;
          }
        }, {
          key: "rawSpaceAfter",
          get: function get() {
            var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.after;
            if (rawSpace === void 0) {
              rawSpace = this.spaces.after;
            }
            return rawSpace || "";
          },
          set: function set2(raw) {
            (0, _util.ensureObject)(this, "raws", "spaces");
            this.raws.spaces.after = raw;
          }
        }]);
        return Node3;
      }();
      exports3["default"] = Node2;
      module3.exports = exports3.default;
    })(node$12, node$12.exports);
    var types2 = {};
    types2.__esModule = true;
    types2.UNIVERSAL = types2.ATTRIBUTE = types2.CLASS = types2.COMBINATOR = types2.COMMENT = types2.ID = types2.NESTING = types2.PSEUDO = types2.ROOT = types2.SELECTOR = types2.STRING = types2.TAG = void 0;
    var TAG = "tag";
    types2.TAG = TAG;
    var STRING = "string";
    types2.STRING = STRING;
    var SELECTOR = "selector";
    types2.SELECTOR = SELECTOR;
    var ROOT = "root";
    types2.ROOT = ROOT;
    var PSEUDO = "pseudo";
    types2.PSEUDO = PSEUDO;
    var NESTING = "nesting";
    types2.NESTING = NESTING;
    var ID = "id";
    types2.ID = ID;
    var COMMENT = "comment";
    types2.COMMENT = COMMENT;
    var COMBINATOR = "combinator";
    types2.COMBINATOR = COMBINATOR;
    var CLASS = "class";
    types2.CLASS = CLASS;
    var ATTRIBUTE = "attribute";
    types2.ATTRIBUTE = ATTRIBUTE;
    var UNIVERSAL = "universal";
    types2.UNIVERSAL = UNIVERSAL;
    (function(module3, exports3) {
      exports3.__esModule = true;
      exports3["default"] = void 0;
      var _node = _interopRequireDefault2(node$12.exports);
      var types$12 = _interopRequireWildcard(types2);
      function _getRequireWildcardCache() {
        if (typeof WeakMap !== "function")
          return null;
        var cache2 = /* @__PURE__ */ new WeakMap();
        _getRequireWildcardCache = function _getRequireWildcardCache2() {
          return cache2;
        };
        return cache2;
      }
      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
          return { "default": obj };
        }
        var cache2 = _getRequireWildcardCache();
        if (cache2 && cache2.has(obj)) {
          return cache2.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key2 in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key2)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key2) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key2, desc);
            } else {
              newObj[key2] = obj[key2];
            }
          }
        }
        newObj["default"] = obj;
        if (cache2) {
          cache2.set(obj, newObj);
        }
        return newObj;
      }
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _createForOfIteratorHelperLoose(o2, allowArrayLike) {
        var it2;
        if (typeof Symbol === "undefined" || o2[Symbol.iterator] == null) {
          if (Array.isArray(o2) || (it2 = _unsupportedIterableToArray(o2)) || allowArrayLike && o2 && typeof o2.length === "number") {
            if (it2)
              o2 = it2;
            var i2 = 0;
            return function() {
              if (i2 >= o2.length)
                return { done: true };
              return { done: false, value: o2[i2++] };
            };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        it2 = o2[Symbol.iterator]();
        return it2.next.bind(it2);
      }
      function _unsupportedIterableToArray(o2, minLen) {
        if (!o2)
          return;
        if (typeof o2 === "string")
          return _arrayLikeToArray(o2, minLen);
        var n3 = Object.prototype.toString.call(o2).slice(8, -1);
        if (n3 === "Object" && o2.constructor)
          n3 = o2.constructor.name;
        if (n3 === "Map" || n3 === "Set")
          return Array.from(o2);
        if (n3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3))
          return _arrayLikeToArray(o2, minLen);
      }
      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length)
          len = arr.length;
        for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
          arr2[i2] = arr[i2];
        }
        return arr2;
      }
      function _defineProperties(target, props) {
        for (var i2 = 0; i2 < props.length; i2++) {
          var descriptor = props[i2];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o2, p2) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
          o3.__proto__ = p3;
          return o3;
        };
        return _setPrototypeOf(o2, p2);
      }
      var Container = function(_Node) {
        _inheritsLoose(Container2, _Node);
        function Container2(opts) {
          var _this;
          _this = _Node.call(this, opts) || this;
          if (!_this.nodes) {
            _this.nodes = [];
          }
          return _this;
        }
        var _proto = Container2.prototype;
        _proto.append = function append2(selector2) {
          selector2.parent = this;
          this.nodes.push(selector2);
          return this;
        };
        _proto.prepend = function prepend(selector2) {
          selector2.parent = this;
          this.nodes.unshift(selector2);
          return this;
        };
        _proto.at = function at3(index3) {
          return this.nodes[index3];
        };
        _proto.index = function index3(child) {
          if (typeof child === "number") {
            return child;
          }
          return this.nodes.indexOf(child);
        };
        _proto.removeChild = function removeChild(child) {
          child = this.index(child);
          this.at(child).parent = void 0;
          this.nodes.splice(child, 1);
          var index3;
          for (var id2 in this.indexes) {
            index3 = this.indexes[id2];
            if (index3 >= child) {
              this.indexes[id2] = index3 - 1;
            }
          }
          return this;
        };
        _proto.removeAll = function removeAll() {
          for (var _iterator = _createForOfIteratorHelperLoose(this.nodes), _step; !(_step = _iterator()).done; ) {
            var node3 = _step.value;
            node3.parent = void 0;
          }
          this.nodes = [];
          return this;
        };
        _proto.empty = function empty2() {
          return this.removeAll();
        };
        _proto.insertAfter = function insertAfter(oldNode, newNode) {
          newNode.parent = this;
          var oldIndex = this.index(oldNode);
          this.nodes.splice(oldIndex + 1, 0, newNode);
          newNode.parent = this;
          var index3;
          for (var id2 in this.indexes) {
            index3 = this.indexes[id2];
            if (oldIndex <= index3) {
              this.indexes[id2] = index3 + 1;
            }
          }
          return this;
        };
        _proto.insertBefore = function insertBefore(oldNode, newNode) {
          newNode.parent = this;
          var oldIndex = this.index(oldNode);
          this.nodes.splice(oldIndex, 0, newNode);
          newNode.parent = this;
          var index3;
          for (var id2 in this.indexes) {
            index3 = this.indexes[id2];
            if (index3 <= oldIndex) {
              this.indexes[id2] = index3 + 1;
            }
          }
          return this;
        };
        _proto._findChildAtPosition = function _findChildAtPosition(line2, col) {
          var found = void 0;
          this.each(function(node3) {
            if (node3.atPosition) {
              var foundChild = node3.atPosition(line2, col);
              if (foundChild) {
                found = foundChild;
                return false;
              }
            } else if (node3.isAtPosition(line2, col)) {
              found = node3;
              return false;
            }
          });
          return found;
        };
        _proto.atPosition = function atPosition(line2, col) {
          if (this.isAtPosition(line2, col)) {
            return this._findChildAtPosition(line2, col) || this;
          } else {
            return void 0;
          }
        };
        _proto._inferEndPosition = function _inferEndPosition() {
          if (this.last && this.last.source && this.last.source.end) {
            this.source = this.source || {};
            this.source.end = this.source.end || {};
            Object.assign(this.source.end, this.last.source.end);
          }
        };
        _proto.each = function each(callback) {
          if (!this.lastEach) {
            this.lastEach = 0;
          }
          if (!this.indexes) {
            this.indexes = {};
          }
          this.lastEach++;
          var id2 = this.lastEach;
          this.indexes[id2] = 0;
          if (!this.length) {
            return void 0;
          }
          var index3, result2;
          while (this.indexes[id2] < this.length) {
            index3 = this.indexes[id2];
            result2 = callback(this.at(index3), index3);
            if (result2 === false) {
              break;
            }
            this.indexes[id2] += 1;
          }
          delete this.indexes[id2];
          if (result2 === false) {
            return false;
          }
        };
        _proto.walk = function walk2(callback) {
          return this.each(function(node3, i2) {
            var result2 = callback(node3, i2);
            if (result2 !== false && node3.length) {
              result2 = node3.walk(callback);
            }
            if (result2 === false) {
              return false;
            }
          });
        };
        _proto.walkAttributes = function walkAttributes(callback) {
          var _this2 = this;
          return this.walk(function(selector2) {
            if (selector2.type === types$12.ATTRIBUTE) {
              return callback.call(_this2, selector2);
            }
          });
        };
        _proto.walkClasses = function walkClasses(callback) {
          var _this3 = this;
          return this.walk(function(selector2) {
            if (selector2.type === types$12.CLASS) {
              return callback.call(_this3, selector2);
            }
          });
        };
        _proto.walkCombinators = function walkCombinators(callback) {
          var _this4 = this;
          return this.walk(function(selector2) {
            if (selector2.type === types$12.COMBINATOR) {
              return callback.call(_this4, selector2);
            }
          });
        };
        _proto.walkComments = function walkComments(callback) {
          var _this5 = this;
          return this.walk(function(selector2) {
            if (selector2.type === types$12.COMMENT) {
              return callback.call(_this5, selector2);
            }
          });
        };
        _proto.walkIds = function walkIds(callback) {
          var _this6 = this;
          return this.walk(function(selector2) {
            if (selector2.type === types$12.ID) {
              return callback.call(_this6, selector2);
            }
          });
        };
        _proto.walkNesting = function walkNesting(callback) {
          var _this7 = this;
          return this.walk(function(selector2) {
            if (selector2.type === types$12.NESTING) {
              return callback.call(_this7, selector2);
            }
          });
        };
        _proto.walkPseudos = function walkPseudos(callback) {
          var _this8 = this;
          return this.walk(function(selector2) {
            if (selector2.type === types$12.PSEUDO) {
              return callback.call(_this8, selector2);
            }
          });
        };
        _proto.walkTags = function walkTags(callback) {
          var _this9 = this;
          return this.walk(function(selector2) {
            if (selector2.type === types$12.TAG) {
              return callback.call(_this9, selector2);
            }
          });
        };
        _proto.walkUniversals = function walkUniversals(callback) {
          var _this10 = this;
          return this.walk(function(selector2) {
            if (selector2.type === types$12.UNIVERSAL) {
              return callback.call(_this10, selector2);
            }
          });
        };
        _proto.split = function split2(callback) {
          var _this11 = this;
          var current = [];
          return this.reduce(function(memo, node3, index3) {
            var split3 = callback.call(_this11, node3);
            current.push(node3);
            if (split3) {
              memo.push(current);
              current = [];
            } else if (index3 === _this11.length - 1) {
              memo.push(current);
            }
            return memo;
          }, []);
        };
        _proto.map = function map2(callback) {
          return this.nodes.map(callback);
        };
        _proto.reduce = function reduce(callback, memo) {
          return this.nodes.reduce(callback, memo);
        };
        _proto.every = function every(callback) {
          return this.nodes.every(callback);
        };
        _proto.some = function some(callback) {
          return this.nodes.some(callback);
        };
        _proto.filter = function filter2(callback) {
          return this.nodes.filter(callback);
        };
        _proto.sort = function sort2(callback) {
          return this.nodes.sort(callback);
        };
        _proto.toString = function toString3() {
          return this.map(String).join("");
        };
        _createClass(Container2, [{
          key: "first",
          get: function get() {
            return this.at(0);
          }
        }, {
          key: "last",
          get: function get() {
            return this.at(this.length - 1);
          }
        }, {
          key: "length",
          get: function get() {
            return this.nodes.length;
          }
        }]);
        return Container2;
      }(_node["default"]);
      exports3["default"] = Container;
      module3.exports = exports3.default;
    })(container, container.exports);
    (function(module3, exports3) {
      exports3.__esModule = true;
      exports3["default"] = void 0;
      var _container = _interopRequireDefault2(container.exports);
      var _types2 = types2;
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _defineProperties(target, props) {
        for (var i2 = 0; i2 < props.length; i2++) {
          var descriptor = props[i2];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o2, p2) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
          o3.__proto__ = p3;
          return o3;
        };
        return _setPrototypeOf(o2, p2);
      }
      var Root = function(_Container) {
        _inheritsLoose(Root2, _Container);
        function Root2(opts) {
          var _this;
          _this = _Container.call(this, opts) || this;
          _this.type = _types2.ROOT;
          return _this;
        }
        var _proto = Root2.prototype;
        _proto.toString = function toString3() {
          var str2 = this.reduce(function(memo, selector2) {
            memo.push(String(selector2));
            return memo;
          }, []).join(",");
          return this.trailingComma ? str2 + "," : str2;
        };
        _proto.error = function error2(message, options2) {
          if (this._error) {
            return this._error(message, options2);
          } else {
            return new Error(message);
          }
        };
        _createClass(Root2, [{
          key: "errorGenerator",
          set: function set2(handler) {
            this._error = handler;
          }
        }]);
        return Root2;
      }(_container["default"]);
      exports3["default"] = Root;
      module3.exports = exports3.default;
    })(root$1, root$1.exports);
    var selector$1 = { exports: {} };
    (function(module3, exports3) {
      exports3.__esModule = true;
      exports3["default"] = void 0;
      var _container = _interopRequireDefault2(container.exports);
      var _types2 = types2;
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o2, p2) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
          o3.__proto__ = p3;
          return o3;
        };
        return _setPrototypeOf(o2, p2);
      }
      var Selector = function(_Container) {
        _inheritsLoose(Selector2, _Container);
        function Selector2(opts) {
          var _this;
          _this = _Container.call(this, opts) || this;
          _this.type = _types2.SELECTOR;
          return _this;
        }
        return Selector2;
      }(_container["default"]);
      exports3["default"] = Selector;
      module3.exports = exports3.default;
    })(selector$1, selector$1.exports);
    var className$1 = { exports: {} };
    var object = {};
    var hasOwnProperty$12 = object.hasOwnProperty;
    var merge3 = function merge4(options2, defaults) {
      if (!options2) {
        return defaults;
      }
      var result2 = {};
      for (var key2 in defaults) {
        result2[key2] = hasOwnProperty$12.call(options2, key2) ? options2[key2] : defaults[key2];
      }
      return result2;
    };
    var regexAnySingleEscape = /[ -,\.\/:-@\[-\^`\{-~]/;
    var regexSingleEscape = /[ -,\.\/:-@\[\]\^`\{-~]/;
    var regexExcessiveSpaces = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g;
    var cssesc = function cssesc2(string3, options2) {
      options2 = merge3(options2, cssesc2.options);
      if (options2.quotes != "single" && options2.quotes != "double") {
        options2.quotes = "single";
      }
      var quote = options2.quotes == "double" ? '"' : "'";
      var isIdentifier2 = options2.isIdentifier;
      var firstChar = string3.charAt(0);
      var output = "";
      var counter = 0;
      var length = string3.length;
      while (counter < length) {
        var character = string3.charAt(counter++);
        var codePoint = character.charCodeAt();
        var value = void 0;
        if (codePoint < 32 || codePoint > 126) {
          if (codePoint >= 55296 && codePoint <= 56319 && counter < length) {
            var extra = string3.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              codePoint = ((codePoint & 1023) << 10) + (extra & 1023) + 65536;
            } else {
              counter--;
            }
          }
          value = "\\" + codePoint.toString(16).toUpperCase() + " ";
        } else {
          if (options2.escapeEverything) {
            if (regexAnySingleEscape.test(character)) {
              value = "\\" + character;
            } else {
              value = "\\" + codePoint.toString(16).toUpperCase() + " ";
            }
          } else if (/[\t\n\f\r\x0B]/.test(character)) {
            value = "\\" + codePoint.toString(16).toUpperCase() + " ";
          } else if (character == "\\" || !isIdentifier2 && (character == '"' && quote == character || character == "'" && quote == character) || isIdentifier2 && regexSingleEscape.test(character)) {
            value = "\\" + character;
          } else {
            value = character;
          }
        }
        output += value;
      }
      if (isIdentifier2) {
        if (/^-[-\d]/.test(output)) {
          output = "\\-" + output.slice(1);
        } else if (/\d/.test(firstChar)) {
          output = "\\3" + firstChar + " " + output.slice(1);
        }
      }
      output = output.replace(regexExcessiveSpaces, function($0, $1, $2) {
        if ($1 && $1.length % 2) {
          return $0;
        }
        return ($1 || "") + $2;
      });
      if (!isIdentifier2 && options2.wrap) {
        return quote + output + quote;
      }
      return output;
    };
    cssesc.options = {
      "escapeEverything": false,
      "isIdentifier": false,
      "quotes": "single",
      "wrap": false
    };
    cssesc.version = "3.0.0";
    var cssesc_1 = cssesc;
    (function(module3, exports3) {
      exports3.__esModule = true;
      exports3["default"] = void 0;
      var _cssesc = _interopRequireDefault2(cssesc_1);
      var _util = util2;
      var _node = _interopRequireDefault2(node$12.exports);
      var _types2 = types2;
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _defineProperties(target, props) {
        for (var i2 = 0; i2 < props.length; i2++) {
          var descriptor = props[i2];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o2, p2) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
          o3.__proto__ = p3;
          return o3;
        };
        return _setPrototypeOf(o2, p2);
      }
      var ClassName = function(_Node) {
        _inheritsLoose(ClassName2, _Node);
        function ClassName2(opts) {
          var _this;
          _this = _Node.call(this, opts) || this;
          _this.type = _types2.CLASS;
          _this._constructed = true;
          return _this;
        }
        var _proto = ClassName2.prototype;
        _proto.valueToString = function valueToString() {
          return "." + _Node.prototype.valueToString.call(this);
        };
        _createClass(ClassName2, [{
          key: "value",
          get: function get() {
            return this._value;
          },
          set: function set2(v2) {
            if (this._constructed) {
              var escaped2 = (0, _cssesc["default"])(v2, {
                isIdentifier: true
              });
              if (escaped2 !== v2) {
                (0, _util.ensureObject)(this, "raws");
                this.raws.value = escaped2;
              } else if (this.raws) {
                delete this.raws.value;
              }
            }
            this._value = v2;
          }
        }]);
        return ClassName2;
      }(_node["default"]);
      exports3["default"] = ClassName;
      module3.exports = exports3.default;
    })(className$1, className$1.exports);
    var comment$2 = { exports: {} };
    (function(module3, exports3) {
      exports3.__esModule = true;
      exports3["default"] = void 0;
      var _node = _interopRequireDefault2(node$12.exports);
      var _types2 = types2;
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o2, p2) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
          o3.__proto__ = p3;
          return o3;
        };
        return _setPrototypeOf(o2, p2);
      }
      var Comment2 = function(_Node) {
        _inheritsLoose(Comment3, _Node);
        function Comment3(opts) {
          var _this;
          _this = _Node.call(this, opts) || this;
          _this.type = _types2.COMMENT;
          return _this;
        }
        return Comment3;
      }(_node["default"]);
      exports3["default"] = Comment2;
      module3.exports = exports3.default;
    })(comment$2, comment$2.exports);
    var id$1 = { exports: {} };
    (function(module3, exports3) {
      exports3.__esModule = true;
      exports3["default"] = void 0;
      var _node = _interopRequireDefault2(node$12.exports);
      var _types2 = types2;
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o2, p2) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
          o3.__proto__ = p3;
          return o3;
        };
        return _setPrototypeOf(o2, p2);
      }
      var ID2 = function(_Node) {
        _inheritsLoose(ID3, _Node);
        function ID3(opts) {
          var _this;
          _this = _Node.call(this, opts) || this;
          _this.type = _types2.ID;
          return _this;
        }
        var _proto = ID3.prototype;
        _proto.valueToString = function valueToString() {
          return "#" + _Node.prototype.valueToString.call(this);
        };
        return ID3;
      }(_node["default"]);
      exports3["default"] = ID2;
      module3.exports = exports3.default;
    })(id$1, id$1.exports);
    var tag$1 = { exports: {} };
    var namespace = { exports: {} };
    (function(module3, exports3) {
      exports3.__esModule = true;
      exports3["default"] = void 0;
      var _cssesc = _interopRequireDefault2(cssesc_1);
      var _util = util2;
      var _node = _interopRequireDefault2(node$12.exports);
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _defineProperties(target, props) {
        for (var i2 = 0; i2 < props.length; i2++) {
          var descriptor = props[i2];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o2, p2) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
          o3.__proto__ = p3;
          return o3;
        };
        return _setPrototypeOf(o2, p2);
      }
      var Namespace = function(_Node) {
        _inheritsLoose(Namespace2, _Node);
        function Namespace2() {
          return _Node.apply(this, arguments) || this;
        }
        var _proto = Namespace2.prototype;
        _proto.qualifiedName = function qualifiedName(value) {
          if (this.namespace) {
            return this.namespaceString + "|" + value;
          } else {
            return value;
          }
        };
        _proto.valueToString = function valueToString() {
          return this.qualifiedName(_Node.prototype.valueToString.call(this));
        };
        _createClass(Namespace2, [{
          key: "namespace",
          get: function get() {
            return this._namespace;
          },
          set: function set2(namespace2) {
            if (namespace2 === true || namespace2 === "*" || namespace2 === "&") {
              this._namespace = namespace2;
              if (this.raws) {
                delete this.raws.namespace;
              }
              return;
            }
            var escaped2 = (0, _cssesc["default"])(namespace2, {
              isIdentifier: true
            });
            this._namespace = namespace2;
            if (escaped2 !== namespace2) {
              (0, _util.ensureObject)(this, "raws");
              this.raws.namespace = escaped2;
            } else if (this.raws) {
              delete this.raws.namespace;
            }
          }
        }, {
          key: "ns",
          get: function get() {
            return this._namespace;
          },
          set: function set2(namespace2) {
            this.namespace = namespace2;
          }
        }, {
          key: "namespaceString",
          get: function get() {
            if (this.namespace) {
              var ns2 = this.stringifyProperty("namespace");
              if (ns2 === true) {
                return "";
              } else {
                return ns2;
              }
            } else {
              return "";
            }
          }
        }]);
        return Namespace2;
      }(_node["default"]);
      exports3["default"] = Namespace;
      module3.exports = exports3.default;
    })(namespace, namespace.exports);
    (function(module3, exports3) {
      exports3.__esModule = true;
      exports3["default"] = void 0;
      var _namespace = _interopRequireDefault2(namespace.exports);
      var _types2 = types2;
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o2, p2) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
          o3.__proto__ = p3;
          return o3;
        };
        return _setPrototypeOf(o2, p2);
      }
      var Tag = function(_Namespace) {
        _inheritsLoose(Tag2, _Namespace);
        function Tag2(opts) {
          var _this;
          _this = _Namespace.call(this, opts) || this;
          _this.type = _types2.TAG;
          return _this;
        }
        return Tag2;
      }(_namespace["default"]);
      exports3["default"] = Tag;
      module3.exports = exports3.default;
    })(tag$1, tag$1.exports);
    var string$12 = { exports: {} };
    (function(module3, exports3) {
      exports3.__esModule = true;
      exports3["default"] = void 0;
      var _node = _interopRequireDefault2(node$12.exports);
      var _types2 = types2;
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o2, p2) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
          o3.__proto__ = p3;
          return o3;
        };
        return _setPrototypeOf(o2, p2);
      }
      var String2 = function(_Node) {
        _inheritsLoose(String3, _Node);
        function String3(opts) {
          var _this;
          _this = _Node.call(this, opts) || this;
          _this.type = _types2.STRING;
          return _this;
        }
        return String3;
      }(_node["default"]);
      exports3["default"] = String2;
      module3.exports = exports3.default;
    })(string$12, string$12.exports);
    var pseudo$1 = { exports: {} };
    (function(module3, exports3) {
      exports3.__esModule = true;
      exports3["default"] = void 0;
      var _container = _interopRequireDefault2(container.exports);
      var _types2 = types2;
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o2, p2) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
          o3.__proto__ = p3;
          return o3;
        };
        return _setPrototypeOf(o2, p2);
      }
      var Pseudo = function(_Container) {
        _inheritsLoose(Pseudo2, _Container);
        function Pseudo2(opts) {
          var _this;
          _this = _Container.call(this, opts) || this;
          _this.type = _types2.PSEUDO;
          return _this;
        }
        var _proto = Pseudo2.prototype;
        _proto.toString = function toString3() {
          var params = this.length ? "(" + this.map(String).join(",") + ")" : "";
          return [this.rawSpaceBefore, this.stringifyProperty("value"), params, this.rawSpaceAfter].join("");
        };
        return Pseudo2;
      }(_container["default"]);
      exports3["default"] = Pseudo;
      module3.exports = exports3.default;
    })(pseudo$1, pseudo$1.exports);
    var attribute$1 = {};
    var node2 = require$$0__default$12.deprecate;
    (function(exports3) {
      exports3.__esModule = true;
      exports3.unescapeValue = unescapeValue;
      exports3["default"] = void 0;
      var _cssesc = _interopRequireDefault2(cssesc_1);
      var _unesc2 = _interopRequireDefault2(unesc.exports);
      var _namespace = _interopRequireDefault2(namespace.exports);
      var _types2 = types2;
      var _CSSESC_QUOTE_OPTIONS;
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _defineProperties(target, props) {
        for (var i2 = 0; i2 < props.length; i2++) {
          var descriptor = props[i2];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o2, p2) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
          o3.__proto__ = p3;
          return o3;
        };
        return _setPrototypeOf(o2, p2);
      }
      var deprecate = node2;
      var WRAPPED_IN_QUOTES = /^('|")([^]*)\1$/;
      var warnOfDeprecatedValueAssignment = deprecate(function() {
      }, "Assigning an attribute a value containing characters that might need to be escaped is deprecated. Call attribute.setValue() instead.");
      var warnOfDeprecatedQuotedAssignment = deprecate(function() {
      }, "Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead.");
      var warnOfDeprecatedConstructor = deprecate(function() {
      }, "Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now.");
      function unescapeValue(value) {
        var deprecatedUsage = false;
        var quoteMark = null;
        var unescaped = value;
        var m3 = unescaped.match(WRAPPED_IN_QUOTES);
        if (m3) {
          quoteMark = m3[1];
          unescaped = m3[2];
        }
        unescaped = (0, _unesc2["default"])(unescaped);
        if (unescaped !== value) {
          deprecatedUsage = true;
        }
        return {
          deprecatedUsage,
          unescaped,
          quoteMark
        };
      }
      function handleDeprecatedContructorOpts(opts) {
        if (opts.quoteMark !== void 0) {
          return opts;
        }
        if (opts.value === void 0) {
          return opts;
        }
        warnOfDeprecatedConstructor();
        var _unescapeValue = unescapeValue(opts.value), quoteMark = _unescapeValue.quoteMark, unescaped = _unescapeValue.unescaped;
        if (!opts.raws) {
          opts.raws = {};
        }
        if (opts.raws.value === void 0) {
          opts.raws.value = opts.value;
        }
        opts.value = unescaped;
        opts.quoteMark = quoteMark;
        return opts;
      }
      var Attribute = function(_Namespace) {
        _inheritsLoose(Attribute2, _Namespace);
        function Attribute2(opts) {
          var _this;
          if (opts === void 0) {
            opts = {};
          }
          _this = _Namespace.call(this, handleDeprecatedContructorOpts(opts)) || this;
          _this.type = _types2.ATTRIBUTE;
          _this.raws = _this.raws || {};
          Object.defineProperty(_this.raws, "unquoted", {
            get: deprecate(function() {
              return _this.value;
            }, "attr.raws.unquoted is deprecated. Call attr.value instead."),
            set: deprecate(function() {
              return _this.value;
            }, "Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.")
          });
          _this._constructed = true;
          return _this;
        }
        var _proto = Attribute2.prototype;
        _proto.getQuotedValue = function getQuotedValue(options2) {
          if (options2 === void 0) {
            options2 = {};
          }
          var quoteMark = this._determineQuoteMark(options2);
          var cssescopts = CSSESC_QUOTE_OPTIONS[quoteMark];
          var escaped2 = (0, _cssesc["default"])(this._value, cssescopts);
          return escaped2;
        };
        _proto._determineQuoteMark = function _determineQuoteMark(options2) {
          return options2.smart ? this.smartQuoteMark(options2) : this.preferredQuoteMark(options2);
        };
        _proto.setValue = function setValue(value, options2) {
          if (options2 === void 0) {
            options2 = {};
          }
          this._value = value;
          this._quoteMark = this._determineQuoteMark(options2);
          this._syncRawValue();
        };
        _proto.smartQuoteMark = function smartQuoteMark(options2) {
          var v2 = this.value;
          var numSingleQuotes = v2.replace(/[^']/g, "").length;
          var numDoubleQuotes = v2.replace(/[^"]/g, "").length;
          if (numSingleQuotes + numDoubleQuotes === 0) {
            var escaped2 = (0, _cssesc["default"])(v2, {
              isIdentifier: true
            });
            if (escaped2 === v2) {
              return Attribute2.NO_QUOTE;
            } else {
              var pref = this.preferredQuoteMark(options2);
              if (pref === Attribute2.NO_QUOTE) {
                var quote = this.quoteMark || options2.quoteMark || Attribute2.DOUBLE_QUOTE;
                var opts = CSSESC_QUOTE_OPTIONS[quote];
                var quoteValue = (0, _cssesc["default"])(v2, opts);
                if (quoteValue.length < escaped2.length) {
                  return quote;
                }
              }
              return pref;
            }
          } else if (numDoubleQuotes === numSingleQuotes) {
            return this.preferredQuoteMark(options2);
          } else if (numDoubleQuotes < numSingleQuotes) {
            return Attribute2.DOUBLE_QUOTE;
          } else {
            return Attribute2.SINGLE_QUOTE;
          }
        };
        _proto.preferredQuoteMark = function preferredQuoteMark(options2) {
          var quoteMark = options2.preferCurrentQuoteMark ? this.quoteMark : options2.quoteMark;
          if (quoteMark === void 0) {
            quoteMark = options2.preferCurrentQuoteMark ? options2.quoteMark : this.quoteMark;
          }
          if (quoteMark === void 0) {
            quoteMark = Attribute2.DOUBLE_QUOTE;
          }
          return quoteMark;
        };
        _proto._syncRawValue = function _syncRawValue() {
          var rawValue = (0, _cssesc["default"])(this._value, CSSESC_QUOTE_OPTIONS[this.quoteMark]);
          if (rawValue === this._value) {
            if (this.raws) {
              delete this.raws.value;
            }
          } else {
            this.raws.value = rawValue;
          }
        };
        _proto._handleEscapes = function _handleEscapes(prop, value) {
          if (this._constructed) {
            var escaped2 = (0, _cssesc["default"])(value, {
              isIdentifier: true
            });
            if (escaped2 !== value) {
              this.raws[prop] = escaped2;
            } else {
              delete this.raws[prop];
            }
          }
        };
        _proto._spacesFor = function _spacesFor(name) {
          var attrSpaces = {
            before: "",
            after: ""
          };
          var spaces = this.spaces[name] || {};
          var rawSpaces = this.raws.spaces && this.raws.spaces[name] || {};
          return Object.assign(attrSpaces, spaces, rawSpaces);
        };
        _proto._stringFor = function _stringFor(name, spaceName, concat2) {
          if (spaceName === void 0) {
            spaceName = name;
          }
          if (concat2 === void 0) {
            concat2 = defaultAttrConcat;
          }
          var attrSpaces = this._spacesFor(spaceName);
          return concat2(this.stringifyProperty(name), attrSpaces);
        };
        _proto.offsetOf = function offsetOf(name) {
          var count = 1;
          var attributeSpaces = this._spacesFor("attribute");
          count += attributeSpaces.before.length;
          if (name === "namespace" || name === "ns") {
            return this.namespace ? count : -1;
          }
          if (name === "attributeNS") {
            return count;
          }
          count += this.namespaceString.length;
          if (this.namespace) {
            count += 1;
          }
          if (name === "attribute") {
            return count;
          }
          count += this.stringifyProperty("attribute").length;
          count += attributeSpaces.after.length;
          var operatorSpaces = this._spacesFor("operator");
          count += operatorSpaces.before.length;
          var operator = this.stringifyProperty("operator");
          if (name === "operator") {
            return operator ? count : -1;
          }
          count += operator.length;
          count += operatorSpaces.after.length;
          var valueSpaces = this._spacesFor("value");
          count += valueSpaces.before.length;
          var value = this.stringifyProperty("value");
          if (name === "value") {
            return value ? count : -1;
          }
          count += value.length;
          count += valueSpaces.after.length;
          var insensitiveSpaces = this._spacesFor("insensitive");
          count += insensitiveSpaces.before.length;
          if (name === "insensitive") {
            return this.insensitive ? count : -1;
          }
          return -1;
        };
        _proto.toString = function toString3() {
          var _this2 = this;
          var selector2 = [this.rawSpaceBefore, "["];
          selector2.push(this._stringFor("qualifiedAttribute", "attribute"));
          if (this.operator && (this.value || this.value === "")) {
            selector2.push(this._stringFor("operator"));
            selector2.push(this._stringFor("value"));
            selector2.push(this._stringFor("insensitiveFlag", "insensitive", function(attrValue, attrSpaces) {
              if (attrValue.length > 0 && !_this2.quoted && attrSpaces.before.length === 0 && !(_this2.spaces.value && _this2.spaces.value.after)) {
                attrSpaces.before = " ";
              }
              return defaultAttrConcat(attrValue, attrSpaces);
            }));
          }
          selector2.push("]");
          selector2.push(this.rawSpaceAfter);
          return selector2.join("");
        };
        _createClass(Attribute2, [{
          key: "quoted",
          get: function get() {
            var qm = this.quoteMark;
            return qm === "'" || qm === '"';
          },
          set: function set2(value) {
            warnOfDeprecatedQuotedAssignment();
          }
        }, {
          key: "quoteMark",
          get: function get() {
            return this._quoteMark;
          },
          set: function set2(quoteMark) {
            if (!this._constructed) {
              this._quoteMark = quoteMark;
              return;
            }
            if (this._quoteMark !== quoteMark) {
              this._quoteMark = quoteMark;
              this._syncRawValue();
            }
          }
        }, {
          key: "qualifiedAttribute",
          get: function get() {
            return this.qualifiedName(this.raws.attribute || this.attribute);
          }
        }, {
          key: "insensitiveFlag",
          get: function get() {
            return this.insensitive ? "i" : "";
          }
        }, {
          key: "value",
          get: function get() {
            return this._value;
          },
          set: function set2(v2) {
            if (this._constructed) {
              var _unescapeValue2 = unescapeValue(v2), deprecatedUsage = _unescapeValue2.deprecatedUsage, unescaped = _unescapeValue2.unescaped, quoteMark = _unescapeValue2.quoteMark;
              if (deprecatedUsage) {
                warnOfDeprecatedValueAssignment();
              }
              if (unescaped === this._value && quoteMark === this._quoteMark) {
                return;
              }
              this._value = unescaped;
              this._quoteMark = quoteMark;
              this._syncRawValue();
            } else {
              this._value = v2;
            }
          }
        }, {
          key: "attribute",
          get: function get() {
            return this._attribute;
          },
          set: function set2(name) {
            this._handleEscapes("attribute", name);
            this._attribute = name;
          }
        }]);
        return Attribute2;
      }(_namespace["default"]);
      exports3["default"] = Attribute;
      Attribute.NO_QUOTE = null;
      Attribute.SINGLE_QUOTE = "'";
      Attribute.DOUBLE_QUOTE = '"';
      var CSSESC_QUOTE_OPTIONS = (_CSSESC_QUOTE_OPTIONS = {
        "'": {
          quotes: "single",
          wrap: true
        },
        '"': {
          quotes: "double",
          wrap: true
        }
      }, _CSSESC_QUOTE_OPTIONS[null] = {
        isIdentifier: true
      }, _CSSESC_QUOTE_OPTIONS);
      function defaultAttrConcat(attrValue, attrSpaces) {
        return "" + attrSpaces.before + attrValue + attrSpaces.after;
      }
    })(attribute$1);
    var universal$1 = { exports: {} };
    (function(module3, exports3) {
      exports3.__esModule = true;
      exports3["default"] = void 0;
      var _namespace = _interopRequireDefault2(namespace.exports);
      var _types2 = types2;
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o2, p2) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
          o3.__proto__ = p3;
          return o3;
        };
        return _setPrototypeOf(o2, p2);
      }
      var Universal = function(_Namespace) {
        _inheritsLoose(Universal2, _Namespace);
        function Universal2(opts) {
          var _this;
          _this = _Namespace.call(this, opts) || this;
          _this.type = _types2.UNIVERSAL;
          _this.value = "*";
          return _this;
        }
        return Universal2;
      }(_namespace["default"]);
      exports3["default"] = Universal;
      module3.exports = exports3.default;
    })(universal$1, universal$1.exports);
    var combinator$2 = { exports: {} };
    (function(module3, exports3) {
      exports3.__esModule = true;
      exports3["default"] = void 0;
      var _node = _interopRequireDefault2(node$12.exports);
      var _types2 = types2;
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o2, p2) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
          o3.__proto__ = p3;
          return o3;
        };
        return _setPrototypeOf(o2, p2);
      }
      var Combinator = function(_Node) {
        _inheritsLoose(Combinator2, _Node);
        function Combinator2(opts) {
          var _this;
          _this = _Node.call(this, opts) || this;
          _this.type = _types2.COMBINATOR;
          return _this;
        }
        return Combinator2;
      }(_node["default"]);
      exports3["default"] = Combinator;
      module3.exports = exports3.default;
    })(combinator$2, combinator$2.exports);
    var nesting$1 = { exports: {} };
    (function(module3, exports3) {
      exports3.__esModule = true;
      exports3["default"] = void 0;
      var _node = _interopRequireDefault2(node$12.exports);
      var _types2 = types2;
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o2, p2) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
          o3.__proto__ = p3;
          return o3;
        };
        return _setPrototypeOf(o2, p2);
      }
      var Nesting = function(_Node) {
        _inheritsLoose(Nesting2, _Node);
        function Nesting2(opts) {
          var _this;
          _this = _Node.call(this, opts) || this;
          _this.type = _types2.NESTING;
          _this.value = "&";
          return _this;
        }
        return Nesting2;
      }(_node["default"]);
      exports3["default"] = Nesting;
      module3.exports = exports3.default;
    })(nesting$1, nesting$1.exports);
    var sortAscending = { exports: {} };
    (function(module3, exports3) {
      exports3.__esModule = true;
      exports3["default"] = sortAscending2;
      function sortAscending2(list2) {
        return list2.sort(function(a2, b2) {
          return a2 - b2;
        });
      }
      module3.exports = exports3.default;
    })(sortAscending, sortAscending.exports);
    var tokenize = {};
    var tokenTypes = {};
    tokenTypes.__esModule = true;
    tokenTypes.combinator = tokenTypes.word = tokenTypes.comment = tokenTypes.str = tokenTypes.tab = tokenTypes.newline = tokenTypes.feed = tokenTypes.cr = tokenTypes.backslash = tokenTypes.bang = tokenTypes.slash = tokenTypes.doubleQuote = tokenTypes.singleQuote = tokenTypes.space = tokenTypes.greaterThan = tokenTypes.pipe = tokenTypes.equals = tokenTypes.plus = tokenTypes.caret = tokenTypes.tilde = tokenTypes.dollar = tokenTypes.closeSquare = tokenTypes.openSquare = tokenTypes.closeParenthesis = tokenTypes.openParenthesis = tokenTypes.semicolon = tokenTypes.colon = tokenTypes.comma = tokenTypes.at = tokenTypes.asterisk = tokenTypes.ampersand = void 0;
    var ampersand = 38;
    tokenTypes.ampersand = ampersand;
    var asterisk = 42;
    tokenTypes.asterisk = asterisk;
    var at2 = 64;
    tokenTypes.at = at2;
    var comma2 = 44;
    tokenTypes.comma = comma2;
    var colon = 58;
    tokenTypes.colon = colon;
    var semicolon2 = 59;
    tokenTypes.semicolon = semicolon2;
    var openParenthesis = 40;
    tokenTypes.openParenthesis = openParenthesis;
    var closeParenthesis = 41;
    tokenTypes.closeParenthesis = closeParenthesis;
    var openSquare = 91;
    tokenTypes.openSquare = openSquare;
    var closeSquare = 93;
    tokenTypes.closeSquare = closeSquare;
    var dollar = 36;
    tokenTypes.dollar = dollar;
    var tilde = 126;
    tokenTypes.tilde = tilde;
    var caret = 94;
    tokenTypes.caret = caret;
    var plus = 43;
    tokenTypes.plus = plus;
    var equals2 = 61;
    tokenTypes.equals = equals2;
    var pipe = 124;
    tokenTypes.pipe = pipe;
    var greaterThan = 62;
    tokenTypes.greaterThan = greaterThan;
    var space = 32;
    tokenTypes.space = space;
    var singleQuote = 39;
    tokenTypes.singleQuote = singleQuote;
    var doubleQuote2 = 34;
    tokenTypes.doubleQuote = doubleQuote2;
    var slash2 = 47;
    tokenTypes.slash = slash2;
    var bang = 33;
    tokenTypes.bang = bang;
    var backslash2 = 92;
    tokenTypes.backslash = backslash2;
    var cr2 = 13;
    tokenTypes.cr = cr2;
    var feed = 12;
    tokenTypes.feed = feed;
    var newline = 10;
    tokenTypes.newline = newline;
    var tab = 9;
    tokenTypes.tab = tab;
    var str = singleQuote;
    tokenTypes.str = str;
    var comment$1 = -1;
    tokenTypes.comment = comment$1;
    var word = -2;
    tokenTypes.word = word;
    var combinator$1 = -3;
    tokenTypes.combinator = combinator$1;
    (function(exports3) {
      exports3.__esModule = true;
      exports3["default"] = tokenize2;
      exports3.FIELDS = void 0;
      var t = _interopRequireWildcard(tokenTypes);
      var _unescapable, _wordDelimiters;
      function _getRequireWildcardCache() {
        if (typeof WeakMap !== "function")
          return null;
        var cache2 = /* @__PURE__ */ new WeakMap();
        _getRequireWildcardCache = function _getRequireWildcardCache2() {
          return cache2;
        };
        return cache2;
      }
      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
          return { "default": obj };
        }
        var cache2 = _getRequireWildcardCache();
        if (cache2 && cache2.has(obj)) {
          return cache2.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key2 in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key2)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key2) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key2, desc);
            } else {
              newObj[key2] = obj[key2];
            }
          }
        }
        newObj["default"] = obj;
        if (cache2) {
          cache2.set(obj, newObj);
        }
        return newObj;
      }
      var unescapable = (_unescapable = {}, _unescapable[t.tab] = true, _unescapable[t.newline] = true, _unescapable[t.cr] = true, _unescapable[t.feed] = true, _unescapable);
      var wordDelimiters = (_wordDelimiters = {}, _wordDelimiters[t.space] = true, _wordDelimiters[t.tab] = true, _wordDelimiters[t.newline] = true, _wordDelimiters[t.cr] = true, _wordDelimiters[t.feed] = true, _wordDelimiters[t.ampersand] = true, _wordDelimiters[t.asterisk] = true, _wordDelimiters[t.bang] = true, _wordDelimiters[t.comma] = true, _wordDelimiters[t.colon] = true, _wordDelimiters[t.semicolon] = true, _wordDelimiters[t.openParenthesis] = true, _wordDelimiters[t.closeParenthesis] = true, _wordDelimiters[t.openSquare] = true, _wordDelimiters[t.closeSquare] = true, _wordDelimiters[t.singleQuote] = true, _wordDelimiters[t.doubleQuote] = true, _wordDelimiters[t.plus] = true, _wordDelimiters[t.pipe] = true, _wordDelimiters[t.tilde] = true, _wordDelimiters[t.greaterThan] = true, _wordDelimiters[t.equals] = true, _wordDelimiters[t.dollar] = true, _wordDelimiters[t.caret] = true, _wordDelimiters[t.slash] = true, _wordDelimiters);
      var hex = {};
      var hexChars = "0123456789abcdefABCDEF";
      for (var i2 = 0; i2 < hexChars.length; i2++) {
        hex[hexChars.charCodeAt(i2)] = true;
      }
      function consumeWord(css, start) {
        var next = start;
        var code;
        do {
          code = css.charCodeAt(next);
          if (wordDelimiters[code]) {
            return next - 1;
          } else if (code === t.backslash) {
            next = consumeEscape(css, next) + 1;
          } else {
            next++;
          }
        } while (next < css.length);
        return next - 1;
      }
      function consumeEscape(css, start) {
        var next = start;
        var code = css.charCodeAt(next + 1);
        if (unescapable[code])
          ;
        else if (hex[code]) {
          var hexDigits = 0;
          do {
            next++;
            hexDigits++;
            code = css.charCodeAt(next + 1);
          } while (hex[code] && hexDigits < 6);
          if (hexDigits < 6 && code === t.space) {
            next++;
          }
        } else {
          next++;
        }
        return next;
      }
      var FIELDS = {
        TYPE: 0,
        START_LINE: 1,
        START_COL: 2,
        END_LINE: 3,
        END_COL: 4,
        START_POS: 5,
        END_POS: 6
      };
      exports3.FIELDS = FIELDS;
      function tokenize2(input) {
        var tokens = [];
        var css = input.css.valueOf();
        var _css = css, length = _css.length;
        var offset2 = -1;
        var line2 = 1;
        var start = 0;
        var end = 0;
        var code, content2, endColumn, endLine, escaped2, escapePos, last, lines, next, nextLine, nextOffset, quote, tokenType;
        function unclosed(what, fix) {
          if (input.safe) {
            css += fix;
            next = css.length - 1;
          } else {
            throw input.error("Unclosed " + what, line2, start - offset2, start);
          }
        }
        while (start < length) {
          code = css.charCodeAt(start);
          if (code === t.newline) {
            offset2 = start;
            line2 += 1;
          }
          switch (code) {
            case t.space:
            case t.tab:
            case t.newline:
            case t.cr:
            case t.feed:
              next = start;
              do {
                next += 1;
                code = css.charCodeAt(next);
                if (code === t.newline) {
                  offset2 = next;
                  line2 += 1;
                }
              } while (code === t.space || code === t.newline || code === t.tab || code === t.cr || code === t.feed);
              tokenType = t.space;
              endLine = line2;
              endColumn = next - offset2 - 1;
              end = next;
              break;
            case t.plus:
            case t.greaterThan:
            case t.tilde:
            case t.pipe:
              next = start;
              do {
                next += 1;
                code = css.charCodeAt(next);
              } while (code === t.plus || code === t.greaterThan || code === t.tilde || code === t.pipe);
              tokenType = t.combinator;
              endLine = line2;
              endColumn = start - offset2;
              end = next;
              break;
            case t.asterisk:
            case t.ampersand:
            case t.bang:
            case t.comma:
            case t.equals:
            case t.dollar:
            case t.caret:
            case t.openSquare:
            case t.closeSquare:
            case t.colon:
            case t.semicolon:
            case t.openParenthesis:
            case t.closeParenthesis:
              next = start;
              tokenType = code;
              endLine = line2;
              endColumn = start - offset2;
              end = next + 1;
              break;
            case t.singleQuote:
            case t.doubleQuote:
              quote = code === t.singleQuote ? "'" : '"';
              next = start;
              do {
                escaped2 = false;
                next = css.indexOf(quote, next + 1);
                if (next === -1) {
                  unclosed("quote", quote);
                }
                escapePos = next;
                while (css.charCodeAt(escapePos - 1) === t.backslash) {
                  escapePos -= 1;
                  escaped2 = !escaped2;
                }
              } while (escaped2);
              tokenType = t.str;
              endLine = line2;
              endColumn = start - offset2;
              end = next + 1;
              break;
            default:
              if (code === t.slash && css.charCodeAt(start + 1) === t.asterisk) {
                next = css.indexOf("*/", start + 2) + 1;
                if (next === 0) {
                  unclosed("comment", "*/");
                }
                content2 = css.slice(start, next + 1);
                lines = content2.split("\n");
                last = lines.length - 1;
                if (last > 0) {
                  nextLine = line2 + last;
                  nextOffset = next - lines[last].length;
                } else {
                  nextLine = line2;
                  nextOffset = offset2;
                }
                tokenType = t.comment;
                line2 = nextLine;
                endLine = nextLine;
                endColumn = next - nextOffset;
              } else if (code === t.slash) {
                next = start;
                tokenType = code;
                endLine = line2;
                endColumn = start - offset2;
                end = next + 1;
              } else {
                next = consumeWord(css, start);
                tokenType = t.word;
                endLine = line2;
                endColumn = next - offset2;
              }
              end = next + 1;
              break;
          }
          tokens.push([
            tokenType,
            line2,
            start - offset2,
            endLine,
            endColumn,
            start,
            end
          ]);
          if (nextOffset) {
            offset2 = nextOffset;
            nextOffset = null;
          }
          start = end;
        }
        return tokens;
      }
    })(tokenize);
    (function(module3, exports3) {
      exports3.__esModule = true;
      exports3["default"] = void 0;
      var _root2 = _interopRequireDefault2(root$1.exports);
      var _selector2 = _interopRequireDefault2(selector$1.exports);
      var _className2 = _interopRequireDefault2(className$1.exports);
      var _comment2 = _interopRequireDefault2(comment$2.exports);
      var _id2 = _interopRequireDefault2(id$1.exports);
      var _tag2 = _interopRequireDefault2(tag$1.exports);
      var _string2 = _interopRequireDefault2(string$12.exports);
      var _pseudo2 = _interopRequireDefault2(pseudo$1.exports);
      var _attribute2 = _interopRequireWildcard(attribute$1);
      var _universal2 = _interopRequireDefault2(universal$1.exports);
      var _combinator2 = _interopRequireDefault2(combinator$2.exports);
      var _nesting2 = _interopRequireDefault2(nesting$1.exports);
      var _sortAscending = _interopRequireDefault2(sortAscending.exports);
      var _tokenize = _interopRequireWildcard(tokenize);
      var tokens = _interopRequireWildcard(tokenTypes);
      var types$12 = _interopRequireWildcard(types2);
      var _util = util2;
      var _WHITESPACE_TOKENS, _Object$assign;
      function _getRequireWildcardCache() {
        if (typeof WeakMap !== "function")
          return null;
        var cache2 = /* @__PURE__ */ new WeakMap();
        _getRequireWildcardCache = function _getRequireWildcardCache2() {
          return cache2;
        };
        return cache2;
      }
      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
          return { "default": obj };
        }
        var cache2 = _getRequireWildcardCache();
        if (cache2 && cache2.has(obj)) {
          return cache2.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key2 in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key2)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key2) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key2, desc);
            } else {
              newObj[key2] = obj[key2];
            }
          }
        }
        newObj["default"] = obj;
        if (cache2) {
          cache2.set(obj, newObj);
        }
        return newObj;
      }
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _defineProperties(target, props) {
        for (var i2 = 0; i2 < props.length; i2++) {
          var descriptor = props[i2];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      var WHITESPACE_TOKENS = (_WHITESPACE_TOKENS = {}, _WHITESPACE_TOKENS[tokens.space] = true, _WHITESPACE_TOKENS[tokens.cr] = true, _WHITESPACE_TOKENS[tokens.feed] = true, _WHITESPACE_TOKENS[tokens.newline] = true, _WHITESPACE_TOKENS[tokens.tab] = true, _WHITESPACE_TOKENS);
      var WHITESPACE_EQUIV_TOKENS = Object.assign({}, WHITESPACE_TOKENS, (_Object$assign = {}, _Object$assign[tokens.comment] = true, _Object$assign));
      function tokenStart(token2) {
        return {
          line: token2[_tokenize.FIELDS.START_LINE],
          column: token2[_tokenize.FIELDS.START_COL]
        };
      }
      function tokenEnd(token2) {
        return {
          line: token2[_tokenize.FIELDS.END_LINE],
          column: token2[_tokenize.FIELDS.END_COL]
        };
      }
      function getSource2(startLine, startColumn, endLine, endColumn) {
        return {
          start: {
            line: startLine,
            column: startColumn
          },
          end: {
            line: endLine,
            column: endColumn
          }
        };
      }
      function getTokenSource(token2) {
        return getSource2(token2[_tokenize.FIELDS.START_LINE], token2[_tokenize.FIELDS.START_COL], token2[_tokenize.FIELDS.END_LINE], token2[_tokenize.FIELDS.END_COL]);
      }
      function getTokenSourceSpan(startToken, endToken) {
        if (!startToken) {
          return void 0;
        }
        return getSource2(startToken[_tokenize.FIELDS.START_LINE], startToken[_tokenize.FIELDS.START_COL], endToken[_tokenize.FIELDS.END_LINE], endToken[_tokenize.FIELDS.END_COL]);
      }
      function unescapeProp(node3, prop) {
        var value = node3[prop];
        if (typeof value !== "string") {
          return;
        }
        if (value.indexOf("\\") !== -1) {
          (0, _util.ensureObject)(node3, "raws");
          node3[prop] = (0, _util.unesc)(value);
          if (node3.raws[prop] === void 0) {
            node3.raws[prop] = value;
          }
        }
        return node3;
      }
      function indexesOf(array2, item) {
        var i2 = -1;
        var indexes = [];
        while ((i2 = array2.indexOf(item, i2 + 1)) !== -1) {
          indexes.push(i2);
        }
        return indexes;
      }
      function uniqs() {
        var list2 = Array.prototype.concat.apply([], arguments);
        return list2.filter(function(item, i2) {
          return i2 === list2.indexOf(item);
        });
      }
      var Parser3 = function() {
        function Parser4(rule, options2) {
          if (options2 === void 0) {
            options2 = {};
          }
          this.rule = rule;
          this.options = Object.assign({
            lossy: false,
            safe: false
          }, options2);
          this.position = 0;
          this.css = typeof this.rule === "string" ? this.rule : this.rule.selector;
          this.tokens = (0, _tokenize["default"])({
            css: this.css,
            error: this._errorGenerator(),
            safe: this.options.safe
          });
          var rootSource = getTokenSourceSpan(this.tokens[0], this.tokens[this.tokens.length - 1]);
          this.root = new _root2["default"]({
            source: rootSource
          });
          this.root.errorGenerator = this._errorGenerator();
          var selector2 = new _selector2["default"]({
            source: {
              start: {
                line: 1,
                column: 1
              }
            }
          });
          this.root.append(selector2);
          this.current = selector2;
          this.loop();
        }
        var _proto = Parser4.prototype;
        _proto._errorGenerator = function _errorGenerator() {
          var _this = this;
          return function(message, errorOptions) {
            if (typeof _this.rule === "string") {
              return new Error(message);
            }
            return _this.rule.error(message, errorOptions);
          };
        };
        _proto.attribute = function attribute2() {
          var attr = [];
          var startingToken = this.currToken;
          this.position++;
          while (this.position < this.tokens.length && this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {
            attr.push(this.currToken);
            this.position++;
          }
          if (this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {
            return this.expected("closing square bracket", this.currToken[_tokenize.FIELDS.START_POS]);
          }
          var len = attr.length;
          var node3 = {
            source: getSource2(startingToken[1], startingToken[2], this.currToken[3], this.currToken[4]),
            sourceIndex: startingToken[_tokenize.FIELDS.START_POS]
          };
          if (len === 1 && !~[tokens.word].indexOf(attr[0][_tokenize.FIELDS.TYPE])) {
            return this.expected("attribute", attr[0][_tokenize.FIELDS.START_POS]);
          }
          var pos2 = 0;
          var spaceBefore = "";
          var commentBefore = "";
          var lastAdded = null;
          var spaceAfterMeaningfulToken = false;
          while (pos2 < len) {
            var token2 = attr[pos2];
            var content2 = this.content(token2);
            var next = attr[pos2 + 1];
            switch (token2[_tokenize.FIELDS.TYPE]) {
              case tokens.space:
                spaceAfterMeaningfulToken = true;
                if (this.options.lossy) {
                  break;
                }
                if (lastAdded) {
                  (0, _util.ensureObject)(node3, "spaces", lastAdded);
                  var prevContent = node3.spaces[lastAdded].after || "";
                  node3.spaces[lastAdded].after = prevContent + content2;
                  var existingComment = (0, _util.getProp)(node3, "raws", "spaces", lastAdded, "after") || null;
                  if (existingComment) {
                    node3.raws.spaces[lastAdded].after = existingComment + content2;
                  }
                } else {
                  spaceBefore = spaceBefore + content2;
                  commentBefore = commentBefore + content2;
                }
                break;
              case tokens.asterisk:
                if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                  node3.operator = content2;
                  lastAdded = "operator";
                } else if ((!node3.namespace || lastAdded === "namespace" && !spaceAfterMeaningfulToken) && next) {
                  if (spaceBefore) {
                    (0, _util.ensureObject)(node3, "spaces", "attribute");
                    node3.spaces.attribute.before = spaceBefore;
                    spaceBefore = "";
                  }
                  if (commentBefore) {
                    (0, _util.ensureObject)(node3, "raws", "spaces", "attribute");
                    node3.raws.spaces.attribute.before = spaceBefore;
                    commentBefore = "";
                  }
                  node3.namespace = (node3.namespace || "") + content2;
                  var rawValue = (0, _util.getProp)(node3, "raws", "namespace") || null;
                  if (rawValue) {
                    node3.raws.namespace += content2;
                  }
                  lastAdded = "namespace";
                }
                spaceAfterMeaningfulToken = false;
                break;
              case tokens.dollar:
                if (lastAdded === "value") {
                  var oldRawValue = (0, _util.getProp)(node3, "raws", "value");
                  node3.value += "$";
                  if (oldRawValue) {
                    node3.raws.value = oldRawValue + "$";
                  }
                  break;
                }
              case tokens.caret:
                if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                  node3.operator = content2;
                  lastAdded = "operator";
                }
                spaceAfterMeaningfulToken = false;
                break;
              case tokens.combinator:
                if (content2 === "~" && next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                  node3.operator = content2;
                  lastAdded = "operator";
                }
                if (content2 !== "|") {
                  spaceAfterMeaningfulToken = false;
                  break;
                }
                if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                  node3.operator = content2;
                  lastAdded = "operator";
                } else if (!node3.namespace && !node3.attribute) {
                  node3.namespace = true;
                }
                spaceAfterMeaningfulToken = false;
                break;
              case tokens.word:
                if (next && this.content(next) === "|" && attr[pos2 + 2] && attr[pos2 + 2][_tokenize.FIELDS.TYPE] !== tokens.equals && !node3.operator && !node3.namespace) {
                  node3.namespace = content2;
                  lastAdded = "namespace";
                } else if (!node3.attribute || lastAdded === "attribute" && !spaceAfterMeaningfulToken) {
                  if (spaceBefore) {
                    (0, _util.ensureObject)(node3, "spaces", "attribute");
                    node3.spaces.attribute.before = spaceBefore;
                    spaceBefore = "";
                  }
                  if (commentBefore) {
                    (0, _util.ensureObject)(node3, "raws", "spaces", "attribute");
                    node3.raws.spaces.attribute.before = commentBefore;
                    commentBefore = "";
                  }
                  node3.attribute = (node3.attribute || "") + content2;
                  var _rawValue = (0, _util.getProp)(node3, "raws", "attribute") || null;
                  if (_rawValue) {
                    node3.raws.attribute += content2;
                  }
                  lastAdded = "attribute";
                } else if (!node3.value && node3.value !== "" || lastAdded === "value" && !spaceAfterMeaningfulToken) {
                  var _unescaped = (0, _util.unesc)(content2);
                  var _oldRawValue = (0, _util.getProp)(node3, "raws", "value") || "";
                  var oldValue = node3.value || "";
                  node3.value = oldValue + _unescaped;
                  node3.quoteMark = null;
                  if (_unescaped !== content2 || _oldRawValue) {
                    (0, _util.ensureObject)(node3, "raws");
                    node3.raws.value = (_oldRawValue || oldValue) + content2;
                  }
                  lastAdded = "value";
                } else {
                  var insensitive = content2 === "i" || content2 === "I";
                  if ((node3.value || node3.value === "") && (node3.quoteMark || spaceAfterMeaningfulToken)) {
                    node3.insensitive = insensitive;
                    if (!insensitive || content2 === "I") {
                      (0, _util.ensureObject)(node3, "raws");
                      node3.raws.insensitiveFlag = content2;
                    }
                    lastAdded = "insensitive";
                    if (spaceBefore) {
                      (0, _util.ensureObject)(node3, "spaces", "insensitive");
                      node3.spaces.insensitive.before = spaceBefore;
                      spaceBefore = "";
                    }
                    if (commentBefore) {
                      (0, _util.ensureObject)(node3, "raws", "spaces", "insensitive");
                      node3.raws.spaces.insensitive.before = commentBefore;
                      commentBefore = "";
                    }
                  } else if (node3.value || node3.value === "") {
                    lastAdded = "value";
                    node3.value += content2;
                    if (node3.raws.value) {
                      node3.raws.value += content2;
                    }
                  }
                }
                spaceAfterMeaningfulToken = false;
                break;
              case tokens.str:
                if (!node3.attribute || !node3.operator) {
                  return this.error("Expected an attribute followed by an operator preceding the string.", {
                    index: token2[_tokenize.FIELDS.START_POS]
                  });
                }
                var _unescapeValue = (0, _attribute2.unescapeValue)(content2), unescaped = _unescapeValue.unescaped, quoteMark = _unescapeValue.quoteMark;
                node3.value = unescaped;
                node3.quoteMark = quoteMark;
                lastAdded = "value";
                (0, _util.ensureObject)(node3, "raws");
                node3.raws.value = content2;
                spaceAfterMeaningfulToken = false;
                break;
              case tokens.equals:
                if (!node3.attribute) {
                  return this.expected("attribute", token2[_tokenize.FIELDS.START_POS], content2);
                }
                if (node3.value) {
                  return this.error('Unexpected "=" found; an operator was already defined.', {
                    index: token2[_tokenize.FIELDS.START_POS]
                  });
                }
                node3.operator = node3.operator ? node3.operator + content2 : content2;
                lastAdded = "operator";
                spaceAfterMeaningfulToken = false;
                break;
              case tokens.comment:
                if (lastAdded) {
                  if (spaceAfterMeaningfulToken || next && next[_tokenize.FIELDS.TYPE] === tokens.space || lastAdded === "insensitive") {
                    var lastComment = (0, _util.getProp)(node3, "spaces", lastAdded, "after") || "";
                    var rawLastComment = (0, _util.getProp)(node3, "raws", "spaces", lastAdded, "after") || lastComment;
                    (0, _util.ensureObject)(node3, "raws", "spaces", lastAdded);
                    node3.raws.spaces[lastAdded].after = rawLastComment + content2;
                  } else {
                    var lastValue = node3[lastAdded] || "";
                    var rawLastValue = (0, _util.getProp)(node3, "raws", lastAdded) || lastValue;
                    (0, _util.ensureObject)(node3, "raws");
                    node3.raws[lastAdded] = rawLastValue + content2;
                  }
                } else {
                  commentBefore = commentBefore + content2;
                }
                break;
              default:
                return this.error('Unexpected "' + content2 + '" found.', {
                  index: token2[_tokenize.FIELDS.START_POS]
                });
            }
            pos2++;
          }
          unescapeProp(node3, "attribute");
          unescapeProp(node3, "namespace");
          this.newNode(new _attribute2["default"](node3));
          this.position++;
        };
        _proto.parseWhitespaceEquivalentTokens = function parseWhitespaceEquivalentTokens(stopPosition) {
          if (stopPosition < 0) {
            stopPosition = this.tokens.length;
          }
          var startPosition = this.position;
          var nodes = [];
          var space2 = "";
          var lastComment = void 0;
          do {
            if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {
              if (!this.options.lossy) {
                space2 += this.content();
              }
            } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.comment) {
              var spaces = {};
              if (space2) {
                spaces.before = space2;
                space2 = "";
              }
              lastComment = new _comment2["default"]({
                value: this.content(),
                source: getTokenSource(this.currToken),
                sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],
                spaces
              });
              nodes.push(lastComment);
            }
          } while (++this.position < stopPosition);
          if (space2) {
            if (lastComment) {
              lastComment.spaces.after = space2;
            } else if (!this.options.lossy) {
              var firstToken = this.tokens[startPosition];
              var lastToken = this.tokens[this.position - 1];
              nodes.push(new _string2["default"]({
                value: "",
                source: getSource2(firstToken[_tokenize.FIELDS.START_LINE], firstToken[_tokenize.FIELDS.START_COL], lastToken[_tokenize.FIELDS.END_LINE], lastToken[_tokenize.FIELDS.END_COL]),
                sourceIndex: firstToken[_tokenize.FIELDS.START_POS],
                spaces: {
                  before: space2,
                  after: ""
                }
              }));
            }
          }
          return nodes;
        };
        _proto.convertWhitespaceNodesToSpace = function convertWhitespaceNodesToSpace(nodes, requiredSpace) {
          var _this2 = this;
          if (requiredSpace === void 0) {
            requiredSpace = false;
          }
          var space2 = "";
          var rawSpace = "";
          nodes.forEach(function(n3) {
            var spaceBefore = _this2.lossySpace(n3.spaces.before, requiredSpace);
            var rawSpaceBefore = _this2.lossySpace(n3.rawSpaceBefore, requiredSpace);
            space2 += spaceBefore + _this2.lossySpace(n3.spaces.after, requiredSpace && spaceBefore.length === 0);
            rawSpace += spaceBefore + n3.value + _this2.lossySpace(n3.rawSpaceAfter, requiredSpace && rawSpaceBefore.length === 0);
          });
          if (rawSpace === space2) {
            rawSpace = void 0;
          }
          var result2 = {
            space: space2,
            rawSpace
          };
          return result2;
        };
        _proto.isNamedCombinator = function isNamedCombinator(position) {
          if (position === void 0) {
            position = this.position;
          }
          return this.tokens[position + 0] && this.tokens[position + 0][_tokenize.FIELDS.TYPE] === tokens.slash && this.tokens[position + 1] && this.tokens[position + 1][_tokenize.FIELDS.TYPE] === tokens.word && this.tokens[position + 2] && this.tokens[position + 2][_tokenize.FIELDS.TYPE] === tokens.slash;
        };
        _proto.namedCombinator = function namedCombinator() {
          if (this.isNamedCombinator()) {
            var nameRaw = this.content(this.tokens[this.position + 1]);
            var name = (0, _util.unesc)(nameRaw).toLowerCase();
            var raws = {};
            if (name !== nameRaw) {
              raws.value = "/" + nameRaw + "/";
            }
            var node3 = new _combinator2["default"]({
              value: "/" + name + "/",
              source: getSource2(this.currToken[_tokenize.FIELDS.START_LINE], this.currToken[_tokenize.FIELDS.START_COL], this.tokens[this.position + 2][_tokenize.FIELDS.END_LINE], this.tokens[this.position + 2][_tokenize.FIELDS.END_COL]),
              sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],
              raws
            });
            this.position = this.position + 3;
            return node3;
          } else {
            this.unexpected();
          }
        };
        _proto.combinator = function combinator2() {
          var _this3 = this;
          if (this.content() === "|") {
            return this.namespace();
          }
          var nextSigTokenPos = this.locateNextMeaningfulToken(this.position);
          if (nextSigTokenPos < 0 || this.tokens[nextSigTokenPos][_tokenize.FIELDS.TYPE] === tokens.comma) {
            var nodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);
            if (nodes.length > 0) {
              var last = this.current.last;
              if (last) {
                var _this$convertWhitespa = this.convertWhitespaceNodesToSpace(nodes), space2 = _this$convertWhitespa.space, rawSpace = _this$convertWhitespa.rawSpace;
                if (rawSpace !== void 0) {
                  last.rawSpaceAfter += rawSpace;
                }
                last.spaces.after += space2;
              } else {
                nodes.forEach(function(n3) {
                  return _this3.newNode(n3);
                });
              }
            }
            return;
          }
          var firstToken = this.currToken;
          var spaceOrDescendantSelectorNodes = void 0;
          if (nextSigTokenPos > this.position) {
            spaceOrDescendantSelectorNodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);
          }
          var node3;
          if (this.isNamedCombinator()) {
            node3 = this.namedCombinator();
          } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.combinator) {
            node3 = new _combinator2["default"]({
              value: this.content(),
              source: getTokenSource(this.currToken),
              sourceIndex: this.currToken[_tokenize.FIELDS.START_POS]
            });
            this.position++;
          } else if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]])
            ;
          else if (!spaceOrDescendantSelectorNodes) {
            this.unexpected();
          }
          if (node3) {
            if (spaceOrDescendantSelectorNodes) {
              var _this$convertWhitespa2 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes), _space = _this$convertWhitespa2.space, _rawSpace = _this$convertWhitespa2.rawSpace;
              node3.spaces.before = _space;
              node3.rawSpaceBefore = _rawSpace;
            }
          } else {
            var _this$convertWhitespa3 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes, true), _space2 = _this$convertWhitespa3.space, _rawSpace2 = _this$convertWhitespa3.rawSpace;
            if (!_rawSpace2) {
              _rawSpace2 = _space2;
            }
            var spaces = {};
            var raws = {
              spaces: {}
            };
            if (_space2.endsWith(" ") && _rawSpace2.endsWith(" ")) {
              spaces.before = _space2.slice(0, _space2.length - 1);
              raws.spaces.before = _rawSpace2.slice(0, _rawSpace2.length - 1);
            } else if (_space2.startsWith(" ") && _rawSpace2.startsWith(" ")) {
              spaces.after = _space2.slice(1);
              raws.spaces.after = _rawSpace2.slice(1);
            } else {
              raws.value = _rawSpace2;
            }
            node3 = new _combinator2["default"]({
              value: " ",
              source: getTokenSourceSpan(firstToken, this.tokens[this.position - 1]),
              sourceIndex: firstToken[_tokenize.FIELDS.START_POS],
              spaces,
              raws
            });
          }
          if (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.space) {
            node3.spaces.after = this.optionalSpace(this.content());
            this.position++;
          }
          return this.newNode(node3);
        };
        _proto.comma = function comma3() {
          if (this.position === this.tokens.length - 1) {
            this.root.trailingComma = true;
            this.position++;
            return;
          }
          this.current._inferEndPosition();
          var selector2 = new _selector2["default"]({
            source: {
              start: tokenStart(this.tokens[this.position + 1])
            }
          });
          this.current.parent.append(selector2);
          this.current = selector2;
          this.position++;
        };
        _proto.comment = function comment2() {
          var current = this.currToken;
          this.newNode(new _comment2["default"]({
            value: this.content(),
            source: getTokenSource(current),
            sourceIndex: current[_tokenize.FIELDS.START_POS]
          }));
          this.position++;
        };
        _proto.error = function error2(message, opts) {
          throw this.root.error(message, opts);
        };
        _proto.missingBackslash = function missingBackslash() {
          return this.error("Expected a backslash preceding the semicolon.", {
            index: this.currToken[_tokenize.FIELDS.START_POS]
          });
        };
        _proto.missingParenthesis = function missingParenthesis() {
          return this.expected("opening parenthesis", this.currToken[_tokenize.FIELDS.START_POS]);
        };
        _proto.missingSquareBracket = function missingSquareBracket() {
          return this.expected("opening square bracket", this.currToken[_tokenize.FIELDS.START_POS]);
        };
        _proto.unexpected = function unexpected() {
          return this.error("Unexpected '" + this.content() + "'. Escaping special characters with \\ may help.", this.currToken[_tokenize.FIELDS.START_POS]);
        };
        _proto.namespace = function namespace2() {
          var before = this.prevToken && this.content(this.prevToken) || true;
          if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.word) {
            this.position++;
            return this.word(before);
          } else if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.asterisk) {
            this.position++;
            return this.universal(before);
          }
        };
        _proto.nesting = function nesting2() {
          if (this.nextToken) {
            var nextContent = this.content(this.nextToken);
            if (nextContent === "|") {
              this.position++;
              return;
            }
          }
          var current = this.currToken;
          this.newNode(new _nesting2["default"]({
            value: this.content(),
            source: getTokenSource(current),
            sourceIndex: current[_tokenize.FIELDS.START_POS]
          }));
          this.position++;
        };
        _proto.parentheses = function parentheses() {
          var last = this.current.last;
          var unbalanced = 1;
          this.position++;
          if (last && last.type === types$12.PSEUDO) {
            var selector2 = new _selector2["default"]({
              source: {
                start: tokenStart(this.tokens[this.position - 1])
              }
            });
            var cache2 = this.current;
            last.append(selector2);
            this.current = selector2;
            while (this.position < this.tokens.length && unbalanced) {
              if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
                unbalanced++;
              }
              if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
                unbalanced--;
              }
              if (unbalanced) {
                this.parse();
              } else {
                this.current.source.end = tokenEnd(this.currToken);
                this.current.parent.source.end = tokenEnd(this.currToken);
                this.position++;
              }
            }
            this.current = cache2;
          } else {
            var parenStart = this.currToken;
            var parenValue = "(";
            var parenEnd;
            while (this.position < this.tokens.length && unbalanced) {
              if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
                unbalanced++;
              }
              if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
                unbalanced--;
              }
              parenEnd = this.currToken;
              parenValue += this.parseParenthesisToken(this.currToken);
              this.position++;
            }
            if (last) {
              last.appendToPropertyAndEscape("value", parenValue, parenValue);
            } else {
              this.newNode(new _string2["default"]({
                value: parenValue,
                source: getSource2(parenStart[_tokenize.FIELDS.START_LINE], parenStart[_tokenize.FIELDS.START_COL], parenEnd[_tokenize.FIELDS.END_LINE], parenEnd[_tokenize.FIELDS.END_COL]),
                sourceIndex: parenStart[_tokenize.FIELDS.START_POS]
              }));
            }
          }
          if (unbalanced) {
            return this.expected("closing parenthesis", this.currToken[_tokenize.FIELDS.START_POS]);
          }
        };
        _proto.pseudo = function pseudo2() {
          var _this4 = this;
          var pseudoStr = "";
          var startingToken = this.currToken;
          while (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.colon) {
            pseudoStr += this.content();
            this.position++;
          }
          if (!this.currToken) {
            return this.expected(["pseudo-class", "pseudo-element"], this.position - 1);
          }
          if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.word) {
            this.splitWord(false, function(first2, length) {
              pseudoStr += first2;
              _this4.newNode(new _pseudo2["default"]({
                value: pseudoStr,
                source: getTokenSourceSpan(startingToken, _this4.currToken),
                sourceIndex: startingToken[_tokenize.FIELDS.START_POS]
              }));
              if (length > 1 && _this4.nextToken && _this4.nextToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
                _this4.error("Misplaced parenthesis.", {
                  index: _this4.nextToken[_tokenize.FIELDS.START_POS]
                });
              }
            });
          } else {
            return this.expected(["pseudo-class", "pseudo-element"], this.currToken[_tokenize.FIELDS.START_POS]);
          }
        };
        _proto.space = function space2() {
          var content2 = this.content();
          if (this.position === 0 || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis || this.current.nodes.every(function(node3) {
            return node3.type === "comment";
          })) {
            this.spaces = this.optionalSpace(content2);
            this.position++;
          } else if (this.position === this.tokens.length - 1 || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
            this.current.last.spaces.after = this.optionalSpace(content2);
            this.position++;
          } else {
            this.combinator();
          }
        };
        _proto.string = function string3() {
          var current = this.currToken;
          this.newNode(new _string2["default"]({
            value: this.content(),
            source: getTokenSource(current),
            sourceIndex: current[_tokenize.FIELDS.START_POS]
          }));
          this.position++;
        };
        _proto.universal = function universal2(namespace2) {
          var nextToken = this.nextToken;
          if (nextToken && this.content(nextToken) === "|") {
            this.position++;
            return this.namespace();
          }
          var current = this.currToken;
          this.newNode(new _universal2["default"]({
            value: this.content(),
            source: getTokenSource(current),
            sourceIndex: current[_tokenize.FIELDS.START_POS]
          }), namespace2);
          this.position++;
        };
        _proto.splitWord = function splitWord(namespace2, firstCallback) {
          var _this5 = this;
          var nextToken = this.nextToken;
          var word2 = this.content();
          while (nextToken && ~[tokens.dollar, tokens.caret, tokens.equals, tokens.word].indexOf(nextToken[_tokenize.FIELDS.TYPE])) {
            this.position++;
            var current = this.content();
            word2 += current;
            if (current.lastIndexOf("\\") === current.length - 1) {
              var next = this.nextToken;
              if (next && next[_tokenize.FIELDS.TYPE] === tokens.space) {
                word2 += this.requiredSpace(this.content(next));
                this.position++;
              }
            }
            nextToken = this.nextToken;
          }
          var hasClass = indexesOf(word2, ".").filter(function(i2) {
            var escapedDot = word2[i2 - 1] === "\\";
            var isKeyframesPercent = /^\d+\.\d+%$/.test(word2);
            return !escapedDot && !isKeyframesPercent;
          });
          var hasId = indexesOf(word2, "#").filter(function(i2) {
            return word2[i2 - 1] !== "\\";
          });
          var interpolations = indexesOf(word2, "#{");
          if (interpolations.length) {
            hasId = hasId.filter(function(hashIndex) {
              return !~interpolations.indexOf(hashIndex);
            });
          }
          var indices = (0, _sortAscending["default"])(uniqs([0].concat(hasClass, hasId)));
          indices.forEach(function(ind, i2) {
            var index3 = indices[i2 + 1] || word2.length;
            var value = word2.slice(ind, index3);
            if (i2 === 0 && firstCallback) {
              return firstCallback.call(_this5, value, indices.length);
            }
            var node3;
            var current2 = _this5.currToken;
            var sourceIndex = current2[_tokenize.FIELDS.START_POS] + indices[i2];
            var source2 = getSource2(current2[1], current2[2] + ind, current2[3], current2[2] + (index3 - 1));
            if (~hasClass.indexOf(ind)) {
              var classNameOpts = {
                value: value.slice(1),
                source: source2,
                sourceIndex
              };
              node3 = new _className2["default"](unescapeProp(classNameOpts, "value"));
            } else if (~hasId.indexOf(ind)) {
              var idOpts = {
                value: value.slice(1),
                source: source2,
                sourceIndex
              };
              node3 = new _id2["default"](unescapeProp(idOpts, "value"));
            } else {
              var tagOpts = {
                value,
                source: source2,
                sourceIndex
              };
              unescapeProp(tagOpts, "value");
              node3 = new _tag2["default"](tagOpts);
            }
            _this5.newNode(node3, namespace2);
            namespace2 = null;
          });
          this.position++;
        };
        _proto.word = function word2(namespace2) {
          var nextToken = this.nextToken;
          if (nextToken && this.content(nextToken) === "|") {
            this.position++;
            return this.namespace();
          }
          return this.splitWord(namespace2);
        };
        _proto.loop = function loop2() {
          while (this.position < this.tokens.length) {
            this.parse(true);
          }
          this.current._inferEndPosition();
          return this.root;
        };
        _proto.parse = function parse2(throwOnParenthesis) {
          switch (this.currToken[_tokenize.FIELDS.TYPE]) {
            case tokens.space:
              this.space();
              break;
            case tokens.comment:
              this.comment();
              break;
            case tokens.openParenthesis:
              this.parentheses();
              break;
            case tokens.closeParenthesis:
              if (throwOnParenthesis) {
                this.missingParenthesis();
              }
              break;
            case tokens.openSquare:
              this.attribute();
              break;
            case tokens.dollar:
            case tokens.caret:
            case tokens.equals:
            case tokens.word:
              this.word();
              break;
            case tokens.colon:
              this.pseudo();
              break;
            case tokens.comma:
              this.comma();
              break;
            case tokens.asterisk:
              this.universal();
              break;
            case tokens.ampersand:
              this.nesting();
              break;
            case tokens.slash:
            case tokens.combinator:
              this.combinator();
              break;
            case tokens.str:
              this.string();
              break;
            case tokens.closeSquare:
              this.missingSquareBracket();
            case tokens.semicolon:
              this.missingBackslash();
            default:
              this.unexpected();
          }
        };
        _proto.expected = function expected(description, index3, found) {
          if (Array.isArray(description)) {
            var last = description.pop();
            description = description.join(", ") + " or " + last;
          }
          var an2 = /^[aeiou]/.test(description[0]) ? "an" : "a";
          if (!found) {
            return this.error("Expected " + an2 + " " + description + ".", {
              index: index3
            });
          }
          return this.error("Expected " + an2 + " " + description + ', found "' + found + '" instead.', {
            index: index3
          });
        };
        _proto.requiredSpace = function requiredSpace(space2) {
          return this.options.lossy ? " " : space2;
        };
        _proto.optionalSpace = function optionalSpace(space2) {
          return this.options.lossy ? "" : space2;
        };
        _proto.lossySpace = function lossySpace(space2, required) {
          if (this.options.lossy) {
            return required ? " " : "";
          } else {
            return space2;
          }
        };
        _proto.parseParenthesisToken = function parseParenthesisToken(token2) {
          var content2 = this.content(token2);
          if (token2[_tokenize.FIELDS.TYPE] === tokens.space) {
            return this.requiredSpace(content2);
          } else {
            return content2;
          }
        };
        _proto.newNode = function newNode(node3, namespace2) {
          if (namespace2) {
            if (/^ +$/.test(namespace2)) {
              if (!this.options.lossy) {
                this.spaces = (this.spaces || "") + namespace2;
              }
              namespace2 = true;
            }
            node3.namespace = namespace2;
            unescapeProp(node3, "namespace");
          }
          if (this.spaces) {
            node3.spaces.before = this.spaces;
            this.spaces = "";
          }
          return this.current.append(node3);
        };
        _proto.content = function content2(token2) {
          if (token2 === void 0) {
            token2 = this.currToken;
          }
          return this.css.slice(token2[_tokenize.FIELDS.START_POS], token2[_tokenize.FIELDS.END_POS]);
        };
        _proto.locateNextMeaningfulToken = function locateNextMeaningfulToken(startPosition) {
          if (startPosition === void 0) {
            startPosition = this.position + 1;
          }
          var searchPosition = startPosition;
          while (searchPosition < this.tokens.length) {
            if (WHITESPACE_EQUIV_TOKENS[this.tokens[searchPosition][_tokenize.FIELDS.TYPE]]) {
              searchPosition++;
              continue;
            } else {
              return searchPosition;
            }
          }
          return -1;
        };
        _createClass(Parser4, [{
          key: "currToken",
          get: function get() {
            return this.tokens[this.position];
          }
        }, {
          key: "nextToken",
          get: function get() {
            return this.tokens[this.position + 1];
          }
        }, {
          key: "prevToken",
          get: function get() {
            return this.tokens[this.position - 1];
          }
        }]);
        return Parser4;
      }();
      exports3["default"] = Parser3;
      module3.exports = exports3.default;
    })(parser2, parser2.exports);
    (function(module3, exports3) {
      exports3.__esModule = true;
      exports3["default"] = void 0;
      var _parser3 = _interopRequireDefault2(parser2.exports);
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var Processor = function() {
        function Processor2(func, options2) {
          this.func = func || function noop2() {
          };
          this.funcRes = null;
          this.options = options2;
        }
        var _proto = Processor2.prototype;
        _proto._shouldUpdateSelector = function _shouldUpdateSelector(rule, options2) {
          if (options2 === void 0) {
            options2 = {};
          }
          var merged = Object.assign({}, this.options, options2);
          if (merged.updateSelector === false) {
            return false;
          } else {
            return typeof rule !== "string";
          }
        };
        _proto._isLossy = function _isLossy(options2) {
          if (options2 === void 0) {
            options2 = {};
          }
          var merged = Object.assign({}, this.options, options2);
          if (merged.lossless === false) {
            return true;
          } else {
            return false;
          }
        };
        _proto._root = function _root2(rule, options2) {
          if (options2 === void 0) {
            options2 = {};
          }
          var parser3 = new _parser3["default"](rule, this._parseOptions(options2));
          return parser3.root;
        };
        _proto._parseOptions = function _parseOptions(options2) {
          return {
            lossy: this._isLossy(options2)
          };
        };
        _proto._run = function _run(rule, options2) {
          var _this = this;
          if (options2 === void 0) {
            options2 = {};
          }
          return new Promise(function(resolve2, reject) {
            try {
              var root3 = _this._root(rule, options2);
              Promise.resolve(_this.func(root3)).then(function(transform2) {
                var string3 = void 0;
                if (_this._shouldUpdateSelector(rule, options2)) {
                  string3 = root3.toString();
                  rule.selector = string3;
                }
                return {
                  transform: transform2,
                  root: root3,
                  string: string3
                };
              }).then(resolve2, reject);
            } catch (e2) {
              reject(e2);
              return;
            }
          });
        };
        _proto._runSync = function _runSync(rule, options2) {
          if (options2 === void 0) {
            options2 = {};
          }
          var root3 = this._root(rule, options2);
          var transform2 = this.func(root3);
          if (transform2 && typeof transform2.then === "function") {
            throw new Error("Selector processor returned a promise to a synchronous call.");
          }
          var string3 = void 0;
          if (options2.updateSelector && typeof rule !== "string") {
            string3 = root3.toString();
            rule.selector = string3;
          }
          return {
            transform: transform2,
            root: root3,
            string: string3
          };
        };
        _proto.ast = function ast(rule, options2) {
          return this._run(rule, options2).then(function(result2) {
            return result2.root;
          });
        };
        _proto.astSync = function astSync(rule, options2) {
          return this._runSync(rule, options2).root;
        };
        _proto.transform = function transform2(rule, options2) {
          return this._run(rule, options2).then(function(result2) {
            return result2.transform;
          });
        };
        _proto.transformSync = function transformSync(rule, options2) {
          return this._runSync(rule, options2).transform;
        };
        _proto.process = function process2(rule, options2) {
          return this._run(rule, options2).then(function(result2) {
            return result2.string || result2.root.toString();
          });
        };
        _proto.processSync = function processSync(rule, options2) {
          var result2 = this._runSync(rule, options2);
          return result2.string || result2.root.toString();
        };
        return Processor2;
      }();
      exports3["default"] = Processor;
      module3.exports = exports3.default;
    })(processor, processor.exports);
    var selectors = {};
    var constructors = {};
    constructors.__esModule = true;
    constructors.universal = constructors.tag = constructors.string = constructors.selector = constructors.root = constructors.pseudo = constructors.nesting = constructors.id = constructors.comment = constructors.combinator = constructors.className = constructors.attribute = void 0;
    var _attribute = _interopRequireDefault$2(attribute$1);
    var _className = _interopRequireDefault$2(className$1.exports);
    var _combinator = _interopRequireDefault$2(combinator$2.exports);
    var _comment = _interopRequireDefault$2(comment$2.exports);
    var _id = _interopRequireDefault$2(id$1.exports);
    var _nesting = _interopRequireDefault$2(nesting$1.exports);
    var _pseudo = _interopRequireDefault$2(pseudo$1.exports);
    var _root = _interopRequireDefault$2(root$1.exports);
    var _selector = _interopRequireDefault$2(selector$1.exports);
    var _string = _interopRequireDefault$2(string$12.exports);
    var _tag = _interopRequireDefault$2(tag$1.exports);
    var _universal = _interopRequireDefault$2(universal$1.exports);
    function _interopRequireDefault$2(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var attribute = function attribute2(opts) {
      return new _attribute["default"](opts);
    };
    constructors.attribute = attribute;
    var className = function className2(opts) {
      return new _className["default"](opts);
    };
    constructors.className = className;
    var combinator = function combinator2(opts) {
      return new _combinator["default"](opts);
    };
    constructors.combinator = combinator;
    var comment = function comment2(opts) {
      return new _comment["default"](opts);
    };
    constructors.comment = comment;
    var id = function id2(opts) {
      return new _id["default"](opts);
    };
    constructors.id = id;
    var nesting = function nesting2(opts) {
      return new _nesting["default"](opts);
    };
    constructors.nesting = nesting;
    var pseudo = function pseudo2(opts) {
      return new _pseudo["default"](opts);
    };
    constructors.pseudo = pseudo;
    var root2 = function root3(opts) {
      return new _root["default"](opts);
    };
    constructors.root = root2;
    var selector = function selector2(opts) {
      return new _selector["default"](opts);
    };
    constructors.selector = selector;
    var string2 = function string3(opts) {
      return new _string["default"](opts);
    };
    constructors.string = string2;
    var tag = function tag2(opts) {
      return new _tag["default"](opts);
    };
    constructors.tag = tag;
    var universal = function universal2(opts) {
      return new _universal["default"](opts);
    };
    constructors.universal = universal;
    var guards = {};
    guards.__esModule = true;
    guards.isNode = isNode;
    guards.isPseudoElement = isPseudoElement;
    guards.isPseudoClass = isPseudoClass;
    guards.isContainer = isContainer;
    guards.isNamespace = isNamespace;
    guards.isUniversal = guards.isTag = guards.isString = guards.isSelector = guards.isRoot = guards.isPseudo = guards.isNesting = guards.isIdentifier = guards.isComment = guards.isCombinator = guards.isClassName = guards.isAttribute = void 0;
    var _types = types2;
    var _IS_TYPE;
    var IS_TYPE = (_IS_TYPE = {}, _IS_TYPE[_types.ATTRIBUTE] = true, _IS_TYPE[_types.CLASS] = true, _IS_TYPE[_types.COMBINATOR] = true, _IS_TYPE[_types.COMMENT] = true, _IS_TYPE[_types.ID] = true, _IS_TYPE[_types.NESTING] = true, _IS_TYPE[_types.PSEUDO] = true, _IS_TYPE[_types.ROOT] = true, _IS_TYPE[_types.SELECTOR] = true, _IS_TYPE[_types.STRING] = true, _IS_TYPE[_types.TAG] = true, _IS_TYPE[_types.UNIVERSAL] = true, _IS_TYPE);
    function isNode(node3) {
      return typeof node3 === "object" && IS_TYPE[node3.type];
    }
    function isNodeType(type, node3) {
      return isNode(node3) && node3.type === type;
    }
    var isAttribute = isNodeType.bind(null, _types.ATTRIBUTE);
    guards.isAttribute = isAttribute;
    var isClassName = isNodeType.bind(null, _types.CLASS);
    guards.isClassName = isClassName;
    var isCombinator = isNodeType.bind(null, _types.COMBINATOR);
    guards.isCombinator = isCombinator;
    var isComment = isNodeType.bind(null, _types.COMMENT);
    guards.isComment = isComment;
    var isIdentifier = isNodeType.bind(null, _types.ID);
    guards.isIdentifier = isIdentifier;
    var isNesting = isNodeType.bind(null, _types.NESTING);
    guards.isNesting = isNesting;
    var isPseudo = isNodeType.bind(null, _types.PSEUDO);
    guards.isPseudo = isPseudo;
    var isRoot = isNodeType.bind(null, _types.ROOT);
    guards.isRoot = isRoot;
    var isSelector = isNodeType.bind(null, _types.SELECTOR);
    guards.isSelector = isSelector;
    var isString2 = isNodeType.bind(null, _types.STRING);
    guards.isString = isString2;
    var isTag = isNodeType.bind(null, _types.TAG);
    guards.isTag = isTag;
    var isUniversal = isNodeType.bind(null, _types.UNIVERSAL);
    guards.isUniversal = isUniversal;
    function isPseudoElement(node3) {
      return isPseudo(node3) && node3.value && (node3.value.startsWith("::") || node3.value.toLowerCase() === ":before" || node3.value.toLowerCase() === ":after");
    }
    function isPseudoClass(node3) {
      return isPseudo(node3) && !isPseudoElement(node3);
    }
    function isContainer(node3) {
      return !!(isNode(node3) && node3.walk);
    }
    function isNamespace(node3) {
      return isAttribute(node3) || isTag(node3);
    }
    (function(exports3) {
      exports3.__esModule = true;
      var _types2 = types2;
      Object.keys(_types2).forEach(function(key2) {
        if (key2 === "default" || key2 === "__esModule")
          return;
        if (key2 in exports3 && exports3[key2] === _types2[key2])
          return;
        exports3[key2] = _types2[key2];
      });
      var _constructors = constructors;
      Object.keys(_constructors).forEach(function(key2) {
        if (key2 === "default" || key2 === "__esModule")
          return;
        if (key2 in exports3 && exports3[key2] === _constructors[key2])
          return;
        exports3[key2] = _constructors[key2];
      });
      var _guards = guards;
      Object.keys(_guards).forEach(function(key2) {
        if (key2 === "default" || key2 === "__esModule")
          return;
        if (key2 in exports3 && exports3[key2] === _guards[key2])
          return;
        exports3[key2] = _guards[key2];
      });
    })(selectors);
    (function(module3, exports3) {
      exports3.__esModule = true;
      exports3["default"] = void 0;
      var _processor = _interopRequireDefault2(processor.exports);
      var selectors$1 = _interopRequireWildcard(selectors);
      function _getRequireWildcardCache() {
        if (typeof WeakMap !== "function")
          return null;
        var cache2 = /* @__PURE__ */ new WeakMap();
        _getRequireWildcardCache = function _getRequireWildcardCache2() {
          return cache2;
        };
        return cache2;
      }
      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
          return { "default": obj };
        }
        var cache2 = _getRequireWildcardCache();
        if (cache2 && cache2.has(obj)) {
          return cache2.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key2 in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key2)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key2) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key2, desc);
            } else {
              newObj[key2] = obj[key2];
            }
          }
        }
        newObj["default"] = obj;
        if (cache2) {
          cache2.set(obj, newObj);
        }
        return newObj;
      }
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var parser3 = function parser4(processor2) {
        return new _processor["default"](processor2);
      };
      Object.assign(parser3, selectors$1);
      delete parser3.__esModule;
      var _default = parser3;
      exports3["default"] = _default;
      module3.exports = exports3.default;
    })(dist2, dist2.exports);
    var matchValueName = /[$]?[\w-]+/g;
    var replaceValueSymbols$2 = (value, replacements) => {
      let matches2;
      while (matches2 = matchValueName.exec(value)) {
        const replacement2 = replacements[matches2[0]];
        if (replacement2) {
          value = value.slice(0, matches2.index) + replacement2 + value.slice(matchValueName.lastIndex);
          matchValueName.lastIndex -= matches2[0].length - replacement2.length;
        }
      }
      return value;
    };
    var replaceValueSymbols_1 = replaceValueSymbols$2;
    var replaceValueSymbols$1 = replaceValueSymbols_1;
    var replaceSymbols$1 = (css, replacements) => {
      css.walk((node3) => {
        if (node3.type === "decl" && node3.value) {
          node3.value = replaceValueSymbols$1(node3.value.toString(), replacements);
        } else if (node3.type === "rule" && node3.selector) {
          node3.selector = replaceValueSymbols$1(node3.selector.toString(), replacements);
        } else if (node3.type === "atrule" && node3.params) {
          node3.params = replaceValueSymbols$1(node3.params.toString(), replacements);
        }
      });
    };
    var replaceSymbols_1 = replaceSymbols$1;
    var importPattern = /^:import\(("[^"]*"|'[^']*'|[^"']+)\)$/;
    var balancedQuotes = /^("[^"]*"|'[^']*'|[^"']+)$/;
    var getDeclsObject = (rule) => {
      const object2 = {};
      rule.walkDecls((decl) => {
        const before = decl.raws.before ? decl.raws.before.trim() : "";
        object2[before + decl.prop] = decl.value;
      });
      return object2;
    };
    var extractICSS$2 = (css, removeRules = true, mode2 = "auto") => {
      const icssImports = {};
      const icssExports = {};
      function addImports(node3, path3) {
        const unquoted = path3.replace(/'|"/g, "");
        icssImports[unquoted] = Object.assign(icssImports[unquoted] || {}, getDeclsObject(node3));
        if (removeRules) {
          node3.remove();
        }
      }
      function addExports(node3) {
        Object.assign(icssExports, getDeclsObject(node3));
        if (removeRules) {
          node3.remove();
        }
      }
      css.each((node3) => {
        if (node3.type === "rule" && mode2 !== "at-rule") {
          if (node3.selector.slice(0, 7) === ":import") {
            const matches2 = importPattern.exec(node3.selector);
            if (matches2) {
              addImports(node3, matches2[1]);
            }
          }
          if (node3.selector === ":export") {
            addExports(node3);
          }
        }
        if (node3.type === "atrule" && mode2 !== "rule") {
          if (node3.name === "icss-import") {
            const matches2 = balancedQuotes.exec(node3.params);
            if (matches2) {
              addImports(node3, matches2[1]);
            }
          }
          if (node3.name === "icss-export") {
            addExports(node3);
          }
        }
      });
      return { icssImports, icssExports };
    };
    var extractICSS_1 = extractICSS$2;
    var createImports = (imports, postcss3, mode2 = "rule") => {
      return Object.keys(imports).map((path3) => {
        const aliases = imports[path3];
        const declarations = Object.keys(aliases).map((key2) => postcss3.decl({
          prop: key2,
          value: aliases[key2],
          raws: { before: "\n  " }
        }));
        const hasDeclarations = declarations.length > 0;
        const rule = mode2 === "rule" ? postcss3.rule({
          selector: `:import('${path3}')`,
          raws: { after: hasDeclarations ? "\n" : "" }
        }) : postcss3.atRule({
          name: "icss-import",
          params: `'${path3}'`,
          raws: { after: hasDeclarations ? "\n" : "" }
        });
        if (hasDeclarations) {
          rule.append(declarations);
        }
        return rule;
      });
    };
    var createExports = (exports3, postcss3, mode2 = "rule") => {
      const declarations = Object.keys(exports3).map((key2) => postcss3.decl({
        prop: key2,
        value: exports3[key2],
        raws: { before: "\n  " }
      }));
      if (declarations.length === 0) {
        return [];
      }
      const rule = mode2 === "rule" ? postcss3.rule({
        selector: `:export`,
        raws: { after: "\n" }
      }) : postcss3.atRule({
        name: "icss-export",
        raws: { after: "\n" }
      });
      rule.append(declarations);
      return [rule];
    };
    var createICSSRules$1 = (imports, exports3, postcss3, mode2) => [
      ...createImports(imports, postcss3, mode2),
      ...createExports(exports3, postcss3, mode2)
    ];
    var createICSSRules_1 = createICSSRules$1;
    var replaceValueSymbols = replaceValueSymbols_1;
    var replaceSymbols = replaceSymbols_1;
    var extractICSS$1 = extractICSS_1;
    var createICSSRules = createICSSRules_1;
    var src$3 = {
      replaceValueSymbols,
      replaceSymbols,
      extractICSS: extractICSS$1,
      createICSSRules
    };
    var selectorParser$1 = dist2.exports;
    var valueParser2 = index$2.lib;
    var { extractICSS } = src$3;
    var isSpacing = (node3) => node3.type === "combinator" && node3.value === " ";
    function normalizeNodeArray(nodes) {
      const array2 = [];
      nodes.forEach((x2) => {
        if (Array.isArray(x2)) {
          normalizeNodeArray(x2).forEach((item) => {
            array2.push(item);
          });
        } else if (x2) {
          array2.push(x2);
        }
      });
      if (array2.length > 0 && isSpacing(array2[array2.length - 1])) {
        array2.pop();
      }
      return array2;
    }
    function localizeNode(rule, mode2, localAliasMap) {
      const transform2 = (node3, context2) => {
        if (context2.ignoreNextSpacing && !isSpacing(node3)) {
          throw new Error("Missing whitespace after " + context2.ignoreNextSpacing);
        }
        if (context2.enforceNoSpacing && isSpacing(node3)) {
          throw new Error("Missing whitespace before " + context2.enforceNoSpacing);
        }
        let newNodes;
        switch (node3.type) {
          case "root": {
            let resultingGlobal;
            context2.hasPureGlobals = false;
            newNodes = node3.nodes.map((n3) => {
              const nContext = {
                global: context2.global,
                lastWasSpacing: true,
                hasLocals: false,
                explicit: false
              };
              n3 = transform2(n3, nContext);
              if (typeof resultingGlobal === "undefined") {
                resultingGlobal = nContext.global;
              } else if (resultingGlobal !== nContext.global) {
                throw new Error('Inconsistent rule global/local result in rule "' + node3 + '" (multiple selectors must result in the same mode for the rule)');
              }
              if (!nContext.hasLocals) {
                context2.hasPureGlobals = true;
              }
              return n3;
            });
            context2.global = resultingGlobal;
            node3.nodes = normalizeNodeArray(newNodes);
            break;
          }
          case "selector": {
            newNodes = node3.map((childNode) => transform2(childNode, context2));
            node3 = node3.clone();
            node3.nodes = normalizeNodeArray(newNodes);
            break;
          }
          case "combinator": {
            if (isSpacing(node3)) {
              if (context2.ignoreNextSpacing) {
                context2.ignoreNextSpacing = false;
                context2.lastWasSpacing = false;
                context2.enforceNoSpacing = false;
                return null;
              }
              context2.lastWasSpacing = true;
              return node3;
            }
            break;
          }
          case "pseudo": {
            let childContext;
            const isNested = !!node3.length;
            const isScoped = node3.value === ":local" || node3.value === ":global";
            const isImportExport = node3.value === ":import" || node3.value === ":export";
            if (isImportExport) {
              context2.hasLocals = true;
            } else if (isNested) {
              if (isScoped) {
                if (node3.nodes.length === 0) {
                  throw new Error(`${node3.value}() can't be empty`);
                }
                if (context2.inside) {
                  throw new Error(`A ${node3.value} is not allowed inside of a ${context2.inside}(...)`);
                }
                childContext = {
                  global: node3.value === ":global",
                  inside: node3.value,
                  hasLocals: false,
                  explicit: true
                };
                newNodes = node3.map((childNode) => transform2(childNode, childContext)).reduce((acc, next) => acc.concat(next.nodes), []);
                if (newNodes.length) {
                  const { before, after } = node3.spaces;
                  const first2 = newNodes[0];
                  const last = newNodes[newNodes.length - 1];
                  first2.spaces = { before, after: first2.spaces.after };
                  last.spaces = { before: last.spaces.before, after };
                }
                node3 = newNodes;
                break;
              } else {
                childContext = {
                  global: context2.global,
                  inside: context2.inside,
                  lastWasSpacing: true,
                  hasLocals: false,
                  explicit: context2.explicit
                };
                newNodes = node3.map((childNode) => transform2(childNode, childContext));
                node3 = node3.clone();
                node3.nodes = normalizeNodeArray(newNodes);
                if (childContext.hasLocals) {
                  context2.hasLocals = true;
                }
              }
              break;
            } else if (isScoped) {
              if (context2.inside) {
                throw new Error(`A ${node3.value} is not allowed inside of a ${context2.inside}(...)`);
              }
              const addBackSpacing = !!node3.spaces.before;
              context2.ignoreNextSpacing = context2.lastWasSpacing ? node3.value : false;
              context2.enforceNoSpacing = context2.lastWasSpacing ? false : node3.value;
              context2.global = node3.value === ":global";
              context2.explicit = true;
              return addBackSpacing ? selectorParser$1.combinator({ value: " " }) : null;
            }
            break;
          }
          case "id":
          case "class": {
            if (!node3.value) {
              throw new Error("Invalid class or id selector syntax");
            }
            if (context2.global) {
              break;
            }
            const isImportedValue = localAliasMap.has(node3.value);
            const isImportedWithExplicitScope = isImportedValue && context2.explicit;
            if (!isImportedValue || isImportedWithExplicitScope) {
              const innerNode = node3.clone();
              innerNode.spaces = { before: "", after: "" };
              node3 = selectorParser$1.pseudo({
                value: ":local",
                nodes: [innerNode],
                spaces: node3.spaces
              });
              context2.hasLocals = true;
            }
            break;
          }
        }
        context2.lastWasSpacing = false;
        context2.ignoreNextSpacing = false;
        context2.enforceNoSpacing = false;
        return node3;
      };
      const rootContext = {
        global: mode2 === "global",
        hasPureGlobals: false
      };
      rootContext.selector = selectorParser$1((root3) => {
        transform2(root3, rootContext);
      }).processSync(rule, { updateSelector: false, lossless: true });
      return rootContext;
    }
    function localizeDeclNode(node3, context2) {
      switch (node3.type) {
        case "word":
          if (context2.localizeNextItem) {
            if (!context2.localAliasMap.has(node3.value)) {
              node3.value = ":local(" + node3.value + ")";
              context2.localizeNextItem = false;
            }
          }
          break;
        case "function":
          if (context2.options && context2.options.rewriteUrl && node3.value.toLowerCase() === "url") {
            node3.nodes.map((nestedNode) => {
              if (nestedNode.type !== "string" && nestedNode.type !== "word") {
                return;
              }
              let newUrl = context2.options.rewriteUrl(context2.global, nestedNode.value);
              switch (nestedNode.type) {
                case "string":
                  if (nestedNode.quote === "'") {
                    newUrl = newUrl.replace(/(\\)/g, "\\$1").replace(/'/g, "\\'");
                  }
                  if (nestedNode.quote === '"') {
                    newUrl = newUrl.replace(/(\\)/g, "\\$1").replace(/"/g, '\\"');
                  }
                  break;
                case "word":
                  newUrl = newUrl.replace(/("|'|\)|\\)/g, "\\$1");
                  break;
              }
              nestedNode.value = newUrl;
            });
          }
          break;
      }
      return node3;
    }
    function isWordAFunctionArgument(wordNode, functionNode) {
      return functionNode ? functionNode.nodes.some((functionNodeChild) => functionNodeChild.sourceIndex === wordNode.sourceIndex) : false;
    }
    function localizeDeclarationValues(localize, declaration, context2) {
      const valueNodes = valueParser2(declaration.value);
      valueNodes.walk((node3, index3, nodes) => {
        const subContext = {
          options: context2.options,
          global: context2.global,
          localizeNextItem: localize && !context2.global,
          localAliasMap: context2.localAliasMap
        };
        nodes[index3] = localizeDeclNode(node3, subContext);
      });
      declaration.value = valueNodes.toString();
    }
    function localizeDeclaration(declaration, context2) {
      const isAnimation = /animation$/i.test(declaration.prop);
      if (isAnimation) {
        const validIdent = /^-?[_a-z][_a-z0-9-]*$/i;
        const animationKeywords = {
          $alternate: 1,
          "$alternate-reverse": 1,
          $backwards: 1,
          $both: 1,
          $ease: 1,
          "$ease-in": 1,
          "$ease-in-out": 1,
          "$ease-out": 1,
          $forwards: 1,
          $infinite: 1,
          $linear: 1,
          $none: Infinity,
          $normal: 1,
          $paused: 1,
          $reverse: 1,
          $running: 1,
          "$step-end": 1,
          "$step-start": 1,
          $initial: Infinity,
          $inherit: Infinity,
          $unset: Infinity
        };
        let parsedAnimationKeywords = {};
        let stepsFunctionNode = null;
        const valueNodes = valueParser2(declaration.value).walk((node3) => {
          if (node3.type === "div") {
            parsedAnimationKeywords = {};
          }
          if (node3.type === "function" && node3.value.toLowerCase() === "steps") {
            stepsFunctionNode = node3;
          }
          const value = node3.type === "word" && !isWordAFunctionArgument(node3, stepsFunctionNode) ? node3.value.toLowerCase() : null;
          let shouldParseAnimationName = false;
          if (value && validIdent.test(value)) {
            if ("$" + value in animationKeywords) {
              parsedAnimationKeywords["$" + value] = "$" + value in parsedAnimationKeywords ? parsedAnimationKeywords["$" + value] + 1 : 0;
              shouldParseAnimationName = parsedAnimationKeywords["$" + value] >= animationKeywords["$" + value];
            } else {
              shouldParseAnimationName = true;
            }
          }
          const subContext = {
            options: context2.options,
            global: context2.global,
            localizeNextItem: shouldParseAnimationName && !context2.global,
            localAliasMap: context2.localAliasMap
          };
          return localizeDeclNode(node3, subContext);
        });
        declaration.value = valueNodes.toString();
        return;
      }
      const isAnimationName = /animation(-name)?$/i.test(declaration.prop);
      if (isAnimationName) {
        return localizeDeclarationValues(true, declaration, context2);
      }
      const hasUrl = /url\(/i.test(declaration.value);
      if (hasUrl) {
        return localizeDeclarationValues(false, declaration, context2);
      }
    }
    src$4.exports = (options2 = {}) => {
      if (options2 && options2.mode && options2.mode !== "global" && options2.mode !== "local" && options2.mode !== "pure") {
        throw new Error('options.mode must be either "global", "local" or "pure" (default "local")');
      }
      const pureMode = options2 && options2.mode === "pure";
      const globalMode = options2 && options2.mode === "global";
      return {
        postcssPlugin: "postcss-modules-local-by-default",
        prepare() {
          const localAliasMap = /* @__PURE__ */ new Map();
          return {
            Once(root3) {
              const { icssImports } = extractICSS(root3, false);
              Object.keys(icssImports).forEach((key2) => {
                Object.keys(icssImports[key2]).forEach((prop) => {
                  localAliasMap.set(prop, icssImports[key2][prop]);
                });
              });
              root3.walkAtRules((atRule) => {
                if (/keyframes$/i.test(atRule.name)) {
                  const globalMatch = /^\s*:global\s*\((.+)\)\s*$/.exec(atRule.params);
                  const localMatch = /^\s*:local\s*\((.+)\)\s*$/.exec(atRule.params);
                  let globalKeyframes = globalMode;
                  if (globalMatch) {
                    if (pureMode) {
                      throw atRule.error("@keyframes :global(...) is not allowed in pure mode");
                    }
                    atRule.params = globalMatch[1];
                    globalKeyframes = true;
                  } else if (localMatch) {
                    atRule.params = localMatch[0];
                    globalKeyframes = false;
                  } else if (!globalMode) {
                    if (atRule.params && !localAliasMap.has(atRule.params)) {
                      atRule.params = ":local(" + atRule.params + ")";
                    }
                  }
                  atRule.walkDecls((declaration) => {
                    localizeDeclaration(declaration, {
                      localAliasMap,
                      options: options2,
                      global: globalKeyframes
                    });
                  });
                } else if (atRule.nodes) {
                  atRule.nodes.forEach((declaration) => {
                    if (declaration.type === "decl") {
                      localizeDeclaration(declaration, {
                        localAliasMap,
                        options: options2,
                        global: globalMode
                      });
                    }
                  });
                }
              });
              root3.walkRules((rule) => {
                if (rule.parent && rule.parent.type === "atrule" && /keyframes$/i.test(rule.parent.name)) {
                  return;
                }
                const context2 = localizeNode(rule, options2.mode, localAliasMap);
                context2.options = options2;
                context2.localAliasMap = localAliasMap;
                if (pureMode && context2.hasPureGlobals) {
                  throw rule.error('Selector "' + rule.selector + '" is not pure (pure selectors must contain at least one local class or id)');
                }
                rule.selector = context2.selector;
                if (rule.nodes) {
                  rule.nodes.forEach((declaration) => localizeDeclaration(declaration, context2));
                }
              });
            }
          };
        }
      };
    };
    src$4.exports.postcss = true;
    var src$22 = { exports: {} };
    var PERMANENT_MARKER = 2;
    var TEMPORARY_MARKER = 1;
    function createError(node3, graph) {
      const er2 = new Error("Nondeterministic import's order");
      const related = graph[node3];
      const relatedNode = related.find((relatedNode2) => graph[relatedNode2].indexOf(node3) > -1);
      er2.nodes = [node3, relatedNode];
      return er2;
    }
    function walkGraph(node3, graph, state, result2, strict) {
      if (state[node3] === PERMANENT_MARKER) {
        return;
      }
      if (state[node3] === TEMPORARY_MARKER) {
        if (strict) {
          return createError(node3, graph);
        }
        return;
      }
      state[node3] = TEMPORARY_MARKER;
      const children = graph[node3];
      const length = children.length;
      for (let i2 = 0; i2 < length; ++i2) {
        const error2 = walkGraph(children[i2], graph, state, result2, strict);
        if (error2 instanceof Error) {
          return error2;
        }
      }
      state[node3] = PERMANENT_MARKER;
      result2.push(node3);
    }
    function topologicalSort$1(graph, strict) {
      const result2 = [];
      const state = {};
      const nodes = Object.keys(graph);
      const length = nodes.length;
      for (let i2 = 0; i2 < length; ++i2) {
        const er2 = walkGraph(nodes[i2], graph, state, result2, strict);
        if (er2 instanceof Error) {
          return er2;
        }
      }
      return result2;
    }
    var topologicalSort_1 = topologicalSort$1;
    var topologicalSort = topologicalSort_1;
    var matchImports$1 = /^(.+?)\s+from\s+(?:"([^"]+)"|'([^']+)'|(global))$/;
    var icssImport = /^:import\((?:"([^"]+)"|'([^']+)')\)/;
    var VISITED_MARKER = 1;
    function addImportToGraph(importId, parentId, graph, visited) {
      const siblingsId = parentId + "_siblings";
      const visitedId = parentId + "_" + importId;
      if (visited[visitedId] !== VISITED_MARKER) {
        if (!Array.isArray(visited[siblingsId])) {
          visited[siblingsId] = [];
        }
        const siblings = visited[siblingsId];
        if (Array.isArray(graph[importId])) {
          graph[importId] = graph[importId].concat(siblings);
        } else {
          graph[importId] = siblings.slice();
        }
        visited[visitedId] = VISITED_MARKER;
        siblings.push(importId);
      }
    }
    src$22.exports = (options2 = {}) => {
      let importIndex = 0;
      const createImportedName = typeof options2.createImportedName !== "function" ? (importName) => `i__imported_${importName.replace(/\W/g, "_")}_${importIndex++}` : options2.createImportedName;
      const failOnWrongOrder = options2.failOnWrongOrder;
      return {
        postcssPlugin: "postcss-modules-extract-imports",
        prepare() {
          const graph = {};
          const visited = {};
          const existingImports = {};
          const importDecls = {};
          const imports = {};
          return {
            Once(root3, postcss3) {
              root3.walkRules((rule) => {
                const matches2 = icssImport.exec(rule.selector);
                if (matches2) {
                  const [, doubleQuotePath, singleQuotePath] = matches2;
                  const importPath = doubleQuotePath || singleQuotePath;
                  addImportToGraph(importPath, "root", graph, visited);
                  existingImports[importPath] = rule;
                }
              });
              root3.walkDecls(/^composes$/, (declaration) => {
                const matches2 = declaration.value.match(matchImports$1);
                if (!matches2) {
                  return;
                }
                let tmpSymbols;
                let [
                  ,
                  symbols,
                  doubleQuotePath,
                  singleQuotePath,
                  global2
                ] = matches2;
                if (global2) {
                  tmpSymbols = symbols.split(/\s+/).map((s2) => `global(${s2})`);
                } else {
                  const importPath = doubleQuotePath || singleQuotePath;
                  let parent = declaration.parent;
                  let parentIndexes = "";
                  while (parent.type !== "root") {
                    parentIndexes = parent.parent.index(parent) + "_" + parentIndexes;
                    parent = parent.parent;
                  }
                  const { selector: selector2 } = declaration.parent;
                  const parentRule = `_${parentIndexes}${selector2}`;
                  addImportToGraph(importPath, parentRule, graph, visited);
                  importDecls[importPath] = declaration;
                  imports[importPath] = imports[importPath] || {};
                  tmpSymbols = symbols.split(/\s+/).map((s2) => {
                    if (!imports[importPath][s2]) {
                      imports[importPath][s2] = createImportedName(s2, importPath);
                    }
                    return imports[importPath][s2];
                  });
                }
                declaration.value = tmpSymbols.join(" ");
              });
              const importsOrder = topologicalSort(graph, failOnWrongOrder);
              if (importsOrder instanceof Error) {
                const importPath = importsOrder.nodes.find((importPath2) => importDecls.hasOwnProperty(importPath2));
                const decl = importDecls[importPath];
                throw decl.error("Failed to resolve order of composed modules " + importsOrder.nodes.map((importPath2) => "`" + importPath2 + "`").join(", ") + ".", {
                  plugin: "postcss-modules-extract-imports",
                  word: "composes"
                });
              }
              let lastImportRule;
              importsOrder.forEach((path3) => {
                const importedSymbols = imports[path3];
                let rule = existingImports[path3];
                if (!rule && importedSymbols) {
                  rule = postcss3.rule({
                    selector: `:import("${path3}")`,
                    raws: { after: "\n" }
                  });
                  if (lastImportRule) {
                    root3.insertAfter(lastImportRule, rule);
                  } else {
                    root3.prepend(rule);
                  }
                }
                lastImportRule = rule;
                if (!importedSymbols) {
                  return;
                }
                Object.keys(importedSymbols).forEach((importedSymbol) => {
                  rule.append(postcss3.decl({
                    value: importedSymbol,
                    prop: importedSymbols[importedSymbol],
                    raws: { before: "\n  " }
                  }));
                });
              });
            }
          };
        }
      };
    };
    src$22.exports.postcss = true;
    var selectorParser = dist2.exports;
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    function getSingleLocalNamesForComposes(root3) {
      return root3.nodes.map((node3) => {
        if (node3.type !== "selector" || node3.nodes.length !== 1) {
          throw new Error(`composition is only allowed when selector is single :local class name not in "${root3}"`);
        }
        node3 = node3.nodes[0];
        if (node3.type !== "pseudo" || node3.value !== ":local" || node3.nodes.length !== 1) {
          throw new Error('composition is only allowed when selector is single :local class name not in "' + root3 + '", "' + node3 + '" is weird');
        }
        node3 = node3.first;
        if (node3.type !== "selector" || node3.length !== 1) {
          throw new Error('composition is only allowed when selector is single :local class name not in "' + root3 + '", "' + node3 + '" is weird');
        }
        node3 = node3.first;
        if (node3.type !== "class") {
          throw new Error('composition is only allowed when selector is single :local class name not in "' + root3 + '", "' + node3 + '" is weird');
        }
        return node3.value;
      });
    }
    var whitespace = "[\\x20\\t\\r\\n\\f]";
    var unescapeRegExp = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig");
    function unescape2(str2) {
      return str2.replace(unescapeRegExp, (_2, escaped2, escapedWhitespace) => {
        const high = "0x" + escaped2 - 65536;
        return high !== high || escapedWhitespace ? escaped2 : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
      });
    }
    var plugin = (options2 = {}) => {
      const generateScopedName2 = options2 && options2.generateScopedName || plugin.generateScopedName;
      const generateExportEntry = options2 && options2.generateExportEntry || plugin.generateExportEntry;
      const exportGlobals = options2 && options2.exportGlobals;
      return {
        postcssPlugin: "postcss-modules-scope",
        Once(root3, { rule }) {
          const exports3 = /* @__PURE__ */ Object.create(null);
          function exportScopedName(name, rawName) {
            const scopedName = generateScopedName2(rawName ? rawName : name, root3.source.input.from, root3.source.input.css);
            const exportEntry = generateExportEntry(rawName ? rawName : name, scopedName, root3.source.input.from, root3.source.input.css);
            const { key: key2, value } = exportEntry;
            exports3[key2] = exports3[key2] || [];
            if (exports3[key2].indexOf(value) < 0) {
              exports3[key2].push(value);
            }
            return scopedName;
          }
          function localizeNode2(node3) {
            switch (node3.type) {
              case "selector":
                node3.nodes = node3.map(localizeNode2);
                return node3;
              case "class":
                return selectorParser.className({
                  value: exportScopedName(node3.value, node3.raws && node3.raws.value ? node3.raws.value : null)
                });
              case "id": {
                return selectorParser.id({
                  value: exportScopedName(node3.value, node3.raws && node3.raws.value ? node3.raws.value : null)
                });
              }
            }
            throw new Error(`${node3.type} ("${node3}") is not allowed in a :local block`);
          }
          function traverseNode(node3) {
            switch (node3.type) {
              case "pseudo":
                if (node3.value === ":local") {
                  if (node3.nodes.length !== 1) {
                    throw new Error('Unexpected comma (",") in :local block');
                  }
                  const selector2 = localizeNode2(node3.first);
                  selector2.first.spaces = node3.spaces;
                  const nextNode = node3.next();
                  if (nextNode && nextNode.type === "combinator" && nextNode.value === " " && /\\[A-F0-9]{1,6}$/.test(selector2.last.value)) {
                    selector2.last.spaces.after = " ";
                  }
                  node3.replaceWith(selector2);
                  return;
                }
              case "root":
              case "selector": {
                node3.each(traverseNode);
                break;
              }
              case "id":
              case "class":
                if (exportGlobals) {
                  exports3[node3.value] = [node3.value];
                }
                break;
            }
            return node3;
          }
          const importedNames = {};
          root3.walkRules(/^:import\(.+\)$/, (rule2) => {
            rule2.walkDecls((decl) => {
              importedNames[decl.prop] = true;
            });
          });
          root3.walkRules((rule2) => {
            let parsedSelector = selectorParser().astSync(rule2);
            rule2.selector = traverseNode(parsedSelector.clone()).toString();
            rule2.walkDecls(/composes|compose-with/i, (decl) => {
              const localNames = getSingleLocalNamesForComposes(parsedSelector);
              const classes = decl.value.split(/\s+/);
              classes.forEach((className2) => {
                const global2 = /^global\(([^)]+)\)$/.exec(className2);
                if (global2) {
                  localNames.forEach((exportedName) => {
                    exports3[exportedName].push(global2[1]);
                  });
                } else if (hasOwnProperty2.call(importedNames, className2)) {
                  localNames.forEach((exportedName) => {
                    exports3[exportedName].push(className2);
                  });
                } else if (hasOwnProperty2.call(exports3, className2)) {
                  localNames.forEach((exportedName) => {
                    exports3[className2].forEach((item) => {
                      exports3[exportedName].push(item);
                    });
                  });
                } else {
                  throw decl.error(`referenced class name "${className2}" in ${decl.prop} not found`);
                }
              });
              decl.remove();
            });
            rule2.walkDecls((decl) => {
              if (!/:local\s*\((.+?)\)/.test(decl.value)) {
                return;
              }
              let tokens = decl.value.split(/(,|'[^']*'|"[^"]*")/);
              tokens = tokens.map((token2, idx) => {
                if (idx === 0 || tokens[idx - 1] === ",") {
                  let result2 = token2;
                  const localMatch = /:local\s*\((.+?)\)/.exec(token2);
                  if (localMatch) {
                    const input = localMatch.input;
                    const matchPattern = localMatch[0];
                    const matchVal = localMatch[1];
                    const newVal = exportScopedName(matchVal);
                    result2 = input.replace(matchPattern, newVal);
                  } else {
                    return token2;
                  }
                  return result2;
                } else {
                  return token2;
                }
              });
              decl.value = tokens.join("");
            });
          });
          root3.walkAtRules(/keyframes$/i, (atRule) => {
            const localMatch = /^\s*:local\s*\((.+?)\)\s*$/.exec(atRule.params);
            if (!localMatch) {
              return;
            }
            atRule.params = exportScopedName(localMatch[1]);
          });
          const exportedNames = Object.keys(exports3);
          if (exportedNames.length > 0) {
            const exportRule = rule({ selector: ":export" });
            exportedNames.forEach((exportedName) => exportRule.append({
              prop: exportedName,
              value: exports3[exportedName].join(" "),
              raws: { before: "\n  " }
            }));
            root3.append(exportRule);
          }
        }
      };
    };
    plugin.postcss = true;
    plugin.generateScopedName = function(name, path3) {
      const sanitisedPath = path3.replace(/\.[^./\\]+$/, "").replace(/[\W_]+/g, "_").replace(/^_|_$/g, "");
      return `_${sanitisedPath}__${name}`.trim();
    };
    plugin.generateExportEntry = function(name, scopedName) {
      return {
        key: unescape2(name),
        value: unescape2(scopedName)
      };
    };
    var src$12 = plugin;
    var src2 = { exports: {} };
    var ICSSUtils = src$3;
    var matchImports = /^(.+?|\([\s\S]+?\))\s+from\s+("[^"]*"|'[^']*'|[\w-]+)$/;
    var matchValueDefinition = /(?:\s+|^)([\w-]+):?(.*?)$/;
    var matchImport = /^([\w-]+)(?:\s+as\s+([\w-]+))?/;
    src2.exports = (options2) => {
      let importIndex = 0;
      const createImportedName = options2 && options2.createImportedName || ((importName) => `i__const_${importName.replace(/\W/g, "_")}_${importIndex++}`);
      return {
        postcssPlugin: "postcss-modules-values",
        prepare(result2) {
          const importAliases = [];
          const definitions = {};
          return {
            Once(root3, postcss3) {
              root3.walkAtRules(/value/i, (atRule) => {
                const matches2 = atRule.params.match(matchImports);
                if (matches2) {
                  let [, aliases, path3] = matches2;
                  if (definitions[path3]) {
                    path3 = definitions[path3];
                  }
                  const imports = aliases.replace(/^\(\s*([\s\S]+)\s*\)$/, "$1").split(/\s*,\s*/).map((alias2) => {
                    const tokens = matchImport.exec(alias2);
                    if (tokens) {
                      const [, theirName, myName = theirName] = tokens;
                      const importedName = createImportedName(myName);
                      definitions[myName] = importedName;
                      return { theirName, importedName };
                    } else {
                      throw new Error(`@import statement "${alias2}" is invalid!`);
                    }
                  });
                  importAliases.push({ path: path3, imports });
                  atRule.remove();
                  return;
                }
                if (atRule.params.indexOf("@value") !== -1) {
                  result2.warn("Invalid value definition: " + atRule.params);
                }
                let [, key2, value] = `${atRule.params}${atRule.raws.between}`.match(matchValueDefinition);
                const normalizedValue = value.replace(/\/\*((?!\*\/).*?)\*\//g, "");
                if (normalizedValue.length === 0) {
                  result2.warn("Invalid value definition: " + atRule.params);
                  atRule.remove();
                  return;
                }
                let isOnlySpace = /^\s+$/.test(normalizedValue);
                if (!isOnlySpace) {
                  value = value.trim();
                }
                definitions[key2] = ICSSUtils.replaceValueSymbols(value, definitions);
                atRule.remove();
              });
              if (!Object.keys(definitions).length) {
                return;
              }
              ICSSUtils.replaceSymbols(root3, definitions);
              const exportDeclarations = Object.keys(definitions).map((key2) => postcss3.decl({
                value: definitions[key2],
                prop: key2,
                raws: { before: "\n  " }
              }));
              if (exportDeclarations.length > 0) {
                const exportRule = postcss3.rule({
                  selector: ":export",
                  raws: { after: "\n" }
                });
                exportRule.append(exportDeclarations);
                root3.prepend(exportRule);
              }
              importAliases.reverse().forEach(({ path: path3, imports }) => {
                const importRule = postcss3.rule({
                  selector: `:import(${path3})`,
                  raws: { after: "\n" }
                });
                imports.forEach(({ theirName, importedName }) => {
                  importRule.append({
                    value: theirName,
                    prop: importedName,
                    raws: { before: "\n  " }
                  });
                });
                root3.prepend(importRule);
              });
            }
          };
        }
      };
    };
    src2.exports.postcss = true;
    Object.defineProperty(behaviours$1, "__esModule", {
      value: true
    });
    behaviours$1.behaviours = void 0;
    behaviours$1.getDefaultPlugins = getDefaultPlugins;
    behaviours$1.isValidBehaviour = isValidBehaviour;
    var _postcssModulesLocalByDefault = src$4.exports;
    var _postcssModulesLocalByDefault2 = _interopRequireDefault$1(_postcssModulesLocalByDefault);
    var _postcssModulesExtractImports = src$22.exports;
    var _postcssModulesExtractImports2 = _interopRequireDefault$1(_postcssModulesExtractImports);
    var _postcssModulesScope = src$12;
    var _postcssModulesScope2 = _interopRequireDefault$1(_postcssModulesScope);
    var _postcssModulesValues = src2.exports;
    var _postcssModulesValues2 = _interopRequireDefault$1(_postcssModulesValues);
    function _interopRequireDefault$1(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var behaviours = behaviours$1.behaviours = {
      LOCAL: "local",
      GLOBAL: "global"
    };
    function getDefaultPlugins({
      behaviour,
      generateScopedName: generateScopedName2,
      exportGlobals
    }) {
      const scope = (0, _postcssModulesScope2.default)({ generateScopedName: generateScopedName2, exportGlobals });
      const plugins2 = {
        [behaviours.LOCAL]: [_postcssModulesValues2.default, (0, _postcssModulesLocalByDefault2.default)({ mode: "local" }), _postcssModulesExtractImports2.default, scope],
        [behaviours.GLOBAL]: [_postcssModulesValues2.default, (0, _postcssModulesLocalByDefault2.default)({ mode: "global" }), _postcssModulesExtractImports2.default, scope]
      };
      return plugins2[behaviour];
    }
    function isValidBehaviour(behaviour) {
      return Object.keys(behaviours).map((key2) => behaviours[key2]).indexOf(behaviour) > -1;
    }
    var _postcss = require$$0__default2;
    var _postcss2 = _interopRequireDefault(_postcss);
    var _lodash = lodash_camelcase;
    var _lodash2 = _interopRequireDefault(_lodash);
    var _genericNames = genericNames;
    var _genericNames2 = _interopRequireDefault(_genericNames);
    var _unquote = unquote$1;
    var _unquote2 = _interopRequireDefault(_unquote);
    var _parser = parser$1;
    var _parser2 = _interopRequireDefault(_parser);
    var _loader = loader;
    var _loader2 = _interopRequireDefault(_loader);
    var _generateScopedName = generateScopedName$1;
    var _generateScopedName2 = _interopRequireDefault(_generateScopedName);
    var _saveJSON = saveJSON$1;
    var _saveJSON2 = _interopRequireDefault(_saveJSON);
    var _behaviours = behaviours$1;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _asyncToGenerator(fn2) {
      return function() {
        var gen = fn2.apply(this, arguments);
        return new Promise(function(resolve2, reject) {
          function step(key2, arg) {
            try {
              var info = gen[key2](arg);
              var value = info.value;
            } catch (error2) {
              reject(error2);
              return;
            }
            if (info.done) {
              resolve2(value);
            } else {
              return Promise.resolve(value).then(function(value2) {
                step("next", value2);
              }, function(err) {
                step("throw", err);
              });
            }
          }
          return step("next");
        });
      };
    }
    var PLUGIN_NAME = "postcss-modules";
    function getDefaultScopeBehaviour(opts) {
      if (opts.scopeBehaviour && (0, _behaviours.isValidBehaviour)(opts.scopeBehaviour)) {
        return opts.scopeBehaviour;
      }
      return _behaviours.behaviours.LOCAL;
    }
    function getScopedNameGenerator(opts) {
      const scopedNameGenerator = opts.generateScopedName || _generateScopedName2.default;
      if (typeof scopedNameGenerator === "function")
        return scopedNameGenerator;
      return (0, _genericNames2.default)(scopedNameGenerator, {
        context: process.cwd(),
        hashPrefix: opts.hashPrefix
      });
    }
    function getLoader(opts, plugins2) {
      const root3 = typeof opts.root === "undefined" ? "/" : opts.root;
      return typeof opts.Loader === "function" ? new opts.Loader(root3, plugins2) : new _loader2.default(root3, plugins2);
    }
    function isGlobalModule(globalModules, inputFile) {
      return globalModules.some((regex) => inputFile.match(regex));
    }
    function getDefaultPluginsList(opts, inputFile) {
      const globalModulesList = opts.globalModulePaths || null;
      const exportGlobals = opts.exportGlobals || false;
      const defaultBehaviour = getDefaultScopeBehaviour(opts);
      const generateScopedName2 = getScopedNameGenerator(opts);
      if (globalModulesList && isGlobalModule(globalModulesList, inputFile)) {
        return (0, _behaviours.getDefaultPlugins)({
          behaviour: _behaviours.behaviours.GLOBAL,
          generateScopedName: generateScopedName2,
          exportGlobals
        });
      }
      return (0, _behaviours.getDefaultPlugins)({
        behaviour: defaultBehaviour,
        generateScopedName: generateScopedName2,
        exportGlobals
      });
    }
    function isOurPlugin(plugin2) {
      return plugin2.postcssPlugin === PLUGIN_NAME;
    }
    function dashesCamelCase(string3) {
      return string3.replace(/-+(\w)/g, (_2, firstLetter) => firstLetter.toUpperCase());
    }
    build$12.exports = (opts = {}) => {
      return {
        postcssPlugin: PLUGIN_NAME,
        OnceExit(css, { result: result2 }) {
          return _asyncToGenerator(function* () {
            const getJSON = opts.getJSON || _saveJSON2.default;
            const inputFile = css.source.input.file;
            const pluginList = getDefaultPluginsList(opts, inputFile);
            const resultPluginIndex = result2.processor.plugins.findIndex(function(plugin2) {
              return isOurPlugin(plugin2);
            });
            if (resultPluginIndex === -1) {
              throw new Error("Plugin missing from options.");
            }
            const earlierPlugins = result2.processor.plugins.slice(0, resultPluginIndex);
            const loaderPlugins = [...earlierPlugins, ...pluginList];
            const loader2 = getLoader(opts, loaderPlugins);
            const fetcher = function fetcher2(file, relativeTo, depTrace) {
              const unquoteFile = (0, _unquote2.default)(file);
              const resolvedResult = typeof opts.resolve === "function" && opts.resolve(unquoteFile);
              const resolvedFile = resolvedResult instanceof Promise ? resolvedResult : Promise.resolve(resolvedResult);
              return resolvedFile.then(function(f2) {
                return loader2.fetch.call(loader2, `"${f2 || unquoteFile}"`, relativeTo, depTrace);
              });
            };
            const parser3 = new _parser2.default(fetcher);
            yield (0, _postcss2.default)([...pluginList, parser3.plugin()]).process(css, {
              from: inputFile
            });
            const out2 = loader2.finalSource;
            if (out2)
              css.prepend(out2);
            if (opts.localsConvention) {
              const isFunc = typeof opts.localsConvention === "function";
              parser3.exportTokens = Object.entries(parser3.exportTokens).reduce(function(tokens, [className2, value]) {
                if (isFunc) {
                  tokens[opts.localsConvention(className2, value, inputFile)] = value;
                  return tokens;
                }
                switch (opts.localsConvention) {
                  case "camelCase":
                    tokens[className2] = value;
                    tokens[(0, _lodash2.default)(className2)] = value;
                    break;
                  case "camelCaseOnly":
                    tokens[(0, _lodash2.default)(className2)] = value;
                    break;
                  case "dashes":
                    tokens[className2] = value;
                    tokens[dashesCamelCase(className2)] = value;
                    break;
                  case "dashesOnly":
                    tokens[dashesCamelCase(className2)] = value;
                    break;
                }
                return tokens;
              }, {});
            }
            result2.messages.push({
              type: "export",
              plugin: "postcss-modules",
              exportTokens: parser3.exportTokens
            });
            return getJSON(css.source.input.file, parser3.exportTokens, result2.opts.to);
          })();
        }
      };
    };
    var postcss2 = build$12.exports.postcss = true;
    var build2 = build$12.exports;
    var index2 = _mergeNamespaces2({
      __proto__: null,
      "default": build2,
      postcss: postcss2
    }, [build$12.exports]);
    exports2.index = index2;
  }
});

// node_modules/vite/package.json
var require_package = __commonJS({
  "node_modules/vite/package.json"(exports2, module2) {
    module2.exports = {
      name: "vite",
      version: "2.9.1",
      license: "MIT",
      author: "Evan You",
      description: "Native-ESM powered web dev build tool",
      bin: {
        vite: "bin/vite.js"
      },
      main: "dist/node/index.js",
      types: "dist/node/index.d.ts",
      files: [
        "bin",
        "dist",
        "client.d.ts",
        "src/client",
        "types"
      ],
      engines: {
        node: ">=12.2.0"
      },
      repository: {
        type: "git",
        url: "git+https://github.com/vitejs/vite.git",
        directory: "packages/vite"
      },
      bugs: {
        url: "https://github.com/vitejs/vite/issues"
      },
      homepage: "https://github.com/vitejs/vite/tree/main/#readme",
      scripts: {
        dev: "rimraf dist && rollup -c -w",
        build: "rimraf dist && npm run lint && run-s build-bundle build-types",
        "build-bundle": "rollup -c",
        "build-types": "run-s build-temp-types patch-types roll-types",
        "build-temp-types": "tsc --emitDeclarationOnly --outDir temp/node -p src/node",
        "ci-build": "rimraf dist && run-s build-bundle build-types",
        "patch-types": "ts-node scripts/patchTypes.ts",
        "roll-types": "api-extractor run && rimraf temp",
        lint: "eslint --ext .ts src/**",
        format: 'prettier --write --parser typescript "src/**/*.ts"',
        prepublishOnly: "npm run build"
      },
      "//": "READ CONTRIBUTING.md to understand what to put under deps vs. devDeps!",
      dependencies: {
        esbuild: "^0.14.27",
        postcss: "^8.4.12",
        resolve: "^1.22.0",
        rollup: "^2.59.0"
      },
      optionalDependencies: {
        fsevents: "~2.3.2"
      },
      devDependencies: {
        "@ampproject/remapping": "^2.1.2",
        "@babel/parser": "^7.17.8",
        "@babel/types": "^7.17.0",
        "@jridgewell/trace-mapping": "^0.3.4",
        "@rollup/plugin-alias": "^3.1.9",
        "@rollup/plugin-commonjs": "^21.0.3",
        "@rollup/plugin-dynamic-import-vars": "^1.4.2",
        "@rollup/plugin-json": "^4.1.0",
        "@rollup/plugin-node-resolve": "13.1.3",
        "@rollup/plugin-typescript": "^8.3.1",
        "@rollup/pluginutils": "^4.2.0",
        "@types/convert-source-map": "^1.5.2",
        "@types/cross-spawn": "^6.0.2",
        "@types/debug": "^4.1.7",
        "@types/estree": "^0.0.51",
        "@types/etag": "^1.8.1",
        "@types/less": "^3.0.3",
        "@types/micromatch": "^4.0.2",
        "@types/mime": "^2.0.3",
        "@types/node": "^16.11.26",
        "@types/resolve": "^1.20.1",
        "@types/sass": "~1.43.1",
        "@types/stylus": "^0.48.36",
        "@types/ws": "^8.5.3",
        "@vue/compiler-dom": "^3.2.31",
        acorn: "^8.7.0",
        cac: "6.7.9",
        chokidar: "^3.5.3",
        connect: "^3.7.0",
        "connect-history-api-fallback": "^1.6.0",
        "convert-source-map": "^1.8.0",
        cors: "^2.8.5",
        "cross-spawn": "^7.0.3",
        debug: "^4.3.4",
        dotenv: "^14.3.2",
        "dotenv-expand": "^5.1.0",
        "es-module-lexer": "^0.10.4",
        "estree-walker": "^2.0.2",
        etag: "^1.8.1",
        "fast-glob": "^3.2.11",
        "http-proxy": "^1.18.1",
        json5: "^2.2.1",
        "launch-editor-middleware": "^2.3.0",
        "magic-string": "^0.26.1",
        micromatch: "^4.0.5",
        mrmime: "^1.0.0",
        "node-forge": "^1.3.0",
        okie: "^1.0.1",
        open: "^8.4.0",
        periscopic: "^2.0.3",
        picocolors: "^1.0.0",
        "postcss-import": "^14.1.0",
        "postcss-load-config": "^3.1.3",
        "postcss-modules": "^4.3.1",
        "resolve.exports": "^1.1.0",
        "rollup-plugin-license": "^2.6.1",
        sirv: "^2.0.2",
        "source-map-js": "^1.0.2",
        "source-map-support": "^0.5.21",
        "strip-ansi": "^6.0.1",
        terser: "^5.12.1",
        tsconfck: "^1.2.1",
        tslib: "^2.3.1",
        types: "link:./types",
        ws: "^8.5.0"
      },
      peerDependencies: {
        less: "*",
        sass: "*",
        stylus: "*"
      },
      peerDependenciesMeta: {
        sass: {
          optional: true
        },
        stylus: {
          optional: true
        },
        less: {
          optional: true
        }
      }
    };
  }
});

// node_modules/rollup/dist/es/rollup.browser.js
var rollup_browser_exports = {};
__export(rollup_browser_exports, {
  VERSION: () => e2,
  defineConfig: () => el,
  rollup: () => Kh
});
function n2(e2, t, s2) {
  s2 === 4 ? e2.push([t[0], t[1], t[2], t[3]]) : s2 === 5 ? e2.push([t[0], t[1], t[2], t[3], t[4]]) : s2 === 1 && e2.push([t[0]]);
}
function r(e2) {
  var t = "";
  e2 = e2 < 0 ? -e2 << 1 | 1 : e2 << 1;
  do {
    var i2 = 31 & e2;
    (e2 >>>= 5) > 0 && (i2 |= 32), t += s2[i2];
  } while (e2 > 0);
  return t;
}
function c2(e2) {
  var t = e2.split("\n"), s2 = t.filter(function(e3) {
    return /^\t+/.test(e3);
  }), i2 = t.filter(function(e3) {
    return /^ {2,}/.test(e3);
  });
  if (s2.length === 0 && i2.length === 0)
    return null;
  if (s2.length >= i2.length)
    return "	";
  var n3 = i2.reduce(function(e3, t2) {
    var s3 = /^ +/.exec(t2)[0].length;
    return Math.min(s3, e3);
  }, 1 / 0);
  return new Array(n3 + 1).join(" ");
}
function u(e2, t) {
  var s2 = e2.split(/[/\\]/), i2 = t.split(/[/\\]/);
  for (s2.pop(); s2[0] === i2[0]; )
    s2.shift(), i2.shift();
  if (s2.length)
    for (var n3 = s2.length; n3--; )
      s2[n3] = "..";
  return s2.concat(i2).join("/");
}
function p(e2) {
  return d2.call(e2) === "[object Object]";
}
function f(e2) {
  for (var t = e2.split("\n"), s2 = [], i2 = 0, n3 = 0; i2 < t.length; i2++)
    s2.push(n3), n3 += t[i2].length + 1;
  return function(e3) {
    for (var t2 = 0, i3 = s2.length; t2 < i3; ) {
      var n4 = t2 + i3 >> 1;
      e3 < s2[n4] ? i3 = n4 : t2 = n4 + 1;
    }
    var r2 = t2 - 1;
    return { line: r2, column: e3 - s2[r2] };
  };
}
function C2(e2) {
  return S.test(e2);
}
function I(e2) {
  return A2.test(e2);
}
function N(e2) {
  return e2.replace(P, "/");
}
function _(e2) {
  return e2.split(k).pop() || "";
}
function $(e2) {
  const t = /[/\\][^/\\]*$/.exec(e2);
  if (!t)
    return ".";
  const s2 = e2.slice(0, -t[0].length);
  return s2 || "/";
}
function T(e2) {
  const t = w2.exec(_(e2));
  return t ? t[0] : "";
}
function R(e2, t) {
  const s2 = e2.split(k).filter(Boolean), i2 = t.split(k).filter(Boolean);
  for (s2[0] === "." && s2.shift(), i2[0] === "." && i2.shift(); s2[0] && i2[0] && s2[0] === i2[0]; )
    s2.shift(), i2.shift();
  for (; i2[0] === ".." && s2.length > 0; )
    i2.shift(), s2.pop();
  for (; s2.pop(); )
    i2.unshift("..");
  return i2.join("/");
}
function M(...e2) {
  const t = e2.shift();
  if (!t)
    return "/";
  let s2 = t.split(k);
  for (const t2 of e2)
    if (C2(t2))
      s2 = t2.split(k);
    else {
      const e3 = t2.split(k);
      for (; e3[0] === "." || e3[0] === ".."; ) {
        e3.shift() === ".." && s2.pop();
      }
      s2.push(...e3);
    }
  return s2.join("/");
}
function D(e2, t, s2) {
  const i2 = e2.get(t);
  if (i2)
    return i2;
  const n3 = s2();
  return e2.set(t, n3), n3;
}
function J(e2, t, s2) {
  if (typeof s2 == "number")
    throw new Error("locate takes a { startIndex, offsetLine, offsetColumn } object as the third argument");
  return function(e3, t2) {
    t2 === void 0 && (t2 = {});
    var s3 = t2.offsetLine || 0, i2 = t2.offsetColumn || 0, n3 = e3.split("\n"), r2 = 0, a2 = n3.map(function(e4, t3) {
      var s4 = r2 + e4.length + 1, i3 = { start: r2, end: s4, line: t3 };
      return r2 = s4, i3;
    }), o2 = 0;
    function h3(e4, t3) {
      return e4.start <= t3 && t3 < e4.end;
    }
    function l2(e4, t3) {
      return { line: s3 + e4.line, column: i2 + t3 - e4.start, character: t3 };
    }
    return function(t3, s4) {
      typeof t3 == "string" && (t3 = e3.indexOf(t3, s4 || 0));
      for (var i3 = a2[o2], n4 = t3 >= i3.end ? 1 : -1; i3; ) {
        if (h3(i3, t3))
          return l2(i3, t3);
        i3 = a2[o2 += n4];
      }
    };
  }(e2, s2)(t, s2 && s2.startIndex);
}
function ee(e2) {
  return e2.replace(/^\t+/, (e3) => e3.split("	").join("  "));
}
function te(e2, t) {
  const s2 = e2.length <= 1, i2 = e2.map((e3) => `"${e3}"`);
  let n3 = s2 ? i2[0] : `${i2.slice(0, -1).join(", ")} and ${i2.slice(-1)[0]}`;
  return t && (n3 += ` ${s2 ? t[0] : t[1]}`), n3;
}
function se(e2) {
  const t = _(e2);
  return t.substring(0, t.length - T(e2).length);
}
function ie(e2) {
  return C2(e2) ? R(M(), e2) : e2;
}
function ne(e2) {
  return e2[0] === "/" || e2[0] === "." && (e2[1] === "/" || e2[1] === ".") || C2(e2);
}
function ae(e2, t, s2, i2) {
  let n3 = N(R($(e2), t));
  if (s2 && n3.endsWith(".js") && (n3 = n3.slice(0, -3)), i2) {
    if (n3 === "")
      return "../" + _(t);
    if (re.test(n3))
      return n3.split("/").concat(["..", _(t)]).join("/");
  }
  return n3 ? n3.startsWith("..") ? n3 : "./" + n3 : ".";
}
function oe(e2) {
  throw e2 instanceof Error || (e2 = Object.assign(new Error(e2.message), e2)), e2;
}
function he(e2, t, s2, i2) {
  if (typeof t == "object") {
    const { line: s3, column: n3 } = t;
    e2.loc = { column: n3, file: i2, line: s3 };
  } else {
    e2.pos = t;
    const { line: n3, column: r2 } = J(s2, t, { offsetLine: 1 });
    e2.loc = { column: r2, file: i2, line: n3 };
  }
  if (e2.frame === void 0) {
    const { line: t2, column: i3 } = e2.loc;
    e2.frame = function(e3, t3, s3) {
      let i4 = e3.split("\n");
      const n3 = Math.max(0, t3 - 3);
      let r2 = Math.min(t3 + 2, i4.length);
      for (i4 = i4.slice(n3, r2); !/\S/.test(i4[i4.length - 1]); )
        i4.pop(), r2 -= 1;
      const a2 = String(r2).length;
      return i4.map((e4, i5) => {
        const r3 = n3 + i5 + 1 === t3;
        let o2 = String(i5 + n3 + 1);
        for (; o2.length < a2; )
          o2 = ` ${o2}`;
        if (r3) {
          const t4 = function(e5) {
            let t5 = "";
            for (; e5--; )
              t5 += " ";
            return t5;
          }(a2 + 2 + ee(e4.slice(0, s3)).length) + "^";
          return `${o2}: ${ee(e4)}
${t4}`;
        }
        return `${o2}: ${ee(e4)}`;
      }).join("\n");
    }(s2, t2, i3);
  }
}
function ce({ fileName: e2, code: t }, s2) {
  const i2 = { code: le.CHUNK_INVALID, message: `Chunk "${e2}" is not valid JavaScript: ${s2.message}.` };
  return he(i2, s2.loc, t, e2), i2;
}
function ue(e2, t, s2) {
  return { code: "INVALID_EXPORT_OPTION", message: `"${e2}" was specified for "output.exports", but entry module "${ie(s2)}" has the following exports: ${t.join(", ")}` };
}
function de(e2, t, s2, i2) {
  return { code: le.INVALID_OPTION, message: `Invalid value ${i2 !== void 0 ? `${JSON.stringify(i2)} ` : ""}for option "${e2}" - ${s2}.`, url: `https://rollupjs.org/guide/en/#${t}` };
}
function pe(e2, t, s2) {
  return { code: le.MISSING_EXPORT, message: `'${e2}' is not exported by ${ie(s2)}, imported by ${ie(t)}`, url: "https://rollupjs.org/guide/en/#error-name-is-not-exported-by-module" };
}
function fe(e2) {
  const t = Array.from(e2.implicitlyLoadedBefore, (e3) => ie(e3.id)).sort();
  return { code: le.MISSING_IMPLICIT_DEPENDANT, message: `Module "${ie(e2.id)}" that should be implicitly loaded before ${te(t)} is not included in the module graph. Either it was not imported by an included module or only via a tree-shaken dynamic import, or no imported bindings were used and it had otherwise no side-effects.` };
}
function me(e2, t, s2) {
  const i2 = s2 ? "reexport" : "import";
  return { code: le.UNEXPECTED_NAMED_IMPORT, id: e2, message: `The named export "${t}" was ${i2}ed from the external module ${ie(e2)} even though its interop type is "defaultOnly". Either remove or change this ${i2} or change the value of the "output.interop" option.`, url: "https://rollupjs.org/guide/en/#outputinterop" };
}
function ge(e2) {
  return { code: le.UNEXPECTED_NAMED_IMPORT, id: e2, message: `There was a namespace "*" reexport from the external module ${ie(e2)} even though its interop type is "defaultOnly". This will be ignored as namespace reexports only reexport named exports. If this is not intended, either remove or change this reexport or change the value of the "output.interop" option.`, url: "https://rollupjs.org/guide/en/#outputinterop" };
}
function ye(e2) {
  return { code: le.VALIDATION_ERROR, message: e2 };
}
function Ee() {
  return { code: le.ALREADY_CLOSED, message: 'Bundle is already closed, no more calls to "generate" or "write" are allowed.' };
}
function xe(e2, t, s2) {
  ve(e2, t, s2.onwarn, s2.strictDeprecations);
}
function ve(e2, t, s2, i2) {
  if (t || i2) {
    const t2 = function(e3) {
      return __spreadValues2({ code: le.DEPRECATED_FEATURE }, typeof e3 == "string" ? { message: e3 } : e3);
    }(e2);
    if (i2)
      return oe(t2);
    s2(t2);
  }
}
function Pe(e2) {
  return e2 = e2.replace(/-(\w)/g, (e3, t) => t.toUpperCase()).replace(Se, "_"), (Ae(e2) || be.has(e2)) && (e2 = `_${e2}`), e2 || "_";
}
function Ie() {
  return { brokenFlow: 0, includedCallArguments: /* @__PURE__ */ new Set(), includedLabels: /* @__PURE__ */ new Set() };
}
function Ne() {
  return { accessed: new W(), assigned: new W(), brokenFlow: 0, called: new j(), ignore: { breaks: false, continues: false, labels: /* @__PURE__ */ new Set(), returnYield: false }, includedLabels: /* @__PURE__ */ new Set(), instantiated: new j(), replacedVariableInits: /* @__PURE__ */ new Map() };
}
function $e(e2, t = null) {
  return Object.create(t, e2);
}
function je(e2, t, s2, i2) {
  if (typeof t != "string" || !e2[t])
    return true;
  if (!e2[t].callsArgs)
    return false;
  for (const n3 of e2[t].callsArgs)
    if (s2.args[n3] && s2.args[n3].hasEffectsWhenCalledAtPath(V, { args: _e, thisParam: null, withNew: false }, i2))
      return true;
  return false;
}
function Ge(e2, t) {
  return typeof t == "string" && e2[t] ? e2[t].returns : q;
}
function He(e2, t, s2) {
  s2(e2, t);
}
function qe(e2, t, s2) {
}
function Qe(e2, t, s2 = e2.type) {
  const { annotations: i2 } = t;
  let n3 = i2[t.annotationIndex];
  for (; n3 && e2.start >= n3.end; )
    et(e2, n3, t.code), n3 = i2[++t.annotationIndex];
  if (n3 && n3.end <= e2.end)
    for (Ke[s2](e2, t, Qe); (n3 = i2[t.annotationIndex]) && n3.end <= e2.end; )
      ++t.annotationIndex, it(e2, n3, false);
}
function et(e2, t, s2) {
  const i2 = [];
  let n3;
  if (tt(s2.slice(t.end, e2.start), Ze)) {
    const t2 = e2.start;
    for (; ; ) {
      switch (i2.push(e2), e2.type) {
        case "ExpressionStatement":
        case "ChainExpression":
          e2 = e2.expression;
          continue;
        case "SequenceExpression":
          if (tt(s2.slice(t2, e2.start), Je)) {
            e2 = e2.expressions[0];
            continue;
          }
          n3 = true;
          break;
        case "ConditionalExpression":
          if (tt(s2.slice(t2, e2.start), Je)) {
            e2 = e2.test;
            continue;
          }
          n3 = true;
          break;
        case "LogicalExpression":
        case "BinaryExpression":
          if (tt(s2.slice(t2, e2.start), Je)) {
            e2 = e2.left;
            continue;
          }
          n3 = true;
          break;
        case "CallExpression":
        case "NewExpression":
          break;
        default:
          n3 = true;
      }
      break;
    }
  } else
    n3 = true;
  if (n3)
    it(e2, t, false);
  else
    for (const e3 of i2)
      it(e3, t, true);
}
function tt(e2, t) {
  let s2;
  for (; (s2 = t.exec(e2)) !== null; ) {
    if (s2[0] === "/") {
      const s3 = e2.charCodeAt(t.lastIndex);
      if (s3 === 42) {
        t.lastIndex = e2.indexOf("*/", t.lastIndex + 1) + 2;
        continue;
      }
      if (s3 === 47) {
        t.lastIndex = e2.indexOf("\n", t.lastIndex + 1) + 1;
        continue;
      }
    }
    return t.lastIndex = 0, false;
  }
  return true;
}
function it(e2, t, s2) {
  const i2 = s2 ? "_rollupAnnotations" : "_rollupRemoved", n3 = e2[i2];
  n3 ? n3.push(t) : e2[i2] = [t];
}
function $t(e2) {
  let t = "";
  do {
    const s2 = e2 % 64;
    e2 = Math.floor(e2 / 64), t = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$"[s2] + t;
  } while (e2 !== 0);
  return t;
}
function Tt(e2, t) {
  let s2 = e2, i2 = 1;
  for (; t.has(s2) || be.has(s2); )
    s2 = `${e2}$${$t(i2++)}`;
  return t.add(s2), s2;
}
function Ot(e2, t, s2, i2) {
  if (t.remove(s2, i2), e2.annotations)
    for (const i3 of e2.annotations) {
      if (!(i3.start < s2))
        return;
      t.remove(i3.start, i3.end);
    }
}
function Vt(e2, t) {
  if (e2.annotations || e2.parent.type !== "ExpressionStatement" || (e2 = e2.parent), e2.annotations)
    for (const s2 of e2.annotations)
      t.remove(s2.start, s2.end);
}
function Ft(e2, t, s2 = 0) {
  let i2, n3;
  for (i2 = e2.indexOf(t, s2); ; ) {
    if ((s2 = e2.indexOf("/", s2)) === -1 || s2 >= i2)
      return i2;
    n3 = e2.charCodeAt(++s2), ++s2, (s2 = n3 === 47 ? e2.indexOf("\n", s2) + 1 : e2.indexOf("*/", s2) + 2) > i2 && (i2 = e2.indexOf(t, s2));
  }
}
function Wt(e2, t) {
  zt.lastIndex = t;
  return zt.exec(e2).index;
}
function Ut(e2) {
  let t, s2, i2 = 0;
  for (t = e2.indexOf("\n", i2); ; ) {
    if (i2 = e2.indexOf("/", i2), i2 === -1 || i2 > t)
      return [t, t + 1];
    if (s2 = e2.charCodeAt(i2 + 1), s2 === 47)
      return [i2, t + 1];
    i2 = e2.indexOf("*/", i2 + 3) + 2, i2 > t && (t = e2.indexOf("\n", i2));
  }
}
function jt(e2, t, s2, i2, n3) {
  let r2, a2, o2, h3, l2 = e2[0], c3 = !l2.included || l2.needsBoundaries;
  c3 && (h3 = s2 + Ut(t.original.slice(s2, l2.start))[1]);
  for (let s3 = 1; s3 <= e2.length; s3++)
    r2 = l2, a2 = h3, o2 = c3, l2 = e2[s3], c3 = l2 !== void 0 && (!l2.included || l2.needsBoundaries), o2 || c3 ? (h3 = r2.end + Ut(t.original.slice(r2.end, l2 === void 0 ? i2 : l2.start))[1], r2.included ? o2 ? r2.render(t, n3, { end: h3, start: a2 }) : r2.render(t, n3) : Ot(r2, t, a2, h3)) : r2.render(t, n3);
}
function Gt(e2, t, s2, i2) {
  const n3 = [];
  let r2, a2, o2, h3, l2, c3 = s2 - 1;
  for (let i3 = 0; i3 < e2.length; i3++) {
    for (a2 = e2[i3], r2 !== void 0 && (c3 = r2.end + Ft(t.original.slice(r2.end, a2.start), ",")), o2 = h3 = c3 + 1 + Ut(t.original.slice(c3 + 1, a2.start))[1]; l2 = t.original.charCodeAt(o2), l2 === 32 || l2 === 9 || l2 === 10 || l2 === 13; )
      o2++;
    r2 !== void 0 && n3.push({ contentEnd: h3, end: o2, node: r2, separator: c3, start: s2 }), r2 = a2, s2 = o2;
  }
  return n3.push({ contentEnd: i2, end: i2, node: r2, separator: null, start: s2 }), n3;
}
function Ht(e2, t, s2) {
  for (; ; ) {
    const [i2, n3] = Ut(e2.original.slice(t, s2));
    if (i2 === -1)
      break;
    e2.remove(t + i2, t += n3);
  }
}
function Yt(e2, t) {
  if (e2.type === "MemberExpression")
    return !e2.computed && Yt(e2.object, e2);
  if (e2.type === "Identifier") {
    if (!t)
      return true;
    switch (t.type) {
      case "MemberExpression":
        return t.computed || e2 === t.object;
      case "MethodDefinition":
        return t.computed;
      case "PropertyDefinition":
      case "Property":
        return t.computed || e2 === t.value;
      case "ExportSpecifier":
      case "ImportSpecifier":
        return e2 === t.local;
      case "LabeledStatement":
      case "BreakStatement":
      case "ContinueStatement":
        return false;
      default:
        return true;
    }
  }
  return false;
}
function os2(e2) {
  let t = as;
  for (const s2 of e2) {
    if (typeof s2 != "string")
      return null;
    if (t = t[s2], !t)
      return null;
  }
  return t[Qt];
}
function us(e2) {
  for (; e2 && !/^Program|Function/.test(e2.type); )
    e2 = e2.parent;
  return e2;
}
function fs2(e2, { exportNamesByVariable: t, snippets: { _: s2, getObject: i2, getPropertyAccess: n3 } }, r2 = "") {
  if (e2.length === 1 && t.get(e2[0]).length === 1) {
    const i3 = e2[0];
    return `exports('${t.get(i3)}',${s2}${i3.getName(n3)}${r2})`;
  }
  {
    const s3 = [];
    for (const i3 of e2)
      for (const e3 of t.get(i3))
        s3.push([e3, i3.getName(n3) + r2]);
    return `exports(${i2(s3, { lineBreakIndent: null })})`;
  }
}
function ms2(e2, t, s2, i2, { exportNamesByVariable: n3, snippets: { _: r2 } }) {
  i2.prependRight(t, `exports('${n3.get(e2)}',${r2}`), i2.appendLeft(s2, ")");
}
function gs(e2, t, s2, i2, n3, r2) {
  const { _: a2, getPropertyAccess: o2 } = r2.snippets;
  n3.appendLeft(s2, `,${a2}${fs2([e2], r2)},${a2}${e2.getName(o2)}`), i2 && (n3.prependRight(t, "("), n3.appendLeft(s2, ")"));
}
function ks(e2) {
  return e2.computed ? function(e3) {
    if (e3 instanceof Ps)
      return String(e3.value);
    return null;
  }(e2.property) : e2.property.name;
}
function ws(e2) {
  const t = e2.propertyKey, s2 = e2.object;
  if (typeof t == "string") {
    if (s2 instanceof cs)
      return [{ key: s2.name, pos: s2.start }, { key: t, pos: e2.property.start }];
    if (s2 instanceof Cs) {
      const i2 = ws(s2);
      return i2 && [...i2, { key: t, pos: e2.property.start }];
    }
  }
  return null;
}
function hi(e2) {
  return e2([["value", "'Module'"]], { lineBreakIndent: null });
}
function li(e2, t, s2) {
  return t === "external" ? Hs[String(s2(e2 instanceof ke ? e2.id : null))] : t === "default" ? "_interopNamespaceDefaultOnly" : null;
}
function Ii(e2, t) {
  return e2.renderBaseName !== null && t.has(e2) && e2.isReassigned;
}
function Di(e2) {
  return e2.id;
}
function Fi(e2, t) {
  switch (t) {
    case 1:
      return `# ${e2}`;
    case 2:
      return `## ${e2}`;
    case 3:
      return e2;
    default:
      return `${"  ".repeat(t - 4)}- ${e2}`;
  }
}
function zi(e2, t = 3) {
  e2 = Fi(e2, t);
  const s2 = Oi.memoryUsage().heapUsed, i2 = Li.now(), n3 = Bi.get(e2);
  n3 === void 0 ? Bi.set(e2, { memory: 0, startMemory: s2, startTime: i2, time: 0, totalMemory: 0 }) : (n3.startMemory = s2, n3.startTime = i2);
}
function Wi(e2, t = 3) {
  e2 = Fi(e2, t);
  const s2 = Bi.get(e2);
  if (s2 !== void 0) {
    const e3 = Oi.memoryUsage().heapUsed;
    s2.memory += e3 - s2.startMemory, s2.time += Li.now() - s2.startTime, s2.totalMemory = Math.max(s2.totalMemory, e3);
  }
}
function Ui() {
  const e2 = {};
  for (const [t, { memory: s2, time: i2, totalMemory: n3 }] of Bi)
    e2[t] = [i2, s2, n3];
  return e2;
}
function qi(e2, t) {
  for (const s2 of Hi)
    if (s2 in e2) {
      let i2 = `plugin ${t}`;
      e2.name && (i2 += ` (${e2.name})`), i2 += ` - ${s2}`;
      const n3 = e2[s2];
      e2[s2] = function(...e3) {
        ji(i2, 4);
        const t2 = n3.apply(this, e3);
        return Gi(i2, 4), t2 && typeof t2.then == "function" ? (ji(`${i2} (async)`, 4), t2.then((e4) => (Gi(`${i2} (async)`, 4), e4))) : t2;
      };
    }
  return e2;
}
function Ki(e2) {
  e2.isExecuted = true;
  const t = [e2], s2 = /* @__PURE__ */ new Set();
  for (const e3 of t)
    for (const i2 of [...e3.dependencies, ...e3.implicitlyLoadedBefore])
      i2 instanceof ke || i2.isExecuted || !i2.info.moduleSideEffects && !e3.implicitlyLoadedBefore.has(i2) || s2.has(i2.id) || (i2.isExecuted = true, s2.add(i2.id), t.push(i2));
}
function Yi(e2, t, s2, i2, n3 = /* @__PURE__ */ new Map()) {
  const r2 = n3.get(t);
  if (r2) {
    if (r2.has(e2))
      return i2 ? [null] : oe((a2 = t, o2 = e2.id, { code: le.CIRCULAR_REEXPORT, id: o2, message: `"${a2}" cannot be exported from ${ie(o2)} as it is a reexport that references itself.` }));
    r2.add(e2);
  } else
    n3.set(t, /* @__PURE__ */ new Set([e2]));
  var a2, o2;
  return e2.getVariableForExportName(t, { importerForSideEffects: s2, isExportAllSearch: i2, searchedNamesAndModules: n3 });
}
function Zi(e2, t, s2) {
  if (e2.module instanceof Qi && e2.module !== s2) {
    const i2 = e2.module.cycles;
    if (i2.size > 0) {
      const n3 = s2.cycles;
      for (const r2 of n3)
        if (i2.has(r2)) {
          t.alternativeReexportModules.set(e2, s2);
          break;
        }
    }
  }
}
function Ji(e2) {
  return e2.endsWith(".js") ? e2.slice(0, -3) : e2;
}
function en(e2, t) {
  return e2.autoId ? `${e2.basePath ? e2.basePath + "/" : ""}${Ji(t)}` : e2.id || "";
}
function tn(e2, t, s2, i2, n3, r2, a2, o2 = "return ") {
  const { _: h3, cnst: l2, getDirectReturnFunction: c3, getFunctionIntro: u2, getPropertyAccess: d3, n: p2, s: f2 } = n3;
  if (!s2)
    return `${p2}${p2}${o2}${function(e3, t2, s3, i3, n4) {
      if (e3.length > 0)
        return e3[0].local;
      for (const { defaultVariableName: e4, id: r3, isChunk: a3, name: o3, namedExportsMode: h4, namespaceVariableName: l3, reexports: c4 } of t2)
        if (c4)
          return sn(o3, c4[0].imported, h4, a3, e4, l3, s3, r3, i3, n4);
    }(e2, t, i2, a2, d3)};`;
  let m3 = "";
  for (const { defaultVariableName: e3, id: n4, isChunk: o3, name: l3, namedExportsMode: u3, namespaceVariableName: f3, reexports: g2 } of t)
    if (g2 && s2) {
      for (const t2 of g2)
        if (t2.reexported !== "*") {
          const s3 = sn(l3, t2.imported, u3, o3, e3, f3, i2, n4, a2, d3);
          if (m3 && (m3 += p2), t2.imported !== "*" && t2.needsLiveBinding) {
            const [e4, i3] = c3([], { functionReturn: true, lineBreakIndent: null, name: null });
            m3 += `Object.defineProperty(exports,${h3}'${t2.reexported}',${h3}{${p2}${r2}enumerable:${h3}true,${p2}${r2}get:${h3}${e4}${s3}${i3}${p2}});`;
          } else
            m3 += `exports${d3(t2.reexported)}${h3}=${h3}${s3};`;
        }
    }
  for (const { exported: t2, local: s3 } of e2) {
    const e3 = `exports${d3(t2)}`, i3 = s3;
    e3 !== i3 && (m3 && (m3 += p2), m3 += `${e3}${h3}=${h3}${i3};`);
  }
  for (const { name: e3, reexports: i3 } of t)
    if (i3 && s2) {
      for (const t2 of i3)
        if (t2.reexported === "*") {
          m3 && (m3 += p2);
          const s3 = `{${p2}${r2}if${h3}(k${h3}!==${h3}'default'${h3}&&${h3}!exports.hasOwnProperty(k))${h3}${an(e3, t2.needsLiveBinding, r2, n3)}${f2}${p2}}`;
          m3 += l2 === "var" && t2.needsLiveBinding ? `Object.keys(${e3}).forEach(${u2(["k"], { isAsync: false, name: null })}${s3});` : `for${h3}(${l2} k in ${e3})${h3}${s3}`;
        }
    }
  return m3 ? `${p2}${p2}${m3}` : "";
}
function sn(e2, t, s2, i2, n3, r2, a2, o2, h3, l2) {
  if (t === "default") {
    if (!i2) {
      const t2 = String(a2(o2)), s3 = js[t2] ? n3 : e2;
      return Gs(t2, h3) ? `${s3}${l2("default")}` : s3;
    }
    return s2 ? `${e2}${l2("default")}` : e2;
  }
  return t === "*" ? (i2 ? !s2 : Hs[String(a2(o2))]) ? r2 : e2 : `${e2}${l2(t)}`;
}
function nn(e2) {
  return e2([["value", "true"]], { lineBreakIndent: null });
}
function rn(e2, t, s2, { _: i2, getObject: n3 }) {
  if (e2) {
    if (t)
      return s2 ? `Object.defineProperties(exports,${i2}${n3([["__esModule", nn(n3)], [null, `[Symbol.toStringTag]:${i2}${hi(n3)}`]], { lineBreakIndent: null })});` : `Object.defineProperty(exports,${i2}'__esModule',${i2}${nn(n3)});`;
    if (s2)
      return `Object.defineProperty(exports,${i2}Symbol.toStringTag,${i2}${hi(n3)});`;
  }
  return "";
}
function on(e2, t, s2, i2, n3, r2, a2, o2) {
  const { _: h3, cnst: l2, n: c3 } = o2, u2 = /* @__PURE__ */ new Set(), d3 = [], p2 = (e3, t2, s3) => {
    u2.add(t2), d3.push(`${l2} ${e3}${h3}=${h3}/*#__PURE__*/${t2}(${s3});`);
  };
  for (const { defaultVariableName: s3, imports: i3, id: n4, isChunk: r3, name: a3, namedExportsMode: o3, namespaceVariableName: h4, reexports: l3 } of e2)
    if (r3) {
      for (const { imported: e3, reexported: t2 } of [...i3 || [], ...l3 || []])
        if (e3 === "*" && t2 !== "*") {
          o3 || p2(h4, "_interopNamespaceDefaultOnly", a3);
          break;
        }
    } else {
      const e3 = String(t(n4));
      let r4 = false, o4 = false;
      for (const { imported: t2, reexported: n5 } of [...i3 || [], ...l3 || []]) {
        let i4, l4;
        t2 === "default" ? r4 || (r4 = true, s3 !== h4 && (l4 = s3, i4 = js[e3])) : t2 === "*" && n5 !== "*" && (o4 || (o4 = true, i4 = Hs[e3], l4 = h4)), i4 && p2(l4, i4, a3);
      }
    }
  return `${Ks(u2, r2, a2, o2, s2, i2, n3)}${d3.length > 0 ? `${d3.join(c3)}${c3}${c3}` : ""}`;
}
function hn(e2) {
  return e2[0] === "." ? Ji(e2) : e2;
}
function cn(e2, t) {
  const s2 = t.map(({ id: e3 }) => e3).filter((e3) => e3 in ln);
  s2.length && e2({ code: "MISSING_NODE_BUILTINS", message: `Creating a browser bundle that depends on Node.js built-in modules (${te(s2)}). You might need to include https://github.com/snowpackjs/rollup-plugin-polyfill-node`, modules: s2 });
}
function dn(e2, t, s2, i2, { _: n3, getPropertyAccess: r2 }) {
  const a2 = e2.split(".");
  a2[0] = (typeof s2 == "function" ? s2(a2[0]) : s2[a2[0]]) || a2[0];
  const o2 = a2.pop();
  let h3 = t, l2 = a2.map((e3) => (h3 += r2(e3), `${h3}${n3}=${n3}${h3}${n3}||${n3}{}`)).concat(`${h3}${r2(o2)}`).join(`,${n3}`) + `${n3}=${n3}${i2}`;
  return a2.length > 0 && (l2 = `(${l2})`), l2;
}
function pn(e2) {
  let t = e2.length;
  for (; t--; ) {
    const { imports: s2, reexports: i2 } = e2[t];
    if (s2 || i2)
      return e2.slice(0, t + 1);
  }
  return [];
}
function En(e2, t, { _: s2, n: i2 }) {
  return e2.length === 0 ? "" : e2.length === 1 ? `exports('${e2[0].name}',${s2}${e2[0].value});${i2}${i2}` : `exports({${i2}` + e2.map(({ name: e3, value: i3 }) => `${t}${e3}:${s2}${i3}`).join(`,${i2}`) + `${i2}});${i2}${i2}`;
}
function bn(e2, t, s2) {
  return e2 ? `${t}${un(e2, s2)}` : "null";
}
function kn(e2) {
  return function(t, s2) {
    return s2.mappings ? new Pn(s2, [t]) : (e2({ code: "SOURCEMAP_BROKEN", message: `Sourcemap is likely to be incorrect: a plugin (${s2.plugin}) was used to transform files, but didn't generate a sourcemap for the transformation. Consult the plugin documentation for help`, plugin: s2.plugin, url: "https://rollupjs.org/guide/en/#warning-sourcemap-is-likely-to-be-incorrect" }), new Pn({ mappings: [], names: [] }, [t]));
  };
}
function wn(e2, t, s2, i2, n3) {
  let r2;
  if (s2) {
    const t2 = s2.sources, i3 = s2.sourcesContent || [], n4 = $(e2) || ".", a2 = s2.sourceRoot || ".", o2 = t2.map((e3, t3) => new An(M(n4, a2, e3), i3[t3]));
    r2 = new Pn(s2, o2);
  } else
    r2 = new An(e2, t);
  return i2.reduce(n3, r2);
}
function Nn(e2, t) {
  if (!e2)
    throw new Error(t || "Assertion failed");
}
function Rn(e2, t) {
  return (64512 & e2.charCodeAt(t)) == 55296 && (!(t < 0 || t + 1 >= e2.length) && (64512 & e2.charCodeAt(t + 1)) == 56320);
}
function Mn(e2) {
  return (e2 >>> 24 | e2 >>> 8 & 65280 | e2 << 8 & 16711680 | (255 & e2) << 24) >>> 0;
}
function Dn(e2) {
  return e2.length === 1 ? "0" + e2 : e2;
}
function Ln(e2) {
  return e2.length === 7 ? "0" + e2 : e2.length === 6 ? "00" + e2 : e2.length === 5 ? "000" + e2 : e2.length === 4 ? "0000" + e2 : e2.length === 3 ? "00000" + e2 : e2.length === 2 ? "000000" + e2 : e2.length === 1 ? "0000000" + e2 : e2;
}
function Fn() {
  this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
}
function Un(e2, t, s2) {
  return e2 & t ^ ~e2 & s2;
}
function jn(e2, t, s2) {
  return e2 & t ^ e2 & s2 ^ t & s2;
}
function Gn(e2, t, s2) {
  return e2 ^ t ^ s2;
}
function or() {
  if (!(this instanceof or))
    return new or();
  rr.call(this), this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], this.k = ar, this.W = new Array(64);
}
function dr(e2, t, s2, i2, n3, r2, a2, o2, h3, l2, c3, u2, d3) {
  const p2 = e2.slice().reverse();
  for (const e3 of p2)
    e3.scope.addUsedOutsideNames(i2, n3, c3, u2);
  !function(e3, t2, s3) {
    for (const i3 of t2) {
      for (const t3 of i3.scope.variables.values())
        t3.included && !(t3.renderBaseName || t3 instanceof ki && t3.getOriginalVariable() !== t3) && t3.setRenderNames(null, Tt(t3.name, e3));
      if (s3.has(i3)) {
        const t3 = i3.namespace;
        t3.setRenderNames(null, Tt(t3.name, e3));
      }
    }
  }(i2, p2, d3), ur[n3](i2, s2, t, r2, a2, o2, h3, l2);
  for (const e3 of p2)
    e3.scope.deconflict(n3, c3, u2);
}
function pr(e2, t, s2, i2, n3, r2, a2, o2) {
  for (const t2 of s2.dependencies)
    (n3 || t2 instanceof ke) && (t2.variableName = Tt(t2.suggestedVariableName, e2));
  for (const s3 of t) {
    const t2 = s3.module, i3 = s3.name;
    s3.isNamespace && (n3 || t2 instanceof ke) ? s3.setRenderNames(null, (t2 instanceof ke ? t2 : a2.get(t2)).variableName) : t2 instanceof ke && i3 === "default" ? s3.setRenderNames(null, Tt([...t2.exportedVariables].some(([e3, t3]) => t3 === "*" && e3.included) ? t2.suggestedVariableName + "__default" : t2.suggestedVariableName, e2)) : s3.setRenderNames(null, Tt(i3, e2));
  }
  for (const t2 of o2)
    t2.setRenderNames(null, Tt(t2.name, e2));
}
function fr(e2, t, { deconflictedDefault: s2, deconflictedNamespace: i2, dependencies: n3 }, r2, a2, o2, h3) {
  for (const t2 of n3)
    t2.variableName = Tt(t2.suggestedVariableName, e2);
  for (const t2 of i2)
    t2.namespaceVariableName = Tt(`${t2.suggestedVariableName}__namespace`, e2);
  for (const t2 of s2)
    i2.has(t2) && qs2(String(r2(t2.id)), o2) ? t2.defaultVariableName = t2.namespaceVariableName : t2.defaultVariableName = Tt(`${t2.suggestedVariableName}__default`, e2);
  for (const e3 of t) {
    const t2 = e3.module;
    if (t2 instanceof ke) {
      const s3 = e3.name;
      if (s3 === "default") {
        const s4 = String(r2(t2.id)), i3 = js[s4] ? t2.defaultVariableName : t2.variableName;
        Gs(s4, o2) ? e3.setRenderNames(i3, "default") : e3.setRenderNames(null, i3);
      } else
        s3 === "*" ? e3.setRenderNames(null, Hs[String(r2(t2.id))] ? t2.namespaceVariableName : t2.variableName) : e3.setRenderNames(t2.variableName, null);
    } else {
      const s3 = h3.get(t2);
      a2 && e3.isNamespace ? e3.setRenderNames(null, s3.exportMode === "default" ? s3.namespaceVariableName : s3.variableName) : s3.exportMode === "default" ? e3.setRenderNames(null, s3.variableName) : e3.setRenderNames(s3.variableName, s3.getVariableExportName(e3));
    }
  }
}
function Er(e2) {
  return e2.match(mr) ? e2.replace(yr, "\\\\").replace(gr, "\\$1") : e2;
}
function xr(e2, { exports: t, name: s2, format: i2 }, n3, r2, a2) {
  const o2 = e2.getExportNames();
  if (t === "default") {
    if (o2.length !== 1 || o2[0] !== "default")
      return oe(ue("default", o2, r2));
  } else if (t === "none" && o2.length)
    return oe(ue("none", o2, r2));
  return t === "auto" && (o2.length === 0 ? t = "none" : o2.length === 1 && o2[0] === "default" ? (i2 === "cjs" && n3.has("exports") && a2(function(e3) {
    const t2 = ie(e3);
    return { code: le.PREFER_NAMED_EXPORTS, id: e3, message: `Entry module "${t2}" is implicitly using "default" export mode, which means for CommonJS output that its default export is assigned to "module.exports". For many tools, such CommonJS output will not be interchangeable with the original ES module. If this is intended, explicitly set "output.exports" to either "auto" or "default", otherwise you might want to consider changing the signature of "${t2}" to use named exports only.`, url: "https://rollupjs.org/guide/en/#outputexports" };
  }(r2)), t = "default") : (i2 !== "es" && i2 !== "system" && o2.includes("default") && a2(function(e3, t2) {
    return { code: le.MIXED_EXPORTS, id: e3, message: `Entry module "${ie(e3)}" is using named and default exports together. Consumers of your bundle will have to use \`${t2 || "chunk"}["default"]\` to access the default export, which may not be what you want. Use \`output.exports: "named"\` to disable this warning`, url: "https://rollupjs.org/guide/en/#outputexports" };
  }(r2, s2)), t = "named")), t;
}
function vr(e2) {
  const t = e2.split("\n"), s2 = t.filter((e3) => /^\t+/.test(e3)), i2 = t.filter((e3) => /^ {2,}/.test(e3));
  if (s2.length === 0 && i2.length === 0)
    return null;
  if (s2.length >= i2.length)
    return "	";
  const n3 = i2.reduce((e3, t2) => {
    const s3 = /^ +/.exec(t2)[0].length;
    return Math.min(s3, e3);
  }, 1 / 0);
  return new Array(n3 + 1).join(" ");
}
function br(e2, t, s2, i2, n3) {
  const r2 = e2.getDependenciesToBeIncluded();
  for (const e3 of r2) {
    if (e3 instanceof ke) {
      t.push(e3);
      continue;
    }
    const r3 = n3.get(e3);
    r3 === i2 ? s2.has(e3) || (s2.add(e3), br(e3, t, s2, i2, n3)) : t.push(r3);
  }
}
function Sr(e2) {
  if (!e2)
    return null;
  if (typeof e2 == "string" && (e2 = JSON.parse(e2)), e2.mappings === "")
    return { mappings: [], names: [], sources: [], version: 3 };
  const s2 = typeof e2.mappings == "string" ? function(e3) {
    for (var s3 = [], i2 = [], r2 = [0, 0, 0, 0, 0], a2 = 0, o2 = 0, h3 = 0, l2 = 0; o2 < e3.length; o2++) {
      var c3 = e3.charCodeAt(o2);
      if (c3 === 44)
        n2(i2, r2, a2), a2 = 0;
      else if (c3 === 59)
        n2(i2, r2, a2), a2 = 0, s3.push(i2), i2 = [], r2[0] = 0;
      else {
        var u2 = t[c3];
        if (u2 === void 0)
          throw new Error("Invalid character (" + String.fromCharCode(c3) + ")");
        var d3 = 32 & u2;
        if (l2 += (u2 &= 31) << h3, d3)
          h3 += 5;
        else {
          var p2 = 1 & l2;
          l2 >>>= 1, p2 && (l2 = l2 === 0 ? -2147483648 : -l2), r2[a2] += l2, a2++, l2 = h3 = 0;
        }
      }
    }
    return n2(i2, r2, a2), s3.push(i2), s3;
  }(e2.mappings) : e2.mappings;
  return __spreadProps2(__spreadValues2({}, e2), { mappings: s2 });
}
function Ar(e2, t, s2) {
  return ne(e2) ? oe(ye(`Invalid pattern "${e2}" for "${t}", patterns can be neither absolute nor relative paths.`)) : e2.replace(/\[(\w+)\]/g, (e3, i2) => {
    if (!s2.hasOwnProperty(i2))
      return oe(ye(`"[${i2}]" is not a valid placeholder in "${t}" pattern.`));
    const n3 = s2[i2]();
    return ne(n3) ? oe(ye(`Invalid substitution "${n3}" for placeholder "[${i2}]" in "${t}" pattern, can be neither absolute nor relative path.`)) : n3;
  });
}
function Pr(e2, t) {
  const s2 = new Set(Object.keys(t).map((e3) => e3.toLowerCase()));
  if (!s2.has(e2.toLocaleLowerCase()))
    return e2;
  const i2 = T(e2);
  e2 = e2.substring(0, e2.length - i2.length);
  let n3, r2 = 1;
  for (; s2.has((n3 = e2 + ++r2 + i2).toLowerCase()); )
    ;
  return n3;
}
function wr(e2, t, s2, i2) {
  const n3 = typeof t == "function" ? t(e2.id) : t[e2.id];
  return n3 || (s2 ? (i2({ code: "MISSING_GLOBAL_NAME", guess: e2.variableName, message: `No name was provided for external module '${e2.id}' in output.globals \u2013 guessing '${e2.variableName}'`, source: e2.id }), e2.variableName) : void 0);
}
function Ir(e2) {
  var t, s2, i2, n3;
  return (n3 = (s2 = (t = e2.chunkNames.find(({ isUserDefined: e3 }) => e3)) === null || t === void 0 ? void 0 : t.name) !== null && s2 !== void 0 ? s2 : (i2 = e2.chunkNames[0]) === null || i2 === void 0 ? void 0 : i2.name) !== null && n3 !== void 0 ? n3 : se(e2.id);
}
function _r(e2, t, s2) {
  e2 in t && s2(function(e3) {
    return { code: le.FILE_NAME_CONFLICT, message: `The emitted file "${e3}" overwrites a previously emitted file of the same name.` };
  }(e2)), t[e2] = $r;
}
function Tr(e2, t, s2) {
  if (!(typeof e2 == "string" || e2 instanceof Uint8Array)) {
    const e3 = t.fileName || t.name || s2;
    return oe(ye(`Could not set source for ${typeof e3 == "string" ? `asset "${e3}"` : "unnamed asset"}, asset source needs to be a string, Uint8Array or Buffer.`));
  }
  return e2;
}
function Rr(e2, t) {
  return typeof e2.fileName != "string" ? oe((s2 = e2.name || t, { code: le.ASSET_NOT_FINALISED, message: `Plugin error - Unable to get file name for asset "${s2}". Ensure that the source is set and that generate is called first.` })) : e2.fileName;
  var s2;
}
function Mr(e2, t) {
  var s2;
  const i2 = e2.fileName || e2.module && ((s2 = t == null ? void 0 : t.get(e2.module)) === null || s2 === void 0 ? void 0 : s2.id);
  return i2 || oe((n3 = e2.fileName || e2.name, { code: le.CHUNK_NOT_GENERATED, message: `Plugin error - Unable to get file name for chunk "${n3}". Ensure that generate is called first.` }));
  var n3;
}
function Lr(e2, t) {
  if (typeof e2 == "string")
    return e2 === t;
  if (typeof t == "string")
    return false;
  if ("equals" in e2)
    return e2.equals(t);
  if (e2.length !== t.length)
    return false;
  for (let s2 = 0; s2 < e2.length; s2++)
    if (e2[s2] !== t[s2])
      return false;
  return true;
}
function Br(e2, t) {
  const s2 = [], i2 = new Set(t.keys()), n3 = /* @__PURE__ */ Object.create(null);
  for (const [e3, s3] of t) {
    Fr(e3, n3[s3] = n3[s3] || [], i2);
  }
  for (const [e3, t2] of Object.entries(n3))
    s2.push({ alias: e3, modules: t2 });
  const r2 = /* @__PURE__ */ new Map(), { dependentEntryPointsByModule: a2, dynamicEntryModules: o2 } = function(e3) {
    const t2 = /* @__PURE__ */ new Set(), s3 = /* @__PURE__ */ new Map(), i3 = new Set(e3);
    for (const e4 of i3) {
      const n4 = /* @__PURE__ */ new Set([e4]);
      for (const r3 of n4) {
        D(s3, r3, () => /* @__PURE__ */ new Set()).add(e4);
        for (const e5 of r3.getDependenciesToBeIncluded())
          e5 instanceof ke || n4.add(e5);
        for (const { resolution: e5 } of r3.dynamicImports)
          e5 instanceof Qi && e5.includedDynamicImporters.length > 0 && (t2.add(e5), i3.add(e5));
        for (const e5 of r3.implicitlyLoadedBefore)
          t2.add(e5), i3.add(e5);
      }
    }
    return { dependentEntryPointsByModule: s3, dynamicEntryModules: t2 };
  }(e2), h3 = function(e3, t2) {
    const s3 = /* @__PURE__ */ new Map();
    for (const i3 of t2) {
      const t3 = D(s3, i3, () => /* @__PURE__ */ new Set());
      for (const s4 of [...i3.includedDynamicImporters, ...i3.implicitlyLoadedAfter])
        for (const i4 of e3.get(s4))
          t3.add(i4);
    }
    return s3;
  }(a2, o2), l2 = new Set(e2);
  function c3(e3, t2) {
    const s3 = /* @__PURE__ */ new Set([e3]);
    for (const n4 of s3) {
      const o3 = D(r2, n4, () => /* @__PURE__ */ new Set());
      if (!t2 || !u2(t2, a2.get(n4))) {
        o3.add(e3);
        for (const e4 of n4.getDependenciesToBeIncluded())
          e4 instanceof ke || i2.has(e4) || s3.add(e4);
      }
    }
  }
  function u2(e3, t2) {
    const s3 = new Set(e3);
    for (const e4 of s3)
      if (!t2.has(e4)) {
        if (l2.has(e4))
          return false;
        const t3 = h3.get(e4);
        for (const e5 of t3)
          s3.add(e5);
      }
    return true;
  }
  for (const t2 of e2)
    i2.has(t2) || c3(t2, null);
  for (const e3 of o2)
    i2.has(e3) || c3(e3, h3.get(e3));
  return s2.push(...function(e3, t2) {
    const s3 = /* @__PURE__ */ Object.create(null);
    for (const [i3, n4] of t2) {
      let t3 = "";
      for (const s4 of e3)
        t3 += n4.has(s4) ? "X" : "_";
      const r3 = s3[t3];
      r3 ? r3.push(i3) : s3[t3] = [i3];
    }
    return Object.values(s3).map((e4) => ({ alias: null, modules: e4 }));
  }([...e2, ...o2], r2)), s2;
}
function Fr(e2, t, s2) {
  const i2 = /* @__PURE__ */ new Set([e2]);
  for (const e3 of i2) {
    s2.add(e3), t.push(e3);
    for (const t2 of e3.dependencies)
      t2 instanceof ke || s2.has(t2) || i2.add(t2);
  }
}
function Wr(e2, t, s2) {
  const i2 = Symbol(e2.id), n3 = [ie(e2.id)];
  let r2 = t;
  for (e2.cycles.add(i2); r2 !== e2; )
    r2.cycles.add(i2), n3.push(ie(r2.id)), r2 = s2.get(r2);
  return n3.push(n3[0]), n3.reverse(), n3;
}
function Hr(e2) {
  return [...e2.values()].filter((e3) => e3 instanceof Qi && (e3.isIncluded() || e3.info.isEntry || e3.includedDynamicImporters.length > 0));
}
function qr(e2, t, s2) {
  const i2 = s2.get(t);
  if (typeof i2 == "string" && i2 !== e2)
    return oe((n3 = t.id, r2 = e2, a2 = i2, { code: le.INVALID_CHUNK, message: `Cannot assign ${ie(n3)} to the "${r2}" chunk as it is already in the "${a2}" chunk.` }));
  var n3, r2, a2;
  s2.set(t, e2);
}
function na(e2, t) {
  for (var s2 = 65536, i2 = 0; i2 < t.length; i2 += 2) {
    if ((s2 += t[i2]) > e2)
      return false;
    if ((s2 += t[i2 + 1]) >= e2)
      return true;
  }
}
function ra(e2, t) {
  return e2 < 65 ? e2 === 36 : e2 < 91 || (e2 < 97 ? e2 === 95 : e2 < 123 || (e2 <= 65535 ? e2 >= 170 && ea.test(String.fromCharCode(e2)) : t !== false && na(e2, sa)));
}
function aa(e2, t) {
  return e2 < 48 ? e2 === 36 : e2 < 58 || !(e2 < 65) && (e2 < 91 || (e2 < 97 ? e2 === 95 : e2 < 123 || (e2 <= 65535 ? e2 >= 170 && ta.test(String.fromCharCode(e2)) : t !== false && (na(e2, sa) || na(e2, ia)))));
}
function ha(e2, t) {
  return new oa(e2, { beforeExpr: true, binop: t });
}
function da(e2, t) {
  return t === void 0 && (t = {}), t.keyword = e2, ua[e2] = new oa(e2, t);
}
function ga(e2) {
  return e2 === 10 || e2 === 13 || e2 === 8232 || e2 === 8233;
}
function ya(e2, t, s2) {
  s2 === void 0 && (s2 = e2.length);
  for (var i2 = t; i2 < s2; i2++) {
    var n3 = e2.charCodeAt(i2);
    if (ga(n3))
      return i2 < s2 - 1 && n3 === 13 && e2.charCodeAt(i2 + 1) === 10 ? i2 + 2 : i2 + 1;
  }
  return -1;
}
function ka(e2) {
  return new RegExp("^(?:" + e2.replace(/ /g, "|") + ")$");
}
function Na(e2, t) {
  for (var s2 = 1, i2 = 0; ; ) {
    var n3 = ya(e2, i2, t);
    if (n3 < 0)
      return new Ca(s2, t - i2);
    ++s2, i2 = n3;
  }
}
function Ta(e2) {
  var t = {};
  for (var s2 in _a)
    t[s2] = e2 && Aa(e2, s2) ? e2[s2] : _a[s2];
  if (t.ecmaVersion === "latest" ? t.ecmaVersion = 1e8 : t.ecmaVersion == null ? (!$a && typeof console == "object" && console.warn && ($a = true, console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.")), t.ecmaVersion = 11) : t.ecmaVersion >= 2015 && (t.ecmaVersion -= 2009), t.allowReserved == null && (t.allowReserved = t.ecmaVersion < 5), Pa(t.onToken)) {
    var i2 = t.onToken;
    t.onToken = function(e3) {
      return i2.push(e3);
    };
  }
  return Pa(t.onComment) && (t.onComment = function(e3, t2) {
    return function(s3, i3, n3, r2, a2, o2) {
      var h3 = { type: s3 ? "Block" : "Line", value: i3, start: n3, end: r2 };
      e3.locations && (h3.loc = new Ia(this, a2, o2)), e3.ranges && (h3.range = [n3, r2]), t2.push(h3);
    };
  }(t, t.onComment)), t;
}
function Ra(e2, t) {
  return 2 | (e2 ? 4 : 0) | (t ? 8 : 0);
}
function Va() {
  this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
}
function Ga(e2, t) {
  var s2 = t.key.name, i2 = e2[s2], n3 = "true";
  return t.type !== "MethodDefinition" || t.kind !== "get" && t.kind !== "set" || (n3 = (t.static ? "s" : "i") + t.kind), i2 === "iget" && n3 === "iset" || i2 === "iset" && n3 === "iget" || i2 === "sget" && n3 === "sset" || i2 === "sset" && n3 === "sget" ? (e2[s2] = "true", false) : !!i2 || (e2[s2] = n3, false);
}
function Ha(e2, t) {
  var s2 = e2.computed, i2 = e2.key;
  return !s2 && (i2.type === "Identifier" && i2.name === t || i2.type === "Literal" && i2.value === t);
}
function Za(e2) {
  return e2.type === "MemberExpression" && e2.property.type === "PrivateIdentifier" || e2.type === "ChainExpression" && Za(e2.expression);
}
function ro(e2, t, s2, i2) {
  return e2.type = t, e2.end = s2, this.options.locations && (e2.loc.end = i2), this.options.ranges && (e2.range[1] = s2), e2;
}
function Eo(e2) {
  var t = yo[e2] = { binary: ka(lo[e2] + " " + co), nonBinary: { General_Category: ka(co), Script: ka(go[e2]) } };
  t.nonBinary.Script_Extensions = t.nonBinary.Script, t.nonBinary.gc = t.nonBinary.General_Category, t.nonBinary.sc = t.nonBinary.Script, t.nonBinary.scx = t.nonBinary.Script_Extensions;
}
function Ao(e2) {
  return e2 <= 65535 ? String.fromCharCode(e2) : (e2 -= 65536, String.fromCharCode(55296 + (e2 >> 10), 56320 + (1023 & e2)));
}
function Po(e2) {
  return e2 === 36 || e2 >= 40 && e2 <= 43 || e2 === 46 || e2 === 63 || e2 >= 91 && e2 <= 94 || e2 >= 123 && e2 <= 125;
}
function ko(e2) {
  return e2 >= 65 && e2 <= 90 || e2 >= 97 && e2 <= 122;
}
function wo(e2) {
  return ko(e2) || e2 === 95;
}
function Co(e2) {
  return wo(e2) || Io(e2);
}
function Io(e2) {
  return e2 >= 48 && e2 <= 57;
}
function No(e2) {
  return e2 >= 48 && e2 <= 57 || e2 >= 65 && e2 <= 70 || e2 >= 97 && e2 <= 102;
}
function _o(e2) {
  return e2 >= 65 && e2 <= 70 ? e2 - 65 + 10 : e2 >= 97 && e2 <= 102 ? e2 - 97 + 10 : e2 - 48;
}
function $o(e2) {
  return e2 >= 48 && e2 <= 55;
}
function Mo(e2) {
  return typeof BigInt != "function" ? null : BigInt(e2.replace(/_/g, ""));
}
function Do(e2) {
  return e2 <= 65535 ? String.fromCharCode(e2) : (e2 -= 65536, String.fromCharCode(55296 + (e2 >> 10), 56320 + (1023 & e2)));
}
async function Fo(e2, t, s2, i2, n3, r2, a2, o2) {
  const h3 = await function(e3, t2, s3, i3, n4, r3, a3) {
    let o3 = null, h4 = null;
    if (n4) {
      o3 = /* @__PURE__ */ new Set();
      for (const s4 of n4)
        e3 === s4.source && t2 === s4.importer && o3.add(s4.plugin);
      h4 = (e4, t3) => __spreadProps2(__spreadValues2({}, e4), { resolve: (e5, s4, { custom: r4, isEntry: a4, skipSelf: o4 } = Y) => i3(e5, s4, r4, a4, o4 ? [...n4, { importer: s4, plugin: t3, source: e5 }] : n4) });
    }
    return s3.hookFirst("resolveId", [e3, t2, { custom: r3, isEntry: a3 }], h4, o3);
  }(e2, t, i2, n3, r2, a2, o2);
  return h3;
}
function zo(e2, t, { hook: s2, id: i2 } = {}) {
  return typeof e2 == "string" && (e2 = { message: e2 }), e2.code && e2.code !== le.PLUGIN_ERROR && (e2.pluginCode = e2.code), e2.code = le.PLUGIN_ERROR, e2.plugin = t, s2 && (e2.hook = s2), i2 && (e2.id = i2), oe(e2);
}
function jo(e2) {
  return e2.startsWith("at position ") || e2.startsWith("at output position ") ? oe({ code: "ANONYMOUS_PLUGIN_CACHE", message: "A plugin is trying to use the Rollup cache but is not declaring a plugin name or cacheKey." }) : oe({ code: "DUPLICATE_PLUGIN_NAME", message: `The plugin name ${e2} is being used twice in the same build. Plugin names must be distinct or provide a cacheKey (please post an issue to the plugin if you are a plugin user).` });
}
async function Go(e2, t, s2, i2) {
  const n3 = t.id, r2 = [];
  let a2 = e2.map === null ? null : Sr(e2.map);
  const o2 = e2.code;
  let h3 = e2.ast;
  const c3 = [], u2 = [];
  let d3 = false;
  const p2 = () => d3 = true;
  let f2 = "";
  const m3 = e2.code;
  let g2;
  try {
    g2 = await s2.hookReduceArg0("transform", [m3, n3], function(e3, s3, n4) {
      let a3, o3;
      if (typeof s3 == "string")
        a3 = s3;
      else {
        if (!s3 || typeof s3 != "object")
          return e3;
        if (t.updateOptions(s3), s3.code == null)
          return (s3.map || s3.ast) && i2(function(e4) {
            return { code: le.NO_TRANSFORM_MAP_OR_AST_WITHOUT_CODE, message: `The plugin "${e4}" returned a "map" or "ast" without returning a "code". This will be ignored.` };
          }(n4.name)), e3;
        ({ code: a3, map: o3, ast: h3 } = s3);
      }
      return o3 !== null && r2.push(Sr(typeof o3 == "string" ? JSON.parse(o3) : o3) || { missing: true, plugin: n4.name }), a3;
    }, (e3, t2) => {
      return f2 = t2.name, __spreadProps2(__spreadValues2({}, e3), { addWatchFile(t3) {
        c3.push(t3), e3.addWatchFile(t3);
      }, cache: d3 ? e3.cache : (h4 = e3.cache, g3 = p2, { delete: (e4) => (g3(), h4.delete(e4)), get: (e4) => (g3(), h4.get(e4)), has: (e4) => (g3(), h4.has(e4)), set: (e4, t3) => (g3(), h4.set(e4, t3)) }), emitAsset: (t3, s3) => (u2.push({ name: t3, source: s3, type: "asset" }), e3.emitAsset(t3, s3)), emitChunk: (t3, s3) => (u2.push({ id: t3, name: s3 && s3.name, type: "chunk" }), e3.emitChunk(t3, s3)), emitFile: (e4) => (u2.push(e4), s2.emitFile(e4)), error: (t3, s3) => (typeof t3 == "string" && (t3 = { message: t3 }), s3 && he(t3, s3, m3, n3), t3.id = n3, t3.hook = "transform", e3.error(t3)), getCombinedSourcemap() {
        const e4 = function(e5, t3, s3, i3, n4) {
          return i3.length ? __spreadValues2({ version: 3 }, wn(e5, t3, s3, i3, kn(n4)).traceMappings()) : s3;
        }(n3, o2, a2, r2, i2);
        if (!e4) {
          return new b(o2).generateMap({ hires: true, includeContent: true, source: n3 });
        }
        return a2 !== e4 && (a2 = e4, r2.length = 0), new l(__spreadProps2(__spreadValues2({}, e4), { file: null, sourcesContent: e4.sourcesContent }));
      }, setAssetSource() {
        return this.error({ code: "INVALID_SETASSETSOURCE", message: "setAssetSource cannot be called in transform for caching reasons. Use emitFile with a source, or call setAssetSource in another hook." });
      }, warn(t3, s3) {
        typeof t3 == "string" && (t3 = { message: t3 }), s3 && he(t3, s3, m3, n3), t3.id = n3, t3.hook = "transform", e3.warn(t3);
      } });
      var h4, g3;
    });
  } catch (e3) {
    zo(e3, f2, { hook: "transform", id: n3 });
  }
  return d3 || u2.length && (t.transformFiles = u2), { ast: h3, code: g2, customTransformCache: d3, originalCode: o2, originalSourcemap: a2, sourcemapChain: r2, transformDependencies: c3 };
}
function qo(e2, t) {
  return I(e2) ? t ? M(t, "..", e2) : M(e2) : e2;
}
function Ko(e2, { fileName: t, name: s2 }, i2, n3) {
  var r2;
  if (t !== null)
    e2.chunkFileNames.add(t);
  else if (s2 !== null) {
    let t2 = 0;
    for (; ((r2 = e2.chunkNames[t2]) === null || r2 === void 0 ? void 0 : r2.priority) < n3; )
      t2++;
    e2.chunkNames.splice(t2, 0, { isUserDefined: i2, name: s2, priority: n3 });
  }
}
function Xo(e2, t, s2) {
  return s2 === true || s2 === "ifRelativeSource" && I(t) || !C2(e2);
}
async function Yo(e2) {
  const [t, s2] = await e2;
  return Promise.all([...t, ...s2]);
}
function Zo(e2, t, s2, i2, n3, r2) {
  let a2 = false;
  return (...o2) => (a2 || (a2 = true, xe({ message: `The "this.${t}" plugin context function used by plugin ${i2} is deprecated. The "this.${s2}" plugin context function should be used instead.`, plugin: i2 }, n3, r2)), e2(...o2));
}
function Jo(e2, t, s2, i2, n3, r2) {
  let a2, o2 = true;
  if (typeof e2.cacheKey != "string" && (e2.name.startsWith("at position ") || e2.name.startsWith("at output position ") || r2.has(e2.name) ? o2 = false : r2.add(e2.name)), t)
    if (o2) {
      const s3 = e2.cacheKey || e2.name;
      l2 = t[s3] || (t[s3] = /* @__PURE__ */ Object.create(null)), a2 = { delete: (e3) => delete l2[e3], get(e3) {
        const t2 = l2[e3];
        if (t2)
          return t2[0] = 0, t2[1];
      }, has(e3) {
        const t2 = l2[e3];
        return !!t2 && (t2[0] = 0, true);
      }, set(e3, t2) {
        l2[e3] = [0, t2];
      } };
    } else
      h3 = e2.name, a2 = { delete: () => jo(h3), get: () => jo(h3), has: () => jo(h3), set: () => jo(h3) };
  else
    a2 = Uo;
  var h3, l2;
  const c3 = { addWatchFile(e3) {
    if (s2.phase >= Mi.GENERATE)
      return this.error({ code: le.INVALID_ROLLUP_PHASE, message: "Cannot call addWatchFile after the build has finished." });
    s2.watchFiles[e3] = true;
  }, cache: a2, emitAsset: Zo((e3, t2) => n3.emitFile({ name: e3, source: t2, type: "asset" }), "emitAsset", "emitFile", e2.name, true, i2), emitChunk: Zo((e3, t2) => n3.emitFile({ id: e3, name: t2 && t2.name, type: "chunk" }), "emitChunk", "emitFile", e2.name, true, i2), emitFile: n3.emitFile.bind(n3), error: (t2) => zo(t2, e2.name), getAssetFileName: Zo(n3.getFileName, "getAssetFileName", "getFileName", e2.name, true, i2), getChunkFileName: Zo(n3.getFileName, "getChunkFileName", "getFileName", e2.name, true, i2), getFileName: n3.getFileName, getModuleIds: () => s2.modulesById.keys(), getModuleInfo: s2.getModuleInfo, getWatchFiles: () => Object.keys(s2.watchFiles), isExternal: Zo((e3, t2, s3 = false) => i2.external(e3, t2, s3), "isExternal", "resolve", e2.name, true, i2), load: (e3) => s2.moduleLoader.preloadModule(e3), meta: { rollupVersion: "2.70.1", watchMode: s2.watchMode }, get moduleIds() {
    const t2 = s2.modulesById.keys();
    return function* () {
      xe({ message: `Accessing "this.moduleIds" on the plugin context by plugin ${e2.name} is deprecated. The "this.getModuleIds" plugin context function should be used instead.`, plugin: e2.name }, false, i2), yield* t2;
    }();
  }, parse: s2.contextParse.bind(s2), resolve: (t2, i3, { custom: n4, isEntry: r3, skipSelf: a3 } = Y) => s2.moduleLoader.resolveId(t2, i3, n4, r3, a3 ? [{ importer: i3, plugin: e2, source: t2 }] : null), resolveId: Zo((e3, t2) => s2.moduleLoader.resolveId(e3, t2, Y, void 0).then((e4) => e4 && e4.id), "resolveId", "resolve", e2.name, true, i2), setAssetSource: n3.setAssetSource, warn(t2) {
    typeof t2 == "string" && (t2 = { message: t2 }), t2.code && (t2.pluginCode = t2.code), t2.code = "PLUGIN_WARNING", t2.plugin = e2.name, i2.onwarn(t2);
  } };
  return c3;
}
function th(e2, t) {
  return oe({ code: "INVALID_PLUGIN_HOOK", message: `Error running plugin hook ${e2} for ${t}, expected a function hook.` });
}
function nh(e2) {
  return Array.isArray(e2) ? e2.filter(Boolean) : e2 ? [e2] : [];
}
function rh(e2, t) {
  return t();
}
function oh(e2, t, s2, i2, n3 = /$./) {
  const r2 = new Set(t), a2 = Object.keys(e2).filter((e3) => !(r2.has(e3) || n3.test(e3)));
  a2.length > 0 && i2({ code: "UNKNOWN_OPTION", message: `Unknown ${s2}: ${a2.join(", ")}. Allowed options: ${[...r2].sort().join(", ")}` });
}
function Ih(e2) {
  const t = Ch.exec(e2), s2 = t ? t[0] : "";
  return s2 + e2.substr(s2.length).replace(wh, "_");
}
function Fh(e2, t) {
  const s2 = e2.exports;
  if (s2 == null)
    t.add("exports");
  else if (!["default", "named", "none", "auto"].includes(s2))
    return oe((i2 = s2, { code: le.INVALID_EXPORT_OPTION, message: `"output.exports" must be "default", "named", "none", "auto", or left unspecified (defaults to "auto"), received "${i2}"`, url: "https://rollupjs.org/guide/en/#outputexports" }));
  var i2;
  return s2 || "auto";
}
function Kh(e2) {
  return async function(e3, t) {
    const { options: s2, unsetOptions: i2 } = await async function(e4, t2) {
      if (!e4)
        throw new Error("You must supply an options object to rollup");
      const s3 = nh(e4.plugins), { options: i3, unsetOptions: n4 } = function(e5) {
        var t3, s4, i4;
        const n5 = /* @__PURE__ */ new Set(), r3 = (t3 = e5.context) !== null && t3 !== void 0 ? t3 : "undefined", a3 = dh(e5), o2 = e5.strictDeprecations || false, h3 = { acorn: ph(e5), acornInjectPlugins: fh(e5), cache: mh(e5), context: r3, experimentalCacheExpiry: (s4 = e5.experimentalCacheExpiry) !== null && s4 !== void 0 ? s4 : 10, external: gh(e5.external), inlineDynamicImports: yh(e5, a3, o2), input: Eh(e5), makeAbsoluteExternalsRelative: (i4 = e5.makeAbsoluteExternalsRelative) === null || i4 === void 0 || i4, manualChunks: xh(e5, a3, o2), maxParallelFileReads: vh(e5), moduleContext: bh(e5, r3), onwarn: a3, perf: e5.perf || false, plugins: nh(e5.plugins), preserveEntrySignatures: Sh(e5, n5), preserveModules: Ah(e5, a3, o2), preserveSymlinks: e5.preserveSymlinks || false, shimMissingExports: e5.shimMissingExports || false, strictDeprecations: o2, treeshake: Ph(e5, a3, o2) };
        return oh(e5, [...Object.keys(h3), "watch"], "input options", h3.onwarn, /^(output)$/), { options: h3, unsetOptions: n5 };
      }(await s3.reduce(function(e5) {
        return async (t3, s4) => s4.options && await s4.options.call({ meta: { rollupVersion: "2.70.1", watchMode: e5 } }, await t3) || t3;
      }(t2), Promise.resolve(e4)));
      return Xh(i3.plugins, "at position "), { options: i3, unsetOptions: n4 };
    }(e3, t !== null);
    !function(e4) {
      e4.perf ? (Bi = /* @__PURE__ */ new Map(), ji = zi, Gi = Wi, e4.plugins = e4.plugins.map(qi)) : (ji = Vi, Gi = Vi);
    }(s2);
    const n3 = new ih(s2, t), r2 = e3.cache !== false;
    delete s2.cache, delete e3.cache, ji("BUILD", 1), await rh(n3.pluginDriver, async () => {
      try {
        await n3.pluginDriver.hookParallel("buildStart", [s2]), await n3.build();
      } catch (e4) {
        const t2 = Object.keys(n3.watchFiles);
        throw t2.length > 0 && (e4.watchFiles = t2), await n3.pluginDriver.hookParallel("buildEnd", [e4]), await n3.pluginDriver.hookParallel("closeBundle", []), e4;
      }
      await n3.pluginDriver.hookParallel("buildEnd", []);
    }), Gi("BUILD", 1);
    const a2 = { cache: r2 ? n3.getCache() : void 0, async close() {
      a2.closed || (a2.closed = true, await n3.pluginDriver.hookParallel("closeBundle", []));
    }, closed: false, generate: async (e4) => a2.closed ? oe(Ee()) : Yh(false, s2, i2, e4, n3), watchFiles: Object.keys(n3.watchFiles), write: async (e4) => a2.closed ? oe(Ee()) : Yh(true, s2, i2, e4, n3) };
    s2.perf && (a2.getTimings = Ui);
    return a2;
  }(e2, null);
}
function Xh(e2, t) {
  e2.forEach((e3, s2) => {
    e3.name || (e3.name = `${t}${s2 + 1}`);
  });
}
function Yh(e2, t, s2, i2, n3) {
  const { options: r2, outputPluginDriver: a2, unsetOptions: o2 } = function(e3, t2, s3, i3) {
    if (!e3)
      throw new Error("You must supply an options object");
    const n4 = nh(e3.plugins);
    Xh(n4, "at output position ");
    const r3 = t2.createOutputPluginDriver(n4);
    return __spreadProps2(__spreadValues2({}, Qh(s3, i3, e3, r3)), { outputPluginDriver: r3 });
  }(i2, n3.pluginDriver, t, s2);
  return rh(0, async () => {
    const s3 = new Gr(r2, o2, t, a2, n3), i3 = await s3.generate(e2);
    if (e2) {
      if (!r2.dir && !r2.file)
        return oe({ code: "MISSING_OPTION", message: 'You must specify "output.file" or "output.dir" for the build.' });
      await Promise.all(Object.values(i3).map((e3) => async function(e4, t2) {
        const s4 = M(t2.dir || $(t2.file), e4.fileName);
        let i4, n4;
        if (await Bo.mkdir($(s4), { recursive: true }), e4.type === "asset")
          n4 = e4.source;
        else if (n4 = e4.code, t2.sourcemap && e4.map) {
          let r3;
          t2.sourcemap === "inline" ? r3 = e4.map.toUrl() : (r3 = `${_(e4.fileName)}.map`, i4 = Bo.writeFile(`${s4}.map`, e4.map.toString())), t2.sourcemap !== "hidden" && (n4 += `//# sourceMappingURL=${r3}
`);
        }
        return Promise.all([Bo.writeFile(s4, n4), i4]);
      }(e3, r2))), await a2.hookParallel("writeBundle", [r2, i3]);
    }
    return h3 = i3, { output: Object.values(h3).filter((e3) => Object.keys(e3).length > 0).sort((e3, t2) => {
      const s4 = Jh(e3), i4 = Jh(t2);
      return s4 === i4 ? 0 : s4 < i4 ? -1 : 1;
    }) };
    var h3;
  });
}
function Qh(e2, t, s2, i2) {
  return function(e3, t2, s3) {
    var i3, n3, r2, a2, o2, h3, l2;
    const c3 = new Set(s3), u2 = e3.compact || false, d3 = _h(e3), p2 = $h(e3, t2), f2 = Th(e3, p2, t2), m3 = Nh(e3, f2, t2), g2 = Rh(e3, t2), y3 = zh(e3, g2), E3 = { amd: Dh(e3), assetFileNames: (i3 = e3.assetFileNames) !== null && i3 !== void 0 ? i3 : "assets/[name]-[hash][extname]", banner: Lh(e3, "banner"), chunkFileNames: (n3 = e3.chunkFileNames) !== null && n3 !== void 0 ? n3 : "[name]-[hash].js", compact: u2, dir: Oh(e3, m3), dynamicImportFunction: Vh(e3, t2), entryFileNames: Bh(e3, c3), esModule: (r2 = e3.esModule) === null || r2 === void 0 || r2, exports: Fh(e3, c3), extend: e3.extend || false, externalLiveBindings: (a2 = e3.externalLiveBindings) === null || a2 === void 0 || a2, file: m3, footer: Lh(e3, "footer"), format: d3, freeze: (o2 = e3.freeze) === null || o2 === void 0 || o2, generatedCode: y3, globals: e3.globals || {}, hoistTransitiveImports: (h3 = e3.hoistTransitiveImports) === null || h3 === void 0 || h3, indent: Wh(e3, u2), inlineDynamicImports: p2, interop: jh(e3, t2), intro: Lh(e3, "intro"), manualChunks: Gh(e3, p2, f2, t2), minifyInternalExports: Hh(e3, d3, u2), name: e3.name, namespaceToStringTag: qh(e3, y3, t2), noConflict: e3.noConflict || false, outro: Lh(e3, "outro"), paths: e3.paths || {}, plugins: nh(e3.plugins), preferConst: g2, preserveModules: f2, preserveModulesRoot: Mh(e3), sanitizeFileName: typeof e3.sanitizeFileName == "function" ? e3.sanitizeFileName : e3.sanitizeFileName === false ? (e4) => e4 : Ih, sourcemap: e3.sourcemap || false, sourcemapExcludeSources: e3.sourcemapExcludeSources || false, sourcemapFile: e3.sourcemapFile, sourcemapPathTransform: e3.sourcemapPathTransform, strict: (l2 = e3.strict) === null || l2 === void 0 || l2, systemNullSetters: e3.systemNullSetters || false, validate: e3.validate || false };
    return oh(e3, Object.keys(E3), "output options", t2.onwarn), { options: E3, unsetOptions: c3 };
  }(i2.hookReduceArg0Sync("outputOptions", [s2.output || s2], (e3, t2) => t2 || e3, (e3) => {
    const t2 = () => e3.error({ code: le.CANNOT_EMIT_FROM_OPTIONS_HOOK, message: 'Cannot emit files or set asset sources in the "outputOptions" hook, use the "renderStart" hook instead.' });
    return __spreadProps2(__spreadValues2({}, e3), { emitFile: t2, setAssetSource: t2 });
  }), e2, t);
}
function Jh(e2) {
  return e2.type === "asset" ? Zh.ASSET : e2.isEntry ? Zh.ENTRY_CHUNK : Zh.SECONDARY_CHUNK;
}
function el(e2) {
  return e2;
}
var e2, t, s2, i2, a, o, h2, l, d2, m2, g, y2, E2, x, v, b, S, A2, P, k, w2, L, O, V, B2, F, z, W, U, j, G, H, q, K, X, Y, Q2, Z, re, le, be, Se, Ae, ke, we, Ce, _e, Te, Re, Me, De, Le, Oe, Ve, Be, Fe, ze, We, Ue, Ke, Xe, Ye, Ze, Je, st, nt, rt, at, ot, ht, lt, ct, ut, dt, pt, ft, mt, gt, yt, Et, xt, vt, bt, St, At, Pt, kt, wt, Ct, It, Nt, _t, Rt, Mt, Dt, Lt, Bt, zt, qt, Kt, Xt, Qt, Zt, Jt, es, ts, ss, is, ns, rs, as, hs, ls, cs, ds, ps, ys, Es, xs, vs, bs, Ss, As, Ps, Cs, Is, Ns, _s, $s, Ts, Rs, Ms, Ds, Ls, Os, Vs, Bs, Fs, zs, Ws, Us, js, Gs, Hs, qs2, Ks, Xs, Ys, Qs, Zs, Js, ei, ti, si, ii, ni, ri, ai, oi, ci, ui, di, pi, fi, mi, gi, yi, Ei, xi, vi, bi, Si, Ai, Pi, ki, wi, Ci, Ni, _i, $i, Ti, Ri, Mi, Li, Oi, Vi, Bi, ji, Gi, Hi, Xi, Qi, an, ln, un, fn, mn, gn, yn, xn, vn, Sn, An, Pn, Cn, In, _n, $n, Tn, On, Vn, Bn, zn, Wn, Hn, qn, Kn, Xn, Yn, Qn, Zn, Jn, er, tr, sr, ir, nr, rr, ar, hr, lr, cr, ur, mr, gr, yr, kr, Cr, Nr, $r, Dr, Or, Vr, zr, Ur, jr, Gr, Kr, Xr, Yr, Qr, Zr, Jr, ea, ta, sa, ia, oa, la, ca, ua, pa, fa, ma, Ea, xa, va, ba, Sa, Aa, Pa, wa, Ca, Ia, _a, $a, Ma, Da, La, Oa, Ba, Fa, za, Wa, Ua, ja, qa, Ka, Xa, Ya, Qa, Ja, eo, to, so, io, no, ao, oo, ho, lo, co, uo, po, fo, mo, go, yo, xo, vo, bo, So, To, Ro, Lo, Oo, Vo, Bo, Wo, Uo, Ho, Qo, eh, sh, ih, ah, hh, lh, ch, uh, dh, ph, fh, mh, gh, yh, Eh, xh, vh, bh, Sh, Ah, Ph, kh, wh, Ch, Nh, _h, $h, Th, Rh, Mh, Dh, Lh, Oh, Vh, Bh, zh, Wh, Uh, jh, Gh, Hh, qh, Zh;
var init_rollup_browser = __esm({
  "node_modules/rollup/dist/es/rollup.browser.js"() {
    for (e2 = "2.70.1", t = {}, s2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", i2 = 0; i2 < s2.length; i2++)
      t[s2.charCodeAt(i2)] = i2;
    a = function e(t) {
      this.bits = t instanceof e ? t.bits.slice() : [];
    };
    a.prototype.add = function(e2) {
      this.bits[e2 >> 5] |= 1 << (31 & e2);
    }, a.prototype.has = function(e2) {
      return !!(this.bits[e2 >> 5] & 1 << (31 & e2));
    };
    o = function(e2, t, s2) {
      this.start = e2, this.end = t, this.original = s2, this.intro = "", this.outro = "", this.content = s2, this.storeName = false, this.edited = false, Object.defineProperties(this, { previous: { writable: true, value: null }, next: { writable: true, value: null } });
    };
    o.prototype.appendLeft = function(e2) {
      this.outro += e2;
    }, o.prototype.appendRight = function(e2) {
      this.intro = this.intro + e2;
    }, o.prototype.clone = function() {
      var e2 = new o(this.start, this.end, this.original);
      return e2.intro = this.intro, e2.outro = this.outro, e2.content = this.content, e2.storeName = this.storeName, e2.edited = this.edited, e2;
    }, o.prototype.contains = function(e2) {
      return this.start < e2 && e2 < this.end;
    }, o.prototype.eachNext = function(e2) {
      for (var t = this; t; )
        e2(t), t = t.next;
    }, o.prototype.eachPrevious = function(e2) {
      for (var t = this; t; )
        e2(t), t = t.previous;
    }, o.prototype.edit = function(e2, t, s2) {
      return this.content = e2, s2 || (this.intro = "", this.outro = ""), this.storeName = t, this.edited = true, this;
    }, o.prototype.prependLeft = function(e2) {
      this.outro = e2 + this.outro;
    }, o.prototype.prependRight = function(e2) {
      this.intro = e2 + this.intro;
    }, o.prototype.split = function(e2) {
      var t = e2 - this.start, s2 = this.original.slice(0, t), i2 = this.original.slice(t);
      this.original = s2;
      var n3 = new o(e2, this.end, i2);
      return n3.outro = this.outro, this.outro = "", this.end = e2, this.edited ? (n3.edit("", false), this.content = "") : this.content = s2, n3.next = this.next, n3.next && (n3.next.previous = n3), n3.previous = this, this.next = n3, n3;
    }, o.prototype.toString = function() {
      return this.intro + this.content + this.outro;
    }, o.prototype.trimEnd = function(e2) {
      if (this.outro = this.outro.replace(e2, ""), this.outro.length)
        return true;
      var t = this.content.replace(e2, "");
      return t.length ? (t !== this.content && this.split(this.start + t.length).edit("", void 0, true), true) : (this.edit("", void 0, true), this.intro = this.intro.replace(e2, ""), !!this.intro.length || void 0);
    }, o.prototype.trimStart = function(e2) {
      if (this.intro = this.intro.replace(e2, ""), this.intro.length)
        return true;
      var t = this.content.replace(e2, "");
      return t.length ? (t !== this.content && (this.split(this.end - t.length), this.edit("", void 0, true)), true) : (this.edit("", void 0, true), this.outro = this.outro.replace(e2, ""), !!this.outro.length || void 0);
    };
    h2 = function() {
      throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.");
    };
    typeof window != "undefined" && typeof window.btoa == "function" ? h2 = function(e2) {
      return window.btoa(unescape(encodeURIComponent(e2)));
    } : typeof Buffer == "function" && (h2 = function(e2) {
      return Buffer.from(e2, "utf-8").toString("base64");
    });
    l = function(e2) {
      this.version = 3, this.file = e2.file, this.sources = e2.sources, this.sourcesContent = e2.sourcesContent, this.names = e2.names, this.mappings = function(e3) {
        for (var t = 0, s2 = 0, i2 = 0, n3 = 0, a2 = "", o2 = 0; o2 < e3.length; o2++) {
          var h3 = e3[o2];
          if (o2 > 0 && (a2 += ";"), h3.length !== 0) {
            for (var l2 = 0, c3 = [], u2 = 0, d3 = h3; u2 < d3.length; u2++) {
              var p2 = d3[u2], f2 = r(p2[0] - l2);
              l2 = p2[0], p2.length > 1 && (f2 += r(p2[1] - t) + r(p2[2] - s2) + r(p2[3] - i2), t = p2[1], s2 = p2[2], i2 = p2[3]), p2.length === 5 && (f2 += r(p2[4] - n3), n3 = p2[4]), c3.push(f2);
            }
            a2 += c3.join(",");
          }
        }
        return a2;
      }(e2.mappings);
    };
    l.prototype.toString = function() {
      return JSON.stringify(this);
    }, l.prototype.toUrl = function() {
      return "data:application/json;charset=utf-8;base64," + h2(this.toString());
    };
    d2 = Object.prototype.toString;
    m2 = function(e2) {
      this.hires = e2, this.generatedCodeLine = 0, this.generatedCodeColumn = 0, this.raw = [], this.rawSegments = this.raw[this.generatedCodeLine] = [], this.pending = null;
    };
    m2.prototype.addEdit = function(e2, t, s2, i2) {
      if (t.length) {
        var n3 = [this.generatedCodeColumn, e2, s2.line, s2.column];
        i2 >= 0 && n3.push(i2), this.rawSegments.push(n3);
      } else
        this.pending && this.rawSegments.push(this.pending);
      this.advance(t), this.pending = null;
    }, m2.prototype.addUneditedChunk = function(e2, t, s2, i2, n3) {
      for (var r2 = t.start, a2 = true; r2 < t.end; )
        (this.hires || a2 || n3.has(r2)) && this.rawSegments.push([this.generatedCodeColumn, e2, i2.line, i2.column]), s2[r2] === "\n" ? (i2.line += 1, i2.column = 0, this.generatedCodeLine += 1, this.raw[this.generatedCodeLine] = this.rawSegments = [], this.generatedCodeColumn = 0, a2 = true) : (i2.column += 1, this.generatedCodeColumn += 1, a2 = false), r2 += 1;
      this.pending = null;
    }, m2.prototype.advance = function(e2) {
      if (e2) {
        var t = e2.split("\n");
        if (t.length > 1) {
          for (var s2 = 0; s2 < t.length - 1; s2++)
            this.generatedCodeLine++, this.raw[this.generatedCodeLine] = this.rawSegments = [];
          this.generatedCodeColumn = 0;
        }
        this.generatedCodeColumn += t[t.length - 1].length;
      }
    };
    g = "\n";
    y2 = { insertLeft: false, insertRight: false, storeName: false };
    E2 = function(e2, t) {
      t === void 0 && (t = {});
      var s2 = new o(0, e2.length, e2);
      Object.defineProperties(this, { original: { writable: true, value: e2 }, outro: { writable: true, value: "" }, intro: { writable: true, value: "" }, firstChunk: { writable: true, value: s2 }, lastChunk: { writable: true, value: s2 }, lastSearchedChunk: { writable: true, value: s2 }, byStart: { writable: true, value: {} }, byEnd: { writable: true, value: {} }, filename: { writable: true, value: t.filename }, indentExclusionRanges: { writable: true, value: t.indentExclusionRanges }, sourcemapLocations: { writable: true, value: new a() }, storedNames: { writable: true, value: {} }, indentStr: { writable: true, value: c2(e2) } }), this.byStart[0] = s2, this.byEnd[e2.length] = s2;
    };
    E2.prototype.addSourcemapLocation = function(e2) {
      this.sourcemapLocations.add(e2);
    }, E2.prototype.append = function(e2) {
      if (typeof e2 != "string")
        throw new TypeError("outro content must be a string");
      return this.outro += e2, this;
    }, E2.prototype.appendLeft = function(e2, t) {
      if (typeof t != "string")
        throw new TypeError("inserted content must be a string");
      this._split(e2);
      var s2 = this.byEnd[e2];
      return s2 ? s2.appendLeft(t) : this.intro += t, this;
    }, E2.prototype.appendRight = function(e2, t) {
      if (typeof t != "string")
        throw new TypeError("inserted content must be a string");
      this._split(e2);
      var s2 = this.byStart[e2];
      return s2 ? s2.appendRight(t) : this.outro += t, this;
    }, E2.prototype.clone = function() {
      for (var e2 = new E2(this.original, { filename: this.filename }), t = this.firstChunk, s2 = e2.firstChunk = e2.lastSearchedChunk = t.clone(); t; ) {
        e2.byStart[s2.start] = s2, e2.byEnd[s2.end] = s2;
        var i2 = t.next, n3 = i2 && i2.clone();
        n3 && (s2.next = n3, n3.previous = s2, s2 = n3), t = i2;
      }
      return e2.lastChunk = s2, this.indentExclusionRanges && (e2.indentExclusionRanges = this.indentExclusionRanges.slice()), e2.sourcemapLocations = new a(this.sourcemapLocations), e2.intro = this.intro, e2.outro = this.outro, e2;
    }, E2.prototype.generateDecodedMap = function(e2) {
      var t = this;
      e2 = e2 || {};
      var s2 = Object.keys(this.storedNames), i2 = new m2(e2.hires), n3 = f(this.original);
      return this.intro && i2.advance(this.intro), this.firstChunk.eachNext(function(e3) {
        var r2 = n3(e3.start);
        e3.intro.length && i2.advance(e3.intro), e3.edited ? i2.addEdit(0, e3.content, r2, e3.storeName ? s2.indexOf(e3.original) : -1) : i2.addUneditedChunk(0, e3, t.original, r2, t.sourcemapLocations), e3.outro.length && i2.advance(e3.outro);
      }), { file: e2.file ? e2.file.split(/[/\\]/).pop() : null, sources: [e2.source ? u(e2.file || "", e2.source) : null], sourcesContent: e2.includeContent ? [this.original] : [null], names: s2, mappings: i2.raw };
    }, E2.prototype.generateMap = function(e2) {
      return new l(this.generateDecodedMap(e2));
    }, E2.prototype.getIndentString = function() {
      return this.indentStr === null ? "	" : this.indentStr;
    }, E2.prototype.indent = function(e2, t) {
      var s2 = /^[^\r\n]/gm;
      if (p(e2) && (t = e2, e2 = void 0), (e2 = e2 !== void 0 ? e2 : this.indentStr || "	") === "")
        return this;
      var i2 = {};
      (t = t || {}).exclude && (typeof t.exclude[0] == "number" ? [t.exclude] : t.exclude).forEach(function(e3) {
        for (var t2 = e3[0]; t2 < e3[1]; t2 += 1)
          i2[t2] = true;
      });
      var n3 = t.indentStart !== false, r2 = function(t2) {
        return n3 ? "" + e2 + t2 : (n3 = true, t2);
      };
      this.intro = this.intro.replace(s2, r2);
      for (var a2 = 0, o2 = this.firstChunk; o2; ) {
        var h3 = o2.end;
        if (o2.edited)
          i2[a2] || (o2.content = o2.content.replace(s2, r2), o2.content.length && (n3 = o2.content[o2.content.length - 1] === "\n"));
        else
          for (a2 = o2.start; a2 < h3; ) {
            if (!i2[a2]) {
              var l2 = this.original[a2];
              l2 === "\n" ? n3 = true : l2 !== "\r" && n3 && (n3 = false, a2 === o2.start ? o2.prependRight(e2) : (this._splitChunk(o2, a2), (o2 = o2.next).prependRight(e2)));
            }
            a2 += 1;
          }
        a2 = o2.end, o2 = o2.next;
      }
      return this.outro = this.outro.replace(s2, r2), this;
    }, E2.prototype.insert = function() {
      throw new Error("magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)");
    }, E2.prototype.insertLeft = function(e2, t) {
      return y2.insertLeft || (console.warn("magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead"), y2.insertLeft = true), this.appendLeft(e2, t);
    }, E2.prototype.insertRight = function(e2, t) {
      return y2.insertRight || (console.warn("magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead"), y2.insertRight = true), this.prependRight(e2, t);
    }, E2.prototype.move = function(e2, t, s2) {
      if (s2 >= e2 && s2 <= t)
        throw new Error("Cannot move a selection inside itself");
      this._split(e2), this._split(t), this._split(s2);
      var i2 = this.byStart[e2], n3 = this.byEnd[t], r2 = i2.previous, a2 = n3.next, o2 = this.byStart[s2];
      if (!o2 && n3 === this.lastChunk)
        return this;
      var h3 = o2 ? o2.previous : this.lastChunk;
      return r2 && (r2.next = a2), a2 && (a2.previous = r2), h3 && (h3.next = i2), o2 && (o2.previous = n3), i2.previous || (this.firstChunk = n3.next), n3.next || (this.lastChunk = i2.previous, this.lastChunk.next = null), i2.previous = h3, n3.next = o2 || null, h3 || (this.firstChunk = i2), o2 || (this.lastChunk = n3), this;
    }, E2.prototype.overwrite = function(e2, t, s2, i2) {
      if (typeof s2 != "string")
        throw new TypeError("replacement content must be a string");
      for (; e2 < 0; )
        e2 += this.original.length;
      for (; t < 0; )
        t += this.original.length;
      if (t > this.original.length)
        throw new Error("end is out of bounds");
      if (e2 === t)
        throw new Error("Cannot overwrite a zero-length range \u2013 use appendLeft or prependRight instead");
      this._split(e2), this._split(t), i2 === true && (y2.storeName || (console.warn("The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string"), y2.storeName = true), i2 = { storeName: true });
      var n3 = i2 !== void 0 && i2.storeName, r2 = i2 !== void 0 && i2.contentOnly;
      if (n3) {
        var a2 = this.original.slice(e2, t);
        this.storedNames[a2] = true;
      }
      var h3 = this.byStart[e2], l2 = this.byEnd[t];
      if (h3) {
        if (t > h3.end && h3.next !== this.byStart[h3.end])
          throw new Error("Cannot overwrite across a split point");
        if (h3.edit(s2, n3, r2), h3 !== l2) {
          for (var c3 = h3.next; c3 !== l2; )
            c3.edit("", false), c3 = c3.next;
          c3.edit("", false);
        }
      } else {
        var u2 = new o(e2, t, "").edit(s2, n3);
        l2.next = u2, u2.previous = l2;
      }
      return this;
    }, E2.prototype.prepend = function(e2) {
      if (typeof e2 != "string")
        throw new TypeError("outro content must be a string");
      return this.intro = e2 + this.intro, this;
    }, E2.prototype.prependLeft = function(e2, t) {
      if (typeof t != "string")
        throw new TypeError("inserted content must be a string");
      this._split(e2);
      var s2 = this.byEnd[e2];
      return s2 ? s2.prependLeft(t) : this.intro = t + this.intro, this;
    }, E2.prototype.prependRight = function(e2, t) {
      if (typeof t != "string")
        throw new TypeError("inserted content must be a string");
      this._split(e2);
      var s2 = this.byStart[e2];
      return s2 ? s2.prependRight(t) : this.outro = t + this.outro, this;
    }, E2.prototype.remove = function(e2, t) {
      for (; e2 < 0; )
        e2 += this.original.length;
      for (; t < 0; )
        t += this.original.length;
      if (e2 === t)
        return this;
      if (e2 < 0 || t > this.original.length)
        throw new Error("Character is out of bounds");
      if (e2 > t)
        throw new Error("end must be greater than start");
      this._split(e2), this._split(t);
      for (var s2 = this.byStart[e2]; s2; )
        s2.intro = "", s2.outro = "", s2.edit(""), s2 = t > s2.end ? this.byStart[s2.end] : null;
      return this;
    }, E2.prototype.lastChar = function() {
      if (this.outro.length)
        return this.outro[this.outro.length - 1];
      var e2 = this.lastChunk;
      do {
        if (e2.outro.length)
          return e2.outro[e2.outro.length - 1];
        if (e2.content.length)
          return e2.content[e2.content.length - 1];
        if (e2.intro.length)
          return e2.intro[e2.intro.length - 1];
      } while (e2 = e2.previous);
      return this.intro.length ? this.intro[this.intro.length - 1] : "";
    }, E2.prototype.lastLine = function() {
      var e2 = this.outro.lastIndexOf(g);
      if (e2 !== -1)
        return this.outro.substr(e2 + 1);
      var t = this.outro, s2 = this.lastChunk;
      do {
        if (s2.outro.length > 0) {
          if ((e2 = s2.outro.lastIndexOf(g)) !== -1)
            return s2.outro.substr(e2 + 1) + t;
          t = s2.outro + t;
        }
        if (s2.content.length > 0) {
          if ((e2 = s2.content.lastIndexOf(g)) !== -1)
            return s2.content.substr(e2 + 1) + t;
          t = s2.content + t;
        }
        if (s2.intro.length > 0) {
          if ((e2 = s2.intro.lastIndexOf(g)) !== -1)
            return s2.intro.substr(e2 + 1) + t;
          t = s2.intro + t;
        }
      } while (s2 = s2.previous);
      return (e2 = this.intro.lastIndexOf(g)) !== -1 ? this.intro.substr(e2 + 1) + t : this.intro + t;
    }, E2.prototype.slice = function(e2, t) {
      for (e2 === void 0 && (e2 = 0), t === void 0 && (t = this.original.length); e2 < 0; )
        e2 += this.original.length;
      for (; t < 0; )
        t += this.original.length;
      for (var s2 = "", i2 = this.firstChunk; i2 && (i2.start > e2 || i2.end <= e2); ) {
        if (i2.start < t && i2.end >= t)
          return s2;
        i2 = i2.next;
      }
      if (i2 && i2.edited && i2.start !== e2)
        throw new Error("Cannot use replaced character " + e2 + " as slice start anchor.");
      for (var n3 = i2; i2; ) {
        !i2.intro || n3 === i2 && i2.start !== e2 || (s2 += i2.intro);
        var r2 = i2.start < t && i2.end >= t;
        if (r2 && i2.edited && i2.end !== t)
          throw new Error("Cannot use replaced character " + t + " as slice end anchor.");
        var a2 = n3 === i2 ? e2 - i2.start : 0, o2 = r2 ? i2.content.length + t - i2.end : i2.content.length;
        if (s2 += i2.content.slice(a2, o2), !i2.outro || r2 && i2.end !== t || (s2 += i2.outro), r2)
          break;
        i2 = i2.next;
      }
      return s2;
    }, E2.prototype.snip = function(e2, t) {
      var s2 = this.clone();
      return s2.remove(0, e2), s2.remove(t, s2.original.length), s2;
    }, E2.prototype._split = function(e2) {
      if (!this.byStart[e2] && !this.byEnd[e2])
        for (var t = this.lastSearchedChunk, s2 = e2 > t.end; t; ) {
          if (t.contains(e2))
            return this._splitChunk(t, e2);
          t = s2 ? this.byStart[t.end] : this.byEnd[t.start];
        }
    }, E2.prototype._splitChunk = function(e2, t) {
      if (e2.edited && e2.content.length) {
        var s2 = f(this.original)(t);
        throw new Error("Cannot split a chunk that has already been edited (" + s2.line + ":" + s2.column + ' \u2013 "' + e2.original + '")');
      }
      var i2 = e2.split(t);
      return this.byEnd[t] = e2, this.byStart[t] = i2, this.byEnd[i2.end] = i2, e2 === this.lastChunk && (this.lastChunk = i2), this.lastSearchedChunk = e2, true;
    }, E2.prototype.toString = function() {
      for (var e2 = this.intro, t = this.firstChunk; t; )
        e2 += t.toString(), t = t.next;
      return e2 + this.outro;
    }, E2.prototype.isEmpty = function() {
      var e2 = this.firstChunk;
      do {
        if (e2.intro.length && e2.intro.trim() || e2.content.length && e2.content.trim() || e2.outro.length && e2.outro.trim())
          return false;
      } while (e2 = e2.next);
      return true;
    }, E2.prototype.length = function() {
      var e2 = this.firstChunk, t = 0;
      do {
        t += e2.intro.length + e2.content.length + e2.outro.length;
      } while (e2 = e2.next);
      return t;
    }, E2.prototype.trimLines = function() {
      return this.trim("[\\r\\n]");
    }, E2.prototype.trim = function(e2) {
      return this.trimStart(e2).trimEnd(e2);
    }, E2.prototype.trimEndAborted = function(e2) {
      var t = new RegExp((e2 || "\\s") + "+$");
      if (this.outro = this.outro.replace(t, ""), this.outro.length)
        return true;
      var s2 = this.lastChunk;
      do {
        var i2 = s2.end, n3 = s2.trimEnd(t);
        if (s2.end !== i2 && (this.lastChunk === s2 && (this.lastChunk = s2.next), this.byEnd[s2.end] = s2, this.byStart[s2.next.start] = s2.next, this.byEnd[s2.next.end] = s2.next), n3)
          return true;
        s2 = s2.previous;
      } while (s2);
      return false;
    }, E2.prototype.trimEnd = function(e2) {
      return this.trimEndAborted(e2), this;
    }, E2.prototype.trimStartAborted = function(e2) {
      var t = new RegExp("^" + (e2 || "\\s") + "+");
      if (this.intro = this.intro.replace(t, ""), this.intro.length)
        return true;
      var s2 = this.firstChunk;
      do {
        var i2 = s2.end, n3 = s2.trimStart(t);
        if (s2.end !== i2 && (s2 === this.lastChunk && (this.lastChunk = s2.next), this.byEnd[s2.end] = s2, this.byStart[s2.next.start] = s2.next, this.byEnd[s2.next.end] = s2.next), n3)
          return true;
        s2 = s2.next;
      } while (s2);
      return false;
    }, E2.prototype.trimStart = function(e2) {
      return this.trimStartAborted(e2), this;
    };
    x = Object.prototype.hasOwnProperty;
    v = function(e2) {
      e2 === void 0 && (e2 = {}), this.intro = e2.intro || "", this.separator = e2.separator !== void 0 ? e2.separator : "\n", this.sources = [], this.uniqueSources = [], this.uniqueSourceIndexByFilename = {};
    };
    v.prototype.addSource = function(e2) {
      if (e2 instanceof E2)
        return this.addSource({ content: e2, filename: e2.filename, separator: this.separator });
      if (!p(e2) || !e2.content)
        throw new Error("bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`");
      if (["filename", "indentExclusionRanges", "separator"].forEach(function(t2) {
        x.call(e2, t2) || (e2[t2] = e2.content[t2]);
      }), e2.separator === void 0 && (e2.separator = this.separator), e2.filename)
        if (x.call(this.uniqueSourceIndexByFilename, e2.filename)) {
          var t = this.uniqueSources[this.uniqueSourceIndexByFilename[e2.filename]];
          if (e2.content.original !== t.content)
            throw new Error("Illegal source: same filename (" + e2.filename + "), different contents");
        } else
          this.uniqueSourceIndexByFilename[e2.filename] = this.uniqueSources.length, this.uniqueSources.push({ filename: e2.filename, content: e2.content.original });
      return this.sources.push(e2), this;
    }, v.prototype.append = function(e2, t) {
      return this.addSource({ content: new E2(e2), separator: t && t.separator || "" }), this;
    }, v.prototype.clone = function() {
      var e2 = new v({ intro: this.intro, separator: this.separator });
      return this.sources.forEach(function(t) {
        e2.addSource({ filename: t.filename, content: t.content.clone(), separator: t.separator });
      }), e2;
    }, v.prototype.generateDecodedMap = function(e2) {
      var t = this;
      e2 === void 0 && (e2 = {});
      var s2 = [];
      this.sources.forEach(function(e3) {
        Object.keys(e3.content.storedNames).forEach(function(e4) {
          ~s2.indexOf(e4) || s2.push(e4);
        });
      });
      var i2 = new m2(e2.hires);
      return this.intro && i2.advance(this.intro), this.sources.forEach(function(e3, n3) {
        n3 > 0 && i2.advance(t.separator);
        var r2 = e3.filename ? t.uniqueSourceIndexByFilename[e3.filename] : -1, a2 = e3.content, o2 = f(a2.original);
        a2.intro && i2.advance(a2.intro), a2.firstChunk.eachNext(function(t2) {
          var n4 = o2(t2.start);
          t2.intro.length && i2.advance(t2.intro), e3.filename ? t2.edited ? i2.addEdit(r2, t2.content, n4, t2.storeName ? s2.indexOf(t2.original) : -1) : i2.addUneditedChunk(r2, t2, a2.original, n4, a2.sourcemapLocations) : i2.advance(t2.content), t2.outro.length && i2.advance(t2.outro);
        }), a2.outro && i2.advance(a2.outro);
      }), { file: e2.file ? e2.file.split(/[/\\]/).pop() : null, sources: this.uniqueSources.map(function(t2) {
        return e2.file ? u(e2.file, t2.filename) : t2.filename;
      }), sourcesContent: this.uniqueSources.map(function(t2) {
        return e2.includeContent ? t2.content : null;
      }), names: s2, mappings: i2.raw };
    }, v.prototype.generateMap = function(e2) {
      return new l(this.generateDecodedMap(e2));
    }, v.prototype.getIndentString = function() {
      var e2 = {};
      return this.sources.forEach(function(t) {
        var s2 = t.content.indentStr;
        s2 !== null && (e2[s2] || (e2[s2] = 0), e2[s2] += 1);
      }), Object.keys(e2).sort(function(t, s2) {
        return e2[t] - e2[s2];
      })[0] || "	";
    }, v.prototype.indent = function(e2) {
      var t = this;
      if (arguments.length || (e2 = this.getIndentString()), e2 === "")
        return this;
      var s2 = !this.intro || this.intro.slice(-1) === "\n";
      return this.sources.forEach(function(i2, n3) {
        var r2 = i2.separator !== void 0 ? i2.separator : t.separator, a2 = s2 || n3 > 0 && /\r?\n$/.test(r2);
        i2.content.indent(e2, { exclude: i2.indentExclusionRanges, indentStart: a2 }), s2 = i2.content.lastChar() === "\n";
      }), this.intro && (this.intro = e2 + this.intro.replace(/^[^\n]/gm, function(t2, s3) {
        return s3 > 0 ? e2 + t2 : t2;
      })), this;
    }, v.prototype.prepend = function(e2) {
      return this.intro = e2 + this.intro, this;
    }, v.prototype.toString = function() {
      var e2 = this, t = this.sources.map(function(t2, s2) {
        var i2 = t2.separator !== void 0 ? t2.separator : e2.separator;
        return (s2 > 0 ? i2 : "") + t2.content.toString();
      }).join("");
      return this.intro + t;
    }, v.prototype.isEmpty = function() {
      return (!this.intro.length || !this.intro.trim()) && !this.sources.some(function(e2) {
        return !e2.content.isEmpty();
      });
    }, v.prototype.length = function() {
      return this.sources.reduce(function(e2, t) {
        return e2 + t.content.length();
      }, this.intro.length);
    }, v.prototype.trimLines = function() {
      return this.trim("[\\r\\n]");
    }, v.prototype.trim = function(e2) {
      return this.trimStart(e2).trimEnd(e2);
    }, v.prototype.trimStart = function(e2) {
      var t = new RegExp("^" + (e2 || "\\s") + "+");
      if (this.intro = this.intro.replace(t, ""), !this.intro) {
        var s2, i2 = 0;
        do {
          if (!(s2 = this.sources[i2++]))
            break;
        } while (!s2.content.trimStartAborted(e2));
      }
      return this;
    }, v.prototype.trimEnd = function(e2) {
      var t, s2 = new RegExp((e2 || "\\s") + "+$"), i2 = this.sources.length - 1;
      do {
        if (!(t = this.sources[i2--])) {
          this.intro = this.intro.replace(s2, "");
          break;
        }
      } while (!t.content.trimEndAborted(e2));
      return this;
    };
    b = E2;
    S = /^(?:\/|(?:[A-Za-z]:)?[\\|/])/;
    A2 = /^\.?\.\//;
    P = /\\/g;
    k = /[/\\]/;
    w2 = /\.[^.]+$/;
    L = Symbol("Unknown Key");
    O = Symbol("Unknown Integer");
    V = [];
    B2 = [L];
    F = [O];
    z = Symbol("Entities");
    W = class {
      constructor() {
        this.entityPaths = Object.create(null, { [z]: { value: /* @__PURE__ */ new Set() } });
      }
      trackEntityAtPathAndGetIfTracked(e2, t) {
        const s2 = this.getEntities(e2);
        return !!s2.has(t) || (s2.add(t), false);
      }
      withTrackedEntityAtPath(e2, t, s2, i2) {
        const n3 = this.getEntities(e2);
        if (n3.has(t))
          return i2;
        n3.add(t);
        const r2 = s2();
        return n3.delete(t), r2;
      }
      getEntities(e2) {
        let t = this.entityPaths;
        for (const s2 of e2)
          t = t[s2] = t[s2] || Object.create(null, { [z]: { value: /* @__PURE__ */ new Set() } });
        return t[z];
      }
    };
    U = new W();
    j = class {
      constructor() {
        this.entityPaths = Object.create(null, { [z]: { value: /* @__PURE__ */ new Map() } });
      }
      trackEntityAtPathAndGetIfTracked(e2, t, s2) {
        let i2 = this.entityPaths;
        for (const t2 of e2)
          i2 = i2[t2] = i2[t2] || Object.create(null, { [z]: { value: /* @__PURE__ */ new Map() } });
        const n3 = D(i2[z], t, () => /* @__PURE__ */ new Set());
        return !!n3.has(s2) || (n3.add(s2), false);
      }
    };
    G = Symbol("Unknown Value");
    H = class {
      constructor() {
        this.included = false;
      }
      deoptimizePath(e2) {
      }
      deoptimizeThisOnEventAtPath(e2, t, s2, i2) {
        s2.deoptimizePath(B2);
      }
      getLiteralValueAtPath(e2, t, s2) {
        return G;
      }
      getReturnExpressionWhenCalledAtPath(e2, t, s2, i2) {
        return q;
      }
      hasEffectsWhenAccessedAtPath(e2, t) {
        return true;
      }
      hasEffectsWhenAssignedAtPath(e2, t) {
        return true;
      }
      hasEffectsWhenCalledAtPath(e2, t, s2) {
        return true;
      }
      include(e2, t) {
        this.included = true;
      }
      includeCallArguments(e2, t) {
        for (const s2 of t)
          s2.include(e2, false);
      }
    };
    q = new class extends H {
    }();
    K = class extends H {
      constructor(e2) {
        super(), this.name = e2, this.alwaysRendered = false, this.initReached = false, this.isId = false, this.isReassigned = false, this.kind = null, this.renderBaseName = null, this.renderName = null;
      }
      addReference(e2) {
      }
      getBaseVariableName() {
        return this.renderBaseName || this.renderName || this.name;
      }
      getName(e2) {
        const t = this.renderName || this.name;
        return this.renderBaseName ? `${this.renderBaseName}${e2(t)}` : t;
      }
      hasEffectsWhenAccessedAtPath(e2, t) {
        return e2.length > 0;
      }
      include() {
        this.included = true;
      }
      markCalledFromTryStatement() {
      }
      setRenderNames(e2, t) {
        this.renderBaseName = e2, this.renderName = t;
      }
    };
    X = class extends K {
      constructor(e2, t) {
        super(t), this.referenced = false, this.module = e2, this.isNamespace = t === "*";
      }
      addReference(e2) {
        this.referenced = true, this.name !== "default" && this.name !== "*" || this.module.suggestName(e2.name);
      }
      hasEffectsWhenAccessedAtPath(e2) {
        return e2.length > (this.isNamespace ? 1 : 0);
      }
      include() {
        this.included || (this.included = true, this.module.used = true);
      }
    };
    Y = Object.freeze(/* @__PURE__ */ Object.create(null));
    Q2 = Object.freeze({});
    Z = Object.freeze([]);
    re = /^(\.\.\/)*\.\.$/;
    !function(e2) {
      e2.ALREADY_CLOSED = "ALREADY_CLOSED", e2.ASSET_NOT_FINALISED = "ASSET_NOT_FINALISED", e2.ASSET_NOT_FOUND = "ASSET_NOT_FOUND", e2.ASSET_SOURCE_ALREADY_SET = "ASSET_SOURCE_ALREADY_SET", e2.ASSET_SOURCE_MISSING = "ASSET_SOURCE_MISSING", e2.BAD_LOADER = "BAD_LOADER", e2.CANNOT_EMIT_FROM_OPTIONS_HOOK = "CANNOT_EMIT_FROM_OPTIONS_HOOK", e2.CHUNK_NOT_GENERATED = "CHUNK_NOT_GENERATED", e2.CHUNK_INVALID = "CHUNK_INVALID", e2.CIRCULAR_REEXPORT = "CIRCULAR_REEXPORT", e2.CYCLIC_CROSS_CHUNK_REEXPORT = "CYCLIC_CROSS_CHUNK_REEXPORT", e2.DEPRECATED_FEATURE = "DEPRECATED_FEATURE", e2.EXTERNAL_SYNTHETIC_EXPORTS = "EXTERNAL_SYNTHETIC_EXPORTS", e2.FILE_NAME_CONFLICT = "FILE_NAME_CONFLICT", e2.FILE_NOT_FOUND = "FILE_NOT_FOUND", e2.INPUT_HOOK_IN_OUTPUT_PLUGIN = "INPUT_HOOK_IN_OUTPUT_PLUGIN", e2.INVALID_CHUNK = "INVALID_CHUNK", e2.INVALID_EXPORT_OPTION = "INVALID_EXPORT_OPTION", e2.INVALID_EXTERNAL_ID = "INVALID_EXTERNAL_ID", e2.INVALID_OPTION = "INVALID_OPTION", e2.INVALID_PLUGIN_HOOK = "INVALID_PLUGIN_HOOK", e2.INVALID_ROLLUP_PHASE = "INVALID_ROLLUP_PHASE", e2.MISSING_EXPORT = "MISSING_EXPORT", e2.MISSING_IMPLICIT_DEPENDANT = "MISSING_IMPLICIT_DEPENDANT", e2.MIXED_EXPORTS = "MIXED_EXPORTS", e2.NAMESPACE_CONFLICT = "NAMESPACE_CONFLICT", e2.AMBIGUOUS_EXTERNAL_NAMESPACES = "AMBIGUOUS_EXTERNAL_NAMESPACES", e2.NO_TRANSFORM_MAP_OR_AST_WITHOUT_CODE = "NO_TRANSFORM_MAP_OR_AST_WITHOUT_CODE", e2.PLUGIN_ERROR = "PLUGIN_ERROR", e2.PREFER_NAMED_EXPORTS = "PREFER_NAMED_EXPORTS", e2.SYNTHETIC_NAMED_EXPORTS_NEED_NAMESPACE_EXPORT = "SYNTHETIC_NAMED_EXPORTS_NEED_NAMESPACE_EXPORT", e2.UNEXPECTED_NAMED_IMPORT = "UNEXPECTED_NAMED_IMPORT", e2.UNRESOLVED_ENTRY = "UNRESOLVED_ENTRY", e2.UNRESOLVED_IMPORT = "UNRESOLVED_IMPORT", e2.VALIDATION_ERROR = "VALIDATION_ERROR";
    }(le || (le = {}));
    be = /* @__PURE__ */ new Set(["await", "break", "case", "catch", "class", "const", "continue", "debugger", "default", "delete", "do", "else", "enum", "eval", "export", "extends", "false", "finally", "for", "function", "if", "implements", "import", "in", "instanceof", "interface", "let", "NaN", "new", "null", "package", "private", "protected", "public", "return", "static", "super", "switch", "this", "throw", "true", "try", "typeof", "undefined", "var", "void", "while", "with", "yield"]);
    Se = /[^$_a-zA-Z0-9]/g;
    Ae = (e2) => /\d/.test(e2[0]);
    ke = class {
      constructor(e2, t, s2, i2, n3) {
        this.options = e2, this.id = t, this.renormalizeRenderPath = n3, this.declarations = /* @__PURE__ */ new Map(), this.defaultVariableName = "", this.dynamicImporters = [], this.execIndex = 1 / 0, this.exportedVariables = /* @__PURE__ */ new Map(), this.importers = [], this.mostCommonSuggestion = 0, this.nameSuggestions = /* @__PURE__ */ new Map(), this.namespaceVariableName = "", this.reexported = false, this.renderPath = void 0, this.used = false, this.variableName = "", this.suggestedVariableName = Pe(t.split(/[\\/]/).pop());
        const { importers: r2, dynamicImporters: a2 } = this, o2 = this.info = { ast: null, code: null, dynamicallyImportedIdResolutions: Z, dynamicallyImportedIds: Z, get dynamicImporters() {
          return a2.sort();
        }, hasDefaultExport: null, get hasModuleSideEffects() {
          return xe("Accessing ModuleInfo.hasModuleSideEffects from plugins is deprecated. Please use ModuleInfo.moduleSideEffects instead.", false, e2), o2.moduleSideEffects;
        }, id: t, implicitlyLoadedAfterOneOf: Z, implicitlyLoadedBefore: Z, importedIdResolutions: Z, importedIds: Z, get importers() {
          return r2.sort();
        }, isEntry: false, isExternal: true, isIncluded: null, meta: i2, moduleSideEffects: s2, syntheticNamedExports: false };
        Object.defineProperty(this.info, "hasModuleSideEffects", { enumerable: false });
      }
      getVariableForExportName(e2) {
        const t = this.declarations.get(e2);
        if (t)
          return [t];
        const s2 = new X(this, e2);
        return this.declarations.set(e2, s2), this.exportedVariables.set(s2, e2), [s2];
      }
      setRenderPath(e2, t) {
        this.renderPath = typeof e2.paths == "function" ? e2.paths(this.id) : e2.paths[this.id], this.renderPath || (this.renderPath = this.renormalizeRenderPath ? N(R(t, this.id)) : this.id);
      }
      suggestName(e2) {
        var t;
        const s2 = ((t = this.nameSuggestions.get(e2)) !== null && t !== void 0 ? t : 0) + 1;
        this.nameSuggestions.set(e2, s2), s2 > this.mostCommonSuggestion && (this.mostCommonSuggestion = s2, this.suggestedVariableName = e2);
      }
      warnUnusedImports() {
        const e2 = Array.from(this.declarations).filter(([e3, t2]) => e3 !== "*" && !t2.included && !this.reexported && !t2.referenced).map(([e3]) => e3);
        if (e2.length === 0)
          return;
        const t = /* @__PURE__ */ new Set();
        for (const s3 of e2)
          for (const e3 of this.declarations.get(s3).module.importers)
            t.add(e3);
        const s2 = [...t];
        this.options.onwarn({ code: "UNUSED_EXTERNAL_IMPORT", message: `${te(e2, ["is", "are"])} imported from external module "${this.id}" but never used in ${te(s2.map((e3) => ie(e3)))}.`, names: e2, source: this.id, sources: s2 });
      }
    };
    we = { ArrayPattern(e2, t) {
      for (const s2 of t.elements)
        s2 && we[s2.type](e2, s2);
    }, AssignmentPattern(e2, t) {
      we[t.left.type](e2, t.left);
    }, Identifier(e2, t) {
      e2.push(t.name);
    }, MemberExpression() {
    }, ObjectPattern(e2, t) {
      for (const s2 of t.properties)
        s2.type === "RestElement" ? we.RestElement(e2, s2) : we[s2.value.type](e2, s2.value);
    }, RestElement(e2, t) {
      we[t.argument.type](e2, t.argument);
    } };
    Ce = function(e2) {
      const t = [];
      return we[e2.type](t, e2), t;
    };
    new Set("break case class catch const continue debugger default delete do else export extends finally for function if import in instanceof let new return super switch this throw try typeof var void while with yield enum await implements package protected static interface private public arguments Infinity NaN undefined null true false eval uneval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Symbol Error EvalError InternalError RangeError ReferenceError SyntaxError TypeError URIError Number Math Date String RegExp Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array Map Set WeakMap WeakSet SIMD ArrayBuffer DataView JSON Promise Generator GeneratorFunction Reflect Proxy Intl".split(" ")).add("");
    _e = [];
    Te = new class extends H {
      getLiteralValueAtPath() {
      }
    }();
    Re = { value: { callsArgs: null, returns: q } };
    Me = new class extends H {
      getReturnExpressionWhenCalledAtPath(e2) {
        return e2.length === 1 ? Ge(ze, e2[0]) : q;
      }
      hasEffectsWhenAccessedAtPath(e2) {
        return e2.length > 1;
      }
      hasEffectsWhenCalledAtPath(e2, t, s2) {
        return e2.length !== 1 || je(ze, e2[0], t, s2);
      }
    }();
    De = { value: { callsArgs: null, returns: Me } };
    Le = new class extends H {
      getReturnExpressionWhenCalledAtPath(e2) {
        return e2.length === 1 ? Ge(We, e2[0]) : q;
      }
      hasEffectsWhenAccessedAtPath(e2) {
        return e2.length > 1;
      }
      hasEffectsWhenCalledAtPath(e2, t, s2) {
        return e2.length !== 1 || je(We, e2[0], t, s2);
      }
    }();
    Oe = { value: { callsArgs: null, returns: Le } };
    Ve = new class extends H {
      getReturnExpressionWhenCalledAtPath(e2) {
        return e2.length === 1 ? Ge(Ue, e2[0]) : q;
      }
      hasEffectsWhenAccessedAtPath(e2) {
        return e2.length > 1;
      }
      hasEffectsWhenCalledAtPath(e2, t, s2) {
        return e2.length !== 1 || je(Ue, e2[0], t, s2);
      }
    }();
    Be = { value: { callsArgs: null, returns: Ve } };
    Fe = $e({ hasOwnProperty: De, isPrototypeOf: De, propertyIsEnumerable: De, toLocaleString: Be, toString: Be, valueOf: Re });
    ze = $e({ valueOf: De }, Fe);
    We = $e({ toExponential: Be, toFixed: Be, toLocaleString: Be, toPrecision: Be, valueOf: Oe }, Fe);
    Ue = $e({ anchor: Be, at: Re, big: Be, blink: Be, bold: Be, charAt: Be, charCodeAt: Oe, codePointAt: Re, concat: Be, endsWith: De, fixed: Be, fontcolor: Be, fontsize: Be, includes: De, indexOf: Oe, italics: Be, lastIndexOf: Oe, link: Be, localeCompare: Oe, match: Re, matchAll: Re, normalize: Be, padEnd: Be, padStart: Be, repeat: Be, replace: { value: { callsArgs: [1], returns: Ve } }, replaceAll: { value: { callsArgs: [1], returns: Ve } }, search: Oe, slice: Be, small: Be, split: Re, startsWith: De, strike: Be, sub: Be, substr: Be, substring: Be, sup: Be, toLocaleLowerCase: Be, toLocaleUpperCase: Be, toLowerCase: Be, toString: Be, toUpperCase: Be, trim: Be, trimEnd: Be, trimLeft: Be, trimRight: Be, trimStart: Be, valueOf: Be }, Fe);
    Ke = {};
    Ke.Program = Ke.BlockStatement = Ke.StaticBlock = function(e2, t, s2) {
      for (var i2 = 0, n3 = e2.body; i2 < n3.length; i2 += 1) {
        s2(n3[i2], t, "Statement");
      }
    }, Ke.Statement = He, Ke.EmptyStatement = qe, Ke.ExpressionStatement = Ke.ParenthesizedExpression = Ke.ChainExpression = function(e2, t, s2) {
      return s2(e2.expression, t, "Expression");
    }, Ke.IfStatement = function(e2, t, s2) {
      s2(e2.test, t, "Expression"), s2(e2.consequent, t, "Statement"), e2.alternate && s2(e2.alternate, t, "Statement");
    }, Ke.LabeledStatement = function(e2, t, s2) {
      return s2(e2.body, t, "Statement");
    }, Ke.BreakStatement = Ke.ContinueStatement = qe, Ke.WithStatement = function(e2, t, s2) {
      s2(e2.object, t, "Expression"), s2(e2.body, t, "Statement");
    }, Ke.SwitchStatement = function(e2, t, s2) {
      s2(e2.discriminant, t, "Expression");
      for (var i2 = 0, n3 = e2.cases; i2 < n3.length; i2 += 1) {
        var r2 = n3[i2];
        r2.test && s2(r2.test, t, "Expression");
        for (var a2 = 0, o2 = r2.consequent; a2 < o2.length; a2 += 1) {
          s2(o2[a2], t, "Statement");
        }
      }
    }, Ke.SwitchCase = function(e2, t, s2) {
      e2.test && s2(e2.test, t, "Expression");
      for (var i2 = 0, n3 = e2.consequent; i2 < n3.length; i2 += 1) {
        s2(n3[i2], t, "Statement");
      }
    }, Ke.ReturnStatement = Ke.YieldExpression = Ke.AwaitExpression = function(e2, t, s2) {
      e2.argument && s2(e2.argument, t, "Expression");
    }, Ke.ThrowStatement = Ke.SpreadElement = function(e2, t, s2) {
      return s2(e2.argument, t, "Expression");
    }, Ke.TryStatement = function(e2, t, s2) {
      s2(e2.block, t, "Statement"), e2.handler && s2(e2.handler, t), e2.finalizer && s2(e2.finalizer, t, "Statement");
    }, Ke.CatchClause = function(e2, t, s2) {
      e2.param && s2(e2.param, t, "Pattern"), s2(e2.body, t, "Statement");
    }, Ke.WhileStatement = Ke.DoWhileStatement = function(e2, t, s2) {
      s2(e2.test, t, "Expression"), s2(e2.body, t, "Statement");
    }, Ke.ForStatement = function(e2, t, s2) {
      e2.init && s2(e2.init, t, "ForInit"), e2.test && s2(e2.test, t, "Expression"), e2.update && s2(e2.update, t, "Expression"), s2(e2.body, t, "Statement");
    }, Ke.ForInStatement = Ke.ForOfStatement = function(e2, t, s2) {
      s2(e2.left, t, "ForInit"), s2(e2.right, t, "Expression"), s2(e2.body, t, "Statement");
    }, Ke.ForInit = function(e2, t, s2) {
      e2.type === "VariableDeclaration" ? s2(e2, t) : s2(e2, t, "Expression");
    }, Ke.DebuggerStatement = qe, Ke.FunctionDeclaration = function(e2, t, s2) {
      return s2(e2, t, "Function");
    }, Ke.VariableDeclaration = function(e2, t, s2) {
      for (var i2 = 0, n3 = e2.declarations; i2 < n3.length; i2 += 1) {
        s2(n3[i2], t);
      }
    }, Ke.VariableDeclarator = function(e2, t, s2) {
      s2(e2.id, t, "Pattern"), e2.init && s2(e2.init, t, "Expression");
    }, Ke.Function = function(e2, t, s2) {
      e2.id && s2(e2.id, t, "Pattern");
      for (var i2 = 0, n3 = e2.params; i2 < n3.length; i2 += 1) {
        s2(n3[i2], t, "Pattern");
      }
      s2(e2.body, t, e2.expression ? "Expression" : "Statement");
    }, Ke.Pattern = function(e2, t, s2) {
      e2.type === "Identifier" ? s2(e2, t, "VariablePattern") : e2.type === "MemberExpression" ? s2(e2, t, "MemberPattern") : s2(e2, t);
    }, Ke.VariablePattern = qe, Ke.MemberPattern = He, Ke.RestElement = function(e2, t, s2) {
      return s2(e2.argument, t, "Pattern");
    }, Ke.ArrayPattern = function(e2, t, s2) {
      for (var i2 = 0, n3 = e2.elements; i2 < n3.length; i2 += 1) {
        var r2 = n3[i2];
        r2 && s2(r2, t, "Pattern");
      }
    }, Ke.ObjectPattern = function(e2, t, s2) {
      for (var i2 = 0, n3 = e2.properties; i2 < n3.length; i2 += 1) {
        var r2 = n3[i2];
        r2.type === "Property" ? (r2.computed && s2(r2.key, t, "Expression"), s2(r2.value, t, "Pattern")) : r2.type === "RestElement" && s2(r2.argument, t, "Pattern");
      }
    }, Ke.Expression = He, Ke.ThisExpression = Ke.Super = Ke.MetaProperty = qe, Ke.ArrayExpression = function(e2, t, s2) {
      for (var i2 = 0, n3 = e2.elements; i2 < n3.length; i2 += 1) {
        var r2 = n3[i2];
        r2 && s2(r2, t, "Expression");
      }
    }, Ke.ObjectExpression = function(e2, t, s2) {
      for (var i2 = 0, n3 = e2.properties; i2 < n3.length; i2 += 1) {
        s2(n3[i2], t);
      }
    }, Ke.FunctionExpression = Ke.ArrowFunctionExpression = Ke.FunctionDeclaration, Ke.SequenceExpression = function(e2, t, s2) {
      for (var i2 = 0, n3 = e2.expressions; i2 < n3.length; i2 += 1) {
        s2(n3[i2], t, "Expression");
      }
    }, Ke.TemplateLiteral = function(e2, t, s2) {
      for (var i2 = 0, n3 = e2.quasis; i2 < n3.length; i2 += 1) {
        s2(n3[i2], t);
      }
      for (var r2 = 0, a2 = e2.expressions; r2 < a2.length; r2 += 1) {
        s2(a2[r2], t, "Expression");
      }
    }, Ke.TemplateElement = qe, Ke.UnaryExpression = Ke.UpdateExpression = function(e2, t, s2) {
      s2(e2.argument, t, "Expression");
    }, Ke.BinaryExpression = Ke.LogicalExpression = function(e2, t, s2) {
      s2(e2.left, t, "Expression"), s2(e2.right, t, "Expression");
    }, Ke.AssignmentExpression = Ke.AssignmentPattern = function(e2, t, s2) {
      s2(e2.left, t, "Pattern"), s2(e2.right, t, "Expression");
    }, Ke.ConditionalExpression = function(e2, t, s2) {
      s2(e2.test, t, "Expression"), s2(e2.consequent, t, "Expression"), s2(e2.alternate, t, "Expression");
    }, Ke.NewExpression = Ke.CallExpression = function(e2, t, s2) {
      if (s2(e2.callee, t, "Expression"), e2.arguments)
        for (var i2 = 0, n3 = e2.arguments; i2 < n3.length; i2 += 1) {
          s2(n3[i2], t, "Expression");
        }
    }, Ke.MemberExpression = function(e2, t, s2) {
      s2(e2.object, t, "Expression"), e2.computed && s2(e2.property, t, "Expression");
    }, Ke.ExportNamedDeclaration = Ke.ExportDefaultDeclaration = function(e2, t, s2) {
      e2.declaration && s2(e2.declaration, t, e2.type === "ExportNamedDeclaration" || e2.declaration.id ? "Statement" : "Expression"), e2.source && s2(e2.source, t, "Expression");
    }, Ke.ExportAllDeclaration = function(e2, t, s2) {
      e2.exported && s2(e2.exported, t), s2(e2.source, t, "Expression");
    }, Ke.ImportDeclaration = function(e2, t, s2) {
      for (var i2 = 0, n3 = e2.specifiers; i2 < n3.length; i2 += 1) {
        s2(n3[i2], t);
      }
      s2(e2.source, t, "Expression");
    }, Ke.ImportExpression = function(e2, t, s2) {
      s2(e2.source, t, "Expression");
    }, Ke.ImportSpecifier = Ke.ImportDefaultSpecifier = Ke.ImportNamespaceSpecifier = Ke.Identifier = Ke.PrivateIdentifier = Ke.Literal = qe, Ke.TaggedTemplateExpression = function(e2, t, s2) {
      s2(e2.tag, t, "Expression"), s2(e2.quasi, t, "Expression");
    }, Ke.ClassDeclaration = Ke.ClassExpression = function(e2, t, s2) {
      return s2(e2, t, "Class");
    }, Ke.Class = function(e2, t, s2) {
      e2.id && s2(e2.id, t, "Pattern"), e2.superClass && s2(e2.superClass, t, "Expression"), s2(e2.body, t);
    }, Ke.ClassBody = function(e2, t, s2) {
      for (var i2 = 0, n3 = e2.body; i2 < n3.length; i2 += 1) {
        s2(n3[i2], t);
      }
    }, Ke.MethodDefinition = Ke.PropertyDefinition = Ke.Property = function(e2, t, s2) {
      e2.computed && s2(e2.key, t, "Expression"), e2.value && s2(e2.value, t, "Expression");
    };
    Xe = "sourceMa";
    Xe += "ppingURL";
    Ye = new RegExp("^#[ \\f\\r\\t\\v\\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]+sourceMappingURL=.+");
    Ze = /[^\s(]/g;
    Je = /\S/g;
    st = /[@#]__PURE__/;
    nt = { Literal: [], Program: ["body"] };
    rt = class extends H {
      constructor(e2, t, s2) {
        super(), this.esTreeNode = e2, this.keys = nt[e2.type] || function(e3) {
          return nt[e3.type] = Object.keys(e3).filter((t2) => typeof e3[t2] == "object" && t2.charCodeAt(0) !== 95), nt[e3.type];
        }(e2), this.parent = t, this.context = t.context, this.createScope(s2), this.parseNode(e2), this.initialise(), this.context.magicString.addSourcemapLocation(this.start), this.context.magicString.addSourcemapLocation(this.end);
      }
      addExportedVariables(e2, t) {
      }
      bind() {
        for (const e2 of this.keys) {
          const t = this[e2];
          if (t !== null)
            if (Array.isArray(t))
              for (const e3 of t)
                e3 !== null && e3.bind();
            else
              t.bind();
        }
      }
      createScope(e2) {
        this.scope = e2;
      }
      hasEffects(e2) {
        this.deoptimized === false && this.applyDeoptimizations();
        for (const t of this.keys) {
          const s2 = this[t];
          if (s2 !== null) {
            if (Array.isArray(s2)) {
              for (const t2 of s2)
                if (t2 !== null && t2.hasEffects(e2))
                  return true;
            } else if (s2.hasEffects(e2))
              return true;
          }
        }
        return false;
      }
      include(e2, t) {
        this.deoptimized === false && this.applyDeoptimizations(), this.included = true;
        for (const s2 of this.keys) {
          const i2 = this[s2];
          if (i2 !== null)
            if (Array.isArray(i2))
              for (const s3 of i2)
                s3 !== null && s3.include(e2, t);
            else
              i2.include(e2, t);
        }
      }
      includeAsSingleStatement(e2, t) {
        this.include(e2, t);
      }
      initialise() {
      }
      insertSemicolon(e2) {
        e2.original[this.end - 1] !== ";" && e2.appendLeft(this.end, ";");
      }
      parseNode(e2) {
        for (const [t, s2] of Object.entries(e2))
          if (!this.hasOwnProperty(t))
            if (t.charCodeAt(0) === 95) {
              if (t === "_rollupAnnotations")
                this.annotations = s2;
              else if (t === "_rollupRemoved")
                for (const { start: e3, end: t2 } of s2)
                  this.context.magicString.remove(e3, t2);
            } else if (typeof s2 != "object" || s2 === null)
              this[t] = s2;
            else if (Array.isArray(s2)) {
              this[t] = [];
              for (const e3 of s2)
                this[t].push(e3 === null ? null : new (this.context.getNodeConstructor(e3.type))(e3, this, this.scope));
            } else
              this[t] = new (this.context.getNodeConstructor(s2.type))(s2, this, this.scope);
      }
      render(e2, t) {
        for (const s2 of this.keys) {
          const i2 = this[s2];
          if (i2 !== null)
            if (Array.isArray(i2))
              for (const s3 of i2)
                s3 !== null && s3.render(e2, t);
            else
              i2.render(e2, t);
        }
      }
      shouldBeIncluded(e2) {
        return this.included || !e2.brokenFlow && this.hasEffects(Ne());
      }
      applyDeoptimizations() {
      }
    };
    at = class extends rt {
      constructor() {
        super(...arguments), this.deoptimized = false;
      }
      deoptimizeThisOnEventAtPath(e2, t, s2, i2) {
        t.length > 0 && this.argument.deoptimizeThisOnEventAtPath(e2, [L, ...t], s2, i2);
      }
      hasEffects(e2) {
        this.deoptimized || this.applyDeoptimizations();
        const { propertyReadSideEffects: t } = this.context.options.treeshake;
        return this.argument.hasEffects(e2) || t && (t === "always" || this.argument.hasEffectsWhenAccessedAtPath(B2, e2));
      }
      applyDeoptimizations() {
        this.deoptimized = true, this.argument.deoptimizePath([L, L]), this.context.requestTreeshakingPass();
      }
    };
    ot = class extends H {
      constructor(e2) {
        super(), this.description = e2;
      }
      deoptimizeThisOnEventAtPath(e2, t, s2) {
        e2 === 2 && t.length === 0 && this.description.mutatesSelfAsArray && s2.deoptimizePath(F);
      }
      getReturnExpressionWhenCalledAtPath(e2, t) {
        return e2.length > 0 ? q : this.description.returnsPrimitive || (this.description.returns === "self" ? t.thisParam || q : this.description.returns());
      }
      hasEffectsWhenAccessedAtPath(e2) {
        return e2.length > 1;
      }
      hasEffectsWhenAssignedAtPath(e2) {
        return e2.length > 0;
      }
      hasEffectsWhenCalledAtPath(e2, t, s2) {
        var i2, n3;
        if (e2.length > 0 || this.description.mutatesSelfAsArray === true && ((i2 = t.thisParam) === null || i2 === void 0 ? void 0 : i2.hasEffectsWhenAssignedAtPath(F, s2)))
          return true;
        if (!this.description.callsArgs)
          return false;
        for (const e3 of this.description.callsArgs)
          if ((n3 = t.args[e3]) === null || n3 === void 0 ? void 0 : n3.hasEffectsWhenCalledAtPath(V, { args: _e, thisParam: null, withNew: false }, s2))
            return true;
        return false;
      }
      includeCallArguments(e2, t) {
        for (const s2 of t)
          s2.include(e2, false);
      }
    };
    ht = [new ot({ callsArgs: null, mutatesSelfAsArray: false, returns: null, returnsPrimitive: Me })];
    lt = [new ot({ callsArgs: null, mutatesSelfAsArray: false, returns: null, returnsPrimitive: Ve })];
    ct = [new ot({ callsArgs: null, mutatesSelfAsArray: false, returns: null, returnsPrimitive: Le })];
    ut = [new ot({ callsArgs: null, mutatesSelfAsArray: false, returns: null, returnsPrimitive: q })];
    dt = /^\d+$/;
    pt = class extends H {
      constructor(e2, t, s2 = false) {
        if (super(), this.prototypeExpression = t, this.immutable = s2, this.allProperties = [], this.deoptimizedPaths = /* @__PURE__ */ Object.create(null), this.expressionsToBeDeoptimizedByKey = /* @__PURE__ */ Object.create(null), this.gettersByKey = /* @__PURE__ */ Object.create(null), this.hasUnknownDeoptimizedInteger = false, this.hasUnknownDeoptimizedProperty = false, this.propertiesAndGettersByKey = /* @__PURE__ */ Object.create(null), this.propertiesAndSettersByKey = /* @__PURE__ */ Object.create(null), this.settersByKey = /* @__PURE__ */ Object.create(null), this.thisParametersToBeDeoptimized = /* @__PURE__ */ new Set(), this.unknownIntegerProps = [], this.unmatchableGetters = [], this.unmatchablePropertiesAndGetters = [], this.unmatchableSetters = [], Array.isArray(e2))
          this.buildPropertyMaps(e2);
        else {
          this.propertiesAndGettersByKey = this.propertiesAndSettersByKey = e2;
          for (const t2 of Object.values(e2))
            this.allProperties.push(...t2);
        }
      }
      deoptimizeAllProperties() {
        var e2;
        if (!this.hasUnknownDeoptimizedProperty) {
          this.hasUnknownDeoptimizedProperty = true;
          for (const e3 of Object.values(this.propertiesAndGettersByKey).concat(Object.values(this.settersByKey)))
            for (const t of e3)
              t.deoptimizePath(B2);
          (e2 = this.prototypeExpression) === null || e2 === void 0 || e2.deoptimizePath([L, L]), this.deoptimizeCachedEntities();
        }
      }
      deoptimizeIntegerProperties() {
        if (!this.hasUnknownDeoptimizedProperty && !this.hasUnknownDeoptimizedInteger) {
          this.hasUnknownDeoptimizedInteger = true;
          for (const [e2, t] of Object.entries(this.propertiesAndGettersByKey))
            if (dt.test(e2))
              for (const e3 of t)
                e3.deoptimizePath(B2);
          this.deoptimizeCachedIntegerEntities();
        }
      }
      deoptimizePath(e2) {
        var t;
        if (this.hasUnknownDeoptimizedProperty || this.immutable)
          return;
        const s2 = e2[0];
        if (e2.length === 1) {
          if (typeof s2 != "string")
            return s2 === O ? this.deoptimizeIntegerProperties() : this.deoptimizeAllProperties();
          if (!this.deoptimizedPaths[s2]) {
            this.deoptimizedPaths[s2] = true;
            const e3 = this.expressionsToBeDeoptimizedByKey[s2];
            if (e3)
              for (const t2 of e3)
                t2.deoptimizeCache();
          }
        }
        const i2 = e2.length === 1 ? B2 : e2.slice(1);
        for (const e3 of typeof s2 == "string" ? (this.propertiesAndGettersByKey[s2] || this.unmatchablePropertiesAndGetters).concat(this.settersByKey[s2] || this.unmatchableSetters) : this.allProperties)
          e3.deoptimizePath(i2);
        (t = this.prototypeExpression) === null || t === void 0 || t.deoptimizePath(e2.length === 1 ? [L, L] : e2);
      }
      deoptimizeThisOnEventAtPath(e2, t, s2, i2) {
        var n3;
        const [r2, ...a2] = t;
        if (this.hasUnknownDeoptimizedProperty || (e2 === 2 || t.length > 1) && typeof r2 == "string" && this.deoptimizedPaths[r2])
          return void s2.deoptimizePath(B2);
        const [o2, h3, l2] = e2 === 2 || t.length > 1 ? [this.propertiesAndGettersByKey, this.propertiesAndGettersByKey, this.unmatchablePropertiesAndGetters] : e2 === 0 ? [this.propertiesAndGettersByKey, this.gettersByKey, this.unmatchableGetters] : [this.propertiesAndSettersByKey, this.settersByKey, this.unmatchableSetters];
        if (typeof r2 == "string") {
          if (o2[r2]) {
            const t2 = h3[r2];
            if (t2)
              for (const n4 of t2)
                n4.deoptimizeThisOnEventAtPath(e2, a2, s2, i2);
            return void (this.immutable || this.thisParametersToBeDeoptimized.add(s2));
          }
          for (const t2 of l2)
            t2.deoptimizeThisOnEventAtPath(e2, a2, s2, i2);
          if (dt.test(r2))
            for (const t2 of this.unknownIntegerProps)
              t2.deoptimizeThisOnEventAtPath(e2, a2, s2, i2);
        } else {
          for (const t2 of Object.values(h3).concat([l2]))
            for (const n4 of t2)
              n4.deoptimizeThisOnEventAtPath(e2, a2, s2, i2);
          for (const t2 of this.unknownIntegerProps)
            t2.deoptimizeThisOnEventAtPath(e2, a2, s2, i2);
        }
        this.immutable || this.thisParametersToBeDeoptimized.add(s2), (n3 = this.prototypeExpression) === null || n3 === void 0 || n3.deoptimizeThisOnEventAtPath(e2, t, s2, i2);
      }
      getLiteralValueAtPath(e2, t, s2) {
        if (e2.length === 0)
          return G;
        const i2 = e2[0], n3 = this.getMemberExpressionAndTrackDeopt(i2, s2);
        return n3 ? n3.getLiteralValueAtPath(e2.slice(1), t, s2) : this.prototypeExpression ? this.prototypeExpression.getLiteralValueAtPath(e2, t, s2) : e2.length !== 1 ? G : void 0;
      }
      getReturnExpressionWhenCalledAtPath(e2, t, s2, i2) {
        if (e2.length === 0)
          return q;
        const n3 = e2[0], r2 = this.getMemberExpressionAndTrackDeopt(n3, i2);
        return r2 ? r2.getReturnExpressionWhenCalledAtPath(e2.slice(1), t, s2, i2) : this.prototypeExpression ? this.prototypeExpression.getReturnExpressionWhenCalledAtPath(e2, t, s2, i2) : q;
      }
      hasEffectsWhenAccessedAtPath(e2, t) {
        const [s2, ...i2] = e2;
        if (e2.length > 1) {
          if (typeof s2 != "string")
            return true;
          const n3 = this.getMemberExpression(s2);
          return n3 ? n3.hasEffectsWhenAccessedAtPath(i2, t) : !this.prototypeExpression || this.prototypeExpression.hasEffectsWhenAccessedAtPath(e2, t);
        }
        if (this.hasUnknownDeoptimizedProperty)
          return true;
        if (typeof s2 == "string") {
          if (this.propertiesAndGettersByKey[s2]) {
            const e3 = this.gettersByKey[s2];
            if (e3) {
              for (const s3 of e3)
                if (s3.hasEffectsWhenAccessedAtPath(i2, t))
                  return true;
            }
            return false;
          }
          for (const e3 of this.unmatchableGetters)
            if (e3.hasEffectsWhenAccessedAtPath(i2, t))
              return true;
        } else
          for (const e3 of Object.values(this.gettersByKey).concat([this.unmatchableGetters]))
            for (const s3 of e3)
              if (s3.hasEffectsWhenAccessedAtPath(i2, t))
                return true;
        return !!this.prototypeExpression && this.prototypeExpression.hasEffectsWhenAccessedAtPath(e2, t);
      }
      hasEffectsWhenAssignedAtPath(e2, t) {
        const [s2, ...i2] = e2;
        if (e2.length > 1) {
          if (typeof s2 != "string")
            return true;
          const n3 = this.getMemberExpression(s2);
          return n3 ? n3.hasEffectsWhenAssignedAtPath(i2, t) : !this.prototypeExpression || this.prototypeExpression.hasEffectsWhenAssignedAtPath(e2, t);
        }
        if (this.hasUnknownDeoptimizedProperty)
          return true;
        if (typeof s2 == "string") {
          if (this.propertiesAndSettersByKey[s2]) {
            const e3 = this.settersByKey[s2];
            if (e3) {
              for (const s3 of e3)
                if (s3.hasEffectsWhenAssignedAtPath(i2, t))
                  return true;
            }
            return false;
          }
          for (const e3 of this.unmatchableSetters)
            if (e3.hasEffectsWhenAssignedAtPath(i2, t))
              return true;
        }
        return !!this.prototypeExpression && this.prototypeExpression.hasEffectsWhenAssignedAtPath(e2, t);
      }
      hasEffectsWhenCalledAtPath(e2, t, s2) {
        const i2 = e2[0], n3 = this.getMemberExpression(i2);
        return n3 ? n3.hasEffectsWhenCalledAtPath(e2.slice(1), t, s2) : !this.prototypeExpression || this.prototypeExpression.hasEffectsWhenCalledAtPath(e2, t, s2);
      }
      buildPropertyMaps(e2) {
        const { allProperties: t, propertiesAndGettersByKey: s2, propertiesAndSettersByKey: i2, settersByKey: n3, gettersByKey: r2, unknownIntegerProps: a2, unmatchablePropertiesAndGetters: o2, unmatchableGetters: h3, unmatchableSetters: l2 } = this, c3 = [];
        for (let u2 = e2.length - 1; u2 >= 0; u2--) {
          const { key: d3, kind: p2, property: f2 } = e2[u2];
          if (t.push(f2), typeof d3 != "string") {
            if (d3 === O) {
              a2.push(f2);
              continue;
            }
            p2 === "set" && l2.push(f2), p2 === "get" && h3.push(f2), p2 !== "get" && c3.push(f2), p2 !== "set" && o2.push(f2);
          } else
            p2 === "set" ? i2[d3] || (i2[d3] = [f2, ...c3], n3[d3] = [f2, ...l2]) : p2 === "get" ? s2[d3] || (s2[d3] = [f2, ...o2], r2[d3] = [f2, ...h3]) : (i2[d3] || (i2[d3] = [f2, ...c3]), s2[d3] || (s2[d3] = [f2, ...o2]));
        }
      }
      deoptimizeCachedEntities() {
        for (const e2 of Object.values(this.expressionsToBeDeoptimizedByKey))
          for (const t of e2)
            t.deoptimizeCache();
        for (const e2 of this.thisParametersToBeDeoptimized)
          e2.deoptimizePath(B2);
      }
      deoptimizeCachedIntegerEntities() {
        for (const [e2, t] of Object.entries(this.expressionsToBeDeoptimizedByKey))
          if (dt.test(e2))
            for (const e3 of t)
              e3.deoptimizeCache();
        for (const e2 of this.thisParametersToBeDeoptimized)
          e2.deoptimizePath(F);
      }
      getMemberExpression(e2) {
        if (this.hasUnknownDeoptimizedProperty || typeof e2 != "string" || this.hasUnknownDeoptimizedInteger && dt.test(e2) || this.deoptimizedPaths[e2])
          return q;
        const t = this.propertiesAndGettersByKey[e2];
        return (t == null ? void 0 : t.length) === 1 ? t[0] : t || this.unmatchablePropertiesAndGetters.length > 0 || this.unknownIntegerProps.length && dt.test(e2) ? q : null;
      }
      getMemberExpressionAndTrackDeopt(e2, t) {
        if (typeof e2 != "string")
          return q;
        const s2 = this.getMemberExpression(e2);
        if (s2 !== q && !this.immutable) {
          (this.expressionsToBeDeoptimizedByKey[e2] = this.expressionsToBeDeoptimizedByKey[e2] || []).push(t);
        }
        return s2;
      }
    };
    ft = (e2) => typeof e2 == "string" && /^\d+$/.test(e2);
    mt = new class extends H {
      deoptimizeThisOnEventAtPath(e2, t, s2) {
        e2 !== 2 || t.length !== 1 || ft(t[0]) || s2.deoptimizePath(B2);
      }
      getLiteralValueAtPath(e2) {
        return e2.length === 1 && ft(e2[0]) ? void 0 : G;
      }
      hasEffectsWhenAccessedAtPath(e2) {
        return e2.length > 1;
      }
      hasEffectsWhenAssignedAtPath(e2) {
        return e2.length > 1;
      }
    }();
    gt = new pt({ __proto__: null, hasOwnProperty: ht, isPrototypeOf: ht, propertyIsEnumerable: ht, toLocaleString: lt, toString: lt, valueOf: ut }, mt, true);
    yt = [{ key: O, kind: "init", property: q }, { key: "length", kind: "init", property: Le }];
    Et = [new ot({ callsArgs: [0], mutatesSelfAsArray: "deopt-only", returns: null, returnsPrimitive: Me })];
    xt = [new ot({ callsArgs: [0], mutatesSelfAsArray: "deopt-only", returns: null, returnsPrimitive: Le })];
    vt = [new ot({ callsArgs: null, mutatesSelfAsArray: true, returns: () => new pt(yt, Nt), returnsPrimitive: null })];
    bt = [new ot({ callsArgs: null, mutatesSelfAsArray: "deopt-only", returns: () => new pt(yt, Nt), returnsPrimitive: null })];
    St = [new ot({ callsArgs: [0], mutatesSelfAsArray: "deopt-only", returns: () => new pt(yt, Nt), returnsPrimitive: null })];
    At = [new ot({ callsArgs: null, mutatesSelfAsArray: true, returns: null, returnsPrimitive: Le })];
    Pt = [new ot({ callsArgs: null, mutatesSelfAsArray: true, returns: null, returnsPrimitive: q })];
    kt = [new ot({ callsArgs: null, mutatesSelfAsArray: "deopt-only", returns: null, returnsPrimitive: q })];
    wt = [new ot({ callsArgs: [0], mutatesSelfAsArray: "deopt-only", returns: null, returnsPrimitive: q })];
    Ct = [new ot({ callsArgs: null, mutatesSelfAsArray: true, returns: "self", returnsPrimitive: null })];
    It = [new ot({ callsArgs: [0], mutatesSelfAsArray: true, returns: "self", returnsPrimitive: null })];
    Nt = new pt({ __proto__: null, at: kt, concat: bt, copyWithin: Ct, entries: bt, every: Et, fill: Ct, filter: St, find: wt, findIndex: xt, findLast: wt, findLastIndex: xt, flat: bt, flatMap: St, forEach: wt, groupBy: wt, groupByToMap: wt, includes: ht, indexOf: ct, join: lt, keys: ut, lastIndexOf: ct, map: St, pop: Pt, push: At, reduce: wt, reduceRight: wt, reverse: Ct, shift: Pt, slice: bt, some: Et, sort: It, splice: vt, toLocaleString: lt, toString: lt, unshift: At, values: kt }, gt, true);
    _t = class extends K {
      constructor(e2, t, s2, i2) {
        super(e2), this.calledFromTryStatement = false, this.additionalInitializers = null, this.expressionsToBeDeoptimized = [], this.declarations = t ? [t] : [], this.init = s2, this.deoptimizationTracker = i2.deoptimizationTracker, this.module = i2.module;
      }
      addDeclaration(e2, t) {
        this.declarations.push(e2);
        const s2 = this.markInitializersForDeoptimization();
        t !== null && s2.push(t);
      }
      consolidateInitializers() {
        if (this.additionalInitializers !== null) {
          for (const e2 of this.additionalInitializers)
            e2.deoptimizePath(B2);
          this.additionalInitializers = null;
        }
      }
      deoptimizePath(e2) {
        var t, s2;
        if (!this.isReassigned && !this.deoptimizationTracker.trackEntityAtPathAndGetIfTracked(e2, this))
          if (e2.length === 0) {
            if (!this.isReassigned) {
              this.isReassigned = true;
              const e3 = this.expressionsToBeDeoptimized;
              this.expressionsToBeDeoptimized = [];
              for (const t2 of e3)
                t2.deoptimizeCache();
              (t = this.init) === null || t === void 0 || t.deoptimizePath(B2);
            }
          } else
            (s2 = this.init) === null || s2 === void 0 || s2.deoptimizePath(e2);
      }
      deoptimizeThisOnEventAtPath(e2, t, s2, i2) {
        if (this.isReassigned || !this.init)
          return s2.deoptimizePath(B2);
        i2.withTrackedEntityAtPath(t, this.init, () => this.init.deoptimizeThisOnEventAtPath(e2, t, s2, i2), void 0);
      }
      getLiteralValueAtPath(e2, t, s2) {
        return this.isReassigned || !this.init ? G : t.withTrackedEntityAtPath(e2, this.init, () => (this.expressionsToBeDeoptimized.push(s2), this.init.getLiteralValueAtPath(e2, t, s2)), G);
      }
      getReturnExpressionWhenCalledAtPath(e2, t, s2, i2) {
        return this.isReassigned || !this.init ? q : s2.withTrackedEntityAtPath(e2, this.init, () => (this.expressionsToBeDeoptimized.push(i2), this.init.getReturnExpressionWhenCalledAtPath(e2, t, s2, i2)), q);
      }
      hasEffectsWhenAccessedAtPath(e2, t) {
        return !!this.isReassigned || this.init && !t.accessed.trackEntityAtPathAndGetIfTracked(e2, this) && this.init.hasEffectsWhenAccessedAtPath(e2, t);
      }
      hasEffectsWhenAssignedAtPath(e2, t) {
        return !!this.included || e2.length !== 0 && (!!this.isReassigned || this.init && !t.accessed.trackEntityAtPathAndGetIfTracked(e2, this) && this.init.hasEffectsWhenAssignedAtPath(e2, t));
      }
      hasEffectsWhenCalledAtPath(e2, t, s2) {
        return !!this.isReassigned || this.init && !(t.withNew ? s2.instantiated : s2.called).trackEntityAtPathAndGetIfTracked(e2, t, this) && this.init.hasEffectsWhenCalledAtPath(e2, t, s2);
      }
      include() {
        if (!this.included) {
          this.included = true;
          for (const e2 of this.declarations) {
            e2.included || e2.include(Ie(), false);
            let t = e2.parent;
            for (; !t.included && (t.included = true, t.type !== "Program"); )
              t = t.parent;
          }
        }
      }
      includeCallArguments(e2, t) {
        if (this.isReassigned || this.init && e2.includedCallArguments.has(this.init))
          for (const s2 of t)
            s2.include(e2, false);
        else
          this.init && (e2.includedCallArguments.add(this.init), this.init.includeCallArguments(e2, t), e2.includedCallArguments.delete(this.init));
      }
      markCalledFromTryStatement() {
        this.calledFromTryStatement = true;
      }
      markInitializersForDeoptimization() {
        return this.additionalInitializers === null && (this.additionalInitializers = this.init === null ? [] : [this.init], this.init = q, this.isReassigned = true), this.additionalInitializers;
      }
    };
    Rt = class {
      constructor() {
        this.children = [], this.variables = /* @__PURE__ */ new Map();
      }
      addDeclaration(e2, t, s2, i2) {
        const n3 = e2.name;
        let r2 = this.variables.get(n3);
        return r2 ? r2.addDeclaration(e2, s2) : (r2 = new _t(e2.name, e2, s2 || Te, t), this.variables.set(n3, r2)), r2;
      }
      contains(e2) {
        return this.variables.has(e2);
      }
      findVariable(e2) {
        throw new Error("Internal Error: findVariable needs to be implemented by a subclass");
      }
    };
    Mt = class extends Rt {
      constructor(e2) {
        super(), this.accessedOutsideVariables = /* @__PURE__ */ new Map(), this.parent = e2, e2.children.push(this);
      }
      addAccessedDynamicImport(e2) {
        (this.accessedDynamicImports || (this.accessedDynamicImports = /* @__PURE__ */ new Set())).add(e2), this.parent instanceof Mt && this.parent.addAccessedDynamicImport(e2);
      }
      addAccessedGlobals(e2, t) {
        const s2 = t.get(this) || /* @__PURE__ */ new Set();
        for (const t2 of e2)
          s2.add(t2);
        t.set(this, s2), this.parent instanceof Mt && this.parent.addAccessedGlobals(e2, t);
      }
      addNamespaceMemberAccess(e2, t) {
        this.accessedOutsideVariables.set(e2, t), this.parent.addNamespaceMemberAccess(e2, t);
      }
      addReturnExpression(e2) {
        this.parent instanceof Mt && this.parent.addReturnExpression(e2);
      }
      addUsedOutsideNames(e2, t, s2, i2) {
        for (const i3 of this.accessedOutsideVariables.values())
          i3.included && (e2.add(i3.getBaseVariableName()), t === "system" && s2.has(i3) && e2.add("exports"));
        const n3 = i2.get(this);
        if (n3)
          for (const t2 of n3)
            e2.add(t2);
      }
      contains(e2) {
        return this.variables.has(e2) || this.parent.contains(e2);
      }
      deconflict(e2, t, s2) {
        const i2 = /* @__PURE__ */ new Set();
        if (this.addUsedOutsideNames(i2, e2, t, s2), this.accessedDynamicImports)
          for (const e3 of this.accessedDynamicImports)
            e3.inlineNamespace && i2.add(e3.inlineNamespace.getBaseVariableName());
        for (const [e3, t2] of this.variables)
          (t2.included || t2.alwaysRendered) && t2.setRenderNames(null, Tt(e3, i2));
        for (const i3 of this.children)
          i3.deconflict(e2, t, s2);
      }
      findLexicalBoundary() {
        return this.parent.findLexicalBoundary();
      }
      findVariable(e2) {
        const t = this.variables.get(e2) || this.accessedOutsideVariables.get(e2);
        if (t)
          return t;
        const s2 = this.parent.findVariable(e2);
        return this.accessedOutsideVariables.set(e2, s2), s2;
      }
    };
    Dt = class extends Mt {
      constructor(e2, t) {
        super(e2), this.parameters = [], this.hasRest = false, this.context = t, this.hoistedBodyVarScope = new Mt(this);
      }
      addParameterDeclaration(e2) {
        const t = e2.name;
        let s2 = this.hoistedBodyVarScope.variables.get(t);
        return s2 ? s2.addDeclaration(e2, null) : s2 = new _t(t, e2, q, this.context), this.variables.set(t, s2), s2;
      }
      addParameterVariables(e2, t) {
        this.parameters = e2;
        for (const t2 of e2)
          for (const e3 of t2)
            e3.alwaysRendered = true;
        this.hasRest = t;
      }
      includeCallArguments(e2, t) {
        let s2 = false, i2 = false;
        const n3 = this.hasRest && this.parameters[this.parameters.length - 1];
        for (const s3 of t)
          if (s3 instanceof at) {
            for (const s4 of t)
              s4.include(e2, false);
            break;
          }
        for (let r2 = t.length - 1; r2 >= 0; r2--) {
          const a2 = this.parameters[r2] || n3, o2 = t[r2];
          if (a2)
            if (s2 = false, a2.length === 0)
              i2 = true;
            else
              for (const e3 of a2)
                e3.included && (i2 = true), e3.calledFromTryStatement && (s2 = true);
          !i2 && o2.shouldBeIncluded(e2) && (i2 = true), i2 && o2.include(e2, s2);
        }
      }
    };
    Lt = class extends Dt {
      constructor() {
        super(...arguments), this.returnExpression = null, this.returnExpressions = [];
      }
      addReturnExpression(e2) {
        this.returnExpressions.push(e2);
      }
      getReturnExpression() {
        return this.returnExpression === null && this.updateReturnExpression(), this.returnExpression;
      }
      updateReturnExpression() {
        if (this.returnExpressions.length === 1)
          this.returnExpression = this.returnExpressions[0];
        else {
          this.returnExpression = q;
          for (const e2 of this.returnExpressions)
            e2.deoptimizePath(B2);
        }
      }
    };
    Bt = { isNoStatement: true };
    zt = /\S/g;
    qt = class extends Mt {
      addDeclaration(e2, t, s2, i2) {
        if (i2) {
          const n3 = this.parent.addDeclaration(e2, t, s2, i2);
          return n3.markInitializersForDeoptimization(), n3;
        }
        return super.addDeclaration(e2, t, s2, false);
      }
    };
    Kt = class extends rt {
      initialise() {
        this.directive && this.directive !== "use strict" && this.parent.type === "Program" && this.context.warn({ code: "MODULE_LEVEL_DIRECTIVE", message: `Module level directives cause errors when bundled, '${this.directive}' was ignored.` }, this.start);
      }
      render(e2, t) {
        super.render(e2, t), this.included && this.insertSemicolon(e2);
      }
      shouldBeIncluded(e2) {
        return this.directive && this.directive !== "use strict" ? this.parent.type !== "Program" : super.shouldBeIncluded(e2);
      }
    };
    Xt = class extends rt {
      constructor() {
        super(...arguments), this.directlyIncluded = false;
      }
      addImplicitReturnExpressionToScope() {
        const e2 = this.body[this.body.length - 1];
        e2 && e2.type === "ReturnStatement" || this.scope.addReturnExpression(q);
      }
      createScope(e2) {
        this.scope = this.parent.preventChildBlockScope ? e2 : new qt(e2);
      }
      hasEffects(e2) {
        if (this.deoptimizeBody)
          return true;
        for (const t of this.body) {
          if (e2.brokenFlow)
            break;
          if (t.hasEffects(e2))
            return true;
        }
        return false;
      }
      include(e2, t) {
        if (!this.deoptimizeBody || !this.directlyIncluded) {
          this.included = true, this.directlyIncluded = true, this.deoptimizeBody && (t = true);
          for (const s2 of this.body)
            (t || s2.shouldBeIncluded(e2)) && s2.include(e2, t);
        }
      }
      initialise() {
        const e2 = this.body[0];
        this.deoptimizeBody = e2 instanceof Kt && e2.directive === "use asm";
      }
      render(e2, t) {
        this.body.length ? jt(this.body, e2, this.start + 1, this.end - 1, t) : super.render(e2, t);
      }
    };
    Qt = Symbol("Value Properties");
    Zt = { pure: true };
    Jt = { pure: false };
    es = { __proto__: null, [Qt]: Jt };
    ts = { __proto__: null, [Qt]: Zt };
    ss = { __proto__: null, [Qt]: Jt, prototype: es };
    is = { __proto__: null, [Qt]: Zt, prototype: es };
    ns = { __proto__: null, [Qt]: Zt, from: ts, of: ts, prototype: es };
    rs = { __proto__: null, [Qt]: Zt, supportedLocalesOf: is };
    as = { global: es, globalThis: es, self: es, window: es, __proto__: null, [Qt]: Jt, Array: { __proto__: null, [Qt]: Jt, from: es, isArray: ts, of: ts, prototype: es }, ArrayBuffer: { __proto__: null, [Qt]: Zt, isView: ts, prototype: es }, Atomics: es, BigInt: ss, BigInt64Array: ss, BigUint64Array: ss, Boolean: is, constructor: ss, DataView: is, Date: { __proto__: null, [Qt]: Zt, now: ts, parse: ts, prototype: es, UTC: ts }, decodeURI: ts, decodeURIComponent: ts, encodeURI: ts, encodeURIComponent: ts, Error: is, escape: ts, eval: es, EvalError: is, Float32Array: ns, Float64Array: ns, Function: ss, hasOwnProperty: es, Infinity: es, Int16Array: ns, Int32Array: ns, Int8Array: ns, isFinite: ts, isNaN: ts, isPrototypeOf: es, JSON: es, Map: is, Math: { __proto__: null, [Qt]: Jt, abs: ts, acos: ts, acosh: ts, asin: ts, asinh: ts, atan: ts, atan2: ts, atanh: ts, cbrt: ts, ceil: ts, clz32: ts, cos: ts, cosh: ts, exp: ts, expm1: ts, floor: ts, fround: ts, hypot: ts, imul: ts, log: ts, log10: ts, log1p: ts, log2: ts, max: ts, min: ts, pow: ts, random: ts, round: ts, sign: ts, sin: ts, sinh: ts, sqrt: ts, tan: ts, tanh: ts, trunc: ts }, NaN: es, Number: { __proto__: null, [Qt]: Zt, isFinite: ts, isInteger: ts, isNaN: ts, isSafeInteger: ts, parseFloat: ts, parseInt: ts, prototype: es }, Object: { __proto__: null, [Qt]: Zt, create: ts, getOwnPropertyDescriptor: ts, getOwnPropertyNames: ts, getOwnPropertySymbols: ts, getPrototypeOf: ts, is: ts, isExtensible: ts, isFrozen: ts, isSealed: ts, keys: ts, fromEntries: ts, entries: ts, prototype: es }, parseFloat: ts, parseInt: ts, Promise: { __proto__: null, [Qt]: Jt, all: es, prototype: es, race: es, reject: es, resolve: es }, propertyIsEnumerable: es, Proxy: es, RangeError: is, ReferenceError: is, Reflect: es, RegExp: is, Set: is, SharedArrayBuffer: ss, String: { __proto__: null, [Qt]: Zt, fromCharCode: ts, fromCodePoint: ts, prototype: es, raw: ts }, Symbol: { __proto__: null, [Qt]: Zt, for: ts, keyFor: ts, prototype: es }, SyntaxError: is, toLocaleString: es, toString: es, TypeError: is, Uint16Array: ns, Uint32Array: ns, Uint8Array: ns, Uint8ClampedArray: ns, unescape: ts, URIError: is, valueOf: es, WeakMap: is, WeakSet: is, clearInterval: ss, clearTimeout: ss, console: es, Intl: { __proto__: null, [Qt]: Jt, Collator: rs, DateTimeFormat: rs, ListFormat: rs, NumberFormat: rs, PluralRules: rs, RelativeTimeFormat: rs }, setInterval: ss, setTimeout: ss, TextDecoder: ss, TextEncoder: ss, URL: ss, URLSearchParams: ss, AbortController: ss, AbortSignal: ss, addEventListener: es, alert: es, AnalyserNode: ss, Animation: ss, AnimationEvent: ss, applicationCache: es, ApplicationCache: ss, ApplicationCacheErrorEvent: ss, atob: es, Attr: ss, Audio: ss, AudioBuffer: ss, AudioBufferSourceNode: ss, AudioContext: ss, AudioDestinationNode: ss, AudioListener: ss, AudioNode: ss, AudioParam: ss, AudioProcessingEvent: ss, AudioScheduledSourceNode: ss, AudioWorkletNode: ss, BarProp: ss, BaseAudioContext: ss, BatteryManager: ss, BeforeUnloadEvent: ss, BiquadFilterNode: ss, Blob: ss, BlobEvent: ss, blur: es, BroadcastChannel: ss, btoa: es, ByteLengthQueuingStrategy: ss, Cache: ss, caches: es, CacheStorage: ss, cancelAnimationFrame: es, cancelIdleCallback: es, CanvasCaptureMediaStreamTrack: ss, CanvasGradient: ss, CanvasPattern: ss, CanvasRenderingContext2D: ss, ChannelMergerNode: ss, ChannelSplitterNode: ss, CharacterData: ss, clientInformation: es, ClipboardEvent: ss, close: es, closed: es, CloseEvent: ss, Comment: ss, CompositionEvent: ss, confirm: es, ConstantSourceNode: ss, ConvolverNode: ss, CountQueuingStrategy: ss, createImageBitmap: es, Credential: ss, CredentialsContainer: ss, crypto: es, Crypto: ss, CryptoKey: ss, CSS: ss, CSSConditionRule: ss, CSSFontFaceRule: ss, CSSGroupingRule: ss, CSSImportRule: ss, CSSKeyframeRule: ss, CSSKeyframesRule: ss, CSSMediaRule: ss, CSSNamespaceRule: ss, CSSPageRule: ss, CSSRule: ss, CSSRuleList: ss, CSSStyleDeclaration: ss, CSSStyleRule: ss, CSSStyleSheet: ss, CSSSupportsRule: ss, CustomElementRegistry: ss, customElements: es, CustomEvent: ss, DataTransfer: ss, DataTransferItem: ss, DataTransferItemList: ss, defaultstatus: es, defaultStatus: es, DelayNode: ss, DeviceMotionEvent: ss, DeviceOrientationEvent: ss, devicePixelRatio: es, dispatchEvent: es, document: es, Document: ss, DocumentFragment: ss, DocumentType: ss, DOMError: ss, DOMException: ss, DOMImplementation: ss, DOMMatrix: ss, DOMMatrixReadOnly: ss, DOMParser: ss, DOMPoint: ss, DOMPointReadOnly: ss, DOMQuad: ss, DOMRect: ss, DOMRectReadOnly: ss, DOMStringList: ss, DOMStringMap: ss, DOMTokenList: ss, DragEvent: ss, DynamicsCompressorNode: ss, Element: ss, ErrorEvent: ss, Event: ss, EventSource: ss, EventTarget: ss, external: es, fetch: es, File: ss, FileList: ss, FileReader: ss, find: es, focus: es, FocusEvent: ss, FontFace: ss, FontFaceSetLoadEvent: ss, FormData: ss, frames: es, GainNode: ss, Gamepad: ss, GamepadButton: ss, GamepadEvent: ss, getComputedStyle: es, getSelection: es, HashChangeEvent: ss, Headers: ss, history: es, History: ss, HTMLAllCollection: ss, HTMLAnchorElement: ss, HTMLAreaElement: ss, HTMLAudioElement: ss, HTMLBaseElement: ss, HTMLBodyElement: ss, HTMLBRElement: ss, HTMLButtonElement: ss, HTMLCanvasElement: ss, HTMLCollection: ss, HTMLContentElement: ss, HTMLDataElement: ss, HTMLDataListElement: ss, HTMLDetailsElement: ss, HTMLDialogElement: ss, HTMLDirectoryElement: ss, HTMLDivElement: ss, HTMLDListElement: ss, HTMLDocument: ss, HTMLElement: ss, HTMLEmbedElement: ss, HTMLFieldSetElement: ss, HTMLFontElement: ss, HTMLFormControlsCollection: ss, HTMLFormElement: ss, HTMLFrameElement: ss, HTMLFrameSetElement: ss, HTMLHeadElement: ss, HTMLHeadingElement: ss, HTMLHRElement: ss, HTMLHtmlElement: ss, HTMLIFrameElement: ss, HTMLImageElement: ss, HTMLInputElement: ss, HTMLLabelElement: ss, HTMLLegendElement: ss, HTMLLIElement: ss, HTMLLinkElement: ss, HTMLMapElement: ss, HTMLMarqueeElement: ss, HTMLMediaElement: ss, HTMLMenuElement: ss, HTMLMetaElement: ss, HTMLMeterElement: ss, HTMLModElement: ss, HTMLObjectElement: ss, HTMLOListElement: ss, HTMLOptGroupElement: ss, HTMLOptionElement: ss, HTMLOptionsCollection: ss, HTMLOutputElement: ss, HTMLParagraphElement: ss, HTMLParamElement: ss, HTMLPictureElement: ss, HTMLPreElement: ss, HTMLProgressElement: ss, HTMLQuoteElement: ss, HTMLScriptElement: ss, HTMLSelectElement: ss, HTMLShadowElement: ss, HTMLSlotElement: ss, HTMLSourceElement: ss, HTMLSpanElement: ss, HTMLStyleElement: ss, HTMLTableCaptionElement: ss, HTMLTableCellElement: ss, HTMLTableColElement: ss, HTMLTableElement: ss, HTMLTableRowElement: ss, HTMLTableSectionElement: ss, HTMLTemplateElement: ss, HTMLTextAreaElement: ss, HTMLTimeElement: ss, HTMLTitleElement: ss, HTMLTrackElement: ss, HTMLUListElement: ss, HTMLUnknownElement: ss, HTMLVideoElement: ss, IDBCursor: ss, IDBCursorWithValue: ss, IDBDatabase: ss, IDBFactory: ss, IDBIndex: ss, IDBKeyRange: ss, IDBObjectStore: ss, IDBOpenDBRequest: ss, IDBRequest: ss, IDBTransaction: ss, IDBVersionChangeEvent: ss, IdleDeadline: ss, IIRFilterNode: ss, Image: ss, ImageBitmap: ss, ImageBitmapRenderingContext: ss, ImageCapture: ss, ImageData: ss, indexedDB: es, innerHeight: es, innerWidth: es, InputEvent: ss, IntersectionObserver: ss, IntersectionObserverEntry: ss, isSecureContext: es, KeyboardEvent: ss, KeyframeEffect: ss, length: es, localStorage: es, location: es, Location: ss, locationbar: es, matchMedia: es, MediaDeviceInfo: ss, MediaDevices: ss, MediaElementAudioSourceNode: ss, MediaEncryptedEvent: ss, MediaError: ss, MediaKeyMessageEvent: ss, MediaKeySession: ss, MediaKeyStatusMap: ss, MediaKeySystemAccess: ss, MediaList: ss, MediaQueryList: ss, MediaQueryListEvent: ss, MediaRecorder: ss, MediaSettingsRange: ss, MediaSource: ss, MediaStream: ss, MediaStreamAudioDestinationNode: ss, MediaStreamAudioSourceNode: ss, MediaStreamEvent: ss, MediaStreamTrack: ss, MediaStreamTrackEvent: ss, menubar: es, MessageChannel: ss, MessageEvent: ss, MessagePort: ss, MIDIAccess: ss, MIDIConnectionEvent: ss, MIDIInput: ss, MIDIInputMap: ss, MIDIMessageEvent: ss, MIDIOutput: ss, MIDIOutputMap: ss, MIDIPort: ss, MimeType: ss, MimeTypeArray: ss, MouseEvent: ss, moveBy: es, moveTo: es, MutationEvent: ss, MutationObserver: ss, MutationRecord: ss, name: es, NamedNodeMap: ss, NavigationPreloadManager: ss, navigator: es, Navigator: ss, NetworkInformation: ss, Node: ss, NodeFilter: es, NodeIterator: ss, NodeList: ss, Notification: ss, OfflineAudioCompletionEvent: ss, OfflineAudioContext: ss, offscreenBuffering: es, OffscreenCanvas: ss, open: es, openDatabase: es, Option: ss, origin: es, OscillatorNode: ss, outerHeight: es, outerWidth: es, PageTransitionEvent: ss, pageXOffset: es, pageYOffset: es, PannerNode: ss, parent: es, Path2D: ss, PaymentAddress: ss, PaymentRequest: ss, PaymentRequestUpdateEvent: ss, PaymentResponse: ss, performance: es, Performance: ss, PerformanceEntry: ss, PerformanceLongTaskTiming: ss, PerformanceMark: ss, PerformanceMeasure: ss, PerformanceNavigation: ss, PerformanceNavigationTiming: ss, PerformanceObserver: ss, PerformanceObserverEntryList: ss, PerformancePaintTiming: ss, PerformanceResourceTiming: ss, PerformanceTiming: ss, PeriodicWave: ss, Permissions: ss, PermissionStatus: ss, personalbar: es, PhotoCapabilities: ss, Plugin: ss, PluginArray: ss, PointerEvent: ss, PopStateEvent: ss, postMessage: es, Presentation: ss, PresentationAvailability: ss, PresentationConnection: ss, PresentationConnectionAvailableEvent: ss, PresentationConnectionCloseEvent: ss, PresentationConnectionList: ss, PresentationReceiver: ss, PresentationRequest: ss, print: es, ProcessingInstruction: ss, ProgressEvent: ss, PromiseRejectionEvent: ss, prompt: es, PushManager: ss, PushSubscription: ss, PushSubscriptionOptions: ss, queueMicrotask: es, RadioNodeList: ss, Range: ss, ReadableStream: ss, RemotePlayback: ss, removeEventListener: es, Request: ss, requestAnimationFrame: es, requestIdleCallback: es, resizeBy: es, ResizeObserver: ss, ResizeObserverEntry: ss, resizeTo: es, Response: ss, RTCCertificate: ss, RTCDataChannel: ss, RTCDataChannelEvent: ss, RTCDtlsTransport: ss, RTCIceCandidate: ss, RTCIceTransport: ss, RTCPeerConnection: ss, RTCPeerConnectionIceEvent: ss, RTCRtpReceiver: ss, RTCRtpSender: ss, RTCSctpTransport: ss, RTCSessionDescription: ss, RTCStatsReport: ss, RTCTrackEvent: ss, screen: es, Screen: ss, screenLeft: es, ScreenOrientation: ss, screenTop: es, screenX: es, screenY: es, ScriptProcessorNode: ss, scroll: es, scrollbars: es, scrollBy: es, scrollTo: es, scrollX: es, scrollY: es, SecurityPolicyViolationEvent: ss, Selection: ss, ServiceWorker: ss, ServiceWorkerContainer: ss, ServiceWorkerRegistration: ss, sessionStorage: es, ShadowRoot: ss, SharedWorker: ss, SourceBuffer: ss, SourceBufferList: ss, speechSynthesis: es, SpeechSynthesisEvent: ss, SpeechSynthesisUtterance: ss, StaticRange: ss, status: es, statusbar: es, StereoPannerNode: ss, stop: es, Storage: ss, StorageEvent: ss, StorageManager: ss, styleMedia: es, StyleSheet: ss, StyleSheetList: ss, SubtleCrypto: ss, SVGAElement: ss, SVGAngle: ss, SVGAnimatedAngle: ss, SVGAnimatedBoolean: ss, SVGAnimatedEnumeration: ss, SVGAnimatedInteger: ss, SVGAnimatedLength: ss, SVGAnimatedLengthList: ss, SVGAnimatedNumber: ss, SVGAnimatedNumberList: ss, SVGAnimatedPreserveAspectRatio: ss, SVGAnimatedRect: ss, SVGAnimatedString: ss, SVGAnimatedTransformList: ss, SVGAnimateElement: ss, SVGAnimateMotionElement: ss, SVGAnimateTransformElement: ss, SVGAnimationElement: ss, SVGCircleElement: ss, SVGClipPathElement: ss, SVGComponentTransferFunctionElement: ss, SVGDefsElement: ss, SVGDescElement: ss, SVGDiscardElement: ss, SVGElement: ss, SVGEllipseElement: ss, SVGFEBlendElement: ss, SVGFEColorMatrixElement: ss, SVGFEComponentTransferElement: ss, SVGFECompositeElement: ss, SVGFEConvolveMatrixElement: ss, SVGFEDiffuseLightingElement: ss, SVGFEDisplacementMapElement: ss, SVGFEDistantLightElement: ss, SVGFEDropShadowElement: ss, SVGFEFloodElement: ss, SVGFEFuncAElement: ss, SVGFEFuncBElement: ss, SVGFEFuncGElement: ss, SVGFEFuncRElement: ss, SVGFEGaussianBlurElement: ss, SVGFEImageElement: ss, SVGFEMergeElement: ss, SVGFEMergeNodeElement: ss, SVGFEMorphologyElement: ss, SVGFEOffsetElement: ss, SVGFEPointLightElement: ss, SVGFESpecularLightingElement: ss, SVGFESpotLightElement: ss, SVGFETileElement: ss, SVGFETurbulenceElement: ss, SVGFilterElement: ss, SVGForeignObjectElement: ss, SVGGElement: ss, SVGGeometryElement: ss, SVGGradientElement: ss, SVGGraphicsElement: ss, SVGImageElement: ss, SVGLength: ss, SVGLengthList: ss, SVGLinearGradientElement: ss, SVGLineElement: ss, SVGMarkerElement: ss, SVGMaskElement: ss, SVGMatrix: ss, SVGMetadataElement: ss, SVGMPathElement: ss, SVGNumber: ss, SVGNumberList: ss, SVGPathElement: ss, SVGPatternElement: ss, SVGPoint: ss, SVGPointList: ss, SVGPolygonElement: ss, SVGPolylineElement: ss, SVGPreserveAspectRatio: ss, SVGRadialGradientElement: ss, SVGRect: ss, SVGRectElement: ss, SVGScriptElement: ss, SVGSetElement: ss, SVGStopElement: ss, SVGStringList: ss, SVGStyleElement: ss, SVGSVGElement: ss, SVGSwitchElement: ss, SVGSymbolElement: ss, SVGTextContentElement: ss, SVGTextElement: ss, SVGTextPathElement: ss, SVGTextPositioningElement: ss, SVGTitleElement: ss, SVGTransform: ss, SVGTransformList: ss, SVGTSpanElement: ss, SVGUnitTypes: ss, SVGUseElement: ss, SVGViewElement: ss, TaskAttributionTiming: ss, Text: ss, TextEvent: ss, TextMetrics: ss, TextTrack: ss, TextTrackCue: ss, TextTrackCueList: ss, TextTrackList: ss, TimeRanges: ss, toolbar: es, top: es, Touch: ss, TouchEvent: ss, TouchList: ss, TrackEvent: ss, TransitionEvent: ss, TreeWalker: ss, UIEvent: ss, ValidityState: ss, visualViewport: es, VisualViewport: ss, VTTCue: ss, WaveShaperNode: ss, WebAssembly: es, WebGL2RenderingContext: ss, WebGLActiveInfo: ss, WebGLBuffer: ss, WebGLContextEvent: ss, WebGLFramebuffer: ss, WebGLProgram: ss, WebGLQuery: ss, WebGLRenderbuffer: ss, WebGLRenderingContext: ss, WebGLSampler: ss, WebGLShader: ss, WebGLShaderPrecisionFormat: ss, WebGLSync: ss, WebGLTexture: ss, WebGLTransformFeedback: ss, WebGLUniformLocation: ss, WebGLVertexArrayObject: ss, WebSocket: ss, WheelEvent: ss, Window: ss, Worker: ss, WritableStream: ss, XMLDocument: ss, XMLHttpRequest: ss, XMLHttpRequestEventTarget: ss, XMLHttpRequestUpload: ss, XMLSerializer: ss, XPathEvaluator: ss, XPathExpression: ss, XPathResult: ss, XSLTProcessor: ss };
    for (const e2 of ["window", "global", "self", "globalThis"])
      as[e2] = as;
    hs = class extends K {
      constructor() {
        super(...arguments), this.isReassigned = true;
      }
      hasEffectsWhenAccessedAtPath(e2) {
        return !function(e3) {
          return e3.length === 1 ? e3[0] === "undefined" || os2(e3) !== null : os2(e3.slice(0, -1)) !== null;
        }([this.name, ...e2]);
      }
      hasEffectsWhenCalledAtPath(e2) {
        return !function(e3) {
          const t = os2(e3);
          return t !== null && t.pure;
        }([this.name, ...e2]);
      }
    };
    ls = { __proto__: null, class: true, const: true, let: true, var: true };
    cs = class extends rt {
      constructor() {
        super(...arguments), this.variable = null, this.deoptimized = false, this.isTDZAccess = null;
      }
      addExportedVariables(e2, t) {
        this.variable !== null && t.has(this.variable) && e2.push(this.variable);
      }
      bind() {
        this.variable === null && Yt(this, this.parent) && (this.variable = this.scope.findVariable(this.name), this.variable.addReference(this));
      }
      declare(e2, t) {
        let s2;
        const { treeshake: i2 } = this.context.options;
        switch (e2) {
          case "var":
            s2 = this.scope.addDeclaration(this, this.context, t, true), i2 && i2.correctVarValueBeforeDeclaration && s2.markInitializersForDeoptimization();
            break;
          case "function":
          case "let":
          case "const":
          case "class":
            s2 = this.scope.addDeclaration(this, this.context, t, false);
            break;
          case "parameter":
            s2 = this.scope.addParameterDeclaration(this);
            break;
          default:
            throw new Error(`Internal Error: Unexpected identifier kind ${e2}.`);
        }
        return s2.kind = e2, [this.variable = s2];
      }
      deoptimizePath(e2) {
        e2.length !== 0 || this.scope.contains(this.name) || this.disallowImportReassignment(), this.variable.deoptimizePath(e2);
      }
      deoptimizeThisOnEventAtPath(e2, t, s2, i2) {
        this.variable.deoptimizeThisOnEventAtPath(e2, t, s2, i2);
      }
      getLiteralValueAtPath(e2, t, s2) {
        return this.getVariableRespectingTDZ().getLiteralValueAtPath(e2, t, s2);
      }
      getReturnExpressionWhenCalledAtPath(e2, t, s2, i2) {
        return this.getVariableRespectingTDZ().getReturnExpressionWhenCalledAtPath(e2, t, s2, i2);
      }
      hasEffects() {
        return this.deoptimized || this.applyDeoptimizations(), !(!this.isPossibleTDZ() || this.variable.kind === "var") || this.context.options.treeshake.unknownGlobalSideEffects && this.variable instanceof hs && this.variable.hasEffectsWhenAccessedAtPath(V);
      }
      hasEffectsWhenAccessedAtPath(e2, t) {
        return this.variable !== null && this.getVariableRespectingTDZ().hasEffectsWhenAccessedAtPath(e2, t);
      }
      hasEffectsWhenAssignedAtPath(e2, t) {
        return !this.variable || (e2.length > 0 ? this.getVariableRespectingTDZ() : this.variable).hasEffectsWhenAssignedAtPath(e2, t);
      }
      hasEffectsWhenCalledAtPath(e2, t, s2) {
        return !this.variable || this.getVariableRespectingTDZ().hasEffectsWhenCalledAtPath(e2, t, s2);
      }
      include() {
        this.deoptimized || this.applyDeoptimizations(), this.included || (this.included = true, this.variable !== null && this.context.includeVariableInModule(this.variable));
      }
      includeCallArguments(e2, t) {
        this.getVariableRespectingTDZ().includeCallArguments(e2, t);
      }
      isPossibleTDZ() {
        if (this.isTDZAccess !== null)
          return this.isTDZAccess;
        if (!(this.variable instanceof _t && this.variable.kind && this.variable.kind in ls))
          return this.isTDZAccess = false;
        let e2;
        return this.variable.declarations && this.variable.declarations.length === 1 && (e2 = this.variable.declarations[0]) && this.start < e2.start && us(this) === us(e2) ? this.isTDZAccess = true : this.variable.initReached ? this.isTDZAccess = false : this.isTDZAccess = true;
      }
      markDeclarationReached() {
        this.variable.initReached = true;
      }
      render(e2, { snippets: { getPropertyAccess: t } }, { renderedParentType: s2, isCalleeOfRenderedParent: i2, isShorthandProperty: n3 } = Y) {
        if (this.variable) {
          const r2 = this.variable.getName(t);
          r2 !== this.name && (e2.overwrite(this.start, this.end, r2, { contentOnly: true, storeName: true }), n3 && e2.prependRight(this.start, `${this.name}: `)), r2 === "eval" && s2 === "CallExpression" && i2 && e2.appendRight(this.start, "0, ");
        }
      }
      applyDeoptimizations() {
        this.deoptimized = true, this.variable !== null && this.variable instanceof _t && (this.variable.consolidateInitializers(), this.context.requestTreeshakingPass());
      }
      disallowImportReassignment() {
        return this.context.error({ code: "ILLEGAL_REASSIGNMENT", message: `Illegal reassignment to import '${this.name}'` }, this.start);
      }
      getVariableRespectingTDZ() {
        return this.isPossibleTDZ() ? q : this.variable;
      }
    };
    ds = class extends rt {
      constructor() {
        super(...arguments), this.deoptimized = false, this.declarationInit = null;
      }
      addExportedVariables(e2, t) {
        this.argument.addExportedVariables(e2, t);
      }
      declare(e2, t) {
        return this.declarationInit = t, this.argument.declare(e2, q);
      }
      deoptimizePath(e2) {
        e2.length === 0 && this.argument.deoptimizePath(V);
      }
      hasEffectsWhenAssignedAtPath(e2, t) {
        return e2.length > 0 || this.argument.hasEffectsWhenAssignedAtPath(V, t);
      }
      markDeclarationReached() {
        this.argument.markDeclarationReached();
      }
      applyDeoptimizations() {
        this.deoptimized = true, this.declarationInit !== null && (this.declarationInit.deoptimizePath([L, L]), this.context.requestTreeshakingPass());
      }
    };
    ps = class extends rt {
      constructor() {
        super(...arguments), this.deoptimizedReturn = false;
      }
      createScope(e2) {
        this.scope = new Lt(e2, this.context);
      }
      deoptimizePath(e2) {
        e2.length === 1 && e2[0] === L && this.scope.getReturnExpression().deoptimizePath(B2);
      }
      deoptimizeThisOnEventAtPath() {
      }
      getReturnExpressionWhenCalledAtPath(e2) {
        return e2.length !== 0 ? q : this.async ? (this.deoptimizedReturn || (this.deoptimizedReturn = true, this.scope.getReturnExpression().deoptimizePath(B2), this.context.requestTreeshakingPass()), q) : this.scope.getReturnExpression();
      }
      hasEffects() {
        return false;
      }
      hasEffectsWhenAccessedAtPath(e2) {
        return e2.length > 1;
      }
      hasEffectsWhenAssignedAtPath(e2) {
        return e2.length > 1;
      }
      hasEffectsWhenCalledAtPath(e2, t, s2) {
        if (e2.length > 0)
          return true;
        if (this.async) {
          const { propertyReadSideEffects: e3 } = this.context.options.treeshake, t2 = this.scope.getReturnExpression();
          if (t2.hasEffectsWhenCalledAtPath(["then"], { args: _e, thisParam: null, withNew: false }, s2) || e3 && (e3 === "always" || t2.hasEffectsWhenAccessedAtPath(["then"], s2)))
            return true;
        }
        for (const e3 of this.params)
          if (e3.hasEffects(s2))
            return true;
        const { ignore: i2, brokenFlow: n3 } = s2;
        return s2.ignore = { breaks: false, continues: false, labels: /* @__PURE__ */ new Set(), returnYield: true }, !!this.body.hasEffects(s2) || (s2.ignore = i2, s2.brokenFlow = n3, false);
      }
      include(e2, t) {
        this.included = true;
        for (const s3 of this.params)
          s3 instanceof cs || s3.include(e2, t);
        const { brokenFlow: s2 } = e2;
        e2.brokenFlow = 0, this.body.include(e2, t), e2.brokenFlow = s2;
      }
      includeCallArguments(e2, t) {
        this.scope.includeCallArguments(e2, t);
      }
      initialise() {
        this.scope.addParameterVariables(this.params.map((e2) => e2.declare("parameter", q)), this.params[this.params.length - 1] instanceof ds), this.body instanceof Xt ? this.body.addImplicitReturnExpressionToScope() : this.scope.addReturnExpression(this.body);
      }
      parseNode(e2) {
        e2.body.type === "BlockStatement" && (this.body = new Xt(e2.body, this, this.scope.hoistedBodyVarScope)), super.parseNode(e2);
      }
    };
    ps.prototype.preventChildBlockScope = true;
    ys = class extends rt {
      addExportedVariables(e2, t) {
        for (const s2 of this.properties)
          s2.type === "Property" ? s2.value.addExportedVariables(e2, t) : s2.argument.addExportedVariables(e2, t);
      }
      declare(e2, t) {
        const s2 = [];
        for (const i2 of this.properties)
          s2.push(...i2.declare(e2, t));
        return s2;
      }
      deoptimizePath(e2) {
        if (e2.length === 0)
          for (const t of this.properties)
            t.deoptimizePath(e2);
      }
      hasEffectsWhenAssignedAtPath(e2, t) {
        if (e2.length > 0)
          return true;
        for (const e3 of this.properties)
          if (e3.hasEffectsWhenAssignedAtPath(V, t))
            return true;
        return false;
      }
      markDeclarationReached() {
        for (const e2 of this.properties)
          e2.markDeclarationReached();
      }
    };
    Es = class extends rt {
      constructor() {
        super(...arguments), this.deoptimized = false;
      }
      hasEffects(e2) {
        return this.deoptimized || this.applyDeoptimizations(), this.right.hasEffects(e2) || this.left.hasEffects(e2) || this.left.hasEffectsWhenAssignedAtPath(V, e2);
      }
      hasEffectsWhenAccessedAtPath(e2, t) {
        return e2.length > 0 && this.right.hasEffectsWhenAccessedAtPath(e2, t);
      }
      include(e2, t) {
        let s2;
        this.deoptimized || this.applyDeoptimizations(), this.included = true, (t || this.operator !== "=" || this.left.included || (s2 = Ne(), this.left.hasEffects(s2) || this.left.hasEffectsWhenAssignedAtPath(V, s2))) && this.left.include(e2, t), this.right.include(e2, t);
      }
      render(e2, t, { preventASI: s2, renderedParentType: i2, renderedSurroundingElement: n3 } = Y) {
        if (this.left.included)
          this.left.render(e2, t), this.right.render(e2, t);
        else {
          const r2 = Wt(e2.original, Ft(e2.original, "=", this.left.end) + 1);
          e2.remove(this.start, r2), s2 && Ht(e2, r2, this.right.start), this.right.render(e2, t, { renderedParentType: i2 || this.parent.type, renderedSurroundingElement: n3 || this.parent.type });
        }
        if (t.format === "system")
          if (this.left instanceof cs) {
            const s3 = this.left.variable, i3 = t.exportNamesByVariable.get(s3);
            if (i3)
              return void (i3.length === 1 ? ms2(s3, this.start, this.end, e2, t) : gs(s3, this.start, this.end, this.parent.type !== "ExpressionStatement", e2, t));
          } else {
            const s3 = [];
            if (this.left.addExportedVariables(s3, t.exportNamesByVariable), s3.length > 0)
              return void function(e3, t2, s4, i3, n4, r2) {
                const { _: a2, getDirectReturnIifeLeft: o2 } = r2.snippets;
                n4.prependRight(t2, o2(["v"], `${fs2(e3, r2)},${a2}v`, { needsArrowReturnParens: true, needsWrappedFunction: i3 })), n4.appendLeft(s4, ")");
              }(s3, this.start, this.end, n3 === "ExpressionStatement", e2, t);
          }
        this.left.included && this.left instanceof ys && (n3 === "ExpressionStatement" || n3 === "ArrowFunctionExpression") && (e2.appendRight(this.start, "("), e2.prependLeft(this.end, ")"));
      }
      applyDeoptimizations() {
        this.deoptimized = true, this.left.deoptimizePath(V), this.right.deoptimizePath(B2), this.context.requestTreeshakingPass();
      }
    };
    xs = class extends _t {
      constructor(e2) {
        super("arguments", null, q, e2);
      }
      hasEffectsWhenAccessedAtPath(e2) {
        return e2.length > 1;
      }
      hasEffectsWhenAssignedAtPath() {
        return true;
      }
      hasEffectsWhenCalledAtPath() {
        return true;
      }
    };
    vs = class extends _t {
      constructor(e2) {
        super("this", null, null, e2), this.deoptimizedPaths = [], this.entitiesToBeDeoptimized = /* @__PURE__ */ new Set(), this.thisDeoptimizationList = [], this.thisDeoptimizations = new j();
      }
      addEntityToBeDeoptimized(e2) {
        for (const t of this.deoptimizedPaths)
          e2.deoptimizePath(t);
        for (const t of this.thisDeoptimizationList)
          this.applyThisDeoptimizationEvent(e2, t);
        this.entitiesToBeDeoptimized.add(e2);
      }
      deoptimizePath(e2) {
        if (e2.length !== 0 && !this.deoptimizationTracker.trackEntityAtPathAndGetIfTracked(e2, this)) {
          this.deoptimizedPaths.push(e2);
          for (const t of this.entitiesToBeDeoptimized)
            t.deoptimizePath(e2);
        }
      }
      deoptimizeThisOnEventAtPath(e2, t, s2) {
        const i2 = { event: e2, path: t, thisParameter: s2 };
        if (!this.thisDeoptimizations.trackEntityAtPathAndGetIfTracked(t, e2, s2)) {
          for (const e3 of this.entitiesToBeDeoptimized)
            this.applyThisDeoptimizationEvent(e3, i2);
          this.thisDeoptimizationList.push(i2);
        }
      }
      hasEffectsWhenAccessedAtPath(e2, t) {
        return this.getInit(t).hasEffectsWhenAccessedAtPath(e2, t) || super.hasEffectsWhenAccessedAtPath(e2, t);
      }
      hasEffectsWhenAssignedAtPath(e2, t) {
        return this.getInit(t).hasEffectsWhenAssignedAtPath(e2, t) || super.hasEffectsWhenAssignedAtPath(e2, t);
      }
      applyThisDeoptimizationEvent(e2, { event: t, path: s2, thisParameter: i2 }) {
        e2.deoptimizeThisOnEventAtPath(t, s2, i2 === this ? e2 : i2, U);
      }
      getInit(e2) {
        return e2.replacedVariableInits.get(this) || q;
      }
    };
    bs = class extends Lt {
      constructor(e2, t) {
        super(e2, t), this.variables.set("arguments", this.argumentsVariable = new xs(t)), this.variables.set("this", this.thisVariable = new vs(t));
      }
      findLexicalBoundary() {
        return this;
      }
      includeCallArguments(e2, t) {
        if (super.includeCallArguments(e2, t), this.argumentsVariable.included)
          for (const s2 of t)
            s2.included || s2.include(e2, false);
      }
    };
    Ss = class extends rt {
      constructor() {
        super(...arguments), this.deoptimizedReturn = false, this.isPrototypeDeoptimized = false;
      }
      createScope(e2) {
        this.scope = new bs(e2, this.context);
      }
      deoptimizePath(e2) {
        e2.length === 1 && (e2[0] === "prototype" ? this.isPrototypeDeoptimized = true : e2[0] === L && (this.isPrototypeDeoptimized = true, this.scope.getReturnExpression().deoptimizePath(B2)));
      }
      deoptimizeThisOnEventAtPath(e2, t, s2) {
        e2 === 2 && (t.length > 0 ? s2.deoptimizePath(B2) : this.scope.thisVariable.addEntityToBeDeoptimized(s2));
      }
      getReturnExpressionWhenCalledAtPath(e2) {
        return e2.length !== 0 ? q : this.async ? (this.deoptimizedReturn || (this.deoptimizedReturn = true, this.scope.getReturnExpression().deoptimizePath(B2), this.context.requestTreeshakingPass()), q) : this.scope.getReturnExpression();
      }
      hasEffects() {
        return this.id !== null && this.id.hasEffects();
      }
      hasEffectsWhenAccessedAtPath(e2) {
        return !(e2.length <= 1) && (e2.length > 2 || e2[0] !== "prototype" || this.isPrototypeDeoptimized);
      }
      hasEffectsWhenAssignedAtPath(e2) {
        return !(e2.length <= 1) && (e2.length > 2 || e2[0] !== "prototype" || this.isPrototypeDeoptimized);
      }
      hasEffectsWhenCalledAtPath(e2, t, s2) {
        if (e2.length > 0)
          return true;
        if (this.async) {
          const { propertyReadSideEffects: e3 } = this.context.options.treeshake, t2 = this.scope.getReturnExpression();
          if (t2.hasEffectsWhenCalledAtPath(["then"], { args: _e, thisParam: null, withNew: false }, s2) || e3 && (e3 === "always" || t2.hasEffectsWhenAccessedAtPath(["then"], s2)))
            return true;
        }
        for (const e3 of this.params)
          if (e3.hasEffects(s2))
            return true;
        const i2 = s2.replacedVariableInits.get(this.scope.thisVariable);
        s2.replacedVariableInits.set(this.scope.thisVariable, t.withNew ? new pt(/* @__PURE__ */ Object.create(null), gt) : q);
        const { brokenFlow: n3, ignore: r2 } = s2;
        return s2.ignore = { breaks: false, continues: false, labels: /* @__PURE__ */ new Set(), returnYield: true }, !!this.body.hasEffects(s2) || (s2.brokenFlow = n3, i2 ? s2.replacedVariableInits.set(this.scope.thisVariable, i2) : s2.replacedVariableInits.delete(this.scope.thisVariable), s2.ignore = r2, false);
      }
      include(e2, t) {
        this.included = true, this.id && this.id.include();
        const s2 = this.scope.argumentsVariable.included;
        for (const i3 of this.params)
          i3 instanceof cs && !s2 || i3.include(e2, t);
        const { brokenFlow: i2 } = e2;
        e2.brokenFlow = 0, this.body.include(e2, t), e2.brokenFlow = i2;
      }
      includeCallArguments(e2, t) {
        this.scope.includeCallArguments(e2, t);
      }
      initialise() {
        this.id !== null && this.id.declare("function", this), this.scope.addParameterVariables(this.params.map((e2) => e2.declare("parameter", q)), this.params[this.params.length - 1] instanceof ds), this.body.addImplicitReturnExpressionToScope();
      }
      parseNode(e2) {
        this.body = new Xt(e2.body, this, this.scope.hoistedBodyVarScope), super.parseNode(e2);
      }
    };
    Ss.prototype.preventChildBlockScope = true;
    As = { "!=": (e2, t) => e2 != t, "!==": (e2, t) => e2 !== t, "%": (e2, t) => e2 % t, "&": (e2, t) => e2 & t, "*": (e2, t) => e2 * t, "**": (e2, t) => e2 ** t, "+": (e2, t) => e2 + t, "-": (e2, t) => e2 - t, "/": (e2, t) => e2 / t, "<": (e2, t) => e2 < t, "<<": (e2, t) => e2 << t, "<=": (e2, t) => e2 <= t, "==": (e2, t) => e2 == t, "===": (e2, t) => e2 === t, ">": (e2, t) => e2 > t, ">=": (e2, t) => e2 >= t, ">>": (e2, t) => e2 >> t, ">>>": (e2, t) => e2 >>> t, "^": (e2, t) => e2 ^ t, in: () => G, instanceof: () => G, "|": (e2, t) => e2 | t };
    Ps = class extends rt {
      deoptimizeThisOnEventAtPath() {
      }
      getLiteralValueAtPath(e2) {
        return e2.length > 0 || this.value === null && this.context.code.charCodeAt(this.start) !== 110 || typeof this.value == "bigint" || this.context.code.charCodeAt(this.start) === 47 ? G : this.value;
      }
      getReturnExpressionWhenCalledAtPath(e2) {
        return e2.length !== 1 ? q : Ge(this.members, e2[0]);
      }
      hasEffectsWhenAccessedAtPath(e2) {
        return this.value === null ? e2.length > 0 : e2.length > 1;
      }
      hasEffectsWhenAssignedAtPath(e2) {
        return e2.length > 0;
      }
      hasEffectsWhenCalledAtPath(e2, t, s2) {
        return e2.length !== 1 || je(this.members, e2[0], t, s2);
      }
      initialise() {
        this.members = function(e2) {
          switch (typeof e2) {
            case "boolean":
              return ze;
            case "number":
              return We;
            case "string":
              return Ue;
          }
          return /* @__PURE__ */ Object.create(null);
        }(this.value);
      }
      parseNode(e2) {
        this.value = e2.value, this.regex = e2.regex, super.parseNode(e2);
      }
      render(e2) {
        typeof this.value == "string" && e2.indentExclusionRanges.push([this.start + 1, this.end - 1]);
      }
    };
    Cs = class extends rt {
      constructor() {
        super(...arguments), this.variable = null, this.deoptimized = false, this.bound = false, this.expressionsToBeDeoptimized = [], this.replacement = null;
      }
      bind() {
        this.bound = true;
        const e2 = ws(this), t = e2 && this.scope.findVariable(e2[0].key);
        if (t && t.isNamespace) {
          const s2 = this.resolveNamespaceVariables(t, e2.slice(1));
          s2 ? typeof s2 == "string" ? this.replacement = s2 : (this.variable = s2, this.scope.addNamespaceMemberAccess(function(e3) {
            let t2 = e3[0].key;
            for (let s3 = 1; s3 < e3.length; s3++)
              t2 += "." + e3[s3].key;
            return t2;
          }(e2), s2)) : super.bind();
        } else
          super.bind();
      }
      deoptimizeCache() {
        const e2 = this.expressionsToBeDeoptimized;
        this.expressionsToBeDeoptimized = [], this.propertyKey = L, this.object.deoptimizePath(B2);
        for (const t of e2)
          t.deoptimizeCache();
      }
      deoptimizePath(e2) {
        e2.length === 0 && this.disallowNamespaceReassignment(), this.variable ? this.variable.deoptimizePath(e2) : this.replacement || e2.length < 7 && this.object.deoptimizePath([this.getPropertyKey(), ...e2]);
      }
      deoptimizeThisOnEventAtPath(e2, t, s2, i2) {
        this.variable ? this.variable.deoptimizeThisOnEventAtPath(e2, t, s2, i2) : this.replacement || (t.length < 7 ? this.object.deoptimizeThisOnEventAtPath(e2, [this.getPropertyKey(), ...t], s2, i2) : s2.deoptimizePath(B2));
      }
      getLiteralValueAtPath(e2, t, s2) {
        return this.variable !== null ? this.variable.getLiteralValueAtPath(e2, t, s2) : this.replacement ? G : (this.expressionsToBeDeoptimized.push(s2), e2.length < 7 ? this.object.getLiteralValueAtPath([this.getPropertyKey(), ...e2], t, s2) : G);
      }
      getReturnExpressionWhenCalledAtPath(e2, t, s2, i2) {
        return this.variable !== null ? this.variable.getReturnExpressionWhenCalledAtPath(e2, t, s2, i2) : this.replacement ? q : (this.expressionsToBeDeoptimized.push(i2), e2.length < 7 ? this.object.getReturnExpressionWhenCalledAtPath([this.getPropertyKey(), ...e2], t, s2, i2) : q);
      }
      hasEffects(e2) {
        this.deoptimized || this.applyDeoptimizations();
        const { propertyReadSideEffects: t } = this.context.options.treeshake;
        return this.property.hasEffects(e2) || this.object.hasEffects(e2) || !(this.variable || this.replacement || this.parent instanceof Es && this.parent.operator === "=") && t && (t === "always" || this.object.hasEffectsWhenAccessedAtPath([this.getPropertyKey()], e2));
      }
      hasEffectsWhenAccessedAtPath(e2, t) {
        return this.variable !== null ? this.variable.hasEffectsWhenAccessedAtPath(e2, t) : !!this.replacement || (!(e2.length < 7) || this.object.hasEffectsWhenAccessedAtPath([this.getPropertyKey(), ...e2], t));
      }
      hasEffectsWhenAssignedAtPath(e2, t) {
        return this.variable !== null ? this.variable.hasEffectsWhenAssignedAtPath(e2, t) : !!this.replacement || (!(e2.length < 7) || this.object.hasEffectsWhenAssignedAtPath([this.getPropertyKey(), ...e2], t));
      }
      hasEffectsWhenCalledAtPath(e2, t, s2) {
        return this.variable !== null ? this.variable.hasEffectsWhenCalledAtPath(e2, t, s2) : !!this.replacement || (!(e2.length < 7) || this.object.hasEffectsWhenCalledAtPath([this.getPropertyKey(), ...e2], t, s2));
      }
      include(e2, t) {
        this.deoptimized || this.applyDeoptimizations(), this.included || (this.included = true, this.variable !== null && this.context.includeVariableInModule(this.variable)), this.object.include(e2, t), this.property.include(e2, t);
      }
      includeCallArguments(e2, t) {
        this.variable ? this.variable.includeCallArguments(e2, t) : super.includeCallArguments(e2, t);
      }
      initialise() {
        this.propertyKey = ks(this);
      }
      render(e2, t, { renderedParentType: s2, isCalleeOfRenderedParent: i2, renderedSurroundingElement: n3 } = Y) {
        if (this.variable || this.replacement) {
          const { snippets: { getPropertyAccess: n4 } } = t;
          let r2 = this.variable ? this.variable.getName(n4) : this.replacement;
          s2 && i2 && (r2 = "0, " + r2), e2.overwrite(this.start, this.end, r2, { contentOnly: true, storeName: true });
        } else
          s2 && i2 && e2.appendRight(this.start, "0, "), this.object.render(e2, t, { renderedSurroundingElement: n3 }), this.property.render(e2, t);
      }
      applyDeoptimizations() {
        this.deoptimized = true;
        const { propertyReadSideEffects: e2 } = this.context.options.treeshake;
        this.bound && e2 && !this.variable && !this.replacement && (this.parent instanceof Es && this.parent.operator === "=" || this.object.deoptimizeThisOnEventAtPath(0, [this.propertyKey], this.object, U), this.parent instanceof Es && this.object.deoptimizeThisOnEventAtPath(1, [this.propertyKey], this.object, U), this.context.requestTreeshakingPass());
      }
      disallowNamespaceReassignment() {
        if (this.object instanceof cs) {
          this.scope.findVariable(this.object.name).isNamespace && (this.variable && this.context.includeVariableInModule(this.variable), this.context.warn({ code: "ILLEGAL_NAMESPACE_REASSIGNMENT", message: `Illegal reassignment to import '${this.object.name}'` }, this.start));
        }
      }
      getPropertyKey() {
        if (this.propertyKey === null) {
          this.propertyKey = L;
          const e2 = this.property.getLiteralValueAtPath(V, U, this);
          return this.propertyKey = e2 === G ? L : String(e2);
        }
        return this.propertyKey;
      }
      resolveNamespaceVariables(e2, t) {
        if (t.length === 0)
          return e2;
        if (!e2.isNamespace || e2 instanceof X)
          return null;
        const s2 = t[0].key, i2 = e2.context.traceExport(s2);
        if (!i2) {
          const i3 = e2.context.fileName;
          return this.context.warn({ code: "MISSING_EXPORT", exporter: ie(i3), importer: ie(this.context.fileName), message: `'${s2}' is not exported by '${ie(i3)}'`, missing: s2, url: "https://rollupjs.org/guide/en/#error-name-is-not-exported-by-module" }, t[0].pos), "undefined";
        }
        return this.resolveNamespaceVariables(i2, t.slice(1));
      }
    };
    Is = class extends Dt {
      addDeclaration(e2, t, s2, i2) {
        const n3 = this.variables.get(e2.name);
        return n3 ? (this.parent.addDeclaration(e2, t, Te, i2), n3.addDeclaration(e2, s2), n3) : this.parent.addDeclaration(e2, t, s2, i2);
      }
    };
    Ns = class extends Mt {
      constructor(e2, t, s2) {
        super(e2), this.variables.set("this", this.thisVariable = new _t("this", null, t, s2)), this.instanceScope = new Mt(this), this.instanceScope.variables.set("this", new vs(s2));
      }
      findLexicalBoundary() {
        return this;
      }
    };
    _s = class extends rt {
      constructor() {
        super(...arguments), this.accessedValue = null, this.accessorCallOptions = { args: _e, thisParam: null, withNew: false };
      }
      deoptimizeCache() {
      }
      deoptimizePath(e2) {
        this.getAccessedValue().deoptimizePath(e2);
      }
      deoptimizeThisOnEventAtPath(e2, t, s2, i2) {
        return e2 === 0 && this.kind === "get" && t.length === 0 || e2 === 1 && this.kind === "set" && t.length === 0 ? this.value.deoptimizeThisOnEventAtPath(2, V, s2, i2) : void this.getAccessedValue().deoptimizeThisOnEventAtPath(e2, t, s2, i2);
      }
      getLiteralValueAtPath(e2, t, s2) {
        return this.getAccessedValue().getLiteralValueAtPath(e2, t, s2);
      }
      getReturnExpressionWhenCalledAtPath(e2, t, s2, i2) {
        return this.getAccessedValue().getReturnExpressionWhenCalledAtPath(e2, t, s2, i2);
      }
      hasEffects(e2) {
        return this.key.hasEffects(e2);
      }
      hasEffectsWhenAccessedAtPath(e2, t) {
        return this.kind === "get" && e2.length === 0 ? this.value.hasEffectsWhenCalledAtPath(V, this.accessorCallOptions, t) : this.getAccessedValue().hasEffectsWhenAccessedAtPath(e2, t);
      }
      hasEffectsWhenAssignedAtPath(e2, t) {
        return this.kind === "set" ? this.value.hasEffectsWhenCalledAtPath(V, this.accessorCallOptions, t) : this.getAccessedValue().hasEffectsWhenAssignedAtPath(e2, t);
      }
      hasEffectsWhenCalledAtPath(e2, t, s2) {
        return this.getAccessedValue().hasEffectsWhenCalledAtPath(e2, t, s2);
      }
      getAccessedValue() {
        return this.accessedValue === null ? this.kind === "get" ? (this.accessedValue = q, this.accessedValue = this.value.getReturnExpressionWhenCalledAtPath(V, this.accessorCallOptions, U, this)) : this.accessedValue = this.value : this.accessedValue;
      }
    };
    $s = class extends _s {
    };
    Ts = class extends H {
      constructor(e2, t) {
        super(), this.object = e2, this.key = t;
      }
      deoptimizePath(e2) {
        this.object.deoptimizePath([this.key, ...e2]);
      }
      deoptimizeThisOnEventAtPath(e2, t, s2, i2) {
        this.object.deoptimizeThisOnEventAtPath(e2, [this.key, ...t], s2, i2);
      }
      getLiteralValueAtPath(e2, t, s2) {
        return this.object.getLiteralValueAtPath([this.key, ...e2], t, s2);
      }
      getReturnExpressionWhenCalledAtPath(e2, t, s2, i2) {
        return this.object.getReturnExpressionWhenCalledAtPath([this.key, ...e2], t, s2, i2);
      }
      hasEffectsWhenAccessedAtPath(e2, t) {
        return e2.length !== 0 && this.object.hasEffectsWhenAccessedAtPath([this.key, ...e2], t);
      }
      hasEffectsWhenAssignedAtPath(e2, t) {
        return this.object.hasEffectsWhenAssignedAtPath([this.key, ...e2], t);
      }
      hasEffectsWhenCalledAtPath(e2, t, s2) {
        return this.object.hasEffectsWhenCalledAtPath([this.key, ...e2], t, s2);
      }
    };
    Rs = class extends rt {
      constructor() {
        super(...arguments), this.objectEntity = null;
      }
      createScope(e2) {
        this.scope = new Mt(e2);
      }
      deoptimizeCache() {
        this.getObjectEntity().deoptimizeAllProperties();
      }
      deoptimizePath(e2) {
        this.getObjectEntity().deoptimizePath(e2);
      }
      deoptimizeThisOnEventAtPath(e2, t, s2, i2) {
        this.getObjectEntity().deoptimizeThisOnEventAtPath(e2, t, s2, i2);
      }
      getLiteralValueAtPath(e2, t, s2) {
        return this.getObjectEntity().getLiteralValueAtPath(e2, t, s2);
      }
      getReturnExpressionWhenCalledAtPath(e2, t, s2, i2) {
        return this.getObjectEntity().getReturnExpressionWhenCalledAtPath(e2, t, s2, i2);
      }
      hasEffects(e2) {
        var t, s2;
        const i2 = ((t = this.superClass) === null || t === void 0 ? void 0 : t.hasEffects(e2)) || this.body.hasEffects(e2);
        return (s2 = this.id) === null || s2 === void 0 || s2.markDeclarationReached(), i2 || super.hasEffects(e2);
      }
      hasEffectsWhenAccessedAtPath(e2, t) {
        return this.getObjectEntity().hasEffectsWhenAccessedAtPath(e2, t);
      }
      hasEffectsWhenAssignedAtPath(e2, t) {
        return this.getObjectEntity().hasEffectsWhenAssignedAtPath(e2, t);
      }
      hasEffectsWhenCalledAtPath(e2, t, s2) {
        return e2.length === 0 ? !t.withNew || (this.classConstructor !== null ? this.classConstructor.hasEffectsWhenCalledAtPath(V, t, s2) : this.superClass !== null && this.superClass.hasEffectsWhenCalledAtPath(e2, t, s2)) : this.getObjectEntity().hasEffectsWhenCalledAtPath(e2, t, s2);
      }
      include(e2, t) {
        var s2;
        this.included = true, (s2 = this.superClass) === null || s2 === void 0 || s2.include(e2, t), this.body.include(e2, t), this.id && (this.id.markDeclarationReached(), this.id.include());
      }
      initialise() {
        var e2;
        (e2 = this.id) === null || e2 === void 0 || e2.declare("class", this);
        for (const e3 of this.body.body)
          if (e3 instanceof $s && e3.kind === "constructor")
            return void (this.classConstructor = e3);
        this.classConstructor = null;
      }
      getObjectEntity() {
        if (this.objectEntity !== null)
          return this.objectEntity;
        const e2 = [], t = [];
        for (const s2 of this.body.body) {
          const i2 = s2.static ? e2 : t, n3 = s2.kind;
          if (i2 === t && !n3)
            continue;
          const r2 = n3 === "set" || n3 === "get" ? n3 : "init";
          let a2;
          if (s2.computed) {
            const e3 = s2.key.getLiteralValueAtPath(V, U, this);
            if (e3 === G) {
              i2.push({ key: L, kind: r2, property: s2 });
              continue;
            }
            a2 = String(e3);
          } else
            a2 = s2.key instanceof cs ? s2.key.name : String(s2.key.value);
          i2.push({ key: a2, kind: r2, property: s2 });
        }
        return e2.unshift({ key: "prototype", kind: "init", property: new pt(t, this.superClass ? new Ts(this.superClass, "prototype") : gt) }), this.objectEntity = new pt(e2, this.superClass || gt);
      }
    };
    Ms = class extends Rs {
      initialise() {
        super.initialise(), this.id !== null && (this.id.variable.isId = true);
      }
      parseNode(e2) {
        e2.id !== null && (this.id = new cs(e2.id, this, this.scope.parent)), super.parseNode(e2);
      }
      render(e2, t) {
        const { exportNamesByVariable: s2, format: i2, snippets: { _: n3 } } = t;
        i2 === "system" && this.id && s2.has(this.id.variable) && e2.appendLeft(this.end, `${n3}${fs2([this.id.variable], t)};`), super.render(e2, t);
      }
    };
    Ds = class extends H {
      constructor(e2) {
        super(), this.expressions = e2, this.included = false;
      }
      deoptimizePath(e2) {
        for (const t of this.expressions)
          t.deoptimizePath(e2);
      }
      getReturnExpressionWhenCalledAtPath(e2, t, s2, i2) {
        return new Ds(this.expressions.map((n3) => n3.getReturnExpressionWhenCalledAtPath(e2, t, s2, i2)));
      }
      hasEffectsWhenAccessedAtPath(e2, t) {
        for (const s2 of this.expressions)
          if (s2.hasEffectsWhenAccessedAtPath(e2, t))
            return true;
        return false;
      }
      hasEffectsWhenAssignedAtPath(e2, t) {
        for (const s2 of this.expressions)
          if (s2.hasEffectsWhenAssignedAtPath(e2, t))
            return true;
        return false;
      }
      hasEffectsWhenCalledAtPath(e2, t, s2) {
        for (const i2 of this.expressions)
          if (i2.hasEffectsWhenCalledAtPath(e2, t, s2))
            return true;
        return false;
      }
      include(e2, t) {
        for (const s2 of this.expressions)
          s2.included || s2.include(e2, t);
      }
    };
    Ls = class extends rt {
      hasEffects() {
        return false;
      }
      initialise() {
        this.context.addExport(this);
      }
      render(e2, t, s2) {
        e2.remove(s2.start, s2.end);
      }
    };
    Ls.prototype.needsBoundaries = true;
    Os = class extends Ss {
      initialise() {
        super.initialise(), this.id !== null && (this.id.variable.isId = true);
      }
      parseNode(e2) {
        e2.id !== null && (this.id = new cs(e2.id, this, this.scope.parent)), super.parseNode(e2);
      }
    };
    Vs = class extends rt {
      include(e2, t) {
        super.include(e2, t), t && this.context.includeVariableInModule(this.variable);
      }
      initialise() {
        const e2 = this.declaration;
        this.declarationName = e2.id && e2.id.name || this.declaration.name, this.variable = this.scope.addExportDefaultDeclaration(this.declarationName || this.context.getModuleName(), this, this.context), this.context.addExport(this);
      }
      render(e2, t, s2) {
        const { start: i2, end: n3 } = s2, r2 = function(e3, t2) {
          return Wt(e3, Ft(e3, "default", t2) + 7);
        }(e2.original, this.start);
        if (this.declaration instanceof Os)
          this.renderNamedDeclaration(e2, r2, "function", "(", this.declaration.id === null, t);
        else if (this.declaration instanceof Ms)
          this.renderNamedDeclaration(e2, r2, "class", "{", this.declaration.id === null, t);
        else {
          if (this.variable.getOriginalVariable() !== this.variable)
            return void Ot(this, e2, i2, n3);
          if (!this.variable.included)
            return e2.remove(this.start, r2), this.declaration.render(e2, t, { renderedSurroundingElement: "ExpressionStatement" }), void (e2.original[this.end - 1] !== ";" && e2.appendLeft(this.end, ";"));
          this.renderVariableDeclaration(e2, r2, t);
        }
        this.declaration.render(e2, t);
      }
      renderNamedDeclaration(e2, t, s2, i2, n3, r2) {
        const { exportNamesByVariable: a2, format: o2, snippets: { getPropertyAccess: h3 } } = r2, l2 = this.variable.getName(h3);
        e2.remove(this.start, t), n3 && e2.appendLeft(function(e3, t2, s3, i3) {
          const n4 = Ft(e3, t2, i3) + t2.length;
          e3 = e3.slice(n4, Ft(e3, s3, n4));
          const r3 = Ft(e3, "*");
          return r3 === -1 ? n4 : n4 + r3 + 1;
        }(e2.original, s2, i2, t), ` ${l2}`), o2 === "system" && this.declaration instanceof Ms && a2.has(this.variable) && e2.appendLeft(this.end, ` ${fs2([this.variable], r2)};`);
      }
      renderVariableDeclaration(e2, t, { format: s2, exportNamesByVariable: i2, snippets: { cnst: n3, getPropertyAccess: r2 } }) {
        const a2 = e2.original.charCodeAt(this.end - 1) === 59, o2 = s2 === "system" && i2.get(this.variable);
        o2 ? (e2.overwrite(this.start, t, `${n3} ${this.variable.getName(r2)} = exports('${o2[0]}', `), e2.appendRight(a2 ? this.end - 1 : this.end, ")" + (a2 ? "" : ";"))) : (e2.overwrite(this.start, t, `${n3} ${this.variable.getName(r2)} = `), a2 || e2.appendLeft(this.end, ";"));
      }
    };
    Vs.prototype.needsBoundaries = true;
    Bs = class extends rt {
      bind() {
        this.declaration !== null && this.declaration.bind();
      }
      hasEffects(e2) {
        return this.declaration !== null && this.declaration.hasEffects(e2);
      }
      initialise() {
        this.context.addExport(this);
      }
      render(e2, t, s2) {
        const { start: i2, end: n3 } = s2;
        this.declaration === null ? e2.remove(i2, n3) : (e2.remove(this.start, this.declaration.start), this.declaration.render(e2, t, { end: n3, start: i2 }));
      }
    };
    Bs.prototype.needsBoundaries = true;
    Fs = class extends qt {
      constructor() {
        super(...arguments), this.hoistedDeclarations = [];
      }
      addDeclaration(e2, t, s2, i2) {
        return this.hoistedDeclarations.push(e2), super.addDeclaration(e2, t, s2, i2);
      }
    };
    zs = Symbol("unset");
    Ws = class extends rt {
      constructor() {
        super(...arguments), this.testValue = zs;
      }
      deoptimizeCache() {
        this.testValue = G;
      }
      hasEffects(e2) {
        if (this.test.hasEffects(e2))
          return true;
        const t = this.getTestValue();
        if (t === G) {
          const { brokenFlow: t2 } = e2;
          if (this.consequent.hasEffects(e2))
            return true;
          const s2 = e2.brokenFlow;
          return e2.brokenFlow = t2, this.alternate === null ? false : !!this.alternate.hasEffects(e2) || (e2.brokenFlow = e2.brokenFlow < s2 ? e2.brokenFlow : s2, false);
        }
        return t ? this.consequent.hasEffects(e2) : this.alternate !== null && this.alternate.hasEffects(e2);
      }
      include(e2, t) {
        if (this.included = true, t)
          this.includeRecursively(t, e2);
        else {
          const t2 = this.getTestValue();
          t2 === G ? this.includeUnknownTest(e2) : this.includeKnownTest(e2, t2);
        }
      }
      parseNode(e2) {
        this.consequentScope = new Fs(this.scope), this.consequent = new (this.context.getNodeConstructor(e2.consequent.type))(e2.consequent, this, this.consequentScope), e2.alternate && (this.alternateScope = new Fs(this.scope), this.alternate = new (this.context.getNodeConstructor(e2.alternate.type))(e2.alternate, this, this.alternateScope)), super.parseNode(e2);
      }
      render(e2, t) {
        const { snippets: { getPropertyAccess: s2 } } = t, i2 = this.getTestValue(), n3 = [], r2 = this.test.included, a2 = !this.context.options.treeshake;
        r2 ? this.test.render(e2, t) : e2.remove(this.start, this.consequent.start), this.consequent.included && (a2 || i2 === G || i2) ? this.consequent.render(e2, t) : (e2.overwrite(this.consequent.start, this.consequent.end, r2 ? ";" : ""), n3.push(...this.consequentScope.hoistedDeclarations)), this.alternate && (!this.alternate.included || !a2 && i2 !== G && i2 ? (r2 && this.shouldKeepAlternateBranch() ? e2.overwrite(this.alternate.start, this.end, ";") : e2.remove(this.consequent.end, this.end), n3.push(...this.alternateScope.hoistedDeclarations)) : (r2 ? e2.original.charCodeAt(this.alternate.start - 1) === 101 && e2.prependLeft(this.alternate.start, " ") : e2.remove(this.consequent.end, this.alternate.start), this.alternate.render(e2, t))), this.renderHoistedDeclarations(n3, e2, s2);
      }
      getTestValue() {
        return this.testValue === zs ? this.testValue = this.test.getLiteralValueAtPath(V, U, this) : this.testValue;
      }
      includeKnownTest(e2, t) {
        this.test.shouldBeIncluded(e2) && this.test.include(e2, false), t && this.consequent.shouldBeIncluded(e2) && this.consequent.includeAsSingleStatement(e2, false), this.alternate !== null && !t && this.alternate.shouldBeIncluded(e2) && this.alternate.includeAsSingleStatement(e2, false);
      }
      includeRecursively(e2, t) {
        this.test.include(t, e2), this.consequent.include(t, e2), this.alternate !== null && this.alternate.include(t, e2);
      }
      includeUnknownTest(e2) {
        this.test.include(e2, false);
        const { brokenFlow: t } = e2;
        let s2 = 0;
        this.consequent.shouldBeIncluded(e2) && (this.consequent.includeAsSingleStatement(e2, false), s2 = e2.brokenFlow, e2.brokenFlow = t), this.alternate !== null && this.alternate.shouldBeIncluded(e2) && (this.alternate.includeAsSingleStatement(e2, false), e2.brokenFlow = e2.brokenFlow < s2 ? e2.brokenFlow : s2);
      }
      renderHoistedDeclarations(e2, t, s2) {
        const i2 = [...new Set(e2.map((e3) => {
          const t2 = e3.variable;
          return t2.included ? t2.getName(s2) : "";
        }))].filter(Boolean).join(", ");
        if (i2) {
          const e3 = this.parent.type, s3 = e3 !== "Program" && e3 !== "BlockStatement";
          t.prependRight(this.start, `${s3 ? "{ " : ""}var ${i2}; `), s3 && t.appendLeft(this.end, " }");
        }
      }
      shouldKeepAlternateBranch() {
        let e2 = this.parent;
        do {
          if (e2 instanceof Ws && e2.alternate)
            return true;
          if (e2 instanceof Xt)
            return false;
          e2 = e2.parent;
        } while (e2);
        return false;
      }
    };
    Us = class extends rt {
      bind() {
      }
      hasEffects() {
        return false;
      }
      initialise() {
        this.context.addImport(this);
      }
      render(e2, t, s2) {
        e2.remove(s2.start, s2.end);
      }
    };
    Us.prototype.needsBoundaries = true;
    js = { auto: "_interopDefault", default: null, defaultOnly: null, esModule: null, false: null, true: "_interopDefaultLegacy" };
    Gs = (e2, t) => e2 === "esModule" || t && (e2 === "auto" || e2 === "true");
    Hs = { auto: "_interopNamespace", default: "_interopNamespaceDefault", defaultOnly: "_interopNamespaceDefaultOnly", esModule: null, false: null, true: "_interopNamespace" };
    qs2 = (e2, t) => Gs(e2, t) && js[e2] === "_interopDefault";
    Ks = (e2, t, s2, i2, n3, r2, a2) => {
      const o2 = new Set(e2);
      for (const e3 of oi)
        t.has(e3) && o2.add(e3);
      return oi.map((e3) => o2.has(e3) ? Xs[e3](s2, i2, n3, r2, a2, o2) : "").join("");
    };
    Xs = { _interopDefaultLegacy(e2, t, s2) {
      const { _: i2, getDirectReturnFunction: n3, n: r2 } = t, [a2, o2] = n3(["e"], { functionReturn: true, lineBreakIndent: null, name: "_interopDefaultLegacy" });
      return `${a2}e${i2}&&${i2}typeof e${i2}===${i2}'object'${i2}&&${i2}'default'${i2}in e${i2}?${i2}${s2 ? Ys(t) : Qs(t)}${o2}${r2}${r2}`;
    }, _interopDefault(e2, t, s2) {
      const { _: i2, getDirectReturnFunction: n3, n: r2 } = t, [a2, o2] = n3(["e"], { functionReturn: true, lineBreakIndent: null, name: "_interopDefault" });
      return `${a2}e${i2}&&${i2}e.__esModule${i2}?${i2}${s2 ? Ys(t) : Qs(t)}${o2}${r2}${r2}`;
    }, _interopNamespaceDefaultOnly(e2, t, s2, i2, n3) {
      const { getDirectReturnFunction: r2, getObject: a2, n: o2 } = t, [h3, l2] = r2(["e"], { functionReturn: true, lineBreakIndent: null, name: "_interopNamespaceDefaultOnly" });
      return `${h3}${ri(i2, ai(n3, a2([["__proto__", "null"], ["default", "e"]], { lineBreakIndent: null }), t))}${l2}${o2}${o2}`;
    }, _interopNamespaceDefault(e2, t, s2, i2, n3) {
      const { _: r2, n: a2 } = t;
      return `function _interopNamespaceDefault(e)${r2}{${a2}` + Zs(e2, e2, t, s2, i2, n3) + `}${a2}${a2}`;
    }, _interopNamespace(e2, t, s2, i2, n3, r2) {
      const { _: a2, getDirectReturnFunction: o2, n: h3 } = t;
      if (r2.has("_interopNamespaceDefault")) {
        const [e3, t2] = o2(["e"], { functionReturn: true, lineBreakIndent: null, name: "_interopNamespace" });
        return `${e3}e${a2}&&${a2}e.__esModule${a2}?${a2}e${a2}:${a2}_interopNamespaceDefault(e)${t2}${h3}${h3}`;
      }
      return `function _interopNamespace(e)${a2}{${h3}${e2}if${a2}(e${a2}&&${a2}e.__esModule)${a2}return e;${h3}` + Zs(e2, e2, t, s2, i2, n3) + `}${h3}${h3}`;
    }, _mergeNamespaces(e2, t, s2, i2, n3) {
      const { _: r2, cnst: a2, n: o2 } = t, h3 = a2 === "var" && s2;
      return `function _mergeNamespaces(n, m)${r2}{${o2}${e2}${ei(`{${o2}${e2}${e2}${e2}if${r2}(k${r2}!==${r2}'default'${r2}&&${r2}!(k in n))${r2}{${o2}` + (s2 ? h3 ? si : ii : ni)(e2, e2 + e2 + e2 + e2, t) + `${e2}${e2}${e2}}${o2}${e2}${e2}}`, h3, e2, t)}${o2}${e2}return ${ri(i2, ai(n3, "n", t))};${o2}}${o2}${o2}`;
    } };
    Ys = ({ _: e2, getObject: t }) => `e${e2}:${e2}${t([["default", "e"]], { lineBreakIndent: null })}`;
    Qs = ({ _: e2, getPropertyAccess: t }) => `e${t("default")}${e2}:${e2}e`;
    Zs = (e2, t, s2, i2, n3, r2) => {
      const { _: a2, cnst: o2, getObject: h3, getPropertyAccess: l2, n: c3, s: u2 } = s2, d3 = `{${c3}` + (i2 ? ti : ni)(e2, t + e2 + e2, s2) + `${t}${e2}}`;
      return `${t}${o2} n${a2}=${a2}Object.create(null${r2 ? `,${a2}{${a2}[Symbol.toStringTag]:${a2}${hi(h3)}${a2}}` : ""});${c3}${t}if${a2}(e)${a2}{${c3}${t}${e2}${Js(d3, !i2, s2)}${c3}${t}}${c3}${t}n${l2("default")}${a2}=${a2}e;${c3}${t}return ${ri(n3, "n")}${u2}${c3}`;
    };
    Js = (e2, t, { _: s2, cnst: i2, getFunctionIntro: n3, s: r2 }) => i2 !== "var" || t ? `for${s2}(${i2} k in e)${s2}${e2}` : `Object.keys(e).forEach(${n3(["k"], { isAsync: false, name: null })}${e2})${r2}`;
    ei = (e2, t, s2, { _: i2, cnst: n3, getDirectReturnFunction: r2, getFunctionIntro: a2, n: o2 }) => {
      if (t) {
        const [t2, n4] = r2(["e"], { functionReturn: false, lineBreakIndent: { base: s2, t: s2 }, name: null });
        return `m.forEach(${t2}e${i2}&&${i2}typeof e${i2}!==${i2}'string'${i2}&&${i2}!Array.isArray(e)${i2}&&${i2}Object.keys(e).forEach(${a2(["k"], { isAsync: false, name: null })}${e2})${n4});`;
      }
      return `for${i2}(var i${i2}=${i2}0;${i2}i${i2}<${i2}m.length;${i2}i++)${i2}{${o2}${s2}${s2}${n3} e${i2}=${i2}m[i];${o2}${s2}${s2}if${i2}(typeof e${i2}!==${i2}'string'${i2}&&${i2}!Array.isArray(e))${i2}{${i2}for${i2}(${n3} k in e)${i2}${e2}${i2}}${o2}${s2}}`;
    };
    ti = (e2, t, s2) => {
      const { _: i2, n: n3 } = s2;
      return `${t}if${i2}(k${i2}!==${i2}'default')${i2}{${n3}` + si(e2, t + e2, s2) + `${t}}${n3}`;
    };
    si = (e2, t, { _: s2, cnst: i2, getDirectReturnFunction: n3, n: r2 }) => {
      const [a2, o2] = n3([], { functionReturn: true, lineBreakIndent: null, name: null });
      return `${t}${i2} d${s2}=${s2}Object.getOwnPropertyDescriptor(e,${s2}k);${r2}${t}Object.defineProperty(n,${s2}k,${s2}d.get${s2}?${s2}d${s2}:${s2}{${r2}${t}${e2}enumerable:${s2}true,${r2}${t}${e2}get:${s2}${a2}e[k]${o2}${r2}${t}});${r2}`;
    };
    ii = (e2, t, { _: s2, cnst: i2, getDirectReturnFunction: n3, n: r2 }) => {
      const [a2, o2] = n3([], { functionReturn: true, lineBreakIndent: null, name: null });
      return `${t}${i2} d${s2}=${s2}Object.getOwnPropertyDescriptor(e,${s2}k);${r2}${t}if${s2}(d)${s2}{${r2}${t}${e2}Object.defineProperty(n,${s2}k,${s2}d.get${s2}?${s2}d${s2}:${s2}{${r2}${t}${e2}${e2}enumerable:${s2}true,${r2}${t}${e2}${e2}get:${s2}${a2}e[k]${o2}${r2}${t}${e2}});${r2}${t}}${r2}`;
    };
    ni = (e2, t, { _: s2, n: i2 }) => `${t}n[k]${s2}=${s2}e[k];${i2}`;
    ri = (e2, t) => e2 ? `Object.freeze(${t})` : t;
    ai = (e2, t, { _: s2, getObject: i2 }) => e2 ? `Object.defineProperty(${t},${s2}Symbol.toStringTag,${s2}${hi(i2)})` : t;
    oi = Object.keys(Xs);
    ci = { amd: ["require"], cjs: ["require"], system: ["module"] };
    ui = "ROLLUP_ASSET_URL_";
    di = "ROLLUP_FILE_URL_";
    pi = { amd: ["document", "module", "URL"], cjs: ["document", "require", "URL"], es: [], iife: ["document", "URL"], system: ["module"], umd: ["document", "require", "URL"] };
    fi = { amd: ["document", "require", "URL"], cjs: ["document", "require", "URL"], es: [], iife: ["document", "URL"], system: ["module", "URL"], umd: ["document", "require", "URL"] };
    mi = (e2, t = "URL") => `new ${t}(${e2}).href`;
    gi = (e2, t = false) => mi(`'${e2}', ${t ? "typeof document === 'undefined' ? location.href : " : ""}document.currentScript && document.currentScript.src || document.baseURI`);
    yi = (e2) => (t, { chunkId: s2 }) => {
      const i2 = e2(s2);
      return t === null ? `({ url: ${i2} })` : t === "url" ? i2 : "undefined";
    };
    Ei = (e2, t = false) => `${t ? "typeof document === 'undefined' ? location.href : " : ""}(document.currentScript && document.currentScript.src || new URL('${e2}', document.baseURI).href)`;
    xi = { amd: (e2) => (e2[0] !== "." && (e2 = "./" + e2), mi(`require.toUrl('${e2}'), document.baseURI`)), cjs: (e2) => `(typeof document === 'undefined' ? ${mi(`'file:' + __dirname + '/${e2}'`, "(require('u' + 'rl').URL)")} : ${gi(e2)})`, es: (e2) => mi(`'${e2}', import.meta.url`), iife: (e2) => gi(e2), system: (e2) => mi(`'${e2}', module.meta.url`), umd: (e2) => `(typeof document === 'undefined' && typeof location === 'undefined' ? ${mi(`'file:' + __dirname + '/${e2}'`, "(require('u' + 'rl').URL)")} : ${gi(e2, true)})` };
    vi = { amd: yi(() => mi("module.uri, document.baseURI")), cjs: yi((e2) => `(typeof document === 'undefined' ? ${mi("'file:' + __filename", "(require('u' + 'rl').URL)")} : ${Ei(e2)})`), iife: yi((e2) => Ei(e2)), system: (e2, { snippets: { getPropertyAccess: t } }) => e2 === null ? "module.meta" : `module.meta${t(e2)}`, umd: yi((e2) => `(typeof document === 'undefined' && typeof location === 'undefined' ? ${mi("'file:' + __filename", "(require('u' + 'rl').URL)")} : ${Ei(e2, true)})`) };
    bi = class extends rt {
      constructor() {
        super(...arguments), this.hasCachedEffect = false;
      }
      hasEffects(e2) {
        if (this.hasCachedEffect)
          return true;
        for (const t of this.body)
          if (t.hasEffects(e2))
            return this.hasCachedEffect = true;
        return false;
      }
      include(e2, t) {
        this.included = true;
        for (const s2 of this.body)
          (t || s2.shouldBeIncluded(e2)) && s2.include(e2, t);
      }
      render(e2, t) {
        this.body.length ? jt(this.body, e2, this.start, this.end, t) : super.render(e2, t);
      }
    };
    Si = class extends rt {
      hasEffects(e2) {
        if (this.test && this.test.hasEffects(e2))
          return true;
        for (const t of this.consequent) {
          if (e2.brokenFlow)
            break;
          if (t.hasEffects(e2))
            return true;
        }
        return false;
      }
      include(e2, t) {
        this.included = true, this.test && this.test.include(e2, t);
        for (const s2 of this.consequent)
          (t || s2.shouldBeIncluded(e2)) && s2.include(e2, t);
      }
      render(e2, t, s2) {
        if (this.consequent.length) {
          this.test && this.test.render(e2, t);
          const i2 = this.test ? this.test.end : Ft(e2.original, "default", this.start) + 7, n3 = Ft(e2.original, ":", i2) + 1;
          jt(this.consequent, e2, n3, s2.end, t);
        } else
          super.render(e2, t);
      }
    };
    Si.prototype.needsBoundaries = true;
    Ai = class extends rt {
      getLiteralValueAtPath(e2) {
        return e2.length > 0 || this.quasis.length !== 1 ? G : this.quasis[0].value.cooked;
      }
      render(e2, t) {
        e2.indentExclusionRanges.push([this.start, this.end]), super.render(e2, t);
      }
    };
    Pi = class extends K {
      constructor() {
        super("undefined");
      }
      getLiteralValueAtPath() {
      }
    };
    ki = class extends _t {
      constructor(e2, t, s2) {
        super(e2, t, t.declaration, s2), this.hasId = false, this.originalId = null, this.originalVariable = null;
        const i2 = t.declaration;
        (i2 instanceof Os || i2 instanceof Ms) && i2.id ? (this.hasId = true, this.originalId = i2.id) : i2 instanceof cs && (this.originalId = i2);
      }
      addReference(e2) {
        this.hasId || (this.name = e2.name);
      }
      getAssignedVariableName() {
        return this.originalId && this.originalId.name || null;
      }
      getBaseVariableName() {
        const e2 = this.getOriginalVariable();
        return e2 === this ? super.getBaseVariableName() : e2.getBaseVariableName();
      }
      getDirectOriginalVariable() {
        return !this.originalId || !this.hasId && (this.originalId.isPossibleTDZ() || this.originalId.variable.isReassigned || this.originalId.variable instanceof Pi || "syntheticNamespace" in this.originalId.variable) ? null : this.originalId.variable;
      }
      getName(e2) {
        const t = this.getOriginalVariable();
        return t === this ? super.getName(e2) : t.getName(e2);
      }
      getOriginalVariable() {
        if (this.originalVariable)
          return this.originalVariable;
        let e2, t = this;
        const s2 = /* @__PURE__ */ new Set();
        do {
          s2.add(t), e2 = t, t = e2.getDirectOriginalVariable();
        } while (t instanceof ki && !s2.has(t));
        return this.originalVariable = t || e2;
      }
    };
    wi = class extends Mt {
      constructor(e2, t) {
        super(e2), this.context = t, this.variables.set("this", new _t("this", null, Te, t));
      }
      addExportDefaultDeclaration(e2, t, s2) {
        const i2 = new ki(e2, t, s2);
        return this.variables.set("default", i2), i2;
      }
      addNamespaceMemberAccess() {
      }
      deconflict(e2, t, s2) {
        for (const i2 of this.children)
          i2.deconflict(e2, t, s2);
      }
      findLexicalBoundary() {
        return this;
      }
      findVariable(e2) {
        const t = this.variables.get(e2) || this.accessedOutsideVariables.get(e2);
        if (t)
          return t;
        const s2 = this.context.traceVariable(e2) || this.parent.findVariable(e2);
        return s2 instanceof hs && this.accessedOutsideVariables.set(e2, s2), s2;
      }
    };
    Ci = { "!": (e2) => !e2, "+": (e2) => +e2, "-": (e2) => -e2, delete: () => G, typeof: (e2) => typeof e2, void: () => {
    }, "~": (e2) => ~e2 };
    Ni = class extends rt {
      deoptimizePath() {
        for (const e2 of this.declarations)
          e2.deoptimizePath(V);
      }
      hasEffectsWhenAssignedAtPath() {
        return false;
      }
      include(e2, t) {
        this.included = true;
        for (const s2 of this.declarations)
          (t || s2.shouldBeIncluded(e2)) && s2.include(e2, t);
      }
      includeAsSingleStatement(e2, t) {
        this.included = true;
        for (const s2 of this.declarations)
          (t || s2.shouldBeIncluded(e2)) && (s2.include(e2, t), s2.id.include(e2, t));
      }
      initialise() {
        for (const e2 of this.declarations)
          e2.declareDeclarator(this.kind);
      }
      render(e2, t, s2 = Y) {
        if (function(e3, t2) {
          for (const s3 of e3) {
            if (!s3.id.included)
              return false;
            if (s3.id.type === "Identifier") {
              if (t2.has(s3.id.variable))
                return false;
            } else {
              const e4 = [];
              if (s3.id.addExportedVariables(e4, t2), e4.length > 0)
                return false;
            }
          }
          return true;
        }(this.declarations, t.exportNamesByVariable)) {
          for (const s3 of this.declarations)
            s3.render(e2, t);
          s2.isNoStatement || e2.original.charCodeAt(this.end - 1) === 59 || e2.appendLeft(this.end, ";");
        } else
          this.renderReplacedDeclarations(e2, t, s2);
      }
      renderDeclarationEnd(e2, t, s2, i2, n3, r2, a2, o2) {
        e2.original.charCodeAt(this.end - 1) === 59 && e2.remove(this.end - 1, this.end), o2 || (t += ";"), s2 !== null ? (e2.original.charCodeAt(i2 - 1) !== 10 || e2.original.charCodeAt(this.end) !== 10 && e2.original.charCodeAt(this.end) !== 13 || (i2--, e2.original.charCodeAt(i2) === 13 && i2--), i2 === s2 + 1 ? e2.overwrite(s2, n3, t) : (e2.overwrite(s2, s2 + 1, t), e2.remove(i2, n3))) : e2.appendLeft(n3, t), r2.length > 0 && e2.appendLeft(n3, ` ${fs2(r2, a2)};`);
      }
      renderReplacedDeclarations(e2, t, { isNoStatement: s2 }) {
        const i2 = Gt(this.declarations, e2, this.start + this.kind.length, this.end - (e2.original.charCodeAt(this.end - 1) === 59 ? 1 : 0));
        let n3, r2;
        r2 = Wt(e2.original, this.start + this.kind.length);
        let a2 = r2 - 1;
        e2.remove(this.start, a2);
        let o2, h3, l2 = false, c3 = false, u2 = "";
        const d3 = [], p2 = function(e3, t2, s3) {
          var i3;
          let n4 = null;
          if (t2.format === "system") {
            for (const { node: r3 } of e3)
              r3.id instanceof cs && r3.init && s3.length === 0 && ((i3 = t2.exportNamesByVariable.get(r3.id.variable)) === null || i3 === void 0 ? void 0 : i3.length) === 1 ? (n4 = r3.id.variable, s3.push(n4)) : r3.id.addExportedVariables(s3, t2.exportNamesByVariable);
            s3.length > 1 ? n4 = null : n4 && (s3.length = 0);
          }
          return n4;
        }(i2, t, d3);
        for (const { node: s3, start: d4, separator: f2, contentEnd: m3, end: g2 } of i2)
          if (s3.included) {
            if (s3.render(e2, t), o2 = "", h3 = "", !s3.id.included || s3.id instanceof cs && Ii(s3.id.variable, t.exportNamesByVariable))
              c3 && (u2 += ";"), l2 = false;
            else {
              if (p2 && p2 === s3.id.variable) {
                const i3 = Ft(e2.original, "=", s3.id.end);
                ms2(p2, Wt(e2.original, i3 + 1), f2 === null ? m3 : f2, e2, t);
              }
              l2 ? u2 += "," : (c3 && (u2 += ";"), o2 += `${this.kind} `, l2 = true);
            }
            r2 === a2 + 1 ? e2.overwrite(a2, r2, u2 + o2) : (e2.overwrite(a2, a2 + 1, u2), e2.appendLeft(r2, o2)), n3 = m3, r2 = g2, c3 = true, a2 = f2, u2 = "";
          } else
            e2.remove(d4, g2);
        this.renderDeclarationEnd(e2, u2, a2, n3, r2, d3, t, s2);
      }
    };
    _i = { ArrayExpression: class extends rt {
      constructor() {
        super(...arguments), this.objectEntity = null;
      }
      deoptimizePath(e2) {
        this.getObjectEntity().deoptimizePath(e2);
      }
      deoptimizeThisOnEventAtPath(e2, t, s2, i2) {
        this.getObjectEntity().deoptimizeThisOnEventAtPath(e2, t, s2, i2);
      }
      getLiteralValueAtPath(e2, t, s2) {
        return this.getObjectEntity().getLiteralValueAtPath(e2, t, s2);
      }
      getReturnExpressionWhenCalledAtPath(e2, t, s2, i2) {
        return this.getObjectEntity().getReturnExpressionWhenCalledAtPath(e2, t, s2, i2);
      }
      hasEffectsWhenAccessedAtPath(e2, t) {
        return this.getObjectEntity().hasEffectsWhenAccessedAtPath(e2, t);
      }
      hasEffectsWhenAssignedAtPath(e2, t) {
        return this.getObjectEntity().hasEffectsWhenAssignedAtPath(e2, t);
      }
      hasEffectsWhenCalledAtPath(e2, t, s2) {
        return this.getObjectEntity().hasEffectsWhenCalledAtPath(e2, t, s2);
      }
      getObjectEntity() {
        if (this.objectEntity !== null)
          return this.objectEntity;
        const e2 = [{ key: "length", kind: "init", property: Le }];
        let t = false;
        for (let s2 = 0; s2 < this.elements.length; s2++) {
          const i2 = this.elements[s2];
          i2 instanceof at || t ? i2 && (t = true, e2.unshift({ key: O, kind: "init", property: i2 })) : i2 ? e2.push({ key: String(s2), kind: "init", property: i2 }) : e2.push({ key: String(s2), kind: "init", property: Te });
        }
        return this.objectEntity = new pt(e2, Nt);
      }
    }, ArrayPattern: class extends rt {
      addExportedVariables(e2, t) {
        for (const s2 of this.elements)
          s2 !== null && s2.addExportedVariables(e2, t);
      }
      declare(e2) {
        const t = [];
        for (const s2 of this.elements)
          s2 !== null && t.push(...s2.declare(e2, q));
        return t;
      }
      deoptimizePath(e2) {
        if (e2.length === 0)
          for (const t of this.elements)
            t !== null && t.deoptimizePath(e2);
      }
      hasEffectsWhenAssignedAtPath(e2, t) {
        if (e2.length > 0)
          return true;
        for (const e3 of this.elements)
          if (e3 !== null && e3.hasEffectsWhenAssignedAtPath(V, t))
            return true;
        return false;
      }
      markDeclarationReached() {
        for (const e2 of this.elements)
          e2 !== null && e2.markDeclarationReached();
      }
    }, ArrowFunctionExpression: ps, AssignmentExpression: Es, AssignmentPattern: class extends rt {
      constructor() {
        super(...arguments), this.deoptimized = false;
      }
      addExportedVariables(e2, t) {
        this.left.addExportedVariables(e2, t);
      }
      declare(e2, t) {
        return this.left.declare(e2, t);
      }
      deoptimizePath(e2) {
        e2.length === 0 && this.left.deoptimizePath(e2);
      }
      hasEffectsWhenAssignedAtPath(e2, t) {
        return e2.length > 0 || this.left.hasEffectsWhenAssignedAtPath(V, t);
      }
      markDeclarationReached() {
        this.left.markDeclarationReached();
      }
      render(e2, t, { isShorthandProperty: s2 } = Y) {
        this.left.render(e2, t, { isShorthandProperty: s2 }), this.right.render(e2, t);
      }
      applyDeoptimizations() {
        this.deoptimized = true, this.left.deoptimizePath(V), this.right.deoptimizePath(B2), this.context.requestTreeshakingPass();
      }
    }, AwaitExpression: class extends rt {
      constructor() {
        super(...arguments), this.deoptimized = false;
      }
      hasEffects() {
        return this.deoptimized || this.applyDeoptimizations(), true;
      }
      include(e2, t) {
        if (this.deoptimized || this.applyDeoptimizations(), !this.included) {
          this.included = true;
          e:
            if (!this.context.usesTopLevelAwait) {
              let e3 = this.parent;
              do {
                if (e3 instanceof Ss || e3 instanceof ps)
                  break e;
              } while (e3 = e3.parent);
              this.context.usesTopLevelAwait = true;
            }
        }
        this.argument.include(e2, t);
      }
      applyDeoptimizations() {
        this.deoptimized = true, this.argument.deoptimizePath(B2), this.context.requestTreeshakingPass();
      }
    }, BinaryExpression: class extends rt {
      deoptimizeCache() {
      }
      getLiteralValueAtPath(e2, t, s2) {
        if (e2.length > 0)
          return G;
        const i2 = this.left.getLiteralValueAtPath(V, t, s2);
        if (i2 === G)
          return G;
        const n3 = this.right.getLiteralValueAtPath(V, t, s2);
        if (n3 === G)
          return G;
        const r2 = As[this.operator];
        return r2 ? r2(i2, n3) : G;
      }
      hasEffects(e2) {
        return this.operator === "+" && this.parent instanceof Kt && this.left.getLiteralValueAtPath(V, U, this) === "" || super.hasEffects(e2);
      }
      hasEffectsWhenAccessedAtPath(e2) {
        return e2.length > 1;
      }
      render(e2, t, { renderedSurroundingElement: s2 } = Y) {
        this.left.render(e2, t, { renderedSurroundingElement: s2 }), this.right.render(e2, t);
      }
    }, BlockStatement: Xt, BreakStatement: class extends rt {
      hasEffects(e2) {
        if (this.label) {
          if (!e2.ignore.labels.has(this.label.name))
            return true;
          e2.includedLabels.add(this.label.name), e2.brokenFlow = 2;
        } else {
          if (!e2.ignore.breaks)
            return true;
          e2.brokenFlow = 1;
        }
        return false;
      }
      include(e2) {
        this.included = true, this.label && (this.label.include(), e2.includedLabels.add(this.label.name)), e2.brokenFlow = this.label ? 2 : 1;
      }
    }, CallExpression: class extends rt {
      constructor() {
        super(...arguments), this.deoptimized = false, this.deoptimizableDependentExpressions = [], this.expressionsToBeDeoptimized = /* @__PURE__ */ new Set(), this.returnExpression = null;
      }
      bind() {
        if (super.bind(), this.callee instanceof cs) {
          this.scope.findVariable(this.callee.name).isNamespace && this.context.warn({ code: "CANNOT_CALL_NAMESPACE", message: `Cannot call a namespace ('${this.callee.name}')` }, this.start), this.callee.name === "eval" && this.context.warn({ code: "EVAL", message: "Use of eval is strongly discouraged, as it poses security risks and may cause issues with minification", url: "https://rollupjs.org/guide/en/#avoiding-eval" }, this.start);
        }
        this.callOptions = { args: this.arguments, thisParam: this.callee instanceof Cs && !this.callee.variable ? this.callee.object : null, withNew: false };
      }
      deoptimizeCache() {
        if (this.returnExpression !== q) {
          this.returnExpression = q;
          for (const e2 of this.deoptimizableDependentExpressions)
            e2.deoptimizeCache();
          for (const e2 of this.expressionsToBeDeoptimized)
            e2.deoptimizePath(B2);
        }
      }
      deoptimizePath(e2) {
        if (e2.length === 0 || this.context.deoptimizationTracker.trackEntityAtPathAndGetIfTracked(e2, this))
          return;
        const t = this.getReturnExpression();
        t !== q && t.deoptimizePath(e2);
      }
      deoptimizeThisOnEventAtPath(e2, t, s2, i2) {
        const n3 = this.getReturnExpression(i2);
        n3 === q ? s2.deoptimizePath(B2) : i2.withTrackedEntityAtPath(t, n3, () => {
          this.expressionsToBeDeoptimized.add(s2), n3.deoptimizeThisOnEventAtPath(e2, t, s2, i2);
        }, void 0);
      }
      getLiteralValueAtPath(e2, t, s2) {
        const i2 = this.getReturnExpression(t);
        return i2 === q ? G : t.withTrackedEntityAtPath(e2, i2, () => (this.deoptimizableDependentExpressions.push(s2), i2.getLiteralValueAtPath(e2, t, s2)), G);
      }
      getReturnExpressionWhenCalledAtPath(e2, t, s2, i2) {
        const n3 = this.getReturnExpression(s2);
        return this.returnExpression === q ? q : s2.withTrackedEntityAtPath(e2, n3, () => (this.deoptimizableDependentExpressions.push(i2), n3.getReturnExpressionWhenCalledAtPath(e2, t, s2, i2)), q);
      }
      hasEffects(e2) {
        try {
          for (const t of this.arguments)
            if (t.hasEffects(e2))
              return true;
          return (!this.context.options.treeshake.annotations || !this.annotations) && (this.callee.hasEffects(e2) || this.callee.hasEffectsWhenCalledAtPath(V, this.callOptions, e2));
        } finally {
          this.deoptimized || this.applyDeoptimizations();
        }
      }
      hasEffectsWhenAccessedAtPath(e2, t) {
        return !t.accessed.trackEntityAtPathAndGetIfTracked(e2, this) && this.getReturnExpression().hasEffectsWhenAccessedAtPath(e2, t);
      }
      hasEffectsWhenAssignedAtPath(e2, t) {
        return !t.assigned.trackEntityAtPathAndGetIfTracked(e2, this) && this.getReturnExpression().hasEffectsWhenAssignedAtPath(e2, t);
      }
      hasEffectsWhenCalledAtPath(e2, t, s2) {
        return !(t.withNew ? s2.instantiated : s2.called).trackEntityAtPathAndGetIfTracked(e2, t, this) && this.getReturnExpression().hasEffectsWhenCalledAtPath(e2, t, s2);
      }
      include(e2, t) {
        this.deoptimized || this.applyDeoptimizations(), t ? (super.include(e2, t), t === "variables" && this.callee instanceof cs && this.callee.variable && this.callee.variable.markCalledFromTryStatement()) : (this.included = true, this.callee.include(e2, false)), this.callee.includeCallArguments(e2, this.arguments);
        const s2 = this.getReturnExpression();
        s2.included || s2.include(e2, false);
      }
      render(e2, t, { renderedSurroundingElement: s2 } = Y) {
        if (this.callee.render(e2, t, { isCalleeOfRenderedParent: true, renderedSurroundingElement: s2 }), this.arguments.length > 0)
          if (this.arguments[this.arguments.length - 1].included)
            for (const s3 of this.arguments)
              s3.render(e2, t);
          else {
            let s3 = this.arguments.length - 2;
            for (; s3 >= 0 && !this.arguments[s3].included; )
              s3--;
            if (s3 >= 0) {
              for (let i2 = 0; i2 <= s3; i2++)
                this.arguments[i2].render(e2, t);
              e2.remove(Ft(e2.original, ",", this.arguments[s3].end), this.end - 1);
            } else
              e2.remove(Ft(e2.original, "(", this.callee.end) + 1, this.end - 1);
          }
      }
      applyDeoptimizations() {
        this.deoptimized = true;
        const { thisParam: e2 } = this.callOptions;
        e2 && this.callee.deoptimizeThisOnEventAtPath(2, V, e2, U);
        for (const e3 of this.arguments)
          e3.deoptimizePath(B2);
        this.context.requestTreeshakingPass();
      }
      getReturnExpression(e2 = U) {
        return this.returnExpression === null ? (this.returnExpression = q, this.returnExpression = this.callee.getReturnExpressionWhenCalledAtPath(V, this.callOptions, e2, this)) : this.returnExpression;
      }
    }, CatchClause: class extends rt {
      createScope(e2) {
        this.scope = new Is(e2, this.context);
      }
      parseNode(e2) {
        const { param: t } = e2;
        t && (this.param = new (this.context.getNodeConstructor(t.type))(t, this, this.scope), this.param.declare("parameter", q)), super.parseNode(e2);
      }
    }, ChainExpression: class extends rt {
    }, ClassBody: class extends rt {
      createScope(e2) {
        this.scope = new Ns(e2, this.parent, this.context);
      }
      include(e2, t) {
        this.included = true, this.context.includeVariableInModule(this.scope.thisVariable);
        for (const s2 of this.body)
          s2.include(e2, t);
      }
      parseNode(e2) {
        const t = this.body = [];
        for (const s2 of e2.body)
          t.push(new (this.context.getNodeConstructor(s2.type))(s2, this, s2.static ? this.scope : this.scope.instanceScope));
        super.parseNode(e2);
      }
    }, ClassDeclaration: Ms, ClassExpression: class extends Rs {
      render(e2, t, { renderedSurroundingElement: s2 } = Y) {
        super.render(e2, t), s2 === "ExpressionStatement" && (e2.appendRight(this.start, "("), e2.prependLeft(this.end, ")"));
      }
    }, ConditionalExpression: class extends rt {
      constructor() {
        super(...arguments), this.expressionsToBeDeoptimized = [], this.isBranchResolutionAnalysed = false, this.usedBranch = null;
      }
      deoptimizeCache() {
        if (this.usedBranch !== null) {
          const e2 = this.usedBranch === this.consequent ? this.alternate : this.consequent;
          this.usedBranch = null, e2.deoptimizePath(B2);
          for (const e3 of this.expressionsToBeDeoptimized)
            e3.deoptimizeCache();
        }
      }
      deoptimizePath(e2) {
        const t = this.getUsedBranch();
        t === null ? (this.consequent.deoptimizePath(e2), this.alternate.deoptimizePath(e2)) : t.deoptimizePath(e2);
      }
      deoptimizeThisOnEventAtPath(e2, t, s2, i2) {
        this.consequent.deoptimizeThisOnEventAtPath(e2, t, s2, i2), this.alternate.deoptimizeThisOnEventAtPath(e2, t, s2, i2);
      }
      getLiteralValueAtPath(e2, t, s2) {
        const i2 = this.getUsedBranch();
        return i2 === null ? G : (this.expressionsToBeDeoptimized.push(s2), i2.getLiteralValueAtPath(e2, t, s2));
      }
      getReturnExpressionWhenCalledAtPath(e2, t, s2, i2) {
        const n3 = this.getUsedBranch();
        return n3 === null ? new Ds([this.consequent.getReturnExpressionWhenCalledAtPath(e2, t, s2, i2), this.alternate.getReturnExpressionWhenCalledAtPath(e2, t, s2, i2)]) : (this.expressionsToBeDeoptimized.push(i2), n3.getReturnExpressionWhenCalledAtPath(e2, t, s2, i2));
      }
      hasEffects(e2) {
        if (this.test.hasEffects(e2))
          return true;
        const t = this.getUsedBranch();
        return t === null ? this.consequent.hasEffects(e2) || this.alternate.hasEffects(e2) : t.hasEffects(e2);
      }
      hasEffectsWhenAccessedAtPath(e2, t) {
        const s2 = this.getUsedBranch();
        return s2 === null ? this.consequent.hasEffectsWhenAccessedAtPath(e2, t) || this.alternate.hasEffectsWhenAccessedAtPath(e2, t) : s2.hasEffectsWhenAccessedAtPath(e2, t);
      }
      hasEffectsWhenAssignedAtPath(e2, t) {
        const s2 = this.getUsedBranch();
        return s2 === null ? this.consequent.hasEffectsWhenAssignedAtPath(e2, t) || this.alternate.hasEffectsWhenAssignedAtPath(e2, t) : s2.hasEffectsWhenAssignedAtPath(e2, t);
      }
      hasEffectsWhenCalledAtPath(e2, t, s2) {
        const i2 = this.getUsedBranch();
        return i2 === null ? this.consequent.hasEffectsWhenCalledAtPath(e2, t, s2) || this.alternate.hasEffectsWhenCalledAtPath(e2, t, s2) : i2.hasEffectsWhenCalledAtPath(e2, t, s2);
      }
      include(e2, t) {
        this.included = true;
        const s2 = this.getUsedBranch();
        t || this.test.shouldBeIncluded(e2) || s2 === null ? (this.test.include(e2, t), this.consequent.include(e2, t), this.alternate.include(e2, t)) : s2.include(e2, t);
      }
      includeCallArguments(e2, t) {
        const s2 = this.getUsedBranch();
        s2 === null ? (this.consequent.includeCallArguments(e2, t), this.alternate.includeCallArguments(e2, t)) : s2.includeCallArguments(e2, t);
      }
      render(e2, t, { isCalleeOfRenderedParent: s2, preventASI: i2, renderedParentType: n3, renderedSurroundingElement: r2 } = Y) {
        const a2 = this.getUsedBranch();
        if (this.test.included)
          this.test.render(e2, t, { renderedSurroundingElement: r2 }), this.consequent.render(e2, t), this.alternate.render(e2, t);
        else {
          const o2 = Ft(e2.original, ":", this.consequent.end), h3 = Wt(e2.original, (this.consequent.included ? Ft(e2.original, "?", this.test.end) : o2) + 1);
          i2 && Ht(e2, h3, a2.start), e2.remove(this.start, h3), this.consequent.included && e2.remove(o2, this.end), Vt(this, e2), a2.render(e2, t, { isCalleeOfRenderedParent: s2, preventASI: true, renderedParentType: n3 || this.parent.type, renderedSurroundingElement: r2 || this.parent.type });
        }
      }
      getUsedBranch() {
        if (this.isBranchResolutionAnalysed)
          return this.usedBranch;
        this.isBranchResolutionAnalysed = true;
        const e2 = this.test.getLiteralValueAtPath(V, U, this);
        return e2 === G ? null : this.usedBranch = e2 ? this.consequent : this.alternate;
      }
    }, ContinueStatement: class extends rt {
      hasEffects(e2) {
        if (this.label) {
          if (!e2.ignore.labels.has(this.label.name))
            return true;
          e2.includedLabels.add(this.label.name), e2.brokenFlow = 2;
        } else {
          if (!e2.ignore.continues)
            return true;
          e2.brokenFlow = 1;
        }
        return false;
      }
      include(e2) {
        this.included = true, this.label && (this.label.include(), e2.includedLabels.add(this.label.name)), e2.brokenFlow = this.label ? 2 : 1;
      }
    }, DoWhileStatement: class extends rt {
      hasEffects(e2) {
        if (this.test.hasEffects(e2))
          return true;
        const { brokenFlow: t, ignore: { breaks: s2, continues: i2 } } = e2;
        return e2.ignore.breaks = true, e2.ignore.continues = true, !!this.body.hasEffects(e2) || (e2.ignore.breaks = s2, e2.ignore.continues = i2, e2.brokenFlow = t, false);
      }
      include(e2, t) {
        this.included = true, this.test.include(e2, t);
        const { brokenFlow: s2 } = e2;
        this.body.includeAsSingleStatement(e2, t), e2.brokenFlow = s2;
      }
    }, EmptyStatement: class extends rt {
      hasEffects() {
        return false;
      }
    }, ExportAllDeclaration: Ls, ExportDefaultDeclaration: Vs, ExportNamedDeclaration: Bs, ExportSpecifier: class extends rt {
    }, ExpressionStatement: Kt, ForInStatement: class extends rt {
      constructor() {
        super(...arguments), this.deoptimized = false;
      }
      createScope(e2) {
        this.scope = new qt(e2);
      }
      hasEffects(e2) {
        if (this.deoptimized || this.applyDeoptimizations(), this.left && (this.left.hasEffects(e2) || this.left.hasEffectsWhenAssignedAtPath(V, e2)) || this.right && this.right.hasEffects(e2))
          return true;
        const { brokenFlow: t, ignore: { breaks: s2, continues: i2 } } = e2;
        return e2.ignore.breaks = true, e2.ignore.continues = true, !!this.body.hasEffects(e2) || (e2.ignore.breaks = s2, e2.ignore.continues = i2, e2.brokenFlow = t, false);
      }
      include(e2, t) {
        this.deoptimized || this.applyDeoptimizations(), this.included = true, this.left.include(e2, t || true), this.right.include(e2, t);
        const { brokenFlow: s2 } = e2;
        this.body.includeAsSingleStatement(e2, t), e2.brokenFlow = s2;
      }
      render(e2, t) {
        this.left.render(e2, t, Bt), this.right.render(e2, t, Bt), e2.original.charCodeAt(this.right.start - 1) === 110 && e2.prependLeft(this.right.start, " "), this.body.render(e2, t);
      }
      applyDeoptimizations() {
        this.deoptimized = true, this.left.deoptimizePath(V), this.context.requestTreeshakingPass();
      }
    }, ForOfStatement: class extends rt {
      constructor() {
        super(...arguments), this.deoptimized = false;
      }
      createScope(e2) {
        this.scope = new qt(e2);
      }
      hasEffects() {
        return this.deoptimized || this.applyDeoptimizations(), true;
      }
      include(e2, t) {
        this.deoptimized || this.applyDeoptimizations(), this.included = true, this.left.include(e2, t || true), this.right.include(e2, t);
        const { brokenFlow: s2 } = e2;
        this.body.includeAsSingleStatement(e2, t), e2.brokenFlow = s2;
      }
      render(e2, t) {
        this.left.render(e2, t, Bt), this.right.render(e2, t, Bt), e2.original.charCodeAt(this.right.start - 1) === 102 && e2.prependLeft(this.right.start, " "), this.body.render(e2, t);
      }
      applyDeoptimizations() {
        this.deoptimized = true, this.left.deoptimizePath(V), this.context.requestTreeshakingPass();
      }
    }, ForStatement: class extends rt {
      createScope(e2) {
        this.scope = new qt(e2);
      }
      hasEffects(e2) {
        if (this.init && this.init.hasEffects(e2) || this.test && this.test.hasEffects(e2) || this.update && this.update.hasEffects(e2))
          return true;
        const { brokenFlow: t, ignore: { breaks: s2, continues: i2 } } = e2;
        return e2.ignore.breaks = true, e2.ignore.continues = true, !!this.body.hasEffects(e2) || (e2.ignore.breaks = s2, e2.ignore.continues = i2, e2.brokenFlow = t, false);
      }
      include(e2, t) {
        this.included = true, this.init && this.init.includeAsSingleStatement(e2, t), this.test && this.test.include(e2, t);
        const { brokenFlow: s2 } = e2;
        this.update && this.update.include(e2, t), this.body.includeAsSingleStatement(e2, t), e2.brokenFlow = s2;
      }
      render(e2, t) {
        this.init && this.init.render(e2, t, Bt), this.test && this.test.render(e2, t, Bt), this.update && this.update.render(e2, t, Bt), this.body.render(e2, t);
      }
    }, FunctionDeclaration: Os, FunctionExpression: class extends Ss {
      render(e2, t, { renderedSurroundingElement: s2 } = Y) {
        super.render(e2, t), s2 === "ExpressionStatement" && (e2.appendRight(this.start, "("), e2.prependLeft(this.end, ")"));
      }
    }, Identifier: cs, IfStatement: Ws, ImportDeclaration: Us, ImportDefaultSpecifier: class extends rt {
    }, ImportExpression: class extends rt {
      constructor() {
        super(...arguments), this.inlineNamespace = null, this.mechanism = null, this.resolution = null;
      }
      hasEffects() {
        return true;
      }
      include(e2, t) {
        this.included || (this.included = true, this.context.includeDynamicImport(this), this.scope.addAccessedDynamicImport(this)), this.source.include(e2, t);
      }
      initialise() {
        this.context.addDynamicImport(this);
      }
      render(e2, t) {
        if (this.inlineNamespace) {
          const { snippets: { getDirectReturnFunction: s2, getPropertyAccess: i2 } } = t, [n3, r2] = s2([], { functionReturn: true, lineBreakIndent: null, name: null });
          e2.overwrite(this.start, this.end, `Promise.resolve().then(${n3}${this.inlineNamespace.getName(i2)}${r2})`, { contentOnly: true });
        } else
          this.mechanism && (e2.overwrite(this.start, Ft(e2.original, "(", this.start + 6) + 1, this.mechanism.left, { contentOnly: true }), e2.overwrite(this.end - 1, this.end, this.mechanism.right, { contentOnly: true })), this.source.render(e2, t);
      }
      renderFinalResolution(e2, t, s2, { getDirectReturnFunction: i2 }) {
        if (e2.overwrite(this.source.start, this.source.end, t), s2) {
          const [t2, n3] = i2(["n"], { functionReturn: true, lineBreakIndent: null, name: null });
          e2.prependLeft(this.end, `.then(${t2}n.${s2}${n3})`);
        }
      }
      setExternalResolution(e2, t, s2, i2, n3, r2) {
        const { format: a2 } = s2;
        this.resolution = t;
        const o2 = [...ci[a2] || []];
        let h3;
        ({ helper: h3, mechanism: this.mechanism } = this.getDynamicImportMechanismAndHelper(t, e2, s2, i2, n3)), h3 && o2.push(h3), o2.length > 0 && this.scope.addAccessedGlobals(o2, r2);
      }
      setInternalResolution(e2) {
        this.inlineNamespace = e2;
      }
      getDynamicImportMechanismAndHelper(e2, t, { compact: s2, dynamicImportFunction: i2, format: n3, generatedCode: { arrowFunctions: r2 }, interop: a2 }, { _: o2, getDirectReturnFunction: h3, getDirectReturnIifeLeft: l2 }, c3) {
        const u2 = c3.hookFirstSync("renderDynamicImport", [{ customResolution: typeof this.resolution == "string" ? this.resolution : null, format: n3, moduleId: this.context.module.id, targetModuleId: this.resolution && typeof this.resolution != "string" ? this.resolution.id : null }]);
        if (u2)
          return { helper: null, mechanism: u2 };
        const d3 = !this.resolution || typeof this.resolution == "string";
        switch (n3) {
          case "cjs": {
            const s3 = li(e2, t, a2);
            let i3 = "require(", n4 = ")";
            s3 && (i3 = `/*#__PURE__*/${s3}(${i3}`, n4 += ")");
            const [o3, c4] = h3([], { functionReturn: true, lineBreakIndent: null, name: null });
            return i3 = `Promise.resolve().then(${o3}${i3}`, n4 += `${c4})`, !r2 && d3 && (i3 = l2(["t"], `${i3}t${n4}`, { needsArrowReturnParens: false, needsWrappedFunction: true }), n4 = ")"), { helper: s3, mechanism: { left: i3, right: n4 } };
          }
          case "amd": {
            const i3 = s2 ? "c" : "resolve", n4 = s2 ? "e" : "reject", c4 = li(e2, t, a2), [u3, p2] = h3(["m"], { functionReturn: false, lineBreakIndent: null, name: null }), f2 = c4 ? `${u3}${i3}(/*#__PURE__*/${c4}(m))${p2}` : i3, [m3, g2] = h3([i3, n4], { functionReturn: false, lineBreakIndent: null, name: null });
            let y3 = `new Promise(${m3}require([`, E3 = `],${o2}${f2},${o2}${n4})${g2})`;
            return !r2 && d3 && (y3 = l2(["t"], `${y3}t${E3}`, { needsArrowReturnParens: false, needsWrappedFunction: true }), E3 = ")"), { helper: c4, mechanism: { left: y3, right: E3 } };
          }
          case "system":
            return { helper: null, mechanism: { left: "module.import(", right: ")" } };
          case "es":
            if (i2)
              return { helper: null, mechanism: { left: `${i2}(`, right: ")" } };
        }
        return { helper: null, mechanism: null };
      }
    }, ImportNamespaceSpecifier: class extends rt {
    }, ImportSpecifier: class extends rt {
    }, LabeledStatement: class extends rt {
      hasEffects(e2) {
        const t = e2.brokenFlow;
        return e2.ignore.labels.add(this.label.name), !!this.body.hasEffects(e2) || (e2.ignore.labels.delete(this.label.name), e2.includedLabels.has(this.label.name) && (e2.includedLabels.delete(this.label.name), e2.brokenFlow = t), false);
      }
      include(e2, t) {
        this.included = true;
        const s2 = e2.brokenFlow;
        this.body.include(e2, t), (t || e2.includedLabels.has(this.label.name)) && (this.label.include(), e2.includedLabels.delete(this.label.name), e2.brokenFlow = s2);
      }
      render(e2, t) {
        this.label.included ? this.label.render(e2, t) : e2.remove(this.start, Wt(e2.original, Ft(e2.original, ":", this.label.end) + 1)), this.body.render(e2, t);
      }
    }, Literal: Ps, LogicalExpression: class extends rt {
      constructor() {
        super(...arguments), this.expressionsToBeDeoptimized = [], this.isBranchResolutionAnalysed = false, this.usedBranch = null;
      }
      deoptimizeCache() {
        if (this.usedBranch !== null) {
          const e2 = this.usedBranch === this.left ? this.right : this.left;
          this.usedBranch = null, e2.deoptimizePath(B2);
          for (const e3 of this.expressionsToBeDeoptimized)
            e3.deoptimizeCache();
        }
      }
      deoptimizePath(e2) {
        const t = this.getUsedBranch();
        t === null ? (this.left.deoptimizePath(e2), this.right.deoptimizePath(e2)) : t.deoptimizePath(e2);
      }
      deoptimizeThisOnEventAtPath(e2, t, s2, i2) {
        this.left.deoptimizeThisOnEventAtPath(e2, t, s2, i2), this.right.deoptimizeThisOnEventAtPath(e2, t, s2, i2);
      }
      getLiteralValueAtPath(e2, t, s2) {
        const i2 = this.getUsedBranch();
        return i2 === null ? G : (this.expressionsToBeDeoptimized.push(s2), i2.getLiteralValueAtPath(e2, t, s2));
      }
      getReturnExpressionWhenCalledAtPath(e2, t, s2, i2) {
        const n3 = this.getUsedBranch();
        return n3 === null ? new Ds([this.left.getReturnExpressionWhenCalledAtPath(e2, t, s2, i2), this.right.getReturnExpressionWhenCalledAtPath(e2, t, s2, i2)]) : (this.expressionsToBeDeoptimized.push(i2), n3.getReturnExpressionWhenCalledAtPath(e2, t, s2, i2));
      }
      hasEffects(e2) {
        return !!this.left.hasEffects(e2) || this.getUsedBranch() !== this.left && this.right.hasEffects(e2);
      }
      hasEffectsWhenAccessedAtPath(e2, t) {
        const s2 = this.getUsedBranch();
        return s2 === null ? this.left.hasEffectsWhenAccessedAtPath(e2, t) || this.right.hasEffectsWhenAccessedAtPath(e2, t) : s2.hasEffectsWhenAccessedAtPath(e2, t);
      }
      hasEffectsWhenAssignedAtPath(e2, t) {
        const s2 = this.getUsedBranch();
        return s2 === null ? this.left.hasEffectsWhenAssignedAtPath(e2, t) || this.right.hasEffectsWhenAssignedAtPath(e2, t) : s2.hasEffectsWhenAssignedAtPath(e2, t);
      }
      hasEffectsWhenCalledAtPath(e2, t, s2) {
        const i2 = this.getUsedBranch();
        return i2 === null ? this.left.hasEffectsWhenCalledAtPath(e2, t, s2) || this.right.hasEffectsWhenCalledAtPath(e2, t, s2) : i2.hasEffectsWhenCalledAtPath(e2, t, s2);
      }
      include(e2, t) {
        this.included = true;
        const s2 = this.getUsedBranch();
        t || s2 === this.right && this.left.shouldBeIncluded(e2) || s2 === null ? (this.left.include(e2, t), this.right.include(e2, t)) : s2.include(e2, t);
      }
      render(e2, t, { isCalleeOfRenderedParent: s2, preventASI: i2, renderedParentType: n3, renderedSurroundingElement: r2 } = Y) {
        if (this.left.included && this.right.included)
          this.left.render(e2, t, { preventASI: i2, renderedSurroundingElement: r2 }), this.right.render(e2, t);
        else {
          const a2 = Ft(e2.original, this.operator, this.left.end);
          if (this.right.included) {
            const t2 = Wt(e2.original, a2 + 2);
            e2.remove(this.start, t2), i2 && Ht(e2, t2, this.right.start);
          } else
            e2.remove(a2, this.end);
          Vt(this, e2), this.getUsedBranch().render(e2, t, { isCalleeOfRenderedParent: s2, preventASI: i2, renderedParentType: n3 || this.parent.type, renderedSurroundingElement: r2 || this.parent.type });
        }
      }
      getUsedBranch() {
        if (!this.isBranchResolutionAnalysed) {
          this.isBranchResolutionAnalysed = true;
          const e2 = this.left.getLiteralValueAtPath(V, U, this);
          if (e2 === G)
            return null;
          this.usedBranch = this.operator === "||" && e2 || this.operator === "&&" && !e2 || this.operator === "??" && e2 != null ? this.left : this.right;
        }
        return this.usedBranch;
      }
    }, MemberExpression: Cs, MetaProperty: class extends rt {
      addAccessedGlobals(e2, t) {
        const s2 = this.metaProperty, i2 = (s2 && (s2.startsWith(di) || s2.startsWith(ui) || s2.startsWith("ROLLUP_CHUNK_URL_")) ? fi : pi)[e2];
        i2.length > 0 && this.scope.addAccessedGlobals(i2, t);
      }
      getReferencedFileName(e2) {
        const t = this.metaProperty;
        return t && t.startsWith(di) ? e2.getFileName(t.substring(di.length)) : null;
      }
      hasEffects() {
        return false;
      }
      hasEffectsWhenAccessedAtPath(e2) {
        return e2.length > 1;
      }
      include() {
        if (!this.included && (this.included = true, this.meta.name === "import")) {
          this.context.addImportMeta(this);
          const e2 = this.parent;
          this.metaProperty = e2 instanceof Cs && typeof e2.propertyKey == "string" ? e2.propertyKey : null;
        }
      }
      renderFinalMechanism(e2, t, s2, i2, n3) {
        var r2;
        const a2 = this.parent, o2 = this.metaProperty;
        if (o2 && (o2.startsWith(di) || o2.startsWith(ui) || o2.startsWith("ROLLUP_CHUNK_URL_"))) {
          let i3, r3 = null, h4 = null, l2 = null;
          o2.startsWith(di) ? (r3 = o2.substring(di.length), i3 = n3.getFileName(r3)) : o2.startsWith(ui) ? (xe(`Using the "${ui}" prefix to reference files is deprecated. Use the "${di}" prefix instead.`, true, this.context.options), h4 = o2.substring(ui.length), i3 = n3.getFileName(h4)) : (xe(`Using the "ROLLUP_CHUNK_URL_" prefix to reference files is deprecated. Use the "${di}" prefix instead.`, true, this.context.options), l2 = o2.substring("ROLLUP_CHUNK_URL_".length), i3 = n3.getFileName(l2));
          const c3 = N(R($(t), i3));
          let u2;
          return h4 !== null && (u2 = n3.hookFirstSync("resolveAssetUrl", [{ assetFileName: i3, chunkId: t, format: s2, moduleId: this.context.module.id, relativeAssetPath: c3 }])), u2 || (u2 = n3.hookFirstSync("resolveFileUrl", [{ assetReferenceId: h4, chunkId: t, chunkReferenceId: l2, fileName: i3, format: s2, moduleId: this.context.module.id, referenceId: r3 || h4 || l2, relativePath: c3 }]) || xi[s2](c3)), void e2.overwrite(a2.start, a2.end, u2, { contentOnly: true });
        }
        const h3 = n3.hookFirstSync("resolveImportMeta", [o2, { chunkId: t, format: s2, moduleId: this.context.module.id }]) || ((r2 = vi[s2]) === null || r2 === void 0 ? void 0 : r2.call(vi, o2, { chunkId: t, snippets: i2 }));
        typeof h3 == "string" && (a2 instanceof Cs ? e2.overwrite(a2.start, a2.end, h3, { contentOnly: true }) : e2.overwrite(this.start, this.end, h3, { contentOnly: true }));
      }
    }, MethodDefinition: $s, NewExpression: class extends rt {
      constructor() {
        super(...arguments), this.deoptimized = false;
      }
      hasEffects(e2) {
        this.deoptimized || this.applyDeoptimizations();
        for (const t of this.arguments)
          if (t.hasEffects(e2))
            return true;
        return (!this.context.options.treeshake.annotations || !this.annotations) && (this.callee.hasEffects(e2) || this.callee.hasEffectsWhenCalledAtPath(V, this.callOptions, e2));
      }
      hasEffectsWhenAccessedAtPath(e2) {
        return e2.length > 0;
      }
      initialise() {
        this.callOptions = { args: this.arguments, thisParam: null, withNew: true };
      }
      applyDeoptimizations() {
        this.deoptimized = true;
        for (const e2 of this.arguments)
          e2.deoptimizePath(B2);
        this.context.requestTreeshakingPass();
      }
    }, ObjectExpression: class extends rt {
      constructor() {
        super(...arguments), this.objectEntity = null;
      }
      deoptimizeCache() {
        this.getObjectEntity().deoptimizeAllProperties();
      }
      deoptimizePath(e2) {
        this.getObjectEntity().deoptimizePath(e2);
      }
      deoptimizeThisOnEventAtPath(e2, t, s2, i2) {
        this.getObjectEntity().deoptimizeThisOnEventAtPath(e2, t, s2, i2);
      }
      getLiteralValueAtPath(e2, t, s2) {
        return this.getObjectEntity().getLiteralValueAtPath(e2, t, s2);
      }
      getReturnExpressionWhenCalledAtPath(e2, t, s2, i2) {
        return this.getObjectEntity().getReturnExpressionWhenCalledAtPath(e2, t, s2, i2);
      }
      hasEffectsWhenAccessedAtPath(e2, t) {
        return this.getObjectEntity().hasEffectsWhenAccessedAtPath(e2, t);
      }
      hasEffectsWhenAssignedAtPath(e2, t) {
        return this.getObjectEntity().hasEffectsWhenAssignedAtPath(e2, t);
      }
      hasEffectsWhenCalledAtPath(e2, t, s2) {
        return this.getObjectEntity().hasEffectsWhenCalledAtPath(e2, t, s2);
      }
      render(e2, t, { renderedSurroundingElement: s2 } = Y) {
        super.render(e2, t), s2 !== "ExpressionStatement" && s2 !== "ArrowFunctionExpression" || (e2.appendRight(this.start, "("), e2.prependLeft(this.end, ")"));
      }
      getObjectEntity() {
        if (this.objectEntity !== null)
          return this.objectEntity;
        let e2 = gt;
        const t = [];
        for (const s2 of this.properties) {
          if (s2 instanceof at) {
            t.push({ key: L, kind: "init", property: s2 });
            continue;
          }
          let i2;
          if (s2.computed) {
            const e3 = s2.key.getLiteralValueAtPath(V, U, this);
            if (e3 === G) {
              t.push({ key: L, kind: s2.kind, property: s2 });
              continue;
            }
            i2 = String(e3);
          } else if (i2 = s2.key instanceof cs ? s2.key.name : String(s2.key.value), i2 === "__proto__" && s2.kind === "init") {
            e2 = s2.value instanceof Ps && s2.value.value === null ? null : s2.value;
            continue;
          }
          t.push({ key: i2, kind: s2.kind, property: s2 });
        }
        return this.objectEntity = new pt(t, e2);
      }
    }, ObjectPattern: ys, PrivateIdentifier: class extends rt {
    }, Program: bi, Property: class extends _s {
      constructor() {
        super(...arguments), this.deoptimized = false, this.declarationInit = null;
      }
      declare(e2, t) {
        return this.declarationInit = t, this.value.declare(e2, q);
      }
      hasEffects(e2) {
        this.deoptimized || this.applyDeoptimizations();
        const t = this.context.options.treeshake.propertyReadSideEffects;
        return this.parent.type === "ObjectPattern" && t === "always" || this.key.hasEffects(e2) || this.value.hasEffects(e2);
      }
      markDeclarationReached() {
        this.value.markDeclarationReached();
      }
      render(e2, t) {
        this.shorthand || this.key.render(e2, t), this.value.render(e2, t, { isShorthandProperty: this.shorthand });
      }
      applyDeoptimizations() {
        this.deoptimized = true, this.declarationInit !== null && (this.declarationInit.deoptimizePath([L, L]), this.context.requestTreeshakingPass());
      }
    }, PropertyDefinition: class extends rt {
      deoptimizePath(e2) {
        var t;
        (t = this.value) === null || t === void 0 || t.deoptimizePath(e2);
      }
      deoptimizeThisOnEventAtPath(e2, t, s2, i2) {
        var n3;
        (n3 = this.value) === null || n3 === void 0 || n3.deoptimizeThisOnEventAtPath(e2, t, s2, i2);
      }
      getLiteralValueAtPath(e2, t, s2) {
        return this.value ? this.value.getLiteralValueAtPath(e2, t, s2) : G;
      }
      getReturnExpressionWhenCalledAtPath(e2, t, s2, i2) {
        return this.value ? this.value.getReturnExpressionWhenCalledAtPath(e2, t, s2, i2) : q;
      }
      hasEffects(e2) {
        return this.key.hasEffects(e2) || this.static && this.value !== null && this.value.hasEffects(e2);
      }
      hasEffectsWhenAccessedAtPath(e2, t) {
        return !this.value || this.value.hasEffectsWhenAccessedAtPath(e2, t);
      }
      hasEffectsWhenAssignedAtPath(e2, t) {
        return !this.value || this.value.hasEffectsWhenAssignedAtPath(e2, t);
      }
      hasEffectsWhenCalledAtPath(e2, t, s2) {
        return !this.value || this.value.hasEffectsWhenCalledAtPath(e2, t, s2);
      }
    }, RestElement: ds, ReturnStatement: class extends rt {
      hasEffects(e2) {
        return !(e2.ignore.returnYield && (this.argument === null || !this.argument.hasEffects(e2))) || (e2.brokenFlow = 2, false);
      }
      include(e2, t) {
        this.included = true, this.argument && this.argument.include(e2, t), e2.brokenFlow = 2;
      }
      initialise() {
        this.scope.addReturnExpression(this.argument || q);
      }
      render(e2, t) {
        this.argument && (this.argument.render(e2, t, { preventASI: true }), this.argument.start === this.start + 6 && e2.prependLeft(this.start + 6, " "));
      }
    }, SequenceExpression: class extends rt {
      deoptimizePath(e2) {
        this.expressions[this.expressions.length - 1].deoptimizePath(e2);
      }
      deoptimizeThisOnEventAtPath(e2, t, s2, i2) {
        this.expressions[this.expressions.length - 1].deoptimizeThisOnEventAtPath(e2, t, s2, i2);
      }
      getLiteralValueAtPath(e2, t, s2) {
        return this.expressions[this.expressions.length - 1].getLiteralValueAtPath(e2, t, s2);
      }
      hasEffects(e2) {
        for (const t of this.expressions)
          if (t.hasEffects(e2))
            return true;
        return false;
      }
      hasEffectsWhenAccessedAtPath(e2, t) {
        return e2.length > 0 && this.expressions[this.expressions.length - 1].hasEffectsWhenAccessedAtPath(e2, t);
      }
      hasEffectsWhenAssignedAtPath(e2, t) {
        return this.expressions[this.expressions.length - 1].hasEffectsWhenAssignedAtPath(e2, t);
      }
      hasEffectsWhenCalledAtPath(e2, t, s2) {
        return this.expressions[this.expressions.length - 1].hasEffectsWhenCalledAtPath(e2, t, s2);
      }
      include(e2, t) {
        this.included = true;
        const s2 = this.expressions[this.expressions.length - 1];
        for (const i2 of this.expressions)
          (t || i2 === s2 && !(this.parent instanceof Kt) || i2.shouldBeIncluded(e2)) && i2.include(e2, t);
      }
      render(e2, t, { renderedParentType: s2, isCalleeOfRenderedParent: i2, preventASI: n3 } = Y) {
        let r2 = 0, a2 = null;
        const o2 = this.expressions[this.expressions.length - 1];
        for (const { node: h3, separator: l2, start: c3, end: u2 } of Gt(this.expressions, e2, this.start, this.end))
          if (h3.included)
            if (r2++, a2 = l2, r2 === 1 && n3 && Ht(e2, c3, h3.start), r2 === 1) {
              const n4 = s2 || this.parent.type;
              h3.render(e2, t, { isCalleeOfRenderedParent: i2 && h3 === o2, renderedParentType: n4, renderedSurroundingElement: n4 });
            } else
              h3.render(e2, t);
          else
            Ot(h3, e2, c3, u2);
        a2 && e2.remove(a2, this.end);
      }
    }, SpreadElement: at, StaticBlock: class extends rt {
      createScope(e2) {
        this.scope = new qt(e2);
      }
      hasEffects(e2) {
        for (const t of this.body)
          if (t.hasEffects(e2))
            return true;
        return false;
      }
      include(e2, t) {
        this.included = true;
        for (const s2 of this.body)
          (t || s2.shouldBeIncluded(e2)) && s2.include(e2, t);
      }
      render(e2, t) {
        this.body.length ? jt(this.body, e2, this.start + 1, this.end - 1, t) : super.render(e2, t);
      }
    }, Super: class extends rt {
      bind() {
        this.variable = this.scope.findVariable("this");
      }
      deoptimizePath(e2) {
        this.variable.deoptimizePath(e2);
      }
      include() {
        this.included || (this.included = true, this.context.includeVariableInModule(this.variable));
      }
    }, SwitchCase: Si, SwitchStatement: class extends rt {
      createScope(e2) {
        this.scope = new qt(e2);
      }
      hasEffects(e2) {
        if (this.discriminant.hasEffects(e2))
          return true;
        const { brokenFlow: t, ignore: { breaks: s2 } } = e2;
        let i2 = 1 / 0;
        e2.ignore.breaks = true;
        for (const s3 of this.cases) {
          if (s3.hasEffects(e2))
            return true;
          i2 = e2.brokenFlow < i2 ? e2.brokenFlow : i2, e2.brokenFlow = t;
        }
        return this.defaultCase !== null && i2 !== 1 && (e2.brokenFlow = i2), e2.ignore.breaks = s2, false;
      }
      include(e2, t) {
        this.included = true, this.discriminant.include(e2, t);
        const { brokenFlow: s2 } = e2;
        let i2 = 1 / 0, n3 = t || this.defaultCase !== null && this.defaultCase < this.cases.length - 1;
        for (let r2 = this.cases.length - 1; r2 >= 0; r2--) {
          const a2 = this.cases[r2];
          if (a2.included && (n3 = true), !n3) {
            const e3 = Ne();
            e3.ignore.breaks = true, n3 = a2.hasEffects(e3);
          }
          n3 ? (a2.include(e2, t), i2 = i2 < e2.brokenFlow ? i2 : e2.brokenFlow, e2.brokenFlow = s2) : i2 = s2;
        }
        n3 && this.defaultCase !== null && i2 !== 1 && (e2.brokenFlow = i2);
      }
      initialise() {
        for (let e2 = 0; e2 < this.cases.length; e2++)
          if (this.cases[e2].test === null)
            return void (this.defaultCase = e2);
        this.defaultCase = null;
      }
      render(e2, t) {
        this.discriminant.render(e2, t), this.cases.length > 0 && jt(this.cases, e2, this.cases[0].start, this.end - 1, t);
      }
    }, TaggedTemplateExpression: class extends rt {
      bind() {
        if (super.bind(), this.tag.type === "Identifier") {
          const e2 = this.tag.name;
          this.scope.findVariable(e2).isNamespace && this.context.warn({ code: "CANNOT_CALL_NAMESPACE", message: `Cannot call a namespace ('${e2}')` }, this.start);
        }
      }
      hasEffects(e2) {
        return super.hasEffects(e2) || this.tag.hasEffectsWhenCalledAtPath(V, this.callOptions, e2);
      }
      initialise() {
        this.callOptions = { args: _e, thisParam: null, withNew: false };
      }
      render(e2, t) {
        this.tag.render(e2, t, { isCalleeOfRenderedParent: true }), this.quasi.render(e2, t);
      }
    }, TemplateElement: class extends rt {
      bind() {
      }
      hasEffects() {
        return false;
      }
      include() {
        this.included = true;
      }
      parseNode(e2) {
        this.value = e2.value, super.parseNode(e2);
      }
      render() {
      }
    }, TemplateLiteral: Ai, ThisExpression: class extends rt {
      bind() {
        this.variable = this.scope.findVariable("this");
      }
      deoptimizePath(e2) {
        this.variable.deoptimizePath(e2);
      }
      deoptimizeThisOnEventAtPath(e2, t, s2, i2) {
        this.variable.deoptimizeThisOnEventAtPath(e2, t, s2 === this ? this.variable : s2, i2);
      }
      hasEffectsWhenAccessedAtPath(e2, t) {
        return e2.length > 0 && this.variable.hasEffectsWhenAccessedAtPath(e2, t);
      }
      hasEffectsWhenAssignedAtPath(e2, t) {
        return this.variable.hasEffectsWhenAssignedAtPath(e2, t);
      }
      include() {
        this.included || (this.included = true, this.context.includeVariableInModule(this.variable));
      }
      initialise() {
        this.alias = this.scope.findLexicalBoundary() instanceof wi ? this.context.moduleContext : null, this.alias === "undefined" && this.context.warn({ code: "THIS_IS_UNDEFINED", message: "The 'this' keyword is equivalent to 'undefined' at the top level of an ES module, and has been rewritten", url: "https://rollupjs.org/guide/en/#error-this-is-undefined" }, this.start);
      }
      render(e2) {
        this.alias !== null && e2.overwrite(this.start, this.end, this.alias, { contentOnly: false, storeName: true });
      }
    }, ThrowStatement: class extends rt {
      hasEffects() {
        return true;
      }
      include(e2, t) {
        this.included = true, this.argument.include(e2, t), e2.brokenFlow = 2;
      }
      render(e2, t) {
        this.argument.render(e2, t, { preventASI: true }), this.argument.start === this.start + 5 && e2.prependLeft(this.start + 5, " ");
      }
    }, TryStatement: class extends rt {
      constructor() {
        super(...arguments), this.directlyIncluded = false, this.includedLabelsAfterBlock = null;
      }
      hasEffects(e2) {
        return (this.context.options.treeshake.tryCatchDeoptimization ? this.block.body.length > 0 : this.block.hasEffects(e2)) || this.finalizer !== null && this.finalizer.hasEffects(e2);
      }
      include(e2, t) {
        var s2;
        const i2 = (s2 = this.context.options.treeshake) === null || s2 === void 0 ? void 0 : s2.tryCatchDeoptimization, { brokenFlow: n3 } = e2;
        if (this.directlyIncluded && i2) {
          if (this.includedLabelsAfterBlock)
            for (const t2 of this.includedLabelsAfterBlock)
              e2.includedLabels.add(t2);
        } else
          this.included = true, this.directlyIncluded = true, this.block.include(e2, i2 ? "variables" : t), e2.includedLabels.size > 0 && (this.includedLabelsAfterBlock = [...e2.includedLabels]), e2.brokenFlow = n3;
        this.handler !== null && (this.handler.include(e2, t), e2.brokenFlow = n3), this.finalizer !== null && this.finalizer.include(e2, t);
      }
    }, UnaryExpression: class extends rt {
      constructor() {
        super(...arguments), this.deoptimized = false;
      }
      getLiteralValueAtPath(e2, t, s2) {
        if (e2.length > 0)
          return G;
        const i2 = this.argument.getLiteralValueAtPath(V, t, s2);
        return i2 === G ? G : Ci[this.operator](i2);
      }
      hasEffects(e2) {
        return this.deoptimized || this.applyDeoptimizations(), !(this.operator === "typeof" && this.argument instanceof cs) && (this.argument.hasEffects(e2) || this.operator === "delete" && this.argument.hasEffectsWhenAssignedAtPath(V, e2));
      }
      hasEffectsWhenAccessedAtPath(e2) {
        return this.operator === "void" ? e2.length > 0 : e2.length > 1;
      }
      applyDeoptimizations() {
        this.deoptimized = true, this.operator === "delete" && (this.argument.deoptimizePath(V), this.context.requestTreeshakingPass());
      }
    }, UnknownNode: class extends rt {
      hasEffects() {
        return true;
      }
      include(e2) {
        super.include(e2, true);
      }
    }, UpdateExpression: class extends rt {
      constructor() {
        super(...arguments), this.deoptimized = false;
      }
      hasEffects(e2) {
        return this.deoptimized || this.applyDeoptimizations(), this.argument.hasEffects(e2) || this.argument.hasEffectsWhenAssignedAtPath(V, e2);
      }
      hasEffectsWhenAccessedAtPath(e2) {
        return e2.length > 1;
      }
      render(e2, t) {
        const { exportNamesByVariable: s2, format: i2, snippets: { _: n3 } } = t;
        if (this.argument.render(e2, t), i2 === "system") {
          const i3 = this.argument.variable, r2 = s2.get(i3);
          if (r2)
            if (this.prefix)
              r2.length === 1 ? ms2(i3, this.start, this.end, e2, t) : gs(i3, this.start, this.end, this.parent.type !== "ExpressionStatement", e2, t);
            else {
              const s3 = this.operator[0];
              !function(e3, t2, s4, i4, n4, r3, a2) {
                const { _: o2 } = r3.snippets;
                n4.prependRight(t2, `${fs2([e3], r3, a2)},${o2}`), i4 && (n4.prependRight(t2, "("), n4.appendLeft(s4, ")"));
              }(i3, this.start, this.end, this.parent.type !== "ExpressionStatement", e2, t, `${n3}${s3}${n3}1`);
            }
        }
      }
      applyDeoptimizations() {
        if (this.deoptimized = true, this.argument.deoptimizePath(V), this.argument instanceof cs) {
          this.scope.findVariable(this.argument.name).isReassigned = true;
        }
        this.context.requestTreeshakingPass();
      }
    }, VariableDeclaration: Ni, VariableDeclarator: class extends rt {
      declareDeclarator(e2) {
        this.id.declare(e2, this.init || Te);
      }
      deoptimizePath(e2) {
        this.id.deoptimizePath(e2);
      }
      hasEffects(e2) {
        const t = this.init !== null && this.init.hasEffects(e2);
        return this.id.markDeclarationReached(), t || this.id.hasEffects(e2);
      }
      include(e2, t) {
        this.included = true, this.init && this.init.include(e2, t), this.id.markDeclarationReached(), (t || this.id.shouldBeIncluded(e2)) && this.id.include(e2, t);
      }
      render(e2, t) {
        const { exportNamesByVariable: s2, snippets: { _: i2 } } = t, n3 = this.id.included;
        if (n3)
          this.id.render(e2, t);
        else {
          const t2 = Ft(e2.original, "=", this.id.end);
          e2.remove(this.start, Wt(e2.original, t2 + 1));
        }
        this.init ? this.init.render(e2, t, n3 ? Y : { renderedSurroundingElement: "ExpressionStatement" }) : this.id instanceof cs && Ii(this.id.variable, s2) && e2.appendLeft(this.end, `${i2}=${i2}void 0`);
      }
    }, WhileStatement: class extends rt {
      hasEffects(e2) {
        if (this.test.hasEffects(e2))
          return true;
        const { brokenFlow: t, ignore: { breaks: s2, continues: i2 } } = e2;
        return e2.ignore.breaks = true, e2.ignore.continues = true, !!this.body.hasEffects(e2) || (e2.ignore.breaks = s2, e2.ignore.continues = i2, e2.brokenFlow = t, false);
      }
      include(e2, t) {
        this.included = true, this.test.include(e2, t);
        const { brokenFlow: s2 } = e2;
        this.body.includeAsSingleStatement(e2, t), e2.brokenFlow = s2;
      }
    }, YieldExpression: class extends rt {
      constructor() {
        super(...arguments), this.deoptimized = false;
      }
      hasEffects(e2) {
        return this.deoptimized || this.applyDeoptimizations(), !e2.ignore.returnYield || this.argument !== null && this.argument.hasEffects(e2);
      }
      render(e2, t) {
        this.argument && (this.argument.render(e2, t, { preventASI: true }), this.argument.start === this.start + 5 && e2.prependLeft(this.start + 5, " "));
      }
      applyDeoptimizations() {
        this.deoptimized = true;
        const { argument: e2 } = this;
        e2 && (e2.deoptimizePath(B2), this.context.requestTreeshakingPass());
      }
    } };
    $i = class extends K {
      constructor(e2) {
        super("_missingExportShim"), this.module = e2;
      }
      include() {
        super.include(), this.module.needsExportShim = true;
      }
    };
    Ti = class extends K {
      constructor(e2) {
        super(e2.getModuleName()), this.memberVariables = null, this.mergedNamespaces = [], this.referencedEarly = false, this.references = [], this.context = e2, this.module = e2.module;
      }
      addReference(e2) {
        this.references.push(e2), this.name = e2.name;
      }
      getMemberVariables() {
        if (this.memberVariables)
          return this.memberVariables;
        const e2 = /* @__PURE__ */ Object.create(null);
        for (const t of this.context.getExports().concat(this.context.getReexports()))
          if (t[0] !== "*" && t !== this.module.info.syntheticNamedExports) {
            const s2 = this.context.traceExport(t);
            s2 && (e2[t] = s2);
          }
        return this.memberVariables = e2;
      }
      include() {
        this.included = true, this.context.includeAllExports();
      }
      prepare(e2) {
        this.mergedNamespaces.length > 0 && this.module.scope.addAccessedGlobals(["_mergeNamespaces"], e2);
      }
      renderBlock(e2) {
        const { exportNamesByVariable: t, format: s2, freeze: i2, indent: n3, namespaceToStringTag: r2, snippets: { _: a2, cnst: o2, getObject: h3, getPropertyAccess: l2, n: c3, s: u2 } } = e2, d3 = this.getMemberVariables(), p2 = Object.entries(d3).map(([e3, t2]) => this.referencedEarly || t2.isReassigned ? [null, `get ${e3}${a2}()${a2}{${a2}return ${t2.getName(l2)}${u2}${a2}}`] : [e3, t2.getName(l2)]);
        p2.unshift([null, `__proto__:${a2}null`]);
        let f2 = h3(p2, { lineBreakIndent: { base: "", t: n3 } });
        if (this.mergedNamespaces.length > 0) {
          const e3 = this.mergedNamespaces.map((e4) => e4.getName(l2));
          f2 = `/*#__PURE__*/_mergeNamespaces(${f2},${a2}[${e3.join(`,${a2}`)}])`;
        } else
          r2 && (f2 = `/*#__PURE__*/Object.defineProperty(${f2},${a2}Symbol.toStringTag,${a2}${hi(h3)})`), i2 && (f2 = `/*#__PURE__*/Object.freeze(${f2})`);
        return f2 = `${o2} ${this.getName(l2)}${a2}=${a2}${f2};`, s2 === "system" && t.has(this) && (f2 += `${c3}${fs2([this], e2)};`), f2;
      }
      renderFirst() {
        return this.referencedEarly;
      }
      setMergedNamespaces(e2) {
        this.mergedNamespaces = e2;
        const t = this.context.getModuleExecIndex();
        for (const e3 of this.references)
          if (e3.context.getModuleExecIndex() <= t) {
            this.referencedEarly = true;
            break;
          }
      }
    };
    Ti.prototype.isNamespace = true;
    Ri = class extends K {
      constructor(e2, t, s2) {
        super(t), this.baseVariable = null, this.context = e2, this.module = e2.module, this.syntheticNamespace = s2;
      }
      getBaseVariable() {
        if (this.baseVariable)
          return this.baseVariable;
        let e2 = this.syntheticNamespace;
        for (; e2 instanceof ki || e2 instanceof Ri; ) {
          if (e2 instanceof ki) {
            const t = e2.getOriginalVariable();
            if (t === e2)
              break;
            e2 = t;
          }
          e2 instanceof Ri && (e2 = e2.syntheticNamespace);
        }
        return this.baseVariable = e2;
      }
      getBaseVariableName() {
        return this.syntheticNamespace.getBaseVariableName();
      }
      getName(e2) {
        return `${this.syntheticNamespace.getName(e2)}${e2(this.name)}`;
      }
      include() {
        this.included = true, this.context.includeVariableInModule(this.syntheticNamespace);
      }
      setRenderNames(e2, t) {
        super.setRenderNames(e2, t);
      }
    };
    !function(e2) {
      e2[e2.LOAD_AND_PARSE = 0] = "LOAD_AND_PARSE", e2[e2.ANALYSE = 1] = "ANALYSE", e2[e2.GENERATE = 2] = "GENERATE";
    }(Mi || (Mi = {}));
    Li = "performance" in (typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : {}) ? performance : { now: () => 0 };
    Oi = { memoryUsage: () => ({ heapUsed: 0 }) };
    Vi = () => {
    };
    Bi = /* @__PURE__ */ new Map();
    ji = Vi;
    Gi = Vi;
    Hi = ["load", "resolveDynamicImport", "resolveId", "transform"];
    Xi = { identifier: null, localName: "_missingExportShim" };
    Qi = class {
      constructor(e2, t, s2, i2, n3, r2, a2) {
        this.graph = e2, this.id = t, this.options = s2, this.alternativeReexportModules = /* @__PURE__ */ new Map(), this.chunkFileNames = /* @__PURE__ */ new Set(), this.chunkNames = [], this.cycles = /* @__PURE__ */ new Set(), this.dependencies = /* @__PURE__ */ new Set(), this.dynamicDependencies = /* @__PURE__ */ new Set(), this.dynamicImporters = [], this.dynamicImports = [], this.execIndex = 1 / 0, this.implicitlyLoadedAfter = /* @__PURE__ */ new Set(), this.implicitlyLoadedBefore = /* @__PURE__ */ new Set(), this.importDescriptions = /* @__PURE__ */ new Map(), this.importMetas = [], this.importedFromNotTreeshaken = false, this.importers = [], this.imports = /* @__PURE__ */ new Set(), this.includedDynamicImporters = [], this.isExecuted = false, this.isUserDefinedEntryPoint = false, this.needsExportShim = false, this.sideEffectDependenciesByVariable = /* @__PURE__ */ new Map(), this.sources = /* @__PURE__ */ new Set(), this.usesTopLevelAwait = false, this.allExportNames = null, this.ast = null, this.exportAllModules = [], this.exportAllSources = /* @__PURE__ */ new Set(), this.exportNamesByVariable = null, this.exportShimVariable = new $i(this), this.exports = /* @__PURE__ */ new Map(), this.namespaceReexportsByName = /* @__PURE__ */ new Map(), this.reexportDescriptions = /* @__PURE__ */ new Map(), this.relevantDependencies = null, this.syntheticExports = /* @__PURE__ */ new Map(), this.syntheticNamespace = null, this.transformDependencies = [], this.transitiveReexports = null, this.excludeFromSourcemap = /\0/.test(t), this.context = s2.moduleContext(t), this.preserveSignature = this.options.preserveEntrySignatures;
        const o2 = this, { dynamicImports: h3, dynamicImporters: l2, implicitlyLoadedAfter: c3, implicitlyLoadedBefore: u2, importers: d3, reexportDescriptions: p2, sources: f2 } = this;
        this.info = { ast: null, code: null, get dynamicallyImportedIdResolutions() {
          return h3.map(({ argument: e3 }) => typeof e3 == "string" && o2.resolvedIds[e3]).filter(Boolean);
        }, get dynamicallyImportedIds() {
          return h3.map(({ id: e3 }) => e3).filter((e3) => e3 != null);
        }, get dynamicImporters() {
          return l2.sort();
        }, get hasDefaultExport() {
          return o2.ast ? o2.exports.has("default") || p2.has("default") : null;
        }, get hasModuleSideEffects() {
          return xe("Accessing ModuleInfo.hasModuleSideEffects from plugins is deprecated. Please use ModuleInfo.moduleSideEffects instead.", false, s2), this.moduleSideEffects;
        }, id: t, get implicitlyLoadedAfterOneOf() {
          return Array.from(c3, Di).sort();
        }, get implicitlyLoadedBefore() {
          return Array.from(u2, Di).sort();
        }, get importedIdResolutions() {
          return Array.from(f2, (e3) => o2.resolvedIds[e3]).filter(Boolean);
        }, get importedIds() {
          return Array.from(f2, (e3) => {
            var t2;
            return (t2 = o2.resolvedIds[e3]) === null || t2 === void 0 ? void 0 : t2.id;
          }).filter(Boolean);
        }, get importers() {
          return d3.sort();
        }, isEntry: i2, isExternal: false, get isIncluded() {
          return e2.phase !== Mi.GENERATE ? null : o2.isIncluded();
        }, meta: __spreadValues2({}, a2), moduleSideEffects: n3, syntheticNamedExports: r2 }, Object.defineProperty(this.info, "hasModuleSideEffects", { enumerable: false });
      }
      basename() {
        const e2 = _(this.id), t = T(this.id);
        return Pe(t ? e2.slice(0, -t.length) : e2);
      }
      bindReferences() {
        this.ast.bind();
      }
      error(e2, t) {
        return this.addLocationToLogProps(e2, t), oe(e2);
      }
      getAllExportNames() {
        if (this.allExportNames)
          return this.allExportNames;
        this.allExportNames = /* @__PURE__ */ new Set([...this.exports.keys(), ...this.reexportDescriptions.keys()]);
        for (const e2 of this.exportAllModules)
          if (e2 instanceof ke)
            this.allExportNames.add(`*${e2.id}`);
          else
            for (const t of e2.getAllExportNames())
              t !== "default" && this.allExportNames.add(t);
        return typeof this.info.syntheticNamedExports == "string" && this.allExportNames.delete(this.info.syntheticNamedExports), this.allExportNames;
      }
      getDependenciesToBeIncluded() {
        if (this.relevantDependencies)
          return this.relevantDependencies;
        this.relevantDependencies = /* @__PURE__ */ new Set();
        const e2 = /* @__PURE__ */ new Set(), t = /* @__PURE__ */ new Set(), s2 = new Set(this.imports);
        if (this.info.isEntry || this.includedDynamicImporters.length > 0 || this.namespace.included || this.implicitlyLoadedAfter.size > 0)
          for (const e3 of [...this.getReexports(), ...this.getExports()]) {
            const [t2] = this.getVariableForExportName(e3);
            t2 && s2.add(t2);
          }
        for (let i2 of s2) {
          const s3 = this.sideEffectDependenciesByVariable.get(i2);
          if (s3)
            for (const e3 of s3)
              t.add(e3);
          i2 instanceof Ri ? i2 = i2.getBaseVariable() : i2 instanceof ki && (i2 = i2.getOriginalVariable()), e2.add(i2.module);
        }
        if (this.options.treeshake && this.info.moduleSideEffects !== "no-treeshake")
          this.addRelevantSideEffectDependencies(this.relevantDependencies, e2, t);
        else
          for (const e3 of this.dependencies)
            this.relevantDependencies.add(e3);
        for (const t2 of e2)
          this.relevantDependencies.add(t2);
        return this.relevantDependencies;
      }
      getExportNamesByVariable() {
        if (this.exportNamesByVariable)
          return this.exportNamesByVariable;
        const e2 = /* @__PURE__ */ new Map();
        for (const t of this.getAllExportNames()) {
          let [s2] = this.getVariableForExportName(t);
          if (s2 instanceof ki && (s2 = s2.getOriginalVariable()), !s2 || !(s2.included || s2 instanceof X))
            continue;
          const i2 = e2.get(s2);
          i2 ? i2.push(t) : e2.set(s2, [t]);
        }
        return this.exportNamesByVariable = e2;
      }
      getExports() {
        return Array.from(this.exports.keys());
      }
      getReexports() {
        if (this.transitiveReexports)
          return this.transitiveReexports;
        this.transitiveReexports = [];
        const e2 = new Set(this.reexportDescriptions.keys());
        for (const t of this.exportAllModules)
          if (t instanceof ke)
            e2.add(`*${t.id}`);
          else
            for (const s2 of [...t.getReexports(), ...t.getExports()])
              s2 !== "default" && e2.add(s2);
        return this.transitiveReexports = [...e2];
      }
      getRenderedExports() {
        const e2 = [], t = [];
        for (const s2 of this.exports.keys()) {
          const [i2] = this.getVariableForExportName(s2);
          (i2 && i2.included ? e2 : t).push(s2);
        }
        return { removedExports: t, renderedExports: e2 };
      }
      getSyntheticNamespace() {
        return this.syntheticNamespace === null && (this.syntheticNamespace = void 0, [this.syntheticNamespace] = this.getVariableForExportName(typeof this.info.syntheticNamedExports == "string" ? this.info.syntheticNamedExports : "default", { onlyExplicit: true })), this.syntheticNamespace ? this.syntheticNamespace : oe((e2 = this.id, t = this.info.syntheticNamedExports, { code: le.SYNTHETIC_NAMED_EXPORTS_NEED_NAMESPACE_EXPORT, id: e2, message: `Module "${ie(e2)}" that is marked with 'syntheticNamedExports: ${JSON.stringify(t)}' needs ${typeof t == "string" && t !== "default" ? `an explicit export named "${t}"` : "a default export"} that does not reexport an unresolved named export of the same module.` }));
        var e2, t;
      }
      getVariableForExportName(e2, { importerForSideEffects: t, isExportAllSearch: s2, onlyExplicit: i2, searchedNamesAndModules: n3 } = Q2) {
        var r2;
        if (e2[0] === "*") {
          if (e2.length === 1)
            return [this.namespace];
          return this.graph.modulesById.get(e2.slice(1)).getVariableForExportName("*");
        }
        const a2 = this.reexportDescriptions.get(e2);
        if (a2) {
          const [e3] = Yi(a2.module, a2.localName, t, false, n3);
          return e3 ? (t && Zi(e3, t, this), [e3]) : this.error(pe(a2.localName, this.id, a2.module.id), a2.start);
        }
        const o2 = this.exports.get(e2);
        if (o2) {
          if (o2 === Xi)
            return [this.exportShimVariable];
          const e3 = o2.localName, s3 = this.traceVariable(e3, t);
          return t && (D(t.sideEffectDependenciesByVariable, s3, () => /* @__PURE__ */ new Set()).add(this), Zi(s3, t, this)), [s3];
        }
        if (i2)
          return [null];
        if (e2 !== "default") {
          const s3 = (r2 = this.namespaceReexportsByName.get(e2)) !== null && r2 !== void 0 ? r2 : this.getVariableFromNamespaceReexports(e2, t, n3);
          if (this.namespaceReexportsByName.set(e2, s3), s3[0])
            return s3;
        }
        return this.info.syntheticNamedExports ? [D(this.syntheticExports, e2, () => new Ri(this.astContext, e2, this.getSyntheticNamespace()))] : !s2 && this.options.shimMissingExports ? (this.shimMissingExport(e2), [this.exportShimVariable]) : [null];
      }
      hasEffects() {
        return this.info.moduleSideEffects === "no-treeshake" || this.ast.included && this.ast.hasEffects(Ne());
      }
      include() {
        const e2 = Ie();
        this.ast.shouldBeIncluded(e2) && this.ast.include(e2, false);
      }
      includeAllExports(e2) {
        this.isExecuted || (Ki(this), this.graph.needsTreeshakingPass = true);
        for (const t of this.exports.keys())
          if (e2 || t !== this.info.syntheticNamedExports) {
            const e3 = this.getVariableForExportName(t)[0];
            e3.deoptimizePath(B2), e3.included || this.includeVariable(e3);
          }
        for (const e3 of this.getReexports()) {
          const [t] = this.getVariableForExportName(e3);
          t && (t.deoptimizePath(B2), t.included || this.includeVariable(t), t instanceof X && (t.module.reexported = true));
        }
        e2 && this.namespace.setMergedNamespaces(this.includeAndGetAdditionalMergedNamespaces());
      }
      includeAllInBundle() {
        this.ast.include(Ie(), true), this.includeAllExports(false);
      }
      isIncluded() {
        return this.ast.included || this.namespace.included || this.importedFromNotTreeshaken;
      }
      linkImports() {
        this.addModulesToImportDescriptions(this.importDescriptions), this.addModulesToImportDescriptions(this.reexportDescriptions);
        const e2 = [];
        for (const t of this.exportAllSources) {
          const s2 = this.graph.modulesById.get(this.resolvedIds[t].id);
          s2 instanceof ke ? e2.push(s2) : this.exportAllModules.push(s2);
        }
        this.exportAllModules.push(...e2);
      }
      render(e2) {
        const t = this.magicString.clone();
        return this.ast.render(t, e2), this.usesTopLevelAwait = this.astContext.usesTopLevelAwait, t;
      }
      setSource(_a2) {
        var _b = _a2, { ast: e2, code: t, customTransformCache: s2, originalCode: i2, originalSourcemap: n3, resolvedIds: r2, sourcemapChain: a2, transformDependencies: o2, transformFiles: h3 } = _b, l2 = __objRest(_b, ["ast", "code", "customTransformCache", "originalCode", "originalSourcemap", "resolvedIds", "sourcemapChain", "transformDependencies", "transformFiles"]);
        this.info.code = t, this.originalCode = i2, this.originalSourcemap = n3, this.sourcemapChain = a2, h3 && (this.transformFiles = h3), this.transformDependencies = o2, this.customTransformCache = s2, this.updateOptions(l2), ji("generate ast", 3), e2 || (e2 = this.tryParse()), Gi("generate ast", 3), this.resolvedIds = r2 || /* @__PURE__ */ Object.create(null);
        const c3 = this.id;
        this.magicString = new b(t, { filename: this.excludeFromSourcemap ? null : c3, indentExclusionRanges: [] }), ji("analyse ast", 3), this.astContext = { addDynamicImport: this.addDynamicImport.bind(this), addExport: this.addExport.bind(this), addImport: this.addImport.bind(this), addImportMeta: this.addImportMeta.bind(this), code: t, deoptimizationTracker: this.graph.deoptimizationTracker, error: this.error.bind(this), fileName: c3, getExports: this.getExports.bind(this), getModuleExecIndex: () => this.execIndex, getModuleName: this.basename.bind(this), getNodeConstructor: (e3) => _i[e3] || _i.UnknownNode, getReexports: this.getReexports.bind(this), importDescriptions: this.importDescriptions, includeAllExports: () => this.includeAllExports(true), includeDynamicImport: this.includeDynamicImport.bind(this), includeVariableInModule: this.includeVariableInModule.bind(this), magicString: this.magicString, module: this, moduleContext: this.context, options: this.options, requestTreeshakingPass: () => this.graph.needsTreeshakingPass = true, traceExport: (e3) => this.getVariableForExportName(e3)[0], traceVariable: this.traceVariable.bind(this), usesTopLevelAwait: false, warn: this.warn.bind(this) }, this.scope = new wi(this.graph.scope, this.astContext), this.namespace = new Ti(this.astContext), this.ast = new bi(e2, { context: this.astContext, type: "Module" }, this.scope), this.info.ast = e2, Gi("analyse ast", 3);
      }
      toJSON() {
        return { ast: this.ast.esTreeNode, code: this.info.code, customTransformCache: this.customTransformCache, dependencies: Array.from(this.dependencies, Di), id: this.id, meta: this.info.meta, moduleSideEffects: this.info.moduleSideEffects, originalCode: this.originalCode, originalSourcemap: this.originalSourcemap, resolvedIds: this.resolvedIds, sourcemapChain: this.sourcemapChain, syntheticNamedExports: this.info.syntheticNamedExports, transformDependencies: this.transformDependencies, transformFiles: this.transformFiles };
      }
      traceVariable(e2, t) {
        const s2 = this.scope.variables.get(e2);
        if (s2)
          return s2;
        const i2 = this.importDescriptions.get(e2);
        if (i2) {
          const e3 = i2.module;
          if (e3 instanceof Qi && i2.name === "*")
            return e3.namespace;
          const [s3] = e3.getVariableForExportName(i2.name, { importerForSideEffects: t || this });
          return s3 || this.error(pe(i2.name, this.id, e3.id), i2.start);
        }
        return null;
      }
      tryParse() {
        try {
          return this.graph.contextParse(this.info.code);
        } catch (e2) {
          let t = e2.message.replace(/ \(\d+:\d+\)$/, "");
          return this.id.endsWith(".json") ? t += " (Note that you need @rollup/plugin-json to import JSON files)" : this.id.endsWith(".js") || (t += " (Note that you need plugins to import files that are not JavaScript)"), this.error({ code: "PARSE_ERROR", message: t, parserError: e2 }, e2.pos);
        }
      }
      updateOptions({ meta: e2, moduleSideEffects: t, syntheticNamedExports: s2 }) {
        t != null && (this.info.moduleSideEffects = t), s2 != null && (this.info.syntheticNamedExports = s2), e2 != null && Object.assign(this.info.meta, e2);
      }
      warn(e2, t) {
        this.addLocationToLogProps(e2, t), this.options.onwarn(e2);
      }
      addDynamicImport(e2) {
        let t = e2.source;
        t instanceof Ai ? t.quasis.length === 1 && t.quasis[0].value.cooked && (t = t.quasis[0].value.cooked) : t instanceof Ps && typeof t.value == "string" && (t = t.value), this.dynamicImports.push({ argument: t, id: null, node: e2, resolution: null });
      }
      addExport(e2) {
        if (e2 instanceof Vs)
          this.exports.set("default", { identifier: e2.variable.getAssignedVariableName(), localName: "default" });
        else if (e2 instanceof Ls) {
          const t = e2.source.value;
          if (this.sources.add(t), e2.exported) {
            const s2 = e2.exported.name;
            this.reexportDescriptions.set(s2, { localName: "*", module: null, source: t, start: e2.start });
          } else
            this.exportAllSources.add(t);
        } else if (e2.source instanceof Ps) {
          const t = e2.source.value;
          this.sources.add(t);
          for (const s2 of e2.specifiers) {
            const e3 = s2.exported.name;
            this.reexportDescriptions.set(e3, { localName: s2.local.name, module: null, source: t, start: s2.start });
          }
        } else if (e2.declaration) {
          const t = e2.declaration;
          if (t instanceof Ni)
            for (const e3 of t.declarations)
              for (const t2 of Ce(e3.id))
                this.exports.set(t2, { identifier: null, localName: t2 });
          else {
            const e3 = t.id.name;
            this.exports.set(e3, { identifier: null, localName: e3 });
          }
        } else
          for (const t of e2.specifiers) {
            const e3 = t.local.name, s2 = t.exported.name;
            this.exports.set(s2, { identifier: null, localName: e3 });
          }
      }
      addImport(e2) {
        const t = e2.source.value;
        this.sources.add(t);
        for (const s2 of e2.specifiers) {
          const e3 = s2.type === "ImportDefaultSpecifier", i2 = s2.type === "ImportNamespaceSpecifier", n3 = e3 ? "default" : i2 ? "*" : s2.imported.name;
          this.importDescriptions.set(s2.local.name, { module: null, name: n3, source: t, start: s2.start });
        }
      }
      addImportMeta(e2) {
        this.importMetas.push(e2);
      }
      addLocationToLogProps(e2, t) {
        e2.id = this.id, e2.pos = t;
        let s2 = this.info.code;
        const i2 = J(s2, t, { offsetLine: 1 });
        if (i2) {
          let { column: n3, line: r2 } = i2;
          try {
            ({ column: n3, line: r2 } = function(e3, t2) {
              const s3 = e3.filter((e4) => !!e4.mappings);
              e:
                for (; s3.length > 0; ) {
                  const e4 = s3.pop().mappings[t2.line - 1];
                  if (e4) {
                    const s4 = e4.filter((e5) => e5.length > 1), i3 = s4[s4.length - 1];
                    for (const e5 of s4)
                      if (e5[0] >= t2.column || e5 === i3) {
                        t2 = { column: e5[3], line: e5[2] + 1 };
                        continue e;
                      }
                  }
                  throw new Error("Can't resolve original location of error.");
                }
              return t2;
            }(this.sourcemapChain, { column: n3, line: r2 })), s2 = this.originalCode;
          } catch (e3) {
            this.options.onwarn({ code: "SOURCEMAP_ERROR", id: this.id, loc: { column: n3, file: this.id, line: r2 }, message: `Error when using sourcemap for reporting an error: ${e3.message}`, pos: t });
          }
          he(e2, { column: n3, line: r2 }, s2, this.id);
        }
      }
      addModulesToImportDescriptions(e2) {
        for (const t of e2.values()) {
          const { id: e3 } = this.resolvedIds[t.source];
          t.module = this.graph.modulesById.get(e3);
        }
      }
      addRelevantSideEffectDependencies(e2, t, s2) {
        const i2 = /* @__PURE__ */ new Set(), n3 = (r2) => {
          for (const a2 of r2)
            i2.has(a2) || (i2.add(a2), t.has(a2) ? e2.add(a2) : (a2.info.moduleSideEffects || s2.has(a2)) && (a2 instanceof ke || a2.hasEffects() ? e2.add(a2) : n3(a2.dependencies)));
        };
        n3(this.dependencies), n3(s2);
      }
      getVariableFromNamespaceReexports(e2, t, s2) {
        let i2 = null;
        const n3 = /* @__PURE__ */ new Map(), r2 = /* @__PURE__ */ new Set();
        for (const a2 of this.exportAllModules) {
          if (a2.info.syntheticNamedExports === e2)
            continue;
          const [o2, h3] = Yi(a2, e2, t, true, s2);
          a2 instanceof ke || h3 ? r2.add(o2) : o2 instanceof Ri ? i2 || (i2 = o2) : o2 && n3.set(o2, a2);
        }
        if (n3.size > 0) {
          const t2 = [...n3], s3 = t2[0][0];
          return t2.length === 1 ? [s3] : (this.options.onwarn(function(e3, t3, s4) {
            return { code: le.NAMESPACE_CONFLICT, message: `Conflicting namespaces: "${ie(t3)}" re-exports "${e3}" from one of the modules ${te(s4.map((e4) => ie(e4)))} (will be ignored)`, name: e3, reexporter: t3, sources: s4 };
          }(e2, this.id, t2.map(([, e3]) => e3.id))), [null]);
        }
        if (r2.size > 0) {
          const t2 = [...r2], s3 = t2[0];
          return t2.length > 1 && this.options.onwarn(function(e3, t3, s4, i3) {
            return { code: le.AMBIGUOUS_EXTERNAL_NAMESPACES, message: `Ambiguous external namespace resolution: "${ie(t3)}" re-exports "${e3}" from one of the external modules ${te(i3.map((e4) => ie(e4)))}, guessing "${ie(s4)}".`, name: e3, reexporter: t3, sources: i3 };
          }(e2, this.id, s3.module.id, t2.map((e3) => e3.module.id))), [s3, true];
        }
        return i2 ? [i2] : [null];
      }
      includeAndGetAdditionalMergedNamespaces() {
        const e2 = /* @__PURE__ */ new Set(), t = /* @__PURE__ */ new Set();
        for (const s2 of [this, ...this.exportAllModules])
          if (s2 instanceof ke) {
            const [t2] = s2.getVariableForExportName("*");
            t2.include(), this.imports.add(t2), e2.add(t2);
          } else if (s2.info.syntheticNamedExports) {
            const e3 = s2.getSyntheticNamespace();
            e3.include(), this.imports.add(e3), t.add(e3);
          }
        return [...t, ...e2];
      }
      includeDynamicImport(e2) {
        const t = this.dynamicImports.find((t2) => t2.node === e2).resolution;
        t instanceof Qi && (t.includedDynamicImporters.push(this), t.includeAllExports(true));
      }
      includeVariable(e2) {
        if (!e2.included) {
          e2.include(), this.graph.needsTreeshakingPass = true;
          const t = e2.module;
          if (t instanceof Qi && (t.isExecuted || Ki(t), t !== this)) {
            const t2 = function(e3, t3) {
              const s2 = D(t3.sideEffectDependenciesByVariable, e3, () => /* @__PURE__ */ new Set());
              let i2 = e3;
              const n3 = /* @__PURE__ */ new Set([i2]);
              for (; ; ) {
                const e4 = i2.module;
                if (i2 = i2 instanceof ki ? i2.getDirectOriginalVariable() : i2 instanceof Ri ? i2.syntheticNamespace : null, !i2 || n3.has(i2))
                  break;
                n3.add(i2), s2.add(e4);
                const t4 = e4.sideEffectDependenciesByVariable.get(i2);
                if (t4)
                  for (const e5 of t4)
                    s2.add(e5);
              }
              return s2;
            }(e2, this);
            for (const e3 of t2)
              e3.isExecuted || Ki(e3);
          }
        }
      }
      includeVariableInModule(e2) {
        this.includeVariable(e2);
        const t = e2.module;
        t && t !== this && this.imports.add(e2);
      }
      shimMissingExport(e2) {
        this.options.onwarn({ code: "SHIMMED_EXPORT", exporter: ie(this.id), exportName: e2, message: `Missing export "${e2}" has been shimmed in module ${ie(this.id)}.` }), this.exports.set(e2, Xi);
      }
    };
    an = (e2, t, s2, { _: i2, getDirectReturnFunction: n3, n: r2 }) => {
      if (t) {
        const [t2, a2] = n3([], { functionReturn: true, lineBreakIndent: null, name: null });
        return `Object.defineProperty(exports,${i2}k,${i2}{${r2}${s2}${s2}enumerable:${i2}true,${r2}${s2}${s2}get:${i2}${t2}${e2}[k]${a2}${r2}${s2}})`;
      }
      return `exports[k]${i2}=${i2}${e2}[k]`;
    };
    ln = { assert: true, buffer: true, console: true, constants: true, domain: true, events: true, http: true, https: true, os: true, path: true, process: true, punycode: true, querystring: true, stream: true, string_decoder: true, timers: true, tty: true, url: true, util: true, vm: true, zlib: true };
    un = (e2, t) => e2.split(".").map(t).join("");
    fn = ({ dependencies: e2, exports: t }) => {
      const s2 = new Set(t.map((e3) => e3.exported));
      s2.add("default");
      for (const { reexports: t2 } of e2)
        if (t2)
          for (const e3 of t2)
            e3.reexported !== "*" && s2.add(e3.reexported);
      return s2;
    };
    mn = (e2, t, { _: s2, cnst: i2, getObject: n3, n: r2 }) => e2 ? `${r2}${t}${i2} _starExcludes${s2}=${s2}${n3([...e2].map((e3) => [e3, "1"]), { lineBreakIndent: { base: t, t } })};` : "";
    gn = (e2, t, { _: s2, n: i2 }) => e2.length ? `${i2}${t}var ${e2.join(`,${s2}`)};` : "";
    yn = (e2, t, s2) => En(e2.filter((e3) => e3.hoisted).map((e3) => ({ name: e3.exported, value: e3.local })), t, s2);
    xn = (e2, t, s2) => En(e2.filter((e3) => e3.expression).map((e3) => ({ name: e3.exported, value: e3.local })), t, s2);
    vn = (e2, t, s2) => En(e2.filter((e3) => e3.local === "_missingExportShim").map((e3) => ({ name: e3.exported, value: "_missingExportShim" })), t, s2);
    Sn = { amd: function(e2, { accessedGlobals: t, dependencies: s2, exports: i2, hasExports: n3, id: r2, indent: a2, intro: o2, isEntryFacade: h3, isModuleFacade: l2, namedExportsMode: c3, outro: u2, snippets: d3, warn: p2 }, { amd: f2, esModule: m3, externalLiveBindings: g2, freeze: y3, interop: E3, namespaceToStringTag: x2, strict: v2 }) {
      cn(p2, s2);
      const b2 = s2.map((e3) => `'${hn(e3.id)}'`), S2 = s2.map((e3) => e3.name), { n: A3, getNonArrowFunctionIntro: P2, _: k2 } = d3;
      c3 && n3 && (S2.unshift("exports"), b2.unshift("'exports'")), t.has("require") && (S2.unshift("require"), b2.unshift("'require'")), t.has("module") && (S2.unshift("module"), b2.unshift("'module'"));
      const w3 = en(f2, r2), C3 = (w3 ? `'${w3}',${k2}` : "") + (b2.length ? `[${b2.join(`,${k2}`)}],${k2}` : ""), I2 = v2 ? `${k2}'use strict';` : "";
      e2.prepend(`${o2}${on(s2, E3, g2, y3, x2, t, a2, d3)}`);
      const N2 = tn(i2, s2, c3, E3, d3, a2, g2);
      let _2 = rn(c3 && n3, h3 && m3, l2 && x2, d3);
      return _2 && (_2 = A3 + A3 + _2), e2.append(`${N2}${_2}${u2}`), e2.indent(a2).prepend(`${f2.define}(${C3}(${P2(S2, { isAsync: false, name: null })}{${I2}${A3}${A3}`).append(`${A3}${A3}}));`);
    }, cjs: function(e2, { accessedGlobals: t, dependencies: s2, exports: i2, hasExports: n3, indent: r2, intro: a2, isEntryFacade: o2, isModuleFacade: h3, namedExportsMode: l2, outro: c3, snippets: u2 }, { compact: d3, esModule: p2, externalLiveBindings: f2, freeze: m3, interop: g2, namespaceToStringTag: y3, strict: E3 }) {
      const { _: x2, n: v2 } = u2, b2 = E3 ? `'use strict';${v2}${v2}` : "";
      let S2 = rn(l2 && n3, o2 && p2, h3 && y3, u2);
      S2 && (S2 += v2 + v2);
      const A3 = function(e3, { _: t2, cnst: s3, n: i3 }, n4) {
        let r3 = "", a3 = false;
        for (const { id: o3, name: h4, reexports: l3, imports: c4 } of e3)
          l3 || c4 ? (r3 += n4 && a3 ? "," : `${r3 ? `;${i3}` : ""}${s3} `, a3 = true, r3 += `${h4}${t2}=${t2}require('${o3}')`) : (r3 && (r3 += n4 && !a3 ? "," : `;${i3}`), a3 = false, r3 += `require('${o3}')`);
        if (r3)
          return `${r3};${i3}${i3}`;
        return "";
      }(s2, u2, d3), P2 = on(s2, g2, f2, m3, y3, t, r2, u2);
      e2.prepend(`${b2}${a2}${S2}${A3}${P2}`);
      const k2 = tn(i2, s2, l2, g2, u2, r2, f2, `module.exports${x2}=${x2}`);
      return e2.append(`${k2}${c3}`);
    }, es: function(e2, { accessedGlobals: t, indent: s2, intro: i2, outro: n3, dependencies: r2, exports: a2, snippets: o2 }, { externalLiveBindings: h3, freeze: l2, namespaceToStringTag: c3 }) {
      const { _: u2, n: d3 } = o2, p2 = function(e3, t2) {
        const s3 = [];
        for (const { id: i3, reexports: n4, imports: r3, name: a3 } of e3)
          if (n4 || r3) {
            if (r3) {
              let e4 = null, n5 = null;
              const a4 = [];
              for (const t3 of r3)
                t3.imported === "default" ? e4 = t3 : t3.imported === "*" ? n5 = t3 : a4.push(t3);
              n5 && s3.push(`import${t2}*${t2}as ${n5.local} from${t2}'${i3}';`), e4 && a4.length === 0 ? s3.push(`import ${e4.local} from${t2}'${i3}';`) : a4.length > 0 && s3.push(`import ${e4 ? `${e4.local},${t2}` : ""}{${t2}${a4.map((e5) => e5.imported === e5.local ? e5.imported : `${e5.imported} as ${e5.local}`).join(`,${t2}`)}${t2}}${t2}from${t2}'${i3}';`);
            }
            if (n4) {
              let e4 = null;
              const o3 = [], h4 = [];
              for (const t3 of n4)
                t3.reexported === "*" ? e4 = t3 : t3.imported === "*" ? o3.push(t3) : h4.push(t3);
              if (e4 && s3.push(`export${t2}*${t2}from${t2}'${i3}';`), o3.length > 0) {
                r3 && r3.some((e5) => e5.imported === "*" && e5.local === a3) || s3.push(`import${t2}*${t2}as ${a3} from${t2}'${i3}';`);
                for (const e5 of o3)
                  s3.push(`export${t2}{${t2}${a3 === e5.reexported ? a3 : `${a3} as ${e5.reexported}`} };`);
              }
              h4.length > 0 && s3.push(`export${t2}{${t2}${h4.map((e5) => e5.imported === e5.reexported ? e5.imported : `${e5.imported} as ${e5.reexported}`).join(`,${t2}`)}${t2}}${t2}from${t2}'${i3}';`);
            }
          } else
            s3.push(`import${t2}'${i3}';`);
        return s3;
      }(r2, u2);
      p2.length > 0 && (i2 += p2.join(d3) + d3 + d3), (i2 += Ks(null, t, s2, o2, h3, l2, c3)) && e2.prepend(i2);
      const f2 = function(e3, { _: t2, cnst: s3 }) {
        const i3 = [], n4 = [];
        for (const r3 of e3)
          r3.expression && i3.push(`${s3} ${r3.local}${t2}=${t2}${r3.expression};`), n4.push(r3.exported === r3.local ? r3.local : `${r3.local} as ${r3.exported}`);
        n4.length && i3.push(`export${t2}{${t2}${n4.join(`,${t2}`)}${t2}};`);
        return i3;
      }(a2, o2);
      return f2.length && e2.append(d3 + d3 + f2.join(d3).trim()), n3 && e2.append(n3), e2.trim();
    }, iife: function(e2, { accessedGlobals: t, dependencies: s2, exports: i2, hasExports: n3, indent: r2, intro: a2, namedExportsMode: o2, outro: h3, snippets: l2, warn: c3 }, { compact: u2, esModule: d3, extend: p2, freeze: f2, externalLiveBindings: m3, globals: g2, interop: y3, name: E3, namespaceToStringTag: x2, strict: v2 }) {
      const { _: b2, cnst: S2, getNonArrowFunctionIntro: A3, getPropertyAccess: P2, n: k2 } = l2, w3 = E3 && E3.includes("."), C3 = !p2 && !w3;
      if (E3 && C3 && (Ae(I2 = E3) || be.has(I2) || Se.test(I2)))
        return oe({ code: "ILLEGAL_IDENTIFIER_AS_NAME", message: `Given name "${E3}" is not a legal JS identifier. If you need this, you can try "output.extend: true".` });
      var I2;
      cn(c3, s2);
      const N2 = pn(s2), _2 = N2.map((e3) => e3.globalName || "null"), $2 = N2.map((e3) => e3.name);
      n3 && !E3 && c3({ code: "MISSING_NAME_OPTION_FOR_IIFE_EXPORT", message: 'If you do not supply "output.name", you may not be able to access the exports of an IIFE bundle.' }), o2 && n3 && (p2 ? (_2.unshift(`this${un(E3, P2)}${b2}=${b2}this${un(E3, P2)}${b2}||${b2}{}`), $2.unshift("exports")) : (_2.unshift("{}"), $2.unshift("exports")));
      const T2 = v2 ? `${r2}'use strict';${k2}` : "", R2 = on(s2, y3, m3, f2, x2, t, r2, l2);
      e2.prepend(`${a2}${R2}`);
      let M2 = `(${A3($2, { isAsync: false, name: null })}{${k2}${T2}${k2}`;
      n3 && (!E3 || p2 && o2 || (M2 = (C3 ? `${S2} ${E3}` : `this${un(E3, P2)}`) + `${b2}=${b2}${M2}`), w3 && (M2 = function(e3, t2, s3, { _: i3, getPropertyAccess: n4, s: r3 }, a3) {
        const o3 = e3.split(".");
        o3[0] = (typeof s3 == "function" ? s3(o3[0]) : s3[o3[0]]) || o3[0], o3.pop();
        let h4 = t2;
        return o3.map((e4) => (h4 += n4(e4), `${h4}${i3}=${i3}${h4}${i3}||${i3}{}${r3}`)).join(a3 ? "," : "\n") + (a3 && o3.length ? ";" : "\n");
      }(E3, "this", g2, l2, u2) + M2));
      let D2 = `${k2}${k2}})(${_2.join(`,${b2}`)});`;
      n3 && !p2 && o2 && (D2 = `${k2}${k2}${r2}return exports;${D2}`);
      const L2 = tn(i2, s2, o2, y3, l2, r2, m3);
      let O2 = rn(o2 && n3, d3, x2, l2);
      return O2 && (O2 = k2 + k2 + O2), e2.append(`${L2}${O2}${h3}`), e2.indent(r2).prepend(M2).append(D2);
    }, system: function(e2, { accessedGlobals: t, dependencies: s2, exports: i2, hasExports: n3, indent: r2, intro: a2, snippets: o2, outro: h3, usesTopLevelAwait: l2 }, { externalLiveBindings: c3, freeze: u2, name: d3, namespaceToStringTag: p2, strict: f2, systemNullSetters: m3 }) {
      const { _: g2, getFunctionIntro: y3, getNonArrowFunctionIntro: E3, n: x2, s: v2 } = o2, { importBindings: b2, setters: S2, starExcludes: A3 } = function(e3, t2, s3, { _: i3, cnst: n4, getObject: r3, getPropertyAccess: a3, n: o3 }) {
        const h4 = [], l3 = [];
        let c4 = null;
        for (const { imports: u3, reexports: d4 } of e3) {
          const p3 = [];
          if (u3)
            for (const e4 of u3)
              h4.push(e4.local), e4.imported === "*" ? p3.push(`${e4.local}${i3}=${i3}module;`) : p3.push(`${e4.local}${i3}=${i3}module${a3(e4.imported)};`);
          if (d4) {
            const o4 = [];
            let h5 = false;
            for (const { imported: e4, reexported: t3 } of d4)
              t3 === "*" ? h5 = true : o4.push([t3, e4 === "*" ? "module" : `module${a3(e4)}`]);
            if (o4.length > 1 || h5) {
              const a4 = r3(o4, { lineBreakIndent: null });
              h5 ? (c4 || (c4 = fn({ dependencies: e3, exports: t2 })), p3.push(`${n4} setter${i3}=${i3}${a4};`, `for${i3}(${n4} name in module)${i3}{`, `${s3}if${i3}(!_starExcludes[name])${i3}setter[name]${i3}=${i3}module[name];`, "}", "exports(setter);")) : p3.push(`exports(${a4});`);
            } else {
              const [e4, t3] = o4[0];
              p3.push(`exports('${e4}',${i3}${t3});`);
            }
          }
          l3.push(p3.join(`${o3}${s3}${s3}${s3}`));
        }
        return { importBindings: h4, setters: l3, starExcludes: c4 };
      }(s2, i2, r2, o2), P2 = d3 ? `'${d3}',${g2}` : "", k2 = t.has("module") ? ["exports", "module"] : n3 ? ["exports"] : [];
      let w3 = `System.register(${P2}[` + s2.map(({ id: e3 }) => `'${e3}'`).join(`,${g2}`) + `],${g2}(${E3(k2, { isAsync: false, name: null })}{${x2}${r2}${f2 ? "'use strict';" : ""}` + mn(A3, r2, o2) + gn(b2, r2, o2) + `${x2}${r2}return${g2}{${S2.length ? `${x2}${r2}${r2}setters:${g2}[${S2.map((e3) => e3 ? `${y3(["module"], { isAsync: false, name: null })}{${x2}${r2}${r2}${r2}${e3}${x2}${r2}${r2}}` : m3 ? "null" : `${y3([], { isAsync: false, name: null })}{}`).join(`,${g2}`)}],` : ""}${x2}`;
      w3 += `${r2}${r2}execute:${g2}(${E3([], { isAsync: l2, name: null })}{${x2}${x2}`;
      const C3 = `${r2}${r2}})${x2}${r2}}${v2}${x2}}));`;
      return e2.prepend(a2 + Ks(null, t, r2, o2, c3, u2, p2) + yn(i2, r2, o2)), e2.append(`${h3}${x2}${x2}` + xn(i2, r2, o2) + vn(i2, r2, o2)), e2.indent(`${r2}${r2}${r2}`).append(C3).prepend(w3);
    }, umd: function(e2, { accessedGlobals: t, dependencies: s2, exports: i2, hasExports: n3, id: r2, indent: a2, intro: o2, namedExportsMode: h3, outro: l2, snippets: c3, warn: u2 }, { amd: d3, compact: p2, esModule: f2, extend: m3, externalLiveBindings: g2, freeze: y3, interop: E3, name: x2, namespaceToStringTag: v2, globals: b2, noConflict: S2, strict: A3 }) {
      const { _: P2, cnst: k2, getFunctionIntro: w3, getNonArrowFunctionIntro: C3, getPropertyAccess: I2, n: N2, s: _2 } = c3, $2 = p2 ? "f" : "factory", T2 = p2 ? "g" : "global";
      if (n3 && !x2)
        return oe({ code: "MISSING_NAME_OPTION_FOR_IIFE_EXPORT", message: 'You must supply "output.name" for UMD bundles that have exports so that the exports are accessible in environments without a module loader.' });
      cn(u2, s2);
      const R2 = s2.map((e3) => `'${hn(e3.id)}'`), M2 = s2.map((e3) => `require('${e3.id}')`), D2 = pn(s2), L2 = D2.map((e3) => bn(e3.globalName, T2, I2)), O2 = D2.map((e3) => e3.name);
      h3 && (n3 || S2) && (R2.unshift("'exports'"), M2.unshift("exports"), L2.unshift(dn(x2, T2, b2, (m3 ? `${bn(x2, T2, I2)}${P2}||${P2}` : "") + "{}", c3)), O2.unshift("exports"));
      const V2 = en(d3, r2), B3 = (V2 ? `'${V2}',${P2}` : "") + (R2.length ? `[${R2.join(`,${P2}`)}],${P2}` : ""), F2 = d3.define, z2 = !h3 && n3 ? `module.exports${P2}=${P2}` : "", W2 = A3 ? `${P2}'use strict';${N2}` : "";
      let U2;
      if (S2) {
        const e3 = p2 ? "e" : "exports";
        let t2;
        if (!h3 && n3)
          t2 = `${k2} ${e3}${P2}=${P2}${dn(x2, T2, b2, `${$2}(${L2.join(`,${P2}`)})`, c3)};`;
        else {
          t2 = `${k2} ${e3}${P2}=${P2}${L2.shift()};${N2}${a2}${a2}${$2}(${[e3].concat(L2).join(`,${P2}`)});`;
        }
        U2 = `(${w3([], { isAsync: false, name: null })}{${N2}${a2}${a2}${k2} current${P2}=${P2}${function(e4, t3, { _: s3, getPropertyAccess: i3 }) {
          let n4 = t3;
          return e4.split(".").map((e5) => n4 += i3(e5)).join(`${s3}&&${s3}`);
        }(x2, T2, c3)};${N2}${a2}${a2}${t2}${N2}${a2}${a2}${e3}.noConflict${P2}=${P2}${w3([], { isAsync: false, name: null })}{${P2}${bn(x2, T2, I2)}${P2}=${P2}current;${P2}return ${e3}${_2}${P2}};${N2}${a2}})()`;
      } else
        U2 = `${$2}(${L2.join(`,${P2}`)})`, !h3 && n3 && (U2 = dn(x2, T2, b2, U2, c3));
      const j2 = n3 || S2 && h3 || L2.length > 0, G2 = [$2];
      j2 && G2.unshift(T2);
      const H2 = j2 ? `this,${P2}` : "", q2 = j2 ? `(${T2}${P2}=${P2}typeof globalThis${P2}!==${P2}'undefined'${P2}?${P2}globalThis${P2}:${P2}${T2}${P2}||${P2}self,${P2}` : "", K2 = j2 ? ")" : "", X2 = j2 ? `${a2}typeof exports${P2}===${P2}'object'${P2}&&${P2}typeof module${P2}!==${P2}'undefined'${P2}?${P2}${z2}${$2}(${M2.join(`,${P2}`)})${P2}:${N2}` : "", Y2 = `(${C3(G2, { isAsync: false, name: null })}{${N2}` + X2 + `${a2}typeof ${F2}${P2}===${P2}'function'${P2}&&${P2}${F2}.amd${P2}?${P2}${F2}(${B3}${$2})${P2}:${N2}${a2}${q2}${U2}${K2};${N2}})(${H2}(${C3(O2, { isAsync: false, name: null })}{${W2}${N2}`, Q3 = N2 + N2 + "}));";
      e2.prepend(`${o2}${on(s2, E3, g2, y3, v2, t, a2, c3)}`);
      const Z2 = tn(i2, s2, h3, E3, c3, a2, g2);
      let J2 = rn(h3 && n3, f2, v2, c3);
      return J2 && (J2 = N2 + N2 + J2), e2.append(`${Z2}${J2}${l2}`), e2.trim().indent(a2).append(Q3).prepend(Y2);
    } };
    An = class {
      constructor(e2, t) {
        this.isOriginal = true, this.filename = e2, this.content = t;
      }
      traceSegment(e2, t, s2) {
        return { column: t, line: e2, name: s2, source: this };
      }
    };
    Pn = class {
      constructor(e2, t) {
        this.sources = t, this.names = e2.names, this.mappings = e2.mappings;
      }
      traceMappings() {
        const e2 = [], t = /* @__PURE__ */ new Map(), s2 = [], i2 = [], n3 = /* @__PURE__ */ new Map(), r2 = [];
        for (const a2 of this.mappings) {
          const o2 = [];
          for (const r3 of a2) {
            if (r3.length === 1)
              continue;
            const a3 = this.sources[r3[1]];
            if (!a3)
              continue;
            const h3 = a3.traceSegment(r3[2], r3[3], r3.length === 5 ? this.names[r3[4]] : "");
            if (h3) {
              const { column: a4, line: l2, name: c3, source: { content: u2, filename: d3 } } = h3;
              let p2 = t.get(d3);
              if (p2 === void 0)
                p2 = e2.length, e2.push(d3), t.set(d3, p2), s2[p2] = u2;
              else if (s2[p2] == null)
                s2[p2] = u2;
              else if (u2 != null && s2[p2] !== u2)
                return oe({ message: `Multiple conflicting contents for sourcemap source ${d3}` });
              const f2 = [r3[0], p2, l2, a4];
              if (c3) {
                let e3 = n3.get(c3);
                e3 === void 0 && (e3 = i2.length, i2.push(c3), n3.set(c3, e3)), f2[4] = e3;
              }
              o2.push(f2);
            }
          }
          r2.push(o2);
        }
        return { mappings: r2, names: i2, sources: e2, sourcesContent: s2 };
      }
      traceSegment(e2, t, s2) {
        const i2 = this.mappings[e2];
        if (!i2)
          return null;
        let n3 = 0, r2 = i2.length - 1;
        for (; n3 <= r2; ) {
          const e3 = n3 + r2 >> 1, a2 = i2[e3];
          if (a2[0] === t || n3 === r2) {
            if (a2.length == 1)
              return null;
            const e4 = this.sources[a2[1]];
            return e4 ? e4.traceSegment(a2[2], a2[3], a2.length === 5 ? this.names[a2[4]] : s2) : null;
          }
          a2[0] > t ? r2 = e3 - 1 : n3 = e3 + 1;
        }
        return null;
      }
    };
    Cn = {};
    In = Nn;
    Nn.equal = function(e2, t, s2) {
      if (e2 != t)
        throw new Error(s2 || "Assertion failed: " + e2 + " != " + t);
    };
    _n = { exports: {} };
    typeof Object.create == "function" ? _n.exports = function(e2, t) {
      t && (e2.super_ = t, e2.prototype = Object.create(t.prototype, { constructor: { value: e2, enumerable: false, writable: true, configurable: true } }));
    } : _n.exports = function(e2, t) {
      if (t) {
        e2.super_ = t;
        var s2 = function() {
        };
        s2.prototype = t.prototype, e2.prototype = new s2(), e2.prototype.constructor = e2;
      }
    };
    $n = In;
    Tn = _n.exports;
    Cn.inherits = Tn, Cn.toArray = function(e2, t) {
      if (Array.isArray(e2))
        return e2.slice();
      if (!e2)
        return [];
      var s2 = [];
      if (typeof e2 == "string")
        if (t) {
          if (t === "hex")
            for ((e2 = e2.replace(/[^a-z0-9]+/gi, "")).length % 2 != 0 && (e2 = "0" + e2), n3 = 0; n3 < e2.length; n3 += 2)
              s2.push(parseInt(e2[n3] + e2[n3 + 1], 16));
        } else
          for (var i2 = 0, n3 = 0; n3 < e2.length; n3++) {
            var r2 = e2.charCodeAt(n3);
            r2 < 128 ? s2[i2++] = r2 : r2 < 2048 ? (s2[i2++] = r2 >> 6 | 192, s2[i2++] = 63 & r2 | 128) : Rn(e2, n3) ? (r2 = 65536 + ((1023 & r2) << 10) + (1023 & e2.charCodeAt(++n3)), s2[i2++] = r2 >> 18 | 240, s2[i2++] = r2 >> 12 & 63 | 128, s2[i2++] = r2 >> 6 & 63 | 128, s2[i2++] = 63 & r2 | 128) : (s2[i2++] = r2 >> 12 | 224, s2[i2++] = r2 >> 6 & 63 | 128, s2[i2++] = 63 & r2 | 128);
          }
      else
        for (n3 = 0; n3 < e2.length; n3++)
          s2[n3] = 0 | e2[n3];
      return s2;
    }, Cn.toHex = function(e2) {
      for (var t = "", s2 = 0; s2 < e2.length; s2++)
        t += Dn(e2[s2].toString(16));
      return t;
    }, Cn.htonl = Mn, Cn.toHex32 = function(e2, t) {
      for (var s2 = "", i2 = 0; i2 < e2.length; i2++) {
        var n3 = e2[i2];
        t === "little" && (n3 = Mn(n3)), s2 += Ln(n3.toString(16));
      }
      return s2;
    }, Cn.zero2 = Dn, Cn.zero8 = Ln, Cn.join32 = function(e2, t, s2, i2) {
      var n3 = s2 - t;
      $n(n3 % 4 == 0);
      for (var r2 = new Array(n3 / 4), a2 = 0, o2 = t; a2 < r2.length; a2++, o2 += 4) {
        var h3;
        h3 = i2 === "big" ? e2[o2] << 24 | e2[o2 + 1] << 16 | e2[o2 + 2] << 8 | e2[o2 + 3] : e2[o2 + 3] << 24 | e2[o2 + 2] << 16 | e2[o2 + 1] << 8 | e2[o2], r2[a2] = h3 >>> 0;
      }
      return r2;
    }, Cn.split32 = function(e2, t) {
      for (var s2 = new Array(4 * e2.length), i2 = 0, n3 = 0; i2 < e2.length; i2++, n3 += 4) {
        var r2 = e2[i2];
        t === "big" ? (s2[n3] = r2 >>> 24, s2[n3 + 1] = r2 >>> 16 & 255, s2[n3 + 2] = r2 >>> 8 & 255, s2[n3 + 3] = 255 & r2) : (s2[n3 + 3] = r2 >>> 24, s2[n3 + 2] = r2 >>> 16 & 255, s2[n3 + 1] = r2 >>> 8 & 255, s2[n3] = 255 & r2);
      }
      return s2;
    }, Cn.rotr32 = function(e2, t) {
      return e2 >>> t | e2 << 32 - t;
    }, Cn.rotl32 = function(e2, t) {
      return e2 << t | e2 >>> 32 - t;
    }, Cn.sum32 = function(e2, t) {
      return e2 + t >>> 0;
    }, Cn.sum32_3 = function(e2, t, s2) {
      return e2 + t + s2 >>> 0;
    }, Cn.sum32_4 = function(e2, t, s2, i2) {
      return e2 + t + s2 + i2 >>> 0;
    }, Cn.sum32_5 = function(e2, t, s2, i2, n3) {
      return e2 + t + s2 + i2 + n3 >>> 0;
    }, Cn.sum64 = function(e2, t, s2, i2) {
      var n3 = e2[t], r2 = i2 + e2[t + 1] >>> 0, a2 = (r2 < i2 ? 1 : 0) + s2 + n3;
      e2[t] = a2 >>> 0, e2[t + 1] = r2;
    }, Cn.sum64_hi = function(e2, t, s2, i2) {
      return (t + i2 >>> 0 < t ? 1 : 0) + e2 + s2 >>> 0;
    }, Cn.sum64_lo = function(e2, t, s2, i2) {
      return t + i2 >>> 0;
    }, Cn.sum64_4_hi = function(e2, t, s2, i2, n3, r2, a2, o2) {
      var h3 = 0, l2 = t;
      return h3 += (l2 = l2 + i2 >>> 0) < t ? 1 : 0, h3 += (l2 = l2 + r2 >>> 0) < r2 ? 1 : 0, e2 + s2 + n3 + a2 + (h3 += (l2 = l2 + o2 >>> 0) < o2 ? 1 : 0) >>> 0;
    }, Cn.sum64_4_lo = function(e2, t, s2, i2, n3, r2, a2, o2) {
      return t + i2 + r2 + o2 >>> 0;
    }, Cn.sum64_5_hi = function(e2, t, s2, i2, n3, r2, a2, o2, h3, l2) {
      var c3 = 0, u2 = t;
      return c3 += (u2 = u2 + i2 >>> 0) < t ? 1 : 0, c3 += (u2 = u2 + r2 >>> 0) < r2 ? 1 : 0, c3 += (u2 = u2 + o2 >>> 0) < o2 ? 1 : 0, e2 + s2 + n3 + a2 + h3 + (c3 += (u2 = u2 + l2 >>> 0) < l2 ? 1 : 0) >>> 0;
    }, Cn.sum64_5_lo = function(e2, t, s2, i2, n3, r2, a2, o2, h3, l2) {
      return t + i2 + r2 + o2 + l2 >>> 0;
    }, Cn.rotr64_hi = function(e2, t, s2) {
      return (t << 32 - s2 | e2 >>> s2) >>> 0;
    }, Cn.rotr64_lo = function(e2, t, s2) {
      return (e2 << 32 - s2 | t >>> s2) >>> 0;
    }, Cn.shr64_hi = function(e2, t, s2) {
      return e2 >>> s2;
    }, Cn.shr64_lo = function(e2, t, s2) {
      return (e2 << 32 - s2 | t >>> s2) >>> 0;
    };
    On = {};
    Vn = Cn;
    Bn = In;
    On.BlockHash = Fn, Fn.prototype.update = function(e2, t) {
      if (e2 = Vn.toArray(e2, t), this.pending ? this.pending = this.pending.concat(e2) : this.pending = e2, this.pendingTotal += e2.length, this.pending.length >= this._delta8) {
        var s2 = (e2 = this.pending).length % this._delta8;
        this.pending = e2.slice(e2.length - s2, e2.length), this.pending.length === 0 && (this.pending = null), e2 = Vn.join32(e2, 0, e2.length - s2, this.endian);
        for (var i2 = 0; i2 < e2.length; i2 += this._delta32)
          this._update(e2, i2, i2 + this._delta32);
      }
      return this;
    }, Fn.prototype.digest = function(e2) {
      return this.update(this._pad()), Bn(this.pending === null), this._digest(e2);
    }, Fn.prototype._pad = function() {
      var e2 = this.pendingTotal, t = this._delta8, s2 = t - (e2 + this.padLength) % t, i2 = new Array(s2 + this.padLength);
      i2[0] = 128;
      for (var n3 = 1; n3 < s2; n3++)
        i2[n3] = 0;
      if (e2 <<= 3, this.endian === "big") {
        for (var r2 = 8; r2 < this.padLength; r2++)
          i2[n3++] = 0;
        i2[n3++] = 0, i2[n3++] = 0, i2[n3++] = 0, i2[n3++] = 0, i2[n3++] = e2 >>> 24 & 255, i2[n3++] = e2 >>> 16 & 255, i2[n3++] = e2 >>> 8 & 255, i2[n3++] = 255 & e2;
      } else
        for (i2[n3++] = 255 & e2, i2[n3++] = e2 >>> 8 & 255, i2[n3++] = e2 >>> 16 & 255, i2[n3++] = e2 >>> 24 & 255, i2[n3++] = 0, i2[n3++] = 0, i2[n3++] = 0, i2[n3++] = 0, r2 = 8; r2 < this.padLength; r2++)
          i2[n3++] = 0;
      return i2;
    };
    zn = {};
    Wn = Cn.rotr32;
    zn.ft_1 = function(e2, t, s2, i2) {
      return e2 === 0 ? Un(t, s2, i2) : e2 === 1 || e2 === 3 ? Gn(t, s2, i2) : e2 === 2 ? jn(t, s2, i2) : void 0;
    }, zn.ch32 = Un, zn.maj32 = jn, zn.p32 = Gn, zn.s0_256 = function(e2) {
      return Wn(e2, 2) ^ Wn(e2, 13) ^ Wn(e2, 22);
    }, zn.s1_256 = function(e2) {
      return Wn(e2, 6) ^ Wn(e2, 11) ^ Wn(e2, 25);
    }, zn.g0_256 = function(e2) {
      return Wn(e2, 7) ^ Wn(e2, 18) ^ e2 >>> 3;
    }, zn.g1_256 = function(e2) {
      return Wn(e2, 17) ^ Wn(e2, 19) ^ e2 >>> 10;
    };
    Hn = Cn;
    qn = On;
    Kn = zn;
    Xn = In;
    Yn = Hn.sum32;
    Qn = Hn.sum32_4;
    Zn = Hn.sum32_5;
    Jn = Kn.ch32;
    er = Kn.maj32;
    tr = Kn.s0_256;
    sr = Kn.s1_256;
    ir = Kn.g0_256;
    nr = Kn.g1_256;
    rr = qn.BlockHash;
    ar = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
    Hn.inherits(or, rr);
    hr = or;
    or.blockSize = 512, or.outSize = 256, or.hmacStrength = 192, or.padLength = 64, or.prototype._update = function(e2, t) {
      for (var s2 = this.W, i2 = 0; i2 < 16; i2++)
        s2[i2] = e2[t + i2];
      for (; i2 < s2.length; i2++)
        s2[i2] = Qn(nr(s2[i2 - 2]), s2[i2 - 7], ir(s2[i2 - 15]), s2[i2 - 16]);
      var n3 = this.h[0], r2 = this.h[1], a2 = this.h[2], o2 = this.h[3], h3 = this.h[4], l2 = this.h[5], c3 = this.h[6], u2 = this.h[7];
      for (Xn(this.k.length === s2.length), i2 = 0; i2 < s2.length; i2++) {
        var d3 = Zn(u2, sr(h3), Jn(h3, l2, c3), this.k[i2], s2[i2]), p2 = Yn(tr(n3), er(n3, r2, a2));
        u2 = c3, c3 = l2, l2 = h3, h3 = Yn(o2, d3), o2 = a2, a2 = r2, r2 = n3, n3 = Yn(d3, p2);
      }
      this.h[0] = Yn(this.h[0], n3), this.h[1] = Yn(this.h[1], r2), this.h[2] = Yn(this.h[2], a2), this.h[3] = Yn(this.h[3], o2), this.h[4] = Yn(this.h[4], h3), this.h[5] = Yn(this.h[5], l2), this.h[6] = Yn(this.h[6], c3), this.h[7] = Yn(this.h[7], u2);
    }, or.prototype._digest = function(e2) {
      return e2 === "hex" ? Hn.toHex32(this.h, "big") : Hn.split32(this.h, "big");
    };
    lr = hr;
    cr = () => lr();
    ur = { amd: fr, cjs: fr, es: pr, iife: fr, system: pr, umd: fr };
    mr = /[\\'\r\n\u2028\u2029]/;
    gr = /(['\r\n\u2028\u2029])/g;
    yr = /\\/g;
    kr = [".js", ".jsx", ".ts", ".tsx"];
    Cr = class {
      constructor(e2, t, s2, i2, n3, r2, a2, o2, h3, l2) {
        this.orderedModules = e2, this.inputOptions = t, this.outputOptions = s2, this.unsetOptions = i2, this.pluginDriver = n3, this.modulesById = r2, this.chunkByModule = a2, this.facadeChunkByModule = o2, this.includedNamespaces = h3, this.manualChunkAlias = l2, this.entryModules = [], this.exportMode = "named", this.facadeModule = null, this.id = null, this.namespaceVariableName = "", this.needsExportsShim = false, this.variableName = "", this.accessedGlobalsByScope = /* @__PURE__ */ new Map(), this.dependencies = /* @__PURE__ */ new Set(), this.dynamicDependencies = /* @__PURE__ */ new Set(), this.dynamicEntryModules = [], this.dynamicName = null, this.exportNamesByVariable = /* @__PURE__ */ new Map(), this.exports = /* @__PURE__ */ new Set(), this.exportsByName = /* @__PURE__ */ new Map(), this.fileName = null, this.implicitEntryModules = [], this.implicitlyLoadedBefore = /* @__PURE__ */ new Set(), this.imports = /* @__PURE__ */ new Set(), this.indentString = void 0, this.isEmpty = true, this.name = null, this.renderedDependencies = null, this.renderedExports = null, this.renderedHash = void 0, this.renderedModuleSources = /* @__PURE__ */ new Map(), this.renderedModules = /* @__PURE__ */ Object.create(null), this.renderedSource = null, this.sortedExportNames = null, this.strictFacade = false, this.usedModules = void 0, this.execIndex = e2.length > 0 ? e2[0].execIndex : 1 / 0;
        const c3 = new Set(e2);
        for (const t2 of e2) {
          t2.namespace.included && h3.add(t2), this.isEmpty && t2.isIncluded() && (this.isEmpty = false), (t2.info.isEntry || s2.preserveModules) && this.entryModules.push(t2);
          for (const e3 of t2.includedDynamicImporters)
            c3.has(e3) || (this.dynamicEntryModules.push(t2), t2.info.syntheticNamedExports && !s2.preserveModules && (h3.add(t2), this.exports.add(t2.namespace)));
          t2.implicitlyLoadedAfter.size > 0 && this.implicitEntryModules.push(t2);
        }
        this.suggestedVariableName = Pe(this.generateVariableName());
      }
      static generateFacade(e2, t, s2, i2, n3, r2, a2, o2, h3, l2) {
        const c3 = new Cr([], e2, t, s2, i2, n3, r2, a2, o2, null);
        c3.assignFacadeName(l2, h3), a2.has(h3) || a2.set(h3, c3);
        for (const e3 of h3.getDependenciesToBeIncluded())
          c3.dependencies.add(e3 instanceof Qi ? r2.get(e3) : e3);
        return !c3.dependencies.has(r2.get(h3)) && h3.info.moduleSideEffects && h3.hasEffects() && c3.dependencies.add(r2.get(h3)), c3.ensureReexportsAreAvailableForModule(h3), c3.facadeModule = h3, c3.strictFacade = true, c3;
      }
      canModuleBeFacade(e2, t) {
        const s2 = e2.getExportNamesByVariable();
        for (const t2 of this.exports)
          if (!s2.has(t2))
            return s2.size === 0 && e2.isUserDefinedEntryPoint && e2.preserveSignature === "strict" && this.unsetOptions.has("preserveEntrySignatures") && this.inputOptions.onwarn({ code: "EMPTY_FACADE", id: e2.id, message: `To preserve the export signature of the entry module "${ie(e2.id)}", an empty facade chunk was created. This often happens when creating a bundle for a web app where chunks are placed in script tags and exports are ignored. In this case it is recommended to set "preserveEntrySignatures: false" to avoid this and reduce the number of chunks. Otherwise if this is intentional, set "preserveEntrySignatures: 'strict'" explicitly to silence this warning.`, url: "https://rollupjs.org/guide/en/#preserveentrysignatures" }), false;
        for (const i2 of t)
          if (!s2.has(i2) && i2.module !== e2)
            return false;
        return true;
      }
      generateExports() {
        this.sortedExportNames = null;
        const e2 = new Set(this.exports);
        if (this.facadeModule !== null && (this.facadeModule.preserveSignature !== false || this.strictFacade)) {
          const t = this.facadeModule.getExportNamesByVariable();
          for (const [s2, i2] of t) {
            this.exportNamesByVariable.set(s2, [...i2]);
            for (const e3 of i2)
              this.exportsByName.set(e3, s2);
            e2.delete(s2);
          }
        }
        this.outputOptions.minifyInternalExports ? function(e3, t, s2) {
          let i2 = 0;
          for (const n3 of e3) {
            let [e4] = n3.name;
            if (t.has(e4))
              do {
                e4 = $t(++i2), e4.charCodeAt(0) === 49 && (i2 += 9 * 64 ** (e4.length - 1), e4 = $t(i2));
              } while (be.has(e4) || t.has(e4));
            t.set(e4, n3), s2.set(n3, [e4]);
          }
        }(e2, this.exportsByName, this.exportNamesByVariable) : function(e3, t, s2) {
          for (const i2 of e3) {
            let e4 = 0, n3 = i2.name;
            for (; t.has(n3); )
              n3 = i2.name + "$" + ++e4;
            t.set(n3, i2), s2.set(i2, [n3]);
          }
        }(e2, this.exportsByName, this.exportNamesByVariable), (this.outputOptions.preserveModules || this.facadeModule && this.facadeModule.info.isEntry) && (this.exportMode = xr(this, this.outputOptions, this.unsetOptions, this.facadeModule.id, this.inputOptions.onwarn));
      }
      generateFacades() {
        var e2;
        const t = [], s2 = /* @__PURE__ */ new Set([...this.entryModules, ...this.implicitEntryModules]), i2 = new Set(this.dynamicEntryModules.map(({ namespace: e3 }) => e3));
        for (const e3 of s2)
          if (e3.preserveSignature)
            for (const t2 of e3.getExportNamesByVariable().keys())
              i2.add(t2);
        for (const e3 of s2) {
          const s3 = Array.from(new Set(e3.chunkNames.filter(({ isUserDefined: e4 }) => e4).map(({ name: e4 }) => e4)), (e4) => ({ name: e4 }));
          if (s3.length === 0 && e3.isUserDefinedEntryPoint && s3.push({}), s3.push(...Array.from(e3.chunkFileNames, (e4) => ({ fileName: e4 }))), s3.length === 0 && s3.push({}), !this.facadeModule) {
            const t2 = e3.preserveSignature === "strict" || e3.preserveSignature === "exports-only" && e3.getExportNamesByVariable().size !== 0;
            (!t2 || this.outputOptions.preserveModules || this.canModuleBeFacade(e3, i2)) && (this.facadeModule = e3, this.facadeChunkByModule.set(e3, this), e3.preserveSignature && (this.strictFacade = t2), this.assignFacadeName(s3.shift(), e3));
          }
          for (const i3 of s3)
            t.push(Cr.generateFacade(this.inputOptions, this.outputOptions, this.unsetOptions, this.pluginDriver, this.modulesById, this.chunkByModule, this.facadeChunkByModule, this.includedNamespaces, e3, i3));
        }
        for (const t2 of this.dynamicEntryModules)
          t2.info.syntheticNamedExports || (!this.facadeModule && this.canModuleBeFacade(t2, i2) ? (this.facadeModule = t2, this.facadeChunkByModule.set(t2, this), this.strictFacade = true, this.dynamicName = Ir(t2)) : this.facadeModule === t2 && !this.strictFacade && this.canModuleBeFacade(t2, i2) ? this.strictFacade = true : ((e2 = this.facadeChunkByModule.get(t2)) === null || e2 === void 0 ? void 0 : e2.strictFacade) || (this.includedNamespaces.add(t2), this.exports.add(t2.namespace)));
        return t;
      }
      generateId(e2, t, s2, i2) {
        if (this.fileName !== null)
          return this.fileName;
        const [n3, r2] = this.facadeModule && this.facadeModule.isUserDefinedEntryPoint ? [t.entryFileNames, "output.entryFileNames"] : [t.chunkFileNames, "output.chunkFileNames"];
        return Pr(Ar(typeof n3 == "function" ? n3(this.getChunkInfo()) : n3, r2, { format: () => t.format, hash: () => i2 ? this.computeContentHashWithDependencies(e2, t, s2) : "[hash]", name: () => this.getChunkName() }), s2);
      }
      generateIdPreserveModules(e2, t, s2, i2) {
        const [{ id: n3 }] = this.orderedModules, r2 = this.outputOptions.sanitizeFileName(n3.split(Nr, 1)[0]);
        let a2;
        const o2 = i2.has("entryFileNames") ? "[name][assetExtname].js" : t.entryFileNames, h3 = typeof o2 == "function" ? o2(this.getChunkInfo()) : o2;
        if (C2(r2)) {
          const s3 = $(r2), i3 = T(r2), n4 = `${s3}/${Ar(h3, "output.entryFileNames", { assetExtname: () => kr.includes(i3) ? "" : i3, ext: () => i3.substring(1), extname: () => i3, format: () => t.format, name: () => this.getChunkName() })}`, { preserveModulesRoot: o3 } = t;
          a2 = o3 && n4.startsWith(o3) ? n4.slice(o3.length).replace(/^[\\/]/, "") : R(e2, n4);
        } else {
          const e3 = T(r2);
          a2 = `_virtual/${Ar(h3, "output.entryFileNames", { assetExtname: () => kr.includes(e3) ? "" : e3, ext: () => e3.substring(1), extname: () => e3, format: () => t.format, name: () => se(r2) })}`;
        }
        return Pr(N(a2), s2);
      }
      getChunkInfo() {
        const e2 = this.facadeModule, t = this.getChunkName.bind(this);
        return { exports: this.getExportNames(), facadeModuleId: e2 && e2.id, isDynamicEntry: this.dynamicEntryModules.length > 0, isEntry: e2 !== null && e2.info.isEntry, isImplicitEntry: this.implicitEntryModules.length > 0, modules: this.renderedModules, get name() {
          return t();
        }, type: "chunk" };
      }
      getChunkInfoWithFileNames() {
        return Object.assign(this.getChunkInfo(), { code: void 0, dynamicImports: Array.from(this.dynamicDependencies, Di), fileName: this.id, implicitlyLoadedBefore: Array.from(this.implicitlyLoadedBefore, Di), importedBindings: this.getImportedBindingsPerDependency(), imports: Array.from(this.dependencies, Di), map: void 0, referencedFiles: this.getReferencedFiles() });
      }
      getChunkName() {
        var e2;
        return (e2 = this.name) !== null && e2 !== void 0 ? e2 : this.name = this.outputOptions.sanitizeFileName(this.getFallbackChunkName());
      }
      getExportNames() {
        var e2;
        return (e2 = this.sortedExportNames) !== null && e2 !== void 0 ? e2 : this.sortedExportNames = Array.from(this.exportsByName.keys()).sort();
      }
      getRenderedHash() {
        if (this.renderedHash)
          return this.renderedHash;
        const e2 = cr(), t = this.pluginDriver.hookReduceValueSync("augmentChunkHash", "", [this.getChunkInfo()], (e3, t2) => (t2 && (e3 += t2), e3));
        return e2.update(t), e2.update(this.renderedSource.toString()), e2.update(this.getExportNames().map((e3) => {
          const t2 = this.exportsByName.get(e3);
          return `${ie(t2.module.id).replace(/\\/g, "/")}:${t2.name}:${e3}`;
        }).join(",")), this.renderedHash = e2.digest("hex");
      }
      getVariableExportName(e2) {
        return this.outputOptions.preserveModules && e2 instanceof Ti ? "*" : this.exportNamesByVariable.get(e2)[0];
      }
      link() {
        this.dependencies = function(e2, t, s2) {
          const i2 = [], n3 = /* @__PURE__ */ new Set();
          for (let r3 = t.length - 1; r3 >= 0; r3--) {
            const a2 = t[r3];
            if (!n3.has(a2)) {
              const t2 = [];
              br(a2, t2, n3, e2, s2), i2.unshift(t2);
            }
          }
          const r2 = /* @__PURE__ */ new Set();
          for (const e3 of i2)
            for (const t2 of e3)
              r2.add(t2);
          return r2;
        }(this, this.orderedModules, this.chunkByModule);
        for (const e2 of this.orderedModules)
          this.addDependenciesToChunk(e2.dynamicDependencies, this.dynamicDependencies), this.addDependenciesToChunk(e2.implicitlyLoadedBefore, this.implicitlyLoadedBefore), this.setUpChunkImportsAndExportsForModule(e2);
      }
      preRender(e2, t, s2) {
        const { _: i2, getPropertyAccess: n3, n: r2 } = s2, a2 = new v({ separator: `${r2}${r2}` });
        this.usedModules = [], this.indentString = function(e3, t2) {
          if (t2.indent !== true)
            return t2.indent;
          for (const t3 of e3) {
            const e4 = vr(t3.originalCode);
            if (e4 !== null)
              return e4;
          }
          return "	";
        }(this.orderedModules, e2);
        const o2 = { dynamicImportFunction: e2.dynamicImportFunction, exportNamesByVariable: this.exportNamesByVariable, format: e2.format, freeze: e2.freeze, indent: this.indentString, namespaceToStringTag: e2.namespaceToStringTag, outputPluginDriver: this.pluginDriver, snippets: s2 };
        if (e2.hoistTransitiveImports && !this.outputOptions.preserveModules && this.facadeModule !== null)
          for (const e3 of this.dependencies)
            e3 instanceof Cr && this.inlineChunkDependencies(e3);
        this.prepareModulesForRendering(s2), this.setIdentifierRenderResolutions(e2);
        let h3 = "";
        const l2 = this.renderedModules;
        for (const t2 of this.orderedModules) {
          let s3 = 0;
          if (t2.isIncluded() || this.includedNamespaces.has(t2)) {
            const i4 = t2.render(o2).trim();
            s3 = i4.length(), s3 && (e2.compact && i4.lastLine().includes("//") && i4.append("\n"), this.renderedModuleSources.set(t2, i4), a2.addSource(i4), this.usedModules.push(t2));
            const n5 = t2.namespace;
            if (this.includedNamespaces.has(t2) && !this.outputOptions.preserveModules) {
              const e3 = n5.renderBlock(o2);
              n5.renderFirst() ? h3 += r2 + e3 : a2.addSource(new b(e3));
            }
          }
          const { renderedExports: i3, removedExports: n4 } = t2.getRenderedExports(), { renderedModuleSources: c3 } = this;
          l2[t2.id] = { get code() {
            var e3, s4;
            return (s4 = (e3 = c3.get(t2)) === null || e3 === void 0 ? void 0 : e3.toString()) !== null && s4 !== void 0 ? s4 : null;
          }, originalLength: t2.originalCode.length, removedExports: n4, renderedExports: i3, renderedLength: s3 };
        }
        if (h3 && a2.prepend(h3 + r2 + r2), this.needsExportsShim && a2.prepend(`${r2}${s2.cnst} _missingExportShim${i2}=${i2}void 0;${r2}${r2}`), e2.compact ? this.renderedSource = a2 : this.renderedSource = a2.trim(), this.renderedHash = void 0, this.isEmpty && this.getExportNames().length === 0 && this.dependencies.size === 0) {
          const e3 = this.getChunkName();
          this.inputOptions.onwarn({ chunkName: e3, code: "EMPTY_BUNDLE", message: `Generated an empty chunk: "${e3}"` });
        }
        this.setExternalRenderPaths(e2, t), this.renderedDependencies = this.getChunkDependencyDeclarations(e2, n3), this.renderedExports = this.exportMode === "none" ? [] : this.getChunkExportDeclarations(e2.format, n3);
      }
      async render(e2, t, s2, i2) {
        ji("render format", 2);
        const n3 = e2.format, r2 = Sn[n3];
        e2.dynamicImportFunction && n3 !== "es" && this.inputOptions.onwarn(de("output.dynamicImportFunction", "outputdynamicImportFunction", 'this option is ignored for formats other than "es"'));
        for (const e3 of this.dependencies) {
          const t2 = this.renderedDependencies.get(e3);
          if (e3 instanceof ke) {
            const s3 = e3.renderPath;
            t2.id = Er(e3.renormalizeRenderPath ? ae(this.id, s3, false, false) : s3);
          } else
            t2.namedExportsMode = e3.exportMode !== "default", t2.id = Er(ae(this.id, e3.id, false, true));
        }
        this.finaliseDynamicImports(e2, i2), this.finaliseImportMetas(n3, i2);
        const a2 = this.renderedExports.length !== 0 || [...this.renderedDependencies.values()].some((e3) => e3.reexports && e3.reexports.length !== 0);
        let o2 = null;
        const h3 = /* @__PURE__ */ new Set();
        for (const e3 of this.orderedModules) {
          e3.usesTopLevelAwait && (o2 = e3.id);
          const t2 = this.accessedGlobalsByScope.get(e3.scope);
          if (t2)
            for (const e4 of t2)
              h3.add(e4);
        }
        if (o2 !== null && n3 !== "es" && n3 !== "system")
          return oe({ code: "INVALID_TLA_FORMAT", id: o2, message: `Module format ${n3} does not support top-level await. Use the "es" or "system" output formats rather.` });
        if (!this.id)
          throw new Error("Internal Error: expecting chunk id");
        const c3 = r2(this.renderedSource, { accessedGlobals: h3, dependencies: [...this.renderedDependencies.values()], exports: this.renderedExports, hasExports: a2, id: this.id, indent: this.indentString, intro: t.intro, isEntryFacade: this.outputOptions.preserveModules || this.facadeModule !== null && this.facadeModule.info.isEntry, isModuleFacade: this.facadeModule !== null, namedExportsMode: this.exportMode !== "default", outro: t.outro, snippets: i2, usesTopLevelAwait: o2 !== null, warn: this.inputOptions.onwarn }, e2);
        t.banner && c3.prepend(t.banner), t.footer && c3.append(t.footer);
        const u2 = c3.toString();
        Gi("render format", 2);
        let d3 = null;
        const p2 = [];
        let f2 = await function({ code: e3, options: t2, outputPluginDriver: s3, renderChunk: i3, sourcemapChain: n4 }) {
          return s3.hookReduceArg0("renderChunk", [e3, i3, t2], (e4, t3, s4) => {
            if (t3 == null)
              return e4;
            if (typeof t3 == "string" && (t3 = { code: t3, map: void 0 }), t3.map !== null) {
              const e5 = Sr(t3.map);
              n4.push(e5 || { missing: true, plugin: s4.name });
            }
            return t3.code;
          });
        }({ code: u2, options: e2, outputPluginDriver: this.pluginDriver, renderChunk: s2, sourcemapChain: p2 });
        if (e2.sourcemap) {
          let t2;
          ji("sourcemap", 2), t2 = e2.file ? M(e2.sourcemapFile || e2.file) : e2.dir ? M(e2.dir, this.id) : M(this.id);
          const s3 = c3.generateDecodedMap({});
          d3 = function(e3, t3, s4, i3, n4, r3) {
            const a3 = kn(r3), o3 = s4.filter((e4) => !e4.excludeFromSourcemap).map((e4) => wn(e4.id, e4.originalCode, e4.originalSourcemap, e4.sourcemapChain, a3)), h4 = new Pn(t3, o3), c4 = i3.reduce(a3, h4);
            let { sources: u3, sourcesContent: d4, names: p3, mappings: f3 } = c4.traceMappings();
            if (e3) {
              const t4 = $(e3);
              u3 = u3.map((e4) => R(t4, e4)), e3 = _(e3);
            }
            return d4 = n4 ? null : d4, new l({ file: e3, mappings: f3, names: p3, sources: u3, sourcesContent: d4 });
          }(t2, s3, this.usedModules, p2, e2.sourcemapExcludeSources, this.inputOptions.onwarn), d3.sources = d3.sources.map((s4) => {
            const { sourcemapPathTransform: i3 } = e2;
            if (i3) {
              const e3 = i3(s4, `${t2}.map`);
              return typeof e3 != "string" && oe(ye("sourcemapPathTransform function must return a string.")), e3;
            }
            return s4;
          }).map(N), Gi("sourcemap", 2);
        }
        return e2.compact || f2[f2.length - 1] === "\n" || (f2 += "\n"), { code: f2, map: d3 };
      }
      addDependenciesToChunk(e2, t) {
        for (const s2 of e2)
          if (s2 instanceof Qi) {
            const e3 = this.chunkByModule.get(s2);
            e3 && e3 !== this && t.add(e3);
          } else
            t.add(s2);
      }
      assignFacadeName({ fileName: e2, name: t }, s2) {
        e2 ? this.fileName = e2 : this.name = this.outputOptions.sanitizeFileName(t || Ir(s2));
      }
      checkCircularDependencyImport(e2, t) {
        const s2 = e2.module;
        if (s2 instanceof Qi) {
          const o2 = this.chunkByModule.get(s2);
          let h3;
          do {
            if (h3 = t.alternativeReexportModules.get(e2), h3) {
              const l2 = this.chunkByModule.get(h3);
              l2 && l2 !== o2 && this.inputOptions.onwarn((i2 = s2.getExportNamesByVariable().get(e2)[0], n3 = s2.id, r2 = h3.id, a2 = t.id, { code: le.CYCLIC_CROSS_CHUNK_REEXPORT, exporter: n3, importer: a2, message: `Export "${i2}" of module ${ie(n3)} was reexported through module ${ie(r2)} while both modules are dependencies of each other and will end up in different chunks by current Rollup settings. This scenario is not well supported at the moment as it will produce a circular dependency between chunks and will likely lead to broken execution order.
Either change the import in ${ie(a2)} to point directly to the exporting module or do not use "preserveModules" to ensure these modules end up in the same chunk.`, reexporter: r2 })), t = h3;
            }
          } while (h3);
        }
        var i2, n3, r2, a2;
      }
      computeContentHashWithDependencies(e2, t, s2) {
        const i2 = cr();
        i2.update([e2.intro, e2.outro, e2.banner, e2.footer].join(":")), i2.update(t.format);
        const n3 = /* @__PURE__ */ new Set([this]);
        for (const r2 of n3)
          if (r2 instanceof ke ? i2.update(`:${r2.renderPath}`) : (i2.update(r2.getRenderedHash()), i2.update(r2.generateId(e2, t, s2, false))), !(r2 instanceof ke))
            for (const e3 of [...r2.dependencies, ...r2.dynamicDependencies])
              n3.add(e3);
        return i2.digest("hex").substr(0, 8);
      }
      ensureReexportsAreAvailableForModule(e2) {
        const t = e2.getExportNamesByVariable();
        for (const s2 of t.keys()) {
          const t2 = s2 instanceof Ri, i2 = t2 ? s2.getBaseVariable() : s2;
          if (!(i2 instanceof Ti && this.outputOptions.preserveModules)) {
            this.checkCircularDependencyImport(i2, e2);
            const s3 = i2.module;
            if (s3 instanceof Qi) {
              const e3 = this.chunkByModule.get(s3);
              e3 && e3 !== this && (e3.exports.add(i2), t2 && this.imports.add(i2));
            }
          }
        }
      }
      finaliseDynamicImports(e2, t) {
        const s2 = e2.format === "amd";
        for (const [e3, i2] of this.renderedModuleSources)
          for (const { node: n3, resolution: r2 } of e3.dynamicImports) {
            const e4 = this.chunkByModule.get(r2), a2 = this.facadeChunkByModule.get(r2);
            if (!r2 || !n3.included || e4 === this)
              continue;
            const o2 = r2 instanceof Qi ? `'${Er(ae(this.id, (a2 || e4).id, s2, true))}'` : r2 instanceof ke ? `'${Er(r2.renormalizeRenderPath ? ae(this.id, r2.renderPath, s2, false) : r2.renderPath)}'` : r2;
            n3.renderFinalResolution(i2, o2, r2 instanceof Qi && !(a2 == null ? void 0 : a2.strictFacade) && e4.exportNamesByVariable.get(r2.namespace)[0], t);
          }
      }
      finaliseImportMetas(e2, t) {
        for (const [s2, i2] of this.renderedModuleSources)
          for (const n3 of s2.importMetas)
            n3.renderFinalMechanism(i2, this.id, e2, t, this.pluginDriver);
      }
      generateVariableName() {
        if (this.manualChunkAlias)
          return this.manualChunkAlias;
        const e2 = this.entryModules[0] || this.implicitEntryModules[0] || this.dynamicEntryModules[0] || this.orderedModules[this.orderedModules.length - 1];
        return e2 ? Ir(e2) : "chunk";
      }
      getChunkDependencyDeclarations(e2, t) {
        const s2 = this.getImportSpecifiers(t), i2 = this.getReexportSpecifiers(), n3 = /* @__PURE__ */ new Map();
        for (const t2 of this.dependencies) {
          const r2 = s2.get(t2) || null, a2 = i2.get(t2) || null, o2 = t2 instanceof ke || t2.exportMode !== "default";
          n3.set(t2, { defaultVariableName: t2.defaultVariableName, globalName: t2 instanceof ke && (e2.format === "umd" || e2.format === "iife") && wr(t2, e2.globals, (r2 || a2) !== null, this.inputOptions.onwarn), id: void 0, imports: r2, isChunk: t2 instanceof Cr, name: t2.variableName, namedExportsMode: o2, namespaceVariableName: t2.namespaceVariableName, reexports: a2 });
        }
        return n3;
      }
      getChunkExportDeclarations(e2, t) {
        const s2 = [];
        for (const i2 of this.getExportNames()) {
          if (i2[0] === "*")
            continue;
          const n3 = this.exportsByName.get(i2);
          if (!(n3 instanceof Ri)) {
            const e3 = n3.module;
            if (e3 && this.chunkByModule.get(e3) !== this)
              continue;
          }
          let r2 = null, a2 = false, o2 = n3.getName(t);
          if (n3 instanceof _t) {
            for (const e3 of n3.declarations)
              if (e3.parent instanceof Os || e3 instanceof Vs && e3.declaration instanceof Os) {
                a2 = true;
                break;
              }
          } else
            n3 instanceof Ri && (r2 = o2, e2 === "es" && (o2 = n3.renderName));
          s2.push({ exported: i2, expression: r2, hoisted: a2, local: o2 });
        }
        return s2;
      }
      getDependenciesToBeDeconflicted(e2, t, s2) {
        const i2 = /* @__PURE__ */ new Set(), n3 = /* @__PURE__ */ new Set(), r2 = /* @__PURE__ */ new Set();
        for (const t2 of [...this.exportNamesByVariable.keys(), ...this.imports])
          if (e2 || t2.isNamespace) {
            const a2 = t2.module;
            if (a2 instanceof ke)
              i2.add(a2), e2 && (t2.name === "default" ? js[String(s2(a2.id))] && n3.add(a2) : t2.name === "*" && Hs[String(s2(a2.id))] && r2.add(a2));
            else {
              const s3 = this.chunkByModule.get(a2);
              s3 !== this && (i2.add(s3), e2 && s3.exportMode === "default" && t2.isNamespace && r2.add(s3));
            }
          }
        if (t)
          for (const e3 of this.dependencies)
            i2.add(e3);
        return { deconflictedDefault: n3, deconflictedNamespace: r2, dependencies: i2 };
      }
      getFallbackChunkName() {
        return this.manualChunkAlias ? this.manualChunkAlias : this.dynamicName ? this.dynamicName : this.fileName ? se(this.fileName) : se(this.orderedModules[this.orderedModules.length - 1].id);
      }
      getImportSpecifiers(e2) {
        const { interop: t } = this.outputOptions, s2 = /* @__PURE__ */ new Map();
        for (const i2 of this.imports) {
          const n3 = i2.module;
          let r2, a2;
          if (n3 instanceof ke) {
            if (r2 = n3, a2 = i2.name, a2 !== "default" && a2 !== "*" && t(n3.id) === "defaultOnly")
              return oe(me(n3.id, a2, false));
          } else
            r2 = this.chunkByModule.get(n3), a2 = r2.getVariableExportName(i2);
          D(s2, r2, () => []).push({ imported: a2, local: i2.getName(e2) });
        }
        return s2;
      }
      getImportedBindingsPerDependency() {
        const e2 = {};
        for (const [t, s2] of this.renderedDependencies) {
          const i2 = /* @__PURE__ */ new Set();
          if (s2.imports)
            for (const { imported: e3 } of s2.imports)
              i2.add(e3);
          if (s2.reexports)
            for (const { imported: e3 } of s2.reexports)
              i2.add(e3);
          e2[t.id] = [...i2];
        }
        return e2;
      }
      getReexportSpecifiers() {
        const { externalLiveBindings: e2, interop: t } = this.outputOptions, s2 = /* @__PURE__ */ new Map();
        for (let i2 of this.getExportNames()) {
          let n3, r2, a2 = false;
          if (i2[0] === "*") {
            const s3 = i2.substring(1);
            t(s3) === "defaultOnly" && this.inputOptions.onwarn(ge(s3)), a2 = e2, n3 = this.modulesById.get(s3), r2 = i2 = "*";
          } else {
            const s3 = this.exportsByName.get(i2);
            if (s3 instanceof Ri)
              continue;
            const o2 = s3.module;
            if (o2 instanceof Qi) {
              if (n3 = this.chunkByModule.get(o2), n3 === this)
                continue;
              r2 = n3.getVariableExportName(s3), a2 = s3.isReassigned;
            } else {
              if (n3 = o2, r2 = s3.name, r2 !== "default" && r2 !== "*" && t(o2.id) === "defaultOnly")
                return oe(me(o2.id, r2, true));
              a2 = e2 && (r2 !== "default" || Gs(String(t(o2.id)), true));
            }
          }
          D(s2, n3, () => []).push({ imported: r2, needsLiveBinding: a2, reexported: i2 });
        }
        return s2;
      }
      getReferencedFiles() {
        const e2 = [];
        for (const t of this.orderedModules)
          for (const s2 of t.importMetas) {
            const t2 = s2.getReferencedFileName(this.pluginDriver);
            t2 && e2.push(t2);
          }
        return e2;
      }
      inlineChunkDependencies(e2) {
        for (const t of e2.dependencies)
          this.dependencies.has(t) || (this.dependencies.add(t), t instanceof Cr && this.inlineChunkDependencies(t));
      }
      prepareModulesForRendering(e2) {
        var t;
        const s2 = this.accessedGlobalsByScope;
        for (const i2 of this.orderedModules) {
          for (const { node: n3, resolution: r2 } of i2.dynamicImports)
            if (n3.included)
              if (r2 instanceof Qi) {
                const i3 = this.chunkByModule.get(r2);
                i3 === this ? n3.setInternalResolution(r2.namespace) : n3.setExternalResolution(((t = this.facadeChunkByModule.get(r2)) === null || t === void 0 ? void 0 : t.exportMode) || i3.exportMode, r2, this.outputOptions, e2, this.pluginDriver, s2);
              } else
                n3.setExternalResolution("external", r2, this.outputOptions, e2, this.pluginDriver, s2);
          for (const e3 of i2.importMetas)
            e3.addAccessedGlobals(this.outputOptions.format, s2);
          this.includedNamespaces.has(i2) && !this.outputOptions.preserveModules && i2.namespace.prepare(s2);
        }
      }
      setExternalRenderPaths(e2, t) {
        for (const s2 of [...this.dependencies, ...this.dynamicDependencies])
          s2 instanceof ke && s2.setRenderPath(e2, t);
      }
      setIdentifierRenderResolutions({ format: e2, interop: t, namespaceToStringTag: s2 }) {
        const i2 = /* @__PURE__ */ new Set();
        for (const t2 of this.getExportNames()) {
          const s3 = this.exportsByName.get(t2);
          e2 !== "es" && e2 !== "system" && s3.isReassigned && !s3.isId ? s3.setRenderNames("exports", t2) : s3 instanceof Ri ? i2.add(s3) : s3.setRenderNames(null, null);
        }
        for (const e3 of this.orderedModules)
          if (e3.needsExportShim) {
            this.needsExportsShim = true;
            break;
          }
        const n3 = /* @__PURE__ */ new Set(["Object", "Promise"]);
        switch (this.needsExportsShim && n3.add("_missingExportShim"), s2 && n3.add("Symbol"), e2) {
          case "system":
            n3.add("module").add("exports");
            break;
          case "es":
            break;
          case "cjs":
            n3.add("module").add("require").add("__filename").add("__dirname");
          default:
            n3.add("exports");
            for (const e3 of oi)
              n3.add(e3);
        }
        dr(this.orderedModules, this.getDependenciesToBeDeconflicted(e2 !== "es" && e2 !== "system", e2 === "amd" || e2 === "umd" || e2 === "iife", t), this.imports, n3, e2, t, this.outputOptions.preserveModules, this.outputOptions.externalLiveBindings, this.chunkByModule, i2, this.exportNamesByVariable, this.accessedGlobalsByScope, this.includedNamespaces);
      }
      setUpChunkImportsAndExportsForModule(e2) {
        const t = new Set(e2.imports);
        if (!this.outputOptions.preserveModules && this.includedNamespaces.has(e2)) {
          const s2 = e2.namespace.getMemberVariables();
          for (const e3 of Object.values(s2))
            t.add(e3);
        }
        for (let s2 of t) {
          s2 instanceof ki && (s2 = s2.getOriginalVariable()), s2 instanceof Ri && (s2 = s2.getBaseVariable());
          const t2 = this.chunkByModule.get(s2.module);
          t2 !== this && (this.imports.add(s2), !(s2 instanceof Ti && this.outputOptions.preserveModules) && s2.module instanceof Qi && (t2.exports.add(s2), this.checkCircularDependencyImport(s2, e2)));
        }
        (this.includedNamespaces.has(e2) || e2.info.isEntry && e2.preserveSignature !== false || e2.includedDynamicImporters.some((e3) => this.chunkByModule.get(e3) !== this)) && this.ensureReexportsAreAvailableForModule(e2);
        for (const { node: t2, resolution: s2 } of e2.dynamicImports)
          t2.included && s2 instanceof Qi && this.chunkByModule.get(s2) === this && !this.includedNamespaces.has(s2) && (this.includedNamespaces.add(s2), this.ensureReexportsAreAvailableForModule(s2));
      }
    };
    Nr = /[?#]/;
    $r = { type: "placeholder" };
    Dr = class {
      constructor(e2, t, s2) {
        this.graph = e2, this.options = t, this.bundle = null, this.facadeChunkByModule = null, this.outputOptions = null, this.assertAssetsFinalized = () => {
          for (const [t2, s3] of this.filesByReferenceId)
            if (s3.type === "asset" && typeof s3.fileName != "string")
              return oe((e3 = s3.name || t2, { code: le.ASSET_SOURCE_MISSING, message: `Plugin error creating asset "${e3}" - no asset source set.` }));
          var e3;
        }, this.emitFile = (e3) => function(e4) {
          return Boolean(e4 && (e4.type === "asset" || e4.type === "chunk"));
        }(e3) ? function(e4) {
          const t2 = e4.fileName || e4.name;
          return !t2 || typeof t2 == "string" && !ne(t2);
        }(e3) ? e3.type === "chunk" ? this.emitChunk(e3) : this.emitAsset(e3) : oe(ye(`The "fileName" or "name" properties of emitted files must be strings that are neither absolute nor relative paths, received "${e3.fileName || e3.name}".`)) : oe(ye(`Emitted files must be of type "asset" or "chunk", received "${e3 && e3.type}".`)), this.getFileName = (e3) => {
          const t2 = this.filesByReferenceId.get(e3);
          return t2 ? t2.type === "chunk" ? Mr(t2, this.facadeChunkByModule) : Rr(t2, e3) : oe((s3 = e3, { code: le.FILE_NOT_FOUND, message: `Plugin error - Unable to get file name for unknown file "${s3}".` }));
          var s3;
        }, this.setAssetSource = (e3, t2) => {
          const s3 = this.filesByReferenceId.get(e3);
          if (!s3)
            return oe((i2 = e3, { code: le.ASSET_NOT_FOUND, message: `Plugin error - Unable to set the source for unknown asset "${i2}".` }));
          var i2, n3;
          if (s3.type !== "asset")
            return oe(ye(`Asset sources can only be set for emitted assets but "${e3}" is an emitted chunk.`));
          if (s3.source !== void 0)
            return oe((n3 = s3.name || e3, { code: le.ASSET_SOURCE_ALREADY_SET, message: `Unable to set the source for asset "${n3}", source already set.` }));
          const r2 = Tr(t2, s3, e3);
          this.bundle ? this.finalizeAsset(s3, r2, e3, this.bundle) : s3.source = r2;
        }, this.setOutputBundle = (e3, t2, s3) => {
          this.outputOptions = t2, this.bundle = e3, this.facadeChunkByModule = s3;
          for (const e4 of this.filesByReferenceId.values())
            e4.fileName && _r(e4.fileName, this.bundle, this.options.onwarn);
          for (const [e4, t3] of this.filesByReferenceId)
            t3.type === "asset" && t3.source !== void 0 && this.finalizeAsset(t3, t3.source, e4, this.bundle);
        }, this.filesByReferenceId = s2 ? new Map(s2.filesByReferenceId) : /* @__PURE__ */ new Map();
      }
      assignReferenceId(e2, t) {
        let s2;
        do {
          s2 = cr().update(s2 || t).digest("hex").substring(0, 8);
        } while (this.filesByReferenceId.has(s2));
        return this.filesByReferenceId.set(s2, e2), s2;
      }
      emitAsset(e2) {
        const t = e2.source !== void 0 ? Tr(e2.source, e2, null) : void 0, s2 = { fileName: e2.fileName, name: e2.name, source: t, type: "asset" }, i2 = this.assignReferenceId(s2, e2.fileName || e2.name || e2.type);
        return this.bundle && (e2.fileName && _r(e2.fileName, this.bundle, this.options.onwarn), t !== void 0 && this.finalizeAsset(s2, t, i2, this.bundle)), i2;
      }
      emitChunk(e2) {
        if (this.graph.phase > Mi.LOAD_AND_PARSE)
          return oe({ code: le.INVALID_ROLLUP_PHASE, message: "Cannot emit chunks after module loading has finished." });
        if (typeof e2.id != "string")
          return oe(ye(`Emitted chunks need to have a valid string id, received "${e2.id}"`));
        const t = { fileName: e2.fileName, module: null, name: e2.name || e2.id, type: "chunk" };
        return this.graph.moduleLoader.emitChunk(e2).then((e3) => t.module = e3).catch(() => {
        }), this.assignReferenceId(t, e2.id);
      }
      finalizeAsset(e2, t, s2, i2) {
        const n3 = e2.fileName || function(e3, t2) {
          for (const [s3, i3] of Object.entries(e3))
            if (i3.type === "asset" && Lr(t2, i3.source))
              return s3;
          return null;
        }(i2, t) || function(e3, t2, s3, i3) {
          const n4 = s3.sanitizeFileName(e3 || "asset");
          return Pr(Ar(typeof s3.assetFileNames == "function" ? s3.assetFileNames({ name: e3, source: t2, type: "asset" }) : s3.assetFileNames, "output.assetFileNames", { ext: () => T(n4).substring(1), extname: () => T(n4), hash: () => cr().update(n4).update(":").update(t2).digest("hex").substring(0, 8), name: () => n4.substring(0, n4.length - T(n4).length) }), i3);
        }(e2.name, t, this.outputOptions, i2), r2 = __spreadProps2(__spreadValues2({}, e2), { fileName: n3, source: t });
        this.filesByReferenceId.set(s2, r2);
        const { options: a2 } = this;
        i2[n3] = { fileName: n3, get isAsset() {
          return xe(`Accessing "isAsset" on files in the bundle is deprecated, please use "type === 'asset'" instead`, true, a2), true;
        }, name: e2.name, source: t, type: "asset" };
      }
    };
    Or = (e2, t) => t ? `${e2}
${t}` : e2;
    Vr = (e2, t) => t ? `${e2}

${t}` : e2;
    zr = (e2, t) => e2.execIndex > t.execIndex ? 1 : -1;
    Ur = (e2, t) => t ? `(${e2})` : e2;
    jr = /^(?!\d)[\w$]+$/;
    Gr = class {
      constructor(e2, t, s2, i2, n3) {
        this.outputOptions = e2, this.unsetOptions = t, this.inputOptions = s2, this.pluginDriver = i2, this.graph = n3, this.facadeChunkByModule = /* @__PURE__ */ new Map(), this.includedNamespaces = /* @__PURE__ */ new Set();
      }
      async generate(e2) {
        ji("GENERATE", 1);
        const t = /* @__PURE__ */ Object.create(null);
        this.pluginDriver.setOutputBundle(t, this.outputOptions, this.facadeChunkByModule);
        try {
          await this.pluginDriver.hookParallel("renderStart", [this.outputOptions, this.inputOptions]), ji("generate chunks", 2);
          const e3 = await this.generateChunks();
          e3.length > 1 && function(e4, t2) {
            if (e4.format === "umd" || e4.format === "iife")
              return oe(de("output.format", "outputformat", "UMD and IIFE output formats are not supported for code-splitting builds", e4.format));
            if (typeof e4.file == "string")
              return oe(de("output.file", "outputdir", 'when building multiple chunks, the "output.dir" option must be used, not "output.file". To inline dynamic imports, set the "inlineDynamicImports" option'));
            if (e4.sourcemapFile)
              return oe(de("output.sourcemapFile", "outputsourcemapfile", '"output.sourcemapFile" is only supported for single-file builds'));
            !e4.amd.autoId && e4.amd.id && t2(de("output.amd.id", "outputamd", 'this option is only properly supported for single-file builds. Use "output.amd.autoId" and "output.amd.basePath" instead'));
          }(this.outputOptions, this.inputOptions.onwarn);
          const s2 = function(e4) {
            if (e4.length === 0)
              return "/";
            if (e4.length === 1)
              return $(e4[0]);
            const t2 = e4.slice(1).reduce((e5, t3) => {
              const s3 = t3.split(/\/+|\\+/);
              let i3;
              for (i3 = 0; e5[i3] === s3[i3] && i3 < Math.min(e5.length, s3.length); i3++)
                ;
              return e5.slice(0, i3);
            }, e4[0].split(/\/+|\\+/));
            return t2.length > 1 ? t2.join("/") : "/";
          }(function(e4) {
            const t2 = [];
            for (const s3 of e4)
              for (const e5 of s3.entryModules)
                C2(e5.id) && t2.push(e5.id);
            return t2;
          }(e3));
          Gi("generate chunks", 2), ji("render modules", 2);
          const i2 = await async function(e4, t2) {
            try {
              let [s3, i3, n4, r2] = await Promise.all([t2.hookReduceValue("banner", e4.banner(), [], Or), t2.hookReduceValue("footer", e4.footer(), [], Or), t2.hookReduceValue("intro", e4.intro(), [], Vr), t2.hookReduceValue("outro", e4.outro(), [], Vr)]);
              return n4 && (n4 += "\n\n"), r2 && (r2 = `

${r2}`), s3.length && (s3 += "\n"), i3.length && (i3 = "\n" + i3), { banner: s3, footer: i3, intro: n4, outro: r2 };
            } catch (e5) {
              return oe({ code: "ADDON_ERROR", message: `Could not retrieve ${e5.hook}. Check configuration of plugin ${e5.plugin}.
	Error Message: ${e5.message}` });
            }
          }(this.outputOptions, this.pluginDriver), n3 = function({ compact: e4, generatedCode: { arrowFunctions: t2, constBindings: s3, objectShorthand: i3, reservedNamesAsProps: n4 } }) {
            const { _: r2, n: a2, s: o2 } = e4 ? { _: "", n: "", s: "" } : { _: " ", n: "\n", s: ";" }, h3 = s3 ? "const" : "var", l2 = (e5, { isAsync: t3, name: s4 }) => `${t3 ? "async " : ""}function${s4 ? ` ${s4}` : ""}${r2}(${e5.join(`,${r2}`)})${r2}`, c3 = t2 ? (e5, { isAsync: t3, name: s4 }) => {
              const i4 = e5.length === 1;
              return `${s4 ? `${h3} ${s4}${r2}=${r2}` : ""}${t3 ? `async${i4 ? " " : r2}` : ""}${i4 ? e5[0] : `(${e5.join(`,${r2}`)})`}${r2}=>${r2}`;
            } : l2, u2 = (e5, { functionReturn: s4, lineBreakIndent: i4, name: n5 }) => [`${c3(e5, { isAsync: false, name: n5 })}${t2 ? i4 ? `${a2}${i4.base}${i4.t}` : "" : `{${i4 ? `${a2}${i4.base}${i4.t}` : r2}${s4 ? "return " : ""}`}`, t2 ? `${n5 ? ";" : ""}${i4 ? `${a2}${i4.base}` : ""}` : `${o2}${i4 ? `${a2}${i4.base}` : r2}}`], d3 = n4 ? (e5) => jr.test(e5) : (e5) => !be.has(e5) && jr.test(e5);
            return { _: r2, cnst: h3, getDirectReturnFunction: u2, getDirectReturnIifeLeft: (e5, s4, { needsArrowReturnParens: i4, needsWrappedFunction: n5 }) => {
              const [r3, a3] = u2(e5, { functionReturn: true, lineBreakIndent: null, name: null });
              return `${Ur(`${r3}${Ur(s4, t2 && i4)}${a3}`, t2 || n5)}(`;
            }, getFunctionIntro: c3, getNonArrowFunctionIntro: l2, getObject(e5, { lineBreakIndent: t3 }) {
              const s4 = t3 ? `${a2}${t3.base}${t3.t}` : r2;
              return `{${e5.map(([e6, t4]) => {
                if (e6 === null)
                  return `${s4}${t4}`;
                const n5 = !d3(e6);
                return e6 === t4 && i3 && !n5 ? s4 + e6 : `${s4}${n5 ? `'${e6}'` : e6}:${r2}${t4}`;
              }).join(",")}${e5.length === 0 ? "" : t3 ? `${a2}${t3.base}` : r2}}`;
            }, getPropertyAccess: (e5) => d3(e5) ? `.${e5}` : `[${JSON.stringify(e5)}]`, n: a2, s: o2 };
          }(this.outputOptions);
          this.prerenderChunks(e3, s2, n3), Gi("render modules", 2), await this.addFinalizedChunksToBundle(e3, s2, i2, t, n3);
        } catch (e3) {
          throw await this.pluginDriver.hookParallel("renderError", [e3]), e3;
        }
        return await this.pluginDriver.hookSeq("generateBundle", [this.outputOptions, t, e2]), this.finaliseAssets(t), Gi("GENERATE", 1), t;
      }
      async addFinalizedChunksToBundle(e2, t, s2, i2, n3) {
        this.assignChunkIds(e2, t, s2, i2);
        for (const t2 of e2)
          i2[t2.id] = t2.getChunkInfoWithFileNames();
        await Promise.all(e2.map(async (e3) => {
          const t2 = i2[e3.id];
          Object.assign(t2, await e3.render(this.outputOptions, s2, t2, n3));
        }));
      }
      async addManualChunks(e2) {
        const t = /* @__PURE__ */ new Map(), s2 = await Promise.all(Object.entries(e2).map(async ([e3, t2]) => ({ alias: e3, entries: await this.graph.moduleLoader.addAdditionalModules(t2) })));
        for (const { alias: e3, entries: i2 } of s2)
          for (const s3 of i2)
            qr(e3, s3, t);
        return t;
      }
      assignChunkIds(e2, t, s2, i2) {
        const n3 = [], r2 = [];
        for (const t2 of e2)
          (t2.facadeModule && t2.facadeModule.isUserDefinedEntryPoint ? n3 : r2).push(t2);
        const a2 = n3.concat(r2);
        for (const e3 of a2)
          this.outputOptions.file ? e3.id = _(this.outputOptions.file) : this.outputOptions.preserveModules ? e3.id = e3.generateIdPreserveModules(t, this.outputOptions, i2, this.unsetOptions) : e3.id = e3.generateId(s2, this.outputOptions, i2, true), i2[e3.id] = $r;
      }
      assignManualChunks(e2) {
        const t = [], s2 = { getModuleIds: () => this.graph.modulesById.keys(), getModuleInfo: this.graph.getModuleInfo };
        for (const i3 of this.graph.modulesById.values())
          if (i3 instanceof Qi) {
            const n3 = e2(i3.id, s2);
            typeof n3 == "string" && t.push([n3, i3]);
          }
        t.sort(([e3], [t2]) => e3 > t2 ? 1 : e3 < t2 ? -1 : 0);
        const i2 = /* @__PURE__ */ new Map();
        for (const [e3, s3] of t)
          qr(e3, s3, i2);
        return i2;
      }
      finaliseAssets(e2) {
        for (const t of Object.values(e2))
          if (t.type || (xe('A plugin is directly adding properties to the bundle object in the "generateBundle" hook. This is deprecated and will be removed in a future Rollup version, please use "this.emitFile" instead.', true, this.inputOptions), t.type = "asset"), this.outputOptions.validate && "code" in t)
            try {
              this.graph.contextParse(t.code, { allowHashBang: true, ecmaVersion: "latest" });
            } catch (e3) {
              this.inputOptions.onwarn(ce(t, e3));
            }
        this.pluginDriver.finaliseAssets();
      }
      async generateChunks() {
        const { manualChunks: e2 } = this.outputOptions, t = typeof e2 == "object" ? await this.addManualChunks(e2) : this.assignManualChunks(e2), s2 = [], i2 = /* @__PURE__ */ new Map();
        for (const { alias: e3, modules: n4 } of this.outputOptions.inlineDynamicImports ? [{ alias: null, modules: Hr(this.graph.modulesById) }] : this.outputOptions.preserveModules ? Hr(this.graph.modulesById).map((e4) => ({ alias: null, modules: [e4] })) : Br(this.graph.entryModules, t)) {
          n4.sort(zr);
          const t2 = new Cr(n4, this.inputOptions, this.outputOptions, this.unsetOptions, this.pluginDriver, this.graph.modulesById, i2, this.facadeChunkByModule, this.includedNamespaces, e3);
          s2.push(t2);
          for (const e4 of n4)
            i2.set(e4, t2);
        }
        for (const e3 of s2)
          e3.link();
        const n3 = [];
        for (const e3 of s2)
          n3.push(...e3.generateFacades());
        return [...s2, ...n3];
      }
      prerenderChunks(e2, t, s2) {
        for (const t2 of e2)
          t2.generateExports();
        for (const i2 of e2)
          i2.preRender(this.outputOptions, t, s2);
      }
    };
    Kr = { 3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile", 5: "class enum extends super const export import", 6: "enum", strict: "implements interface let package private protected public static yield", strictBind: "eval arguments" };
    Xr = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
    Yr = { 5: Xr, "5module": Xr + " export import", 6: Xr + " const class extends export import super" };
    Qr = /^in(stanceof)?$/;
    Zr = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
    Jr = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
    ea = new RegExp("[" + Zr + "]");
    ta = new RegExp("[" + Zr + Jr + "]");
    Zr = Jr = null;
    sa = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1070, 4050, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 46, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 482, 44, 11, 6, 17, 0, 322, 29, 19, 43, 1269, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4152, 8, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938];
    ia = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 357, 0, 62, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
    oa = function(e2, t) {
      t === void 0 && (t = {}), this.label = e2, this.keyword = t.keyword, this.beforeExpr = !!t.beforeExpr, this.startsExpr = !!t.startsExpr, this.isLoop = !!t.isLoop, this.isAssign = !!t.isAssign, this.prefix = !!t.prefix, this.postfix = !!t.postfix, this.binop = t.binop || null, this.updateContext = null;
    };
    la = { beforeExpr: true };
    ca = { startsExpr: true };
    ua = {};
    pa = { num: new oa("num", ca), regexp: new oa("regexp", ca), string: new oa("string", ca), name: new oa("name", ca), privateId: new oa("privateId", ca), eof: new oa("eof"), bracketL: new oa("[", { beforeExpr: true, startsExpr: true }), bracketR: new oa("]"), braceL: new oa("{", { beforeExpr: true, startsExpr: true }), braceR: new oa("}"), parenL: new oa("(", { beforeExpr: true, startsExpr: true }), parenR: new oa(")"), comma: new oa(",", la), semi: new oa(";", la), colon: new oa(":", la), dot: new oa("."), question: new oa("?", la), questionDot: new oa("?."), arrow: new oa("=>", la), template: new oa("template"), invalidTemplate: new oa("invalidTemplate"), ellipsis: new oa("...", la), backQuote: new oa("`", ca), dollarBraceL: new oa("${", { beforeExpr: true, startsExpr: true }), eq: new oa("=", { beforeExpr: true, isAssign: true }), assign: new oa("_=", { beforeExpr: true, isAssign: true }), incDec: new oa("++/--", { prefix: true, postfix: true, startsExpr: true }), prefix: new oa("!/~", { beforeExpr: true, prefix: true, startsExpr: true }), logicalOR: ha("||", 1), logicalAND: ha("&&", 2), bitwiseOR: ha("|", 3), bitwiseXOR: ha("^", 4), bitwiseAND: ha("&", 5), equality: ha("==/!=/===/!==", 6), relational: ha("</>/<=/>=", 7), bitShift: ha("<</>>/>>>", 8), plusMin: new oa("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }), modulo: ha("%", 10), star: ha("*", 10), slash: ha("/", 10), starstar: new oa("**", { beforeExpr: true }), coalesce: ha("??", 1), _break: da("break"), _case: da("case", la), _catch: da("catch"), _continue: da("continue"), _debugger: da("debugger"), _default: da("default", la), _do: da("do", { isLoop: true, beforeExpr: true }), _else: da("else", la), _finally: da("finally"), _for: da("for", { isLoop: true }), _function: da("function", ca), _if: da("if"), _return: da("return", la), _switch: da("switch"), _throw: da("throw", la), _try: da("try"), _var: da("var"), _const: da("const"), _while: da("while", { isLoop: true }), _with: da("with"), _new: da("new", { beforeExpr: true, startsExpr: true }), _this: da("this", ca), _super: da("super", ca), _class: da("class", ca), _extends: da("extends", la), _export: da("export"), _import: da("import", ca), _null: da("null", ca), _true: da("true", ca), _false: da("false", ca), _in: da("in", { beforeExpr: true, binop: 7 }), _instanceof: da("instanceof", { beforeExpr: true, binop: 7 }), _typeof: da("typeof", { beforeExpr: true, prefix: true, startsExpr: true }), _void: da("void", { beforeExpr: true, prefix: true, startsExpr: true }), _delete: da("delete", { beforeExpr: true, prefix: true, startsExpr: true }) };
    fa = /\r\n?|\n|\u2028|\u2029/;
    ma = new RegExp(fa.source, "g");
    Ea = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
    xa = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
    va = Object.prototype;
    ba = va.hasOwnProperty;
    Sa = va.toString;
    Aa = Object.hasOwn || function(e2, t) {
      return ba.call(e2, t);
    };
    Pa = Array.isArray || function(e2) {
      return Sa.call(e2) === "[object Array]";
    };
    wa = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
    Ca = function(e2, t) {
      this.line = e2, this.column = t;
    };
    Ca.prototype.offset = function(e2) {
      return new Ca(this.line, this.column + e2);
    };
    Ia = function(e2, t, s2) {
      this.start = t, this.end = s2, e2.sourceFile !== null && (this.source = e2.sourceFile);
    };
    _a = { ecmaVersion: null, sourceType: "script", onInsertedSemicolon: null, onTrailingComma: null, allowReserved: null, allowReturnOutsideFunction: false, allowImportExportEverywhere: false, allowAwaitOutsideFunction: null, allowSuperOutsideMethod: null, allowHashBang: false, locations: false, onToken: null, onComment: null, ranges: false, program: null, sourceFile: null, directSourceFile: null, preserveParens: false };
    $a = false;
    Ma = function(e2, t, s2) {
      this.options = e2 = Ta(e2), this.sourceFile = e2.sourceFile, this.keywords = ka(Yr[e2.ecmaVersion >= 6 ? 6 : e2.sourceType === "module" ? "5module" : 5]);
      var i2 = "";
      e2.allowReserved !== true && (i2 = Kr[e2.ecmaVersion >= 6 ? 6 : e2.ecmaVersion === 5 ? 5 : 3], e2.sourceType === "module" && (i2 += " await")), this.reservedWords = ka(i2);
      var n3 = (i2 ? i2 + " " : "") + Kr.strict;
      this.reservedWordsStrict = ka(n3), this.reservedWordsStrictBind = ka(n3 + " " + Kr.strictBind), this.input = String(t), this.containsEsc = false, s2 ? (this.pos = s2, this.lineStart = this.input.lastIndexOf("\n", s2 - 1) + 1, this.curLine = this.input.slice(0, this.lineStart).split(fa).length) : (this.pos = this.lineStart = 0, this.curLine = 1), this.type = pa.eof, this.value = null, this.start = this.end = this.pos, this.startLoc = this.endLoc = this.curPosition(), this.lastTokEndLoc = this.lastTokStartLoc = null, this.lastTokStart = this.lastTokEnd = this.pos, this.context = this.initialContext(), this.exprAllowed = true, this.inModule = e2.sourceType === "module", this.strict = this.inModule || this.strictDirective(this.pos), this.potentialArrowAt = -1, this.potentialArrowInForAwait = false, this.yieldPos = this.awaitPos = this.awaitIdentPos = 0, this.labels = [], this.undefinedExports = /* @__PURE__ */ Object.create(null), this.pos === 0 && e2.allowHashBang && this.input.slice(0, 2) === "#!" && this.skipLineComment(2), this.scopeStack = [], this.enterScope(1), this.regexpState = null, this.privateNameStack = [];
    };
    Da = { inFunction: { configurable: true }, inGenerator: { configurable: true }, inAsync: { configurable: true }, canAwait: { configurable: true }, allowSuper: { configurable: true }, allowDirectSuper: { configurable: true }, treatFunctionsAsVar: { configurable: true }, allowNewDotTarget: { configurable: true }, inClassStaticBlock: { configurable: true } };
    Ma.prototype.parse = function() {
      var e2 = this.options.program || this.startNode();
      return this.nextToken(), this.parseTopLevel(e2);
    }, Da.inFunction.get = function() {
      return (2 & this.currentVarScope().flags) > 0;
    }, Da.inGenerator.get = function() {
      return (8 & this.currentVarScope().flags) > 0 && !this.currentVarScope().inClassFieldInit;
    }, Da.inAsync.get = function() {
      return (4 & this.currentVarScope().flags) > 0 && !this.currentVarScope().inClassFieldInit;
    }, Da.canAwait.get = function() {
      for (var e2 = this.scopeStack.length - 1; e2 >= 0; e2--) {
        var t = this.scopeStack[e2];
        if (t.inClassFieldInit || 256 & t.flags)
          return false;
        if (2 & t.flags)
          return (4 & t.flags) > 0;
      }
      return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
    }, Da.allowSuper.get = function() {
      var e2 = this.currentThisScope(), t = e2.flags, s2 = e2.inClassFieldInit;
      return (64 & t) > 0 || s2 || this.options.allowSuperOutsideMethod;
    }, Da.allowDirectSuper.get = function() {
      return (128 & this.currentThisScope().flags) > 0;
    }, Da.treatFunctionsAsVar.get = function() {
      return this.treatFunctionsAsVarInScope(this.currentScope());
    }, Da.allowNewDotTarget.get = function() {
      var e2 = this.currentThisScope(), t = e2.flags, s2 = e2.inClassFieldInit;
      return (258 & t) > 0 || s2;
    }, Da.inClassStaticBlock.get = function() {
      return (256 & this.currentVarScope().flags) > 0;
    }, Ma.extend = function() {
      for (var e2 = [], t = arguments.length; t--; )
        e2[t] = arguments[t];
      for (var s2 = this, i2 = 0; i2 < e2.length; i2++)
        s2 = e2[i2](s2);
      return s2;
    }, Ma.parse = function(e2, t) {
      return new this(t, e2).parse();
    }, Ma.parseExpressionAt = function(e2, t, s2) {
      var i2 = new this(s2, e2, t);
      return i2.nextToken(), i2.parseExpression();
    }, Ma.tokenizer = function(e2, t) {
      return new this(t, e2);
    }, Object.defineProperties(Ma.prototype, Da);
    La = Ma.prototype;
    Oa = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
    La.strictDirective = function(e2) {
      for (; ; ) {
        xa.lastIndex = e2, e2 += xa.exec(this.input)[0].length;
        var t = Oa.exec(this.input.slice(e2));
        if (!t)
          return false;
        if ((t[1] || t[2]) === "use strict") {
          xa.lastIndex = e2 + t[0].length;
          var s2 = xa.exec(this.input), i2 = s2.index + s2[0].length, n3 = this.input.charAt(i2);
          return n3 === ";" || n3 === "}" || fa.test(s2[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(n3) || n3 === "!" && this.input.charAt(i2 + 1) === "=");
        }
        e2 += t[0].length, xa.lastIndex = e2, e2 += xa.exec(this.input)[0].length, this.input[e2] === ";" && e2++;
      }
    }, La.eat = function(e2) {
      return this.type === e2 && (this.next(), true);
    }, La.isContextual = function(e2) {
      return this.type === pa.name && this.value === e2 && !this.containsEsc;
    }, La.eatContextual = function(e2) {
      return !!this.isContextual(e2) && (this.next(), true);
    }, La.expectContextual = function(e2) {
      this.eatContextual(e2) || this.unexpected();
    }, La.canInsertSemicolon = function() {
      return this.type === pa.eof || this.type === pa.braceR || fa.test(this.input.slice(this.lastTokEnd, this.start));
    }, La.insertSemicolon = function() {
      if (this.canInsertSemicolon())
        return this.options.onInsertedSemicolon && this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc), true;
    }, La.semicolon = function() {
      this.eat(pa.semi) || this.insertSemicolon() || this.unexpected();
    }, La.afterTrailingComma = function(e2, t) {
      if (this.type === e2)
        return this.options.onTrailingComma && this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc), t || this.next(), true;
    }, La.expect = function(e2) {
      this.eat(e2) || this.unexpected();
    }, La.unexpected = function(e2) {
      this.raise(e2 != null ? e2 : this.start, "Unexpected token");
    }, La.checkPatternErrors = function(e2, t) {
      if (e2) {
        e2.trailingComma > -1 && this.raiseRecoverable(e2.trailingComma, "Comma is not permitted after the rest element");
        var s2 = t ? e2.parenthesizedAssign : e2.parenthesizedBind;
        s2 > -1 && this.raiseRecoverable(s2, "Parenthesized pattern");
      }
    }, La.checkExpressionErrors = function(e2, t) {
      if (!e2)
        return false;
      var s2 = e2.shorthandAssign, i2 = e2.doubleProto;
      if (!t)
        return s2 >= 0 || i2 >= 0;
      s2 >= 0 && this.raise(s2, "Shorthand property assignments are valid only in destructuring patterns"), i2 >= 0 && this.raiseRecoverable(i2, "Redefinition of __proto__ property");
    }, La.checkYieldAwaitInDefaultParams = function() {
      this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos) && this.raise(this.yieldPos, "Yield expression cannot be a default value"), this.awaitPos && this.raise(this.awaitPos, "Await expression cannot be a default value");
    }, La.isSimpleAssignTarget = function(e2) {
      return e2.type === "ParenthesizedExpression" ? this.isSimpleAssignTarget(e2.expression) : e2.type === "Identifier" || e2.type === "MemberExpression";
    };
    Ba = Ma.prototype;
    Ba.parseTopLevel = function(e2) {
      var t = /* @__PURE__ */ Object.create(null);
      for (e2.body || (e2.body = []); this.type !== pa.eof; ) {
        var s2 = this.parseStatement(null, true, t);
        e2.body.push(s2);
      }
      if (this.inModule)
        for (var i2 = 0, n3 = Object.keys(this.undefinedExports); i2 < n3.length; i2 += 1) {
          var r2 = n3[i2];
          this.raiseRecoverable(this.undefinedExports[r2].start, "Export '" + r2 + "' is not defined");
        }
      return this.adaptDirectivePrologue(e2.body), this.next(), e2.sourceType = this.options.sourceType, this.finishNode(e2, "Program");
    };
    Fa = { kind: "loop" };
    za = { kind: "switch" };
    Ba.isLet = function(e2) {
      if (this.options.ecmaVersion < 6 || !this.isContextual("let"))
        return false;
      xa.lastIndex = this.pos;
      var t = xa.exec(this.input), s2 = this.pos + t[0].length, i2 = this.input.charCodeAt(s2);
      if (i2 === 91 || i2 === 92 || i2 > 55295 && i2 < 56320)
        return true;
      if (e2)
        return false;
      if (i2 === 123)
        return true;
      if (ra(i2, true)) {
        for (var n3 = s2 + 1; aa(i2 = this.input.charCodeAt(n3), true); )
          ++n3;
        if (i2 === 92 || i2 > 55295 && i2 < 56320)
          return true;
        var r2 = this.input.slice(s2, n3);
        if (!Qr.test(r2))
          return true;
      }
      return false;
    }, Ba.isAsyncFunction = function() {
      if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
        return false;
      xa.lastIndex = this.pos;
      var e2, t = xa.exec(this.input), s2 = this.pos + t[0].length;
      return !(fa.test(this.input.slice(this.pos, s2)) || this.input.slice(s2, s2 + 8) !== "function" || s2 + 8 !== this.input.length && (aa(e2 = this.input.charCodeAt(s2 + 8)) || e2 > 55295 && e2 < 56320));
    }, Ba.parseStatement = function(e2, t, s2) {
      var i2, n3 = this.type, r2 = this.startNode();
      switch (this.isLet(e2) && (n3 = pa._var, i2 = "let"), n3) {
        case pa._break:
        case pa._continue:
          return this.parseBreakContinueStatement(r2, n3.keyword);
        case pa._debugger:
          return this.parseDebuggerStatement(r2);
        case pa._do:
          return this.parseDoStatement(r2);
        case pa._for:
          return this.parseForStatement(r2);
        case pa._function:
          return e2 && (this.strict || e2 !== "if" && e2 !== "label") && this.options.ecmaVersion >= 6 && this.unexpected(), this.parseFunctionStatement(r2, false, !e2);
        case pa._class:
          return e2 && this.unexpected(), this.parseClass(r2, true);
        case pa._if:
          return this.parseIfStatement(r2);
        case pa._return:
          return this.parseReturnStatement(r2);
        case pa._switch:
          return this.parseSwitchStatement(r2);
        case pa._throw:
          return this.parseThrowStatement(r2);
        case pa._try:
          return this.parseTryStatement(r2);
        case pa._const:
        case pa._var:
          return i2 = i2 || this.value, e2 && i2 !== "var" && this.unexpected(), this.parseVarStatement(r2, i2);
        case pa._while:
          return this.parseWhileStatement(r2);
        case pa._with:
          return this.parseWithStatement(r2);
        case pa.braceL:
          return this.parseBlock(true, r2);
        case pa.semi:
          return this.parseEmptyStatement(r2);
        case pa._export:
        case pa._import:
          if (this.options.ecmaVersion > 10 && n3 === pa._import) {
            xa.lastIndex = this.pos;
            var a2 = xa.exec(this.input), o2 = this.pos + a2[0].length, h3 = this.input.charCodeAt(o2);
            if (h3 === 40 || h3 === 46)
              return this.parseExpressionStatement(r2, this.parseExpression());
          }
          return this.options.allowImportExportEverywhere || (t || this.raise(this.start, "'import' and 'export' may only appear at the top level"), this.inModule || this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'")), n3 === pa._import ? this.parseImport(r2) : this.parseExport(r2, s2);
        default:
          if (this.isAsyncFunction())
            return e2 && this.unexpected(), this.next(), this.parseFunctionStatement(r2, true, !e2);
          var l2 = this.value, c3 = this.parseExpression();
          return n3 === pa.name && c3.type === "Identifier" && this.eat(pa.colon) ? this.parseLabeledStatement(r2, l2, c3, e2) : this.parseExpressionStatement(r2, c3);
      }
    }, Ba.parseBreakContinueStatement = function(e2, t) {
      var s2 = t === "break";
      this.next(), this.eat(pa.semi) || this.insertSemicolon() ? e2.label = null : this.type !== pa.name ? this.unexpected() : (e2.label = this.parseIdent(), this.semicolon());
      for (var i2 = 0; i2 < this.labels.length; ++i2) {
        var n3 = this.labels[i2];
        if (e2.label == null || n3.name === e2.label.name) {
          if (n3.kind != null && (s2 || n3.kind === "loop"))
            break;
          if (e2.label && s2)
            break;
        }
      }
      return i2 === this.labels.length && this.raise(e2.start, "Unsyntactic " + t), this.finishNode(e2, s2 ? "BreakStatement" : "ContinueStatement");
    }, Ba.parseDebuggerStatement = function(e2) {
      return this.next(), this.semicolon(), this.finishNode(e2, "DebuggerStatement");
    }, Ba.parseDoStatement = function(e2) {
      return this.next(), this.labels.push(Fa), e2.body = this.parseStatement("do"), this.labels.pop(), this.expect(pa._while), e2.test = this.parseParenExpression(), this.options.ecmaVersion >= 6 ? this.eat(pa.semi) : this.semicolon(), this.finishNode(e2, "DoWhileStatement");
    }, Ba.parseForStatement = function(e2) {
      this.next();
      var t = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
      if (this.labels.push(Fa), this.enterScope(0), this.expect(pa.parenL), this.type === pa.semi)
        return t > -1 && this.unexpected(t), this.parseFor(e2, null);
      var s2 = this.isLet();
      if (this.type === pa._var || this.type === pa._const || s2) {
        var i2 = this.startNode(), n3 = s2 ? "let" : this.value;
        return this.next(), this.parseVar(i2, true, n3), this.finishNode(i2, "VariableDeclaration"), (this.type === pa._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && i2.declarations.length === 1 ? (this.options.ecmaVersion >= 9 && (this.type === pa._in ? t > -1 && this.unexpected(t) : e2.await = t > -1), this.parseForIn(e2, i2)) : (t > -1 && this.unexpected(t), this.parseFor(e2, i2));
      }
      var r2 = this.isContextual("let"), a2 = false, o2 = new Va(), h3 = this.parseExpression(!(t > -1) || "await", o2);
      return this.type === pa._in || (a2 = this.options.ecmaVersion >= 6 && this.isContextual("of")) ? (this.options.ecmaVersion >= 9 && (this.type === pa._in ? t > -1 && this.unexpected(t) : e2.await = t > -1), r2 && a2 && this.raise(h3.start, "The left-hand side of a for-of loop may not start with 'let'."), this.toAssignable(h3, false, o2), this.checkLValPattern(h3), this.parseForIn(e2, h3)) : (this.checkExpressionErrors(o2, true), t > -1 && this.unexpected(t), this.parseFor(e2, h3));
    }, Ba.parseFunctionStatement = function(e2, t, s2) {
      return this.next(), this.parseFunction(e2, Ua | (s2 ? 0 : ja), false, t);
    }, Ba.parseIfStatement = function(e2) {
      return this.next(), e2.test = this.parseParenExpression(), e2.consequent = this.parseStatement("if"), e2.alternate = this.eat(pa._else) ? this.parseStatement("if") : null, this.finishNode(e2, "IfStatement");
    }, Ba.parseReturnStatement = function(e2) {
      return this.inFunction || this.options.allowReturnOutsideFunction || this.raise(this.start, "'return' outside of function"), this.next(), this.eat(pa.semi) || this.insertSemicolon() ? e2.argument = null : (e2.argument = this.parseExpression(), this.semicolon()), this.finishNode(e2, "ReturnStatement");
    }, Ba.parseSwitchStatement = function(e2) {
      var t;
      this.next(), e2.discriminant = this.parseParenExpression(), e2.cases = [], this.expect(pa.braceL), this.labels.push(za), this.enterScope(0);
      for (var s2 = false; this.type !== pa.braceR; )
        if (this.type === pa._case || this.type === pa._default) {
          var i2 = this.type === pa._case;
          t && this.finishNode(t, "SwitchCase"), e2.cases.push(t = this.startNode()), t.consequent = [], this.next(), i2 ? t.test = this.parseExpression() : (s2 && this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"), s2 = true, t.test = null), this.expect(pa.colon);
        } else
          t || this.unexpected(), t.consequent.push(this.parseStatement(null));
      return this.exitScope(), t && this.finishNode(t, "SwitchCase"), this.next(), this.labels.pop(), this.finishNode(e2, "SwitchStatement");
    }, Ba.parseThrowStatement = function(e2) {
      return this.next(), fa.test(this.input.slice(this.lastTokEnd, this.start)) && this.raise(this.lastTokEnd, "Illegal newline after throw"), e2.argument = this.parseExpression(), this.semicolon(), this.finishNode(e2, "ThrowStatement");
    };
    Wa = [];
    Ba.parseTryStatement = function(e2) {
      if (this.next(), e2.block = this.parseBlock(), e2.handler = null, this.type === pa._catch) {
        var t = this.startNode();
        if (this.next(), this.eat(pa.parenL)) {
          t.param = this.parseBindingAtom();
          var s2 = t.param.type === "Identifier";
          this.enterScope(s2 ? 32 : 0), this.checkLValPattern(t.param, s2 ? 4 : 2), this.expect(pa.parenR);
        } else
          this.options.ecmaVersion < 10 && this.unexpected(), t.param = null, this.enterScope(0);
        t.body = this.parseBlock(false), this.exitScope(), e2.handler = this.finishNode(t, "CatchClause");
      }
      return e2.finalizer = this.eat(pa._finally) ? this.parseBlock() : null, e2.handler || e2.finalizer || this.raise(e2.start, "Missing catch or finally clause"), this.finishNode(e2, "TryStatement");
    }, Ba.parseVarStatement = function(e2, t) {
      return this.next(), this.parseVar(e2, false, t), this.semicolon(), this.finishNode(e2, "VariableDeclaration");
    }, Ba.parseWhileStatement = function(e2) {
      return this.next(), e2.test = this.parseParenExpression(), this.labels.push(Fa), e2.body = this.parseStatement("while"), this.labels.pop(), this.finishNode(e2, "WhileStatement");
    }, Ba.parseWithStatement = function(e2) {
      return this.strict && this.raise(this.start, "'with' in strict mode"), this.next(), e2.object = this.parseParenExpression(), e2.body = this.parseStatement("with"), this.finishNode(e2, "WithStatement");
    }, Ba.parseEmptyStatement = function(e2) {
      return this.next(), this.finishNode(e2, "EmptyStatement");
    }, Ba.parseLabeledStatement = function(e2, t, s2, i2) {
      for (var n3 = 0, r2 = this.labels; n3 < r2.length; n3 += 1) {
        r2[n3].name === t && this.raise(s2.start, "Label '" + t + "' is already declared");
      }
      for (var a2 = this.type.isLoop ? "loop" : this.type === pa._switch ? "switch" : null, o2 = this.labels.length - 1; o2 >= 0; o2--) {
        var h3 = this.labels[o2];
        if (h3.statementStart !== e2.start)
          break;
        h3.statementStart = this.start, h3.kind = a2;
      }
      return this.labels.push({ name: t, kind: a2, statementStart: this.start }), e2.body = this.parseStatement(i2 ? i2.indexOf("label") === -1 ? i2 + "label" : i2 : "label"), this.labels.pop(), e2.label = s2, this.finishNode(e2, "LabeledStatement");
    }, Ba.parseExpressionStatement = function(e2, t) {
      return e2.expression = t, this.semicolon(), this.finishNode(e2, "ExpressionStatement");
    }, Ba.parseBlock = function(e2, t, s2) {
      for (e2 === void 0 && (e2 = true), t === void 0 && (t = this.startNode()), t.body = [], this.expect(pa.braceL), e2 && this.enterScope(0); this.type !== pa.braceR; ) {
        var i2 = this.parseStatement(null);
        t.body.push(i2);
      }
      return s2 && (this.strict = false), this.next(), e2 && this.exitScope(), this.finishNode(t, "BlockStatement");
    }, Ba.parseFor = function(e2, t) {
      return e2.init = t, this.expect(pa.semi), e2.test = this.type === pa.semi ? null : this.parseExpression(), this.expect(pa.semi), e2.update = this.type === pa.parenR ? null : this.parseExpression(), this.expect(pa.parenR), e2.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(e2, "ForStatement");
    }, Ba.parseForIn = function(e2, t) {
      var s2 = this.type === pa._in;
      return this.next(), t.type === "VariableDeclaration" && t.declarations[0].init != null && (!s2 || this.options.ecmaVersion < 8 || this.strict || t.kind !== "var" || t.declarations[0].id.type !== "Identifier") && this.raise(t.start, (s2 ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"), e2.left = t, e2.right = s2 ? this.parseExpression() : this.parseMaybeAssign(), this.expect(pa.parenR), e2.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(e2, s2 ? "ForInStatement" : "ForOfStatement");
    }, Ba.parseVar = function(e2, t, s2) {
      for (e2.declarations = [], e2.kind = s2; ; ) {
        var i2 = this.startNode();
        if (this.parseVarId(i2, s2), this.eat(pa.eq) ? i2.init = this.parseMaybeAssign(t) : s2 !== "const" || this.type === pa._in || this.options.ecmaVersion >= 6 && this.isContextual("of") ? i2.id.type === "Identifier" || t && (this.type === pa._in || this.isContextual("of")) ? i2.init = null : this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value") : this.unexpected(), e2.declarations.push(this.finishNode(i2, "VariableDeclarator")), !this.eat(pa.comma))
          break;
      }
      return e2;
    }, Ba.parseVarId = function(e2, t) {
      e2.id = this.parseBindingAtom(), this.checkLValPattern(e2.id, t === "var" ? 1 : 2, false);
    };
    Ua = 1;
    ja = 2;
    Ba.parseFunction = function(e2, t, s2, i2, n3) {
      this.initFunction(e2), (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !i2) && (this.type === pa.star && t & ja && this.unexpected(), e2.generator = this.eat(pa.star)), this.options.ecmaVersion >= 8 && (e2.async = !!i2), t & Ua && (e2.id = 4 & t && this.type !== pa.name ? null : this.parseIdent(), !e2.id || t & ja || this.checkLValSimple(e2.id, this.strict || e2.generator || e2.async ? this.treatFunctionsAsVar ? 1 : 2 : 3));
      var r2 = this.yieldPos, a2 = this.awaitPos, o2 = this.awaitIdentPos;
      return this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(Ra(e2.async, e2.generator)), t & Ua || (e2.id = this.type === pa.name ? this.parseIdent() : null), this.parseFunctionParams(e2), this.parseFunctionBody(e2, s2, false, n3), this.yieldPos = r2, this.awaitPos = a2, this.awaitIdentPos = o2, this.finishNode(e2, t & Ua ? "FunctionDeclaration" : "FunctionExpression");
    }, Ba.parseFunctionParams = function(e2) {
      this.expect(pa.parenL), e2.params = this.parseBindingList(pa.parenR, false, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams();
    }, Ba.parseClass = function(e2, t) {
      this.next();
      var s2 = this.strict;
      this.strict = true, this.parseClassId(e2, t), this.parseClassSuper(e2);
      var i2 = this.enterClassBody(), n3 = this.startNode(), r2 = false;
      for (n3.body = [], this.expect(pa.braceL); this.type !== pa.braceR; ) {
        var a2 = this.parseClassElement(e2.superClass !== null);
        a2 && (n3.body.push(a2), a2.type === "MethodDefinition" && a2.kind === "constructor" ? (r2 && this.raise(a2.start, "Duplicate constructor in the same class"), r2 = true) : a2.key && a2.key.type === "PrivateIdentifier" && Ga(i2, a2) && this.raiseRecoverable(a2.key.start, "Identifier '#" + a2.key.name + "' has already been declared"));
      }
      return this.strict = s2, this.next(), e2.body = this.finishNode(n3, "ClassBody"), this.exitClassBody(), this.finishNode(e2, t ? "ClassDeclaration" : "ClassExpression");
    }, Ba.parseClassElement = function(e2) {
      if (this.eat(pa.semi))
        return null;
      var t = this.options.ecmaVersion, s2 = this.startNode(), i2 = "", n3 = false, r2 = false, a2 = "method", o2 = false;
      if (this.eatContextual("static")) {
        if (t >= 13 && this.eat(pa.braceL))
          return this.parseClassStaticBlock(s2), s2;
        this.isClassElementNameStart() || this.type === pa.star ? o2 = true : i2 = "static";
      }
      if (s2.static = o2, !i2 && t >= 8 && this.eatContextual("async") && (!this.isClassElementNameStart() && this.type !== pa.star || this.canInsertSemicolon() ? i2 = "async" : r2 = true), !i2 && (t >= 9 || !r2) && this.eat(pa.star) && (n3 = true), !i2 && !r2 && !n3) {
        var h3 = this.value;
        (this.eatContextual("get") || this.eatContextual("set")) && (this.isClassElementNameStart() ? a2 = h3 : i2 = h3);
      }
      if (i2 ? (s2.computed = false, s2.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc), s2.key.name = i2, this.finishNode(s2.key, "Identifier")) : this.parseClassElementName(s2), t < 13 || this.type === pa.parenL || a2 !== "method" || n3 || r2) {
        var l2 = !s2.static && Ha(s2, "constructor"), c3 = l2 && e2;
        l2 && a2 !== "method" && this.raise(s2.key.start, "Constructor can't have get/set modifier"), s2.kind = l2 ? "constructor" : a2, this.parseClassMethod(s2, n3, r2, c3);
      } else
        this.parseClassField(s2);
      return s2;
    }, Ba.isClassElementNameStart = function() {
      return this.type === pa.name || this.type === pa.privateId || this.type === pa.num || this.type === pa.string || this.type === pa.bracketL || this.type.keyword;
    }, Ba.parseClassElementName = function(e2) {
      this.type === pa.privateId ? (this.value === "constructor" && this.raise(this.start, "Classes can't have an element named '#constructor'"), e2.computed = false, e2.key = this.parsePrivateIdent()) : this.parsePropertyName(e2);
    }, Ba.parseClassMethod = function(e2, t, s2, i2) {
      var n3 = e2.key;
      e2.kind === "constructor" ? (t && this.raise(n3.start, "Constructor can't be a generator"), s2 && this.raise(n3.start, "Constructor can't be an async method")) : e2.static && Ha(e2, "prototype") && this.raise(n3.start, "Classes may not have a static property named prototype");
      var r2 = e2.value = this.parseMethod(t, s2, i2);
      return e2.kind === "get" && r2.params.length !== 0 && this.raiseRecoverable(r2.start, "getter should have no params"), e2.kind === "set" && r2.params.length !== 1 && this.raiseRecoverable(r2.start, "setter should have exactly one param"), e2.kind === "set" && r2.params[0].type === "RestElement" && this.raiseRecoverable(r2.params[0].start, "Setter cannot use rest params"), this.finishNode(e2, "MethodDefinition");
    }, Ba.parseClassField = function(e2) {
      if (Ha(e2, "constructor") ? this.raise(e2.key.start, "Classes can't have a field named 'constructor'") : e2.static && Ha(e2, "prototype") && this.raise(e2.key.start, "Classes can't have a static field named 'prototype'"), this.eat(pa.eq)) {
        var t = this.currentThisScope(), s2 = t.inClassFieldInit;
        t.inClassFieldInit = true, e2.value = this.parseMaybeAssign(), t.inClassFieldInit = s2;
      } else
        e2.value = null;
      return this.semicolon(), this.finishNode(e2, "PropertyDefinition");
    }, Ba.parseClassStaticBlock = function(e2) {
      e2.body = [];
      var t = this.labels;
      for (this.labels = [], this.enterScope(320); this.type !== pa.braceR; ) {
        var s2 = this.parseStatement(null);
        e2.body.push(s2);
      }
      return this.next(), this.exitScope(), this.labels = t, this.finishNode(e2, "StaticBlock");
    }, Ba.parseClassId = function(e2, t) {
      this.type === pa.name ? (e2.id = this.parseIdent(), t && this.checkLValSimple(e2.id, 2, false)) : (t === true && this.unexpected(), e2.id = null);
    }, Ba.parseClassSuper = function(e2) {
      e2.superClass = this.eat(pa._extends) ? this.parseExprSubscripts(false) : null;
    }, Ba.enterClassBody = function() {
      var e2 = { declared: /* @__PURE__ */ Object.create(null), used: [] };
      return this.privateNameStack.push(e2), e2.declared;
    }, Ba.exitClassBody = function() {
      for (var e2 = this.privateNameStack.pop(), t = e2.declared, s2 = e2.used, i2 = this.privateNameStack.length, n3 = i2 === 0 ? null : this.privateNameStack[i2 - 1], r2 = 0; r2 < s2.length; ++r2) {
        var a2 = s2[r2];
        Aa(t, a2.name) || (n3 ? n3.used.push(a2) : this.raiseRecoverable(a2.start, "Private field '#" + a2.name + "' must be declared in an enclosing class"));
      }
    }, Ba.parseExport = function(e2, t) {
      if (this.next(), this.eat(pa.star))
        return this.options.ecmaVersion >= 11 && (this.eatContextual("as") ? (e2.exported = this.parseModuleExportName(), this.checkExport(t, e2.exported.name, this.lastTokStart)) : e2.exported = null), this.expectContextual("from"), this.type !== pa.string && this.unexpected(), e2.source = this.parseExprAtom(), this.semicolon(), this.finishNode(e2, "ExportAllDeclaration");
      if (this.eat(pa._default)) {
        var s2;
        if (this.checkExport(t, "default", this.lastTokStart), this.type === pa._function || (s2 = this.isAsyncFunction())) {
          var i2 = this.startNode();
          this.next(), s2 && this.next(), e2.declaration = this.parseFunction(i2, 4 | Ua, false, s2);
        } else if (this.type === pa._class) {
          var n3 = this.startNode();
          e2.declaration = this.parseClass(n3, "nullableID");
        } else
          e2.declaration = this.parseMaybeAssign(), this.semicolon();
        return this.finishNode(e2, "ExportDefaultDeclaration");
      }
      if (this.shouldParseExportStatement())
        e2.declaration = this.parseStatement(null), e2.declaration.type === "VariableDeclaration" ? this.checkVariableExport(t, e2.declaration.declarations) : this.checkExport(t, e2.declaration.id.name, e2.declaration.id.start), e2.specifiers = [], e2.source = null;
      else {
        if (e2.declaration = null, e2.specifiers = this.parseExportSpecifiers(t), this.eatContextual("from"))
          this.type !== pa.string && this.unexpected(), e2.source = this.parseExprAtom();
        else {
          for (var r2 = 0, a2 = e2.specifiers; r2 < a2.length; r2 += 1) {
            var o2 = a2[r2];
            this.checkUnreserved(o2.local), this.checkLocalExport(o2.local), o2.local.type === "Literal" && this.raise(o2.local.start, "A string literal cannot be used as an exported binding without `from`.");
          }
          e2.source = null;
        }
        this.semicolon();
      }
      return this.finishNode(e2, "ExportNamedDeclaration");
    }, Ba.checkExport = function(e2, t, s2) {
      e2 && (Aa(e2, t) && this.raiseRecoverable(s2, "Duplicate export '" + t + "'"), e2[t] = true);
    }, Ba.checkPatternExport = function(e2, t) {
      var s2 = t.type;
      if (s2 === "Identifier")
        this.checkExport(e2, t.name, t.start);
      else if (s2 === "ObjectPattern")
        for (var i2 = 0, n3 = t.properties; i2 < n3.length; i2 += 1) {
          var r2 = n3[i2];
          this.checkPatternExport(e2, r2);
        }
      else if (s2 === "ArrayPattern")
        for (var a2 = 0, o2 = t.elements; a2 < o2.length; a2 += 1) {
          var h3 = o2[a2];
          h3 && this.checkPatternExport(e2, h3);
        }
      else
        s2 === "Property" ? this.checkPatternExport(e2, t.value) : s2 === "AssignmentPattern" ? this.checkPatternExport(e2, t.left) : s2 === "RestElement" ? this.checkPatternExport(e2, t.argument) : s2 === "ParenthesizedExpression" && this.checkPatternExport(e2, t.expression);
    }, Ba.checkVariableExport = function(e2, t) {
      if (e2)
        for (var s2 = 0, i2 = t; s2 < i2.length; s2 += 1) {
          var n3 = i2[s2];
          this.checkPatternExport(e2, n3.id);
        }
    }, Ba.shouldParseExportStatement = function() {
      return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
    }, Ba.parseExportSpecifiers = function(e2) {
      var t = [], s2 = true;
      for (this.expect(pa.braceL); !this.eat(pa.braceR); ) {
        if (s2)
          s2 = false;
        else if (this.expect(pa.comma), this.afterTrailingComma(pa.braceR))
          break;
        var i2 = this.startNode();
        i2.local = this.parseModuleExportName(), i2.exported = this.eatContextual("as") ? this.parseModuleExportName() : i2.local, this.checkExport(e2, i2.exported[i2.exported.type === "Identifier" ? "name" : "value"], i2.exported.start), t.push(this.finishNode(i2, "ExportSpecifier"));
      }
      return t;
    }, Ba.parseImport = function(e2) {
      return this.next(), this.type === pa.string ? (e2.specifiers = Wa, e2.source = this.parseExprAtom()) : (e2.specifiers = this.parseImportSpecifiers(), this.expectContextual("from"), e2.source = this.type === pa.string ? this.parseExprAtom() : this.unexpected()), this.semicolon(), this.finishNode(e2, "ImportDeclaration");
    }, Ba.parseImportSpecifiers = function() {
      var e2 = [], t = true;
      if (this.type === pa.name) {
        var s2 = this.startNode();
        if (s2.local = this.parseIdent(), this.checkLValSimple(s2.local, 2), e2.push(this.finishNode(s2, "ImportDefaultSpecifier")), !this.eat(pa.comma))
          return e2;
      }
      if (this.type === pa.star) {
        var i2 = this.startNode();
        return this.next(), this.expectContextual("as"), i2.local = this.parseIdent(), this.checkLValSimple(i2.local, 2), e2.push(this.finishNode(i2, "ImportNamespaceSpecifier")), e2;
      }
      for (this.expect(pa.braceL); !this.eat(pa.braceR); ) {
        if (t)
          t = false;
        else if (this.expect(pa.comma), this.afterTrailingComma(pa.braceR))
          break;
        var n3 = this.startNode();
        n3.imported = this.parseModuleExportName(), this.eatContextual("as") ? n3.local = this.parseIdent() : (this.checkUnreserved(n3.imported), n3.local = n3.imported), this.checkLValSimple(n3.local, 2), e2.push(this.finishNode(n3, "ImportSpecifier"));
      }
      return e2;
    }, Ba.parseModuleExportName = function() {
      if (this.options.ecmaVersion >= 13 && this.type === pa.string) {
        var e2 = this.parseLiteral(this.value);
        return wa.test(e2.value) && this.raise(e2.start, "An export name cannot include a lone surrogate."), e2;
      }
      return this.parseIdent(true);
    }, Ba.adaptDirectivePrologue = function(e2) {
      for (var t = 0; t < e2.length && this.isDirectiveCandidate(e2[t]); ++t)
        e2[t].directive = e2[t].expression.raw.slice(1, -1);
    }, Ba.isDirectiveCandidate = function(e2) {
      return e2.type === "ExpressionStatement" && e2.expression.type === "Literal" && typeof e2.expression.value == "string" && (this.input[e2.start] === '"' || this.input[e2.start] === "'");
    };
    qa = Ma.prototype;
    qa.toAssignable = function(e2, t, s2) {
      if (this.options.ecmaVersion >= 6 && e2)
        switch (e2.type) {
          case "Identifier":
            this.inAsync && e2.name === "await" && this.raise(e2.start, "Cannot use 'await' as identifier inside an async function");
            break;
          case "ObjectPattern":
          case "ArrayPattern":
          case "AssignmentPattern":
          case "RestElement":
            break;
          case "ObjectExpression":
            e2.type = "ObjectPattern", s2 && this.checkPatternErrors(s2, true);
            for (var i2 = 0, n3 = e2.properties; i2 < n3.length; i2 += 1) {
              var r2 = n3[i2];
              this.toAssignable(r2, t), r2.type !== "RestElement" || r2.argument.type !== "ArrayPattern" && r2.argument.type !== "ObjectPattern" || this.raise(r2.argument.start, "Unexpected token");
            }
            break;
          case "Property":
            e2.kind !== "init" && this.raise(e2.key.start, "Object pattern can't contain getter or setter"), this.toAssignable(e2.value, t);
            break;
          case "ArrayExpression":
            e2.type = "ArrayPattern", s2 && this.checkPatternErrors(s2, true), this.toAssignableList(e2.elements, t);
            break;
          case "SpreadElement":
            e2.type = "RestElement", this.toAssignable(e2.argument, t), e2.argument.type === "AssignmentPattern" && this.raise(e2.argument.start, "Rest elements cannot have a default value");
            break;
          case "AssignmentExpression":
            e2.operator !== "=" && this.raise(e2.left.end, "Only '=' operator can be used for specifying default value."), e2.type = "AssignmentPattern", delete e2.operator, this.toAssignable(e2.left, t);
            break;
          case "ParenthesizedExpression":
            this.toAssignable(e2.expression, t, s2);
            break;
          case "ChainExpression":
            this.raiseRecoverable(e2.start, "Optional chaining cannot appear in left-hand side");
            break;
          case "MemberExpression":
            if (!t)
              break;
          default:
            this.raise(e2.start, "Assigning to rvalue");
        }
      else
        s2 && this.checkPatternErrors(s2, true);
      return e2;
    }, qa.toAssignableList = function(e2, t) {
      for (var s2 = e2.length, i2 = 0; i2 < s2; i2++) {
        var n3 = e2[i2];
        n3 && this.toAssignable(n3, t);
      }
      if (s2) {
        var r2 = e2[s2 - 1];
        this.options.ecmaVersion === 6 && t && r2 && r2.type === "RestElement" && r2.argument.type !== "Identifier" && this.unexpected(r2.argument.start);
      }
      return e2;
    }, qa.parseSpread = function(e2) {
      var t = this.startNode();
      return this.next(), t.argument = this.parseMaybeAssign(false, e2), this.finishNode(t, "SpreadElement");
    }, qa.parseRestBinding = function() {
      var e2 = this.startNode();
      return this.next(), this.options.ecmaVersion === 6 && this.type !== pa.name && this.unexpected(), e2.argument = this.parseBindingAtom(), this.finishNode(e2, "RestElement");
    }, qa.parseBindingAtom = function() {
      if (this.options.ecmaVersion >= 6)
        switch (this.type) {
          case pa.bracketL:
            var e2 = this.startNode();
            return this.next(), e2.elements = this.parseBindingList(pa.bracketR, true, true), this.finishNode(e2, "ArrayPattern");
          case pa.braceL:
            return this.parseObj(true);
        }
      return this.parseIdent();
    }, qa.parseBindingList = function(e2, t, s2) {
      for (var i2 = [], n3 = true; !this.eat(e2); )
        if (n3 ? n3 = false : this.expect(pa.comma), t && this.type === pa.comma)
          i2.push(null);
        else {
          if (s2 && this.afterTrailingComma(e2))
            break;
          if (this.type === pa.ellipsis) {
            var r2 = this.parseRestBinding();
            this.parseBindingListItem(r2), i2.push(r2), this.type === pa.comma && this.raise(this.start, "Comma is not permitted after the rest element"), this.expect(e2);
            break;
          }
          var a2 = this.parseMaybeDefault(this.start, this.startLoc);
          this.parseBindingListItem(a2), i2.push(a2);
        }
      return i2;
    }, qa.parseBindingListItem = function(e2) {
      return e2;
    }, qa.parseMaybeDefault = function(e2, t, s2) {
      if (s2 = s2 || this.parseBindingAtom(), this.options.ecmaVersion < 6 || !this.eat(pa.eq))
        return s2;
      var i2 = this.startNodeAt(e2, t);
      return i2.left = s2, i2.right = this.parseMaybeAssign(), this.finishNode(i2, "AssignmentPattern");
    }, qa.checkLValSimple = function(e2, t, s2) {
      t === void 0 && (t = 0);
      var i2 = t !== 0;
      switch (e2.type) {
        case "Identifier":
          this.strict && this.reservedWordsStrictBind.test(e2.name) && this.raiseRecoverable(e2.start, (i2 ? "Binding " : "Assigning to ") + e2.name + " in strict mode"), i2 && (t === 2 && e2.name === "let" && this.raiseRecoverable(e2.start, "let is disallowed as a lexically bound name"), s2 && (Aa(s2, e2.name) && this.raiseRecoverable(e2.start, "Argument name clash"), s2[e2.name] = true), t !== 5 && this.declareName(e2.name, t, e2.start));
          break;
        case "ChainExpression":
          this.raiseRecoverable(e2.start, "Optional chaining cannot appear in left-hand side");
          break;
        case "MemberExpression":
          i2 && this.raiseRecoverable(e2.start, "Binding member expression");
          break;
        case "ParenthesizedExpression":
          return i2 && this.raiseRecoverable(e2.start, "Binding parenthesized expression"), this.checkLValSimple(e2.expression, t, s2);
        default:
          this.raise(e2.start, (i2 ? "Binding" : "Assigning to") + " rvalue");
      }
    }, qa.checkLValPattern = function(e2, t, s2) {
      switch (t === void 0 && (t = 0), e2.type) {
        case "ObjectPattern":
          for (var i2 = 0, n3 = e2.properties; i2 < n3.length; i2 += 1) {
            var r2 = n3[i2];
            this.checkLValInnerPattern(r2, t, s2);
          }
          break;
        case "ArrayPattern":
          for (var a2 = 0, o2 = e2.elements; a2 < o2.length; a2 += 1) {
            var h3 = o2[a2];
            h3 && this.checkLValInnerPattern(h3, t, s2);
          }
          break;
        default:
          this.checkLValSimple(e2, t, s2);
      }
    }, qa.checkLValInnerPattern = function(e2, t, s2) {
      switch (t === void 0 && (t = 0), e2.type) {
        case "Property":
          this.checkLValInnerPattern(e2.value, t, s2);
          break;
        case "AssignmentPattern":
          this.checkLValPattern(e2.left, t, s2);
          break;
        case "RestElement":
          this.checkLValPattern(e2.argument, t, s2);
          break;
        default:
          this.checkLValPattern(e2, t, s2);
      }
    };
    Ka = function(e2, t, s2, i2, n3) {
      this.token = e2, this.isExpr = !!t, this.preserveSpace = !!s2, this.override = i2, this.generator = !!n3;
    };
    Xa = { b_stat: new Ka("{", false), b_expr: new Ka("{", true), b_tmpl: new Ka("${", false), p_stat: new Ka("(", false), p_expr: new Ka("(", true), q_tmpl: new Ka("`", true, true, function(e2) {
      return e2.tryReadTemplateToken();
    }), f_stat: new Ka("function", false), f_expr: new Ka("function", true), f_expr_gen: new Ka("function", true, false, null, true), f_gen: new Ka("function", false, false, null, true) };
    Ya = Ma.prototype;
    Ya.initialContext = function() {
      return [Xa.b_stat];
    }, Ya.curContext = function() {
      return this.context[this.context.length - 1];
    }, Ya.braceIsBlock = function(e2) {
      var t = this.curContext();
      return t === Xa.f_expr || t === Xa.f_stat || (e2 !== pa.colon || t !== Xa.b_stat && t !== Xa.b_expr ? e2 === pa._return || e2 === pa.name && this.exprAllowed ? fa.test(this.input.slice(this.lastTokEnd, this.start)) : e2 === pa._else || e2 === pa.semi || e2 === pa.eof || e2 === pa.parenR || e2 === pa.arrow || (e2 === pa.braceL ? t === Xa.b_stat : e2 !== pa._var && e2 !== pa._const && e2 !== pa.name && !this.exprAllowed) : !t.isExpr);
    }, Ya.inGeneratorContext = function() {
      for (var e2 = this.context.length - 1; e2 >= 1; e2--) {
        var t = this.context[e2];
        if (t.token === "function")
          return t.generator;
      }
      return false;
    }, Ya.updateContext = function(e2) {
      var t, s2 = this.type;
      s2.keyword && e2 === pa.dot ? this.exprAllowed = false : (t = s2.updateContext) ? t.call(this, e2) : this.exprAllowed = s2.beforeExpr;
    }, Ya.overrideContext = function(e2) {
      this.curContext() !== e2 && (this.context[this.context.length - 1] = e2);
    }, pa.parenR.updateContext = pa.braceR.updateContext = function() {
      if (this.context.length !== 1) {
        var e2 = this.context.pop();
        e2 === Xa.b_stat && this.curContext().token === "function" && (e2 = this.context.pop()), this.exprAllowed = !e2.isExpr;
      } else
        this.exprAllowed = true;
    }, pa.braceL.updateContext = function(e2) {
      this.context.push(this.braceIsBlock(e2) ? Xa.b_stat : Xa.b_expr), this.exprAllowed = true;
    }, pa.dollarBraceL.updateContext = function() {
      this.context.push(Xa.b_tmpl), this.exprAllowed = true;
    }, pa.parenL.updateContext = function(e2) {
      var t = e2 === pa._if || e2 === pa._for || e2 === pa._with || e2 === pa._while;
      this.context.push(t ? Xa.p_stat : Xa.p_expr), this.exprAllowed = true;
    }, pa.incDec.updateContext = function() {
    }, pa._function.updateContext = pa._class.updateContext = function(e2) {
      !e2.beforeExpr || e2 === pa._else || e2 === pa.semi && this.curContext() !== Xa.p_stat || e2 === pa._return && fa.test(this.input.slice(this.lastTokEnd, this.start)) || (e2 === pa.colon || e2 === pa.braceL) && this.curContext() === Xa.b_stat ? this.context.push(Xa.f_stat) : this.context.push(Xa.f_expr), this.exprAllowed = false;
    }, pa.backQuote.updateContext = function() {
      this.curContext() === Xa.q_tmpl ? this.context.pop() : this.context.push(Xa.q_tmpl), this.exprAllowed = false;
    }, pa.star.updateContext = function(e2) {
      if (e2 === pa._function) {
        var t = this.context.length - 1;
        this.context[t] === Xa.f_expr ? this.context[t] = Xa.f_expr_gen : this.context[t] = Xa.f_gen;
      }
      this.exprAllowed = true;
    }, pa.name.updateContext = function(e2) {
      var t = false;
      this.options.ecmaVersion >= 6 && e2 !== pa.dot && (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) && (t = true), this.exprAllowed = t;
    };
    Qa = Ma.prototype;
    Qa.checkPropClash = function(e2, t, s2) {
      if (!(this.options.ecmaVersion >= 9 && e2.type === "SpreadElement" || this.options.ecmaVersion >= 6 && (e2.computed || e2.method || e2.shorthand))) {
        var i2, n3 = e2.key;
        switch (n3.type) {
          case "Identifier":
            i2 = n3.name;
            break;
          case "Literal":
            i2 = String(n3.value);
            break;
          default:
            return;
        }
        var r2 = e2.kind;
        if (this.options.ecmaVersion >= 6)
          i2 === "__proto__" && r2 === "init" && (t.proto && (s2 ? s2.doubleProto < 0 && (s2.doubleProto = n3.start) : this.raiseRecoverable(n3.start, "Redefinition of __proto__ property")), t.proto = true);
        else {
          var a2 = t[i2 = "$" + i2];
          if (a2)
            (r2 === "init" ? this.strict && a2.init || a2.get || a2.set : a2.init || a2[r2]) && this.raiseRecoverable(n3.start, "Redefinition of property");
          else
            a2 = t[i2] = { init: false, get: false, set: false };
          a2[r2] = true;
        }
      }
    }, Qa.parseExpression = function(e2, t) {
      var s2 = this.start, i2 = this.startLoc, n3 = this.parseMaybeAssign(e2, t);
      if (this.type === pa.comma) {
        var r2 = this.startNodeAt(s2, i2);
        for (r2.expressions = [n3]; this.eat(pa.comma); )
          r2.expressions.push(this.parseMaybeAssign(e2, t));
        return this.finishNode(r2, "SequenceExpression");
      }
      return n3;
    }, Qa.parseMaybeAssign = function(e2, t, s2) {
      if (this.isContextual("yield")) {
        if (this.inGenerator)
          return this.parseYield(e2);
        this.exprAllowed = false;
      }
      var i2 = false, n3 = -1, r2 = -1, a2 = -1;
      t ? (n3 = t.parenthesizedAssign, r2 = t.trailingComma, a2 = t.doubleProto, t.parenthesizedAssign = t.trailingComma = -1) : (t = new Va(), i2 = true);
      var o2 = this.start, h3 = this.startLoc;
      this.type !== pa.parenL && this.type !== pa.name || (this.potentialArrowAt = this.start, this.potentialArrowInForAwait = e2 === "await");
      var l2 = this.parseMaybeConditional(e2, t);
      if (s2 && (l2 = s2.call(this, l2, o2, h3)), this.type.isAssign) {
        var c3 = this.startNodeAt(o2, h3);
        return c3.operator = this.value, this.type === pa.eq && (l2 = this.toAssignable(l2, false, t)), i2 || (t.parenthesizedAssign = t.trailingComma = t.doubleProto = -1), t.shorthandAssign >= l2.start && (t.shorthandAssign = -1), this.type === pa.eq ? this.checkLValPattern(l2) : this.checkLValSimple(l2), c3.left = l2, this.next(), c3.right = this.parseMaybeAssign(e2), a2 > -1 && (t.doubleProto = a2), this.finishNode(c3, "AssignmentExpression");
      }
      return i2 && this.checkExpressionErrors(t, true), n3 > -1 && (t.parenthesizedAssign = n3), r2 > -1 && (t.trailingComma = r2), l2;
    }, Qa.parseMaybeConditional = function(e2, t) {
      var s2 = this.start, i2 = this.startLoc, n3 = this.parseExprOps(e2, t);
      if (this.checkExpressionErrors(t))
        return n3;
      if (this.eat(pa.question)) {
        var r2 = this.startNodeAt(s2, i2);
        return r2.test = n3, r2.consequent = this.parseMaybeAssign(), this.expect(pa.colon), r2.alternate = this.parseMaybeAssign(e2), this.finishNode(r2, "ConditionalExpression");
      }
      return n3;
    }, Qa.parseExprOps = function(e2, t) {
      var s2 = this.start, i2 = this.startLoc, n3 = this.parseMaybeUnary(t, false, false, e2);
      return this.checkExpressionErrors(t) || n3.start === s2 && n3.type === "ArrowFunctionExpression" ? n3 : this.parseExprOp(n3, s2, i2, -1, e2);
    }, Qa.parseExprOp = function(e2, t, s2, i2, n3) {
      var r2 = this.type.binop;
      if (r2 != null && (!n3 || this.type !== pa._in) && r2 > i2) {
        var a2 = this.type === pa.logicalOR || this.type === pa.logicalAND, o2 = this.type === pa.coalesce;
        o2 && (r2 = pa.logicalAND.binop);
        var h3 = this.value;
        this.next();
        var l2 = this.start, c3 = this.startLoc, u2 = this.parseExprOp(this.parseMaybeUnary(null, false, false, n3), l2, c3, r2, n3), d3 = this.buildBinary(t, s2, e2, u2, h3, a2 || o2);
        return (a2 && this.type === pa.coalesce || o2 && (this.type === pa.logicalOR || this.type === pa.logicalAND)) && this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses"), this.parseExprOp(d3, t, s2, i2, n3);
      }
      return e2;
    }, Qa.buildBinary = function(e2, t, s2, i2, n3, r2) {
      i2.type === "PrivateIdentifier" && this.raise(i2.start, "Private identifier can only be left side of binary expression");
      var a2 = this.startNodeAt(e2, t);
      return a2.left = s2, a2.operator = n3, a2.right = i2, this.finishNode(a2, r2 ? "LogicalExpression" : "BinaryExpression");
    }, Qa.parseMaybeUnary = function(e2, t, s2, i2) {
      var n3, r2 = this.start, a2 = this.startLoc;
      if (this.isContextual("await") && this.canAwait)
        n3 = this.parseAwait(i2), t = true;
      else if (this.type.prefix) {
        var o2 = this.startNode(), h3 = this.type === pa.incDec;
        o2.operator = this.value, o2.prefix = true, this.next(), o2.argument = this.parseMaybeUnary(null, true, h3, i2), this.checkExpressionErrors(e2, true), h3 ? this.checkLValSimple(o2.argument) : this.strict && o2.operator === "delete" && o2.argument.type === "Identifier" ? this.raiseRecoverable(o2.start, "Deleting local variable in strict mode") : o2.operator === "delete" && Za(o2.argument) ? this.raiseRecoverable(o2.start, "Private fields can not be deleted") : t = true, n3 = this.finishNode(o2, h3 ? "UpdateExpression" : "UnaryExpression");
      } else if (t || this.type !== pa.privateId) {
        if (n3 = this.parseExprSubscripts(e2, i2), this.checkExpressionErrors(e2))
          return n3;
        for (; this.type.postfix && !this.canInsertSemicolon(); ) {
          var l2 = this.startNodeAt(r2, a2);
          l2.operator = this.value, l2.prefix = false, l2.argument = n3, this.checkLValSimple(n3), this.next(), n3 = this.finishNode(l2, "UpdateExpression");
        }
      } else
        (i2 || this.privateNameStack.length === 0) && this.unexpected(), n3 = this.parsePrivateIdent(), this.type !== pa._in && this.unexpected();
      return s2 || !this.eat(pa.starstar) ? n3 : t ? void this.unexpected(this.lastTokStart) : this.buildBinary(r2, a2, n3, this.parseMaybeUnary(null, false, false, i2), "**", false);
    }, Qa.parseExprSubscripts = function(e2, t) {
      var s2 = this.start, i2 = this.startLoc, n3 = this.parseExprAtom(e2, t);
      if (n3.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")")
        return n3;
      var r2 = this.parseSubscripts(n3, s2, i2, false, t);
      return e2 && r2.type === "MemberExpression" && (e2.parenthesizedAssign >= r2.start && (e2.parenthesizedAssign = -1), e2.parenthesizedBind >= r2.start && (e2.parenthesizedBind = -1), e2.trailingComma >= r2.start && (e2.trailingComma = -1)), r2;
    }, Qa.parseSubscripts = function(e2, t, s2, i2, n3) {
      for (var r2 = this.options.ecmaVersion >= 8 && e2.type === "Identifier" && e2.name === "async" && this.lastTokEnd === e2.end && !this.canInsertSemicolon() && e2.end - e2.start == 5 && this.potentialArrowAt === e2.start, a2 = false; ; ) {
        var o2 = this.parseSubscript(e2, t, s2, i2, r2, a2, n3);
        if (o2.optional && (a2 = true), o2 === e2 || o2.type === "ArrowFunctionExpression") {
          if (a2) {
            var h3 = this.startNodeAt(t, s2);
            h3.expression = o2, o2 = this.finishNode(h3, "ChainExpression");
          }
          return o2;
        }
        e2 = o2;
      }
    }, Qa.parseSubscript = function(e2, t, s2, i2, n3, r2, a2) {
      var o2 = this.options.ecmaVersion >= 11, h3 = o2 && this.eat(pa.questionDot);
      i2 && h3 && this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
      var l2 = this.eat(pa.bracketL);
      if (l2 || h3 && this.type !== pa.parenL && this.type !== pa.backQuote || this.eat(pa.dot)) {
        var c3 = this.startNodeAt(t, s2);
        c3.object = e2, l2 ? (c3.property = this.parseExpression(), this.expect(pa.bracketR)) : this.type === pa.privateId && e2.type !== "Super" ? c3.property = this.parsePrivateIdent() : c3.property = this.parseIdent(this.options.allowReserved !== "never"), c3.computed = !!l2, o2 && (c3.optional = h3), e2 = this.finishNode(c3, "MemberExpression");
      } else if (!i2 && this.eat(pa.parenL)) {
        var u2 = new Va(), d3 = this.yieldPos, p2 = this.awaitPos, f2 = this.awaitIdentPos;
        this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0;
        var m3 = this.parseExprList(pa.parenR, this.options.ecmaVersion >= 8, false, u2);
        if (n3 && !h3 && !this.canInsertSemicolon() && this.eat(pa.arrow))
          return this.checkPatternErrors(u2, false), this.checkYieldAwaitInDefaultParams(), this.awaitIdentPos > 0 && this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"), this.yieldPos = d3, this.awaitPos = p2, this.awaitIdentPos = f2, this.parseArrowExpression(this.startNodeAt(t, s2), m3, true, a2);
        this.checkExpressionErrors(u2, true), this.yieldPos = d3 || this.yieldPos, this.awaitPos = p2 || this.awaitPos, this.awaitIdentPos = f2 || this.awaitIdentPos;
        var g2 = this.startNodeAt(t, s2);
        g2.callee = e2, g2.arguments = m3, o2 && (g2.optional = h3), e2 = this.finishNode(g2, "CallExpression");
      } else if (this.type === pa.backQuote) {
        (h3 || r2) && this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
        var y3 = this.startNodeAt(t, s2);
        y3.tag = e2, y3.quasi = this.parseTemplate({ isTagged: true }), e2 = this.finishNode(y3, "TaggedTemplateExpression");
      }
      return e2;
    }, Qa.parseExprAtom = function(e2, t) {
      this.type === pa.slash && this.readRegexp();
      var s2, i2 = this.potentialArrowAt === this.start;
      switch (this.type) {
        case pa._super:
          return this.allowSuper || this.raise(this.start, "'super' keyword outside a method"), s2 = this.startNode(), this.next(), this.type !== pa.parenL || this.allowDirectSuper || this.raise(s2.start, "super() call outside constructor of a subclass"), this.type !== pa.dot && this.type !== pa.bracketL && this.type !== pa.parenL && this.unexpected(), this.finishNode(s2, "Super");
        case pa._this:
          return s2 = this.startNode(), this.next(), this.finishNode(s2, "ThisExpression");
        case pa.name:
          var n3 = this.start, r2 = this.startLoc, a2 = this.containsEsc, o2 = this.parseIdent(false);
          if (this.options.ecmaVersion >= 8 && !a2 && o2.name === "async" && !this.canInsertSemicolon() && this.eat(pa._function))
            return this.overrideContext(Xa.f_expr), this.parseFunction(this.startNodeAt(n3, r2), 0, false, true, t);
          if (i2 && !this.canInsertSemicolon()) {
            if (this.eat(pa.arrow))
              return this.parseArrowExpression(this.startNodeAt(n3, r2), [o2], false, t);
            if (this.options.ecmaVersion >= 8 && o2.name === "async" && this.type === pa.name && !a2 && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc))
              return o2 = this.parseIdent(false), !this.canInsertSemicolon() && this.eat(pa.arrow) || this.unexpected(), this.parseArrowExpression(this.startNodeAt(n3, r2), [o2], true, t);
          }
          return o2;
        case pa.regexp:
          var h3 = this.value;
          return (s2 = this.parseLiteral(h3.value)).regex = { pattern: h3.pattern, flags: h3.flags }, s2;
        case pa.num:
        case pa.string:
          return this.parseLiteral(this.value);
        case pa._null:
        case pa._true:
        case pa._false:
          return (s2 = this.startNode()).value = this.type === pa._null ? null : this.type === pa._true, s2.raw = this.type.keyword, this.next(), this.finishNode(s2, "Literal");
        case pa.parenL:
          var l2 = this.start, c3 = this.parseParenAndDistinguishExpression(i2, t);
          return e2 && (e2.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(c3) && (e2.parenthesizedAssign = l2), e2.parenthesizedBind < 0 && (e2.parenthesizedBind = l2)), c3;
        case pa.bracketL:
          return s2 = this.startNode(), this.next(), s2.elements = this.parseExprList(pa.bracketR, true, true, e2), this.finishNode(s2, "ArrayExpression");
        case pa.braceL:
          return this.overrideContext(Xa.b_expr), this.parseObj(false, e2);
        case pa._function:
          return s2 = this.startNode(), this.next(), this.parseFunction(s2, 0);
        case pa._class:
          return this.parseClass(this.startNode(), false);
        case pa._new:
          return this.parseNew();
        case pa.backQuote:
          return this.parseTemplate();
        case pa._import:
          return this.options.ecmaVersion >= 11 ? this.parseExprImport() : this.unexpected();
        default:
          this.unexpected();
      }
    }, Qa.parseExprImport = function() {
      var e2 = this.startNode();
      this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword import");
      var t = this.parseIdent(true);
      switch (this.type) {
        case pa.parenL:
          return this.parseDynamicImport(e2);
        case pa.dot:
          return e2.meta = t, this.parseImportMeta(e2);
        default:
          this.unexpected();
      }
    }, Qa.parseDynamicImport = function(e2) {
      if (this.next(), e2.source = this.parseMaybeAssign(), !this.eat(pa.parenR)) {
        var t = this.start;
        this.eat(pa.comma) && this.eat(pa.parenR) ? this.raiseRecoverable(t, "Trailing comma is not allowed in import()") : this.unexpected(t);
      }
      return this.finishNode(e2, "ImportExpression");
    }, Qa.parseImportMeta = function(e2) {
      this.next();
      var t = this.containsEsc;
      return e2.property = this.parseIdent(true), e2.property.name !== "meta" && this.raiseRecoverable(e2.property.start, "The only valid meta property for import is 'import.meta'"), t && this.raiseRecoverable(e2.start, "'import.meta' must not contain escaped characters"), this.options.sourceType === "module" || this.options.allowImportExportEverywhere || this.raiseRecoverable(e2.start, "Cannot use 'import.meta' outside a module"), this.finishNode(e2, "MetaProperty");
    }, Qa.parseLiteral = function(e2) {
      var t = this.startNode();
      return t.value = e2, t.raw = this.input.slice(this.start, this.end), t.raw.charCodeAt(t.raw.length - 1) === 110 && (t.bigint = t.raw.slice(0, -1).replace(/_/g, "")), this.next(), this.finishNode(t, "Literal");
    }, Qa.parseParenExpression = function() {
      this.expect(pa.parenL);
      var e2 = this.parseExpression();
      return this.expect(pa.parenR), e2;
    }, Qa.parseParenAndDistinguishExpression = function(e2, t) {
      var s2, i2 = this.start, n3 = this.startLoc, r2 = this.options.ecmaVersion >= 8;
      if (this.options.ecmaVersion >= 6) {
        this.next();
        var a2, o2 = this.start, h3 = this.startLoc, l2 = [], c3 = true, u2 = false, d3 = new Va(), p2 = this.yieldPos, f2 = this.awaitPos;
        for (this.yieldPos = 0, this.awaitPos = 0; this.type !== pa.parenR; ) {
          if (c3 ? c3 = false : this.expect(pa.comma), r2 && this.afterTrailingComma(pa.parenR, true)) {
            u2 = true;
            break;
          }
          if (this.type === pa.ellipsis) {
            a2 = this.start, l2.push(this.parseParenItem(this.parseRestBinding())), this.type === pa.comma && this.raise(this.start, "Comma is not permitted after the rest element");
            break;
          }
          l2.push(this.parseMaybeAssign(false, d3, this.parseParenItem));
        }
        var m3 = this.lastTokEnd, g2 = this.lastTokEndLoc;
        if (this.expect(pa.parenR), e2 && !this.canInsertSemicolon() && this.eat(pa.arrow))
          return this.checkPatternErrors(d3, false), this.checkYieldAwaitInDefaultParams(), this.yieldPos = p2, this.awaitPos = f2, this.parseParenArrowList(i2, n3, l2, t);
        l2.length && !u2 || this.unexpected(this.lastTokStart), a2 && this.unexpected(a2), this.checkExpressionErrors(d3, true), this.yieldPos = p2 || this.yieldPos, this.awaitPos = f2 || this.awaitPos, l2.length > 1 ? ((s2 = this.startNodeAt(o2, h3)).expressions = l2, this.finishNodeAt(s2, "SequenceExpression", m3, g2)) : s2 = l2[0];
      } else
        s2 = this.parseParenExpression();
      if (this.options.preserveParens) {
        var y3 = this.startNodeAt(i2, n3);
        return y3.expression = s2, this.finishNode(y3, "ParenthesizedExpression");
      }
      return s2;
    }, Qa.parseParenItem = function(e2) {
      return e2;
    }, Qa.parseParenArrowList = function(e2, t, s2, i2) {
      return this.parseArrowExpression(this.startNodeAt(e2, t), s2, false, i2);
    };
    Ja = [];
    Qa.parseNew = function() {
      this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword new");
      var e2 = this.startNode(), t = this.parseIdent(true);
      if (this.options.ecmaVersion >= 6 && this.eat(pa.dot)) {
        e2.meta = t;
        var s2 = this.containsEsc;
        return e2.property = this.parseIdent(true), e2.property.name !== "target" && this.raiseRecoverable(e2.property.start, "The only valid meta property for new is 'new.target'"), s2 && this.raiseRecoverable(e2.start, "'new.target' must not contain escaped characters"), this.allowNewDotTarget || this.raiseRecoverable(e2.start, "'new.target' can only be used in functions and class static block"), this.finishNode(e2, "MetaProperty");
      }
      var i2 = this.start, n3 = this.startLoc, r2 = this.type === pa._import;
      return e2.callee = this.parseSubscripts(this.parseExprAtom(), i2, n3, true, false), r2 && e2.callee.type === "ImportExpression" && this.raise(i2, "Cannot use new with import()"), this.eat(pa.parenL) ? e2.arguments = this.parseExprList(pa.parenR, this.options.ecmaVersion >= 8, false) : e2.arguments = Ja, this.finishNode(e2, "NewExpression");
    }, Qa.parseTemplateElement = function(e2) {
      var t = e2.isTagged, s2 = this.startNode();
      return this.type === pa.invalidTemplate ? (t || this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal"), s2.value = { raw: this.value, cooked: null }) : s2.value = { raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"), cooked: this.value }, this.next(), s2.tail = this.type === pa.backQuote, this.finishNode(s2, "TemplateElement");
    }, Qa.parseTemplate = function(e2) {
      e2 === void 0 && (e2 = {});
      var t = e2.isTagged;
      t === void 0 && (t = false);
      var s2 = this.startNode();
      this.next(), s2.expressions = [];
      var i2 = this.parseTemplateElement({ isTagged: t });
      for (s2.quasis = [i2]; !i2.tail; )
        this.type === pa.eof && this.raise(this.pos, "Unterminated template literal"), this.expect(pa.dollarBraceL), s2.expressions.push(this.parseExpression()), this.expect(pa.braceR), s2.quasis.push(i2 = this.parseTemplateElement({ isTagged: t }));
      return this.next(), this.finishNode(s2, "TemplateLiteral");
    }, Qa.isAsyncProp = function(e2) {
      return !e2.computed && e2.key.type === "Identifier" && e2.key.name === "async" && (this.type === pa.name || this.type === pa.num || this.type === pa.string || this.type === pa.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === pa.star) && !fa.test(this.input.slice(this.lastTokEnd, this.start));
    }, Qa.parseObj = function(e2, t) {
      var s2 = this.startNode(), i2 = true, n3 = {};
      for (s2.properties = [], this.next(); !this.eat(pa.braceR); ) {
        if (i2)
          i2 = false;
        else if (this.expect(pa.comma), this.options.ecmaVersion >= 5 && this.afterTrailingComma(pa.braceR))
          break;
        var r2 = this.parseProperty(e2, t);
        e2 || this.checkPropClash(r2, n3, t), s2.properties.push(r2);
      }
      return this.finishNode(s2, e2 ? "ObjectPattern" : "ObjectExpression");
    }, Qa.parseProperty = function(e2, t) {
      var s2, i2, n3, r2, a2 = this.startNode();
      if (this.options.ecmaVersion >= 9 && this.eat(pa.ellipsis))
        return e2 ? (a2.argument = this.parseIdent(false), this.type === pa.comma && this.raise(this.start, "Comma is not permitted after the rest element"), this.finishNode(a2, "RestElement")) : (this.type === pa.parenL && t && (t.parenthesizedAssign < 0 && (t.parenthesizedAssign = this.start), t.parenthesizedBind < 0 && (t.parenthesizedBind = this.start)), a2.argument = this.parseMaybeAssign(false, t), this.type === pa.comma && t && t.trailingComma < 0 && (t.trailingComma = this.start), this.finishNode(a2, "SpreadElement"));
      this.options.ecmaVersion >= 6 && (a2.method = false, a2.shorthand = false, (e2 || t) && (n3 = this.start, r2 = this.startLoc), e2 || (s2 = this.eat(pa.star)));
      var o2 = this.containsEsc;
      return this.parsePropertyName(a2), !e2 && !o2 && this.options.ecmaVersion >= 8 && !s2 && this.isAsyncProp(a2) ? (i2 = true, s2 = this.options.ecmaVersion >= 9 && this.eat(pa.star), this.parsePropertyName(a2, t)) : i2 = false, this.parsePropertyValue(a2, e2, s2, i2, n3, r2, t, o2), this.finishNode(a2, "Property");
    }, Qa.parsePropertyValue = function(e2, t, s2, i2, n3, r2, a2, o2) {
      if ((s2 || i2) && this.type === pa.colon && this.unexpected(), this.eat(pa.colon))
        e2.value = t ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, a2), e2.kind = "init";
      else if (this.options.ecmaVersion >= 6 && this.type === pa.parenL)
        t && this.unexpected(), e2.kind = "init", e2.method = true, e2.value = this.parseMethod(s2, i2);
      else if (t || o2 || !(this.options.ecmaVersion >= 5) || e2.computed || e2.key.type !== "Identifier" || e2.key.name !== "get" && e2.key.name !== "set" || this.type === pa.comma || this.type === pa.braceR || this.type === pa.eq)
        this.options.ecmaVersion >= 6 && !e2.computed && e2.key.type === "Identifier" ? ((s2 || i2) && this.unexpected(), this.checkUnreserved(e2.key), e2.key.name !== "await" || this.awaitIdentPos || (this.awaitIdentPos = n3), e2.kind = "init", t ? e2.value = this.parseMaybeDefault(n3, r2, this.copyNode(e2.key)) : this.type === pa.eq && a2 ? (a2.shorthandAssign < 0 && (a2.shorthandAssign = this.start), e2.value = this.parseMaybeDefault(n3, r2, this.copyNode(e2.key))) : e2.value = this.copyNode(e2.key), e2.shorthand = true) : this.unexpected();
      else {
        (s2 || i2) && this.unexpected(), e2.kind = e2.key.name, this.parsePropertyName(e2), e2.value = this.parseMethod(false);
        var h3 = e2.kind === "get" ? 0 : 1;
        if (e2.value.params.length !== h3) {
          var l2 = e2.value.start;
          e2.kind === "get" ? this.raiseRecoverable(l2, "getter should have no params") : this.raiseRecoverable(l2, "setter should have exactly one param");
        } else
          e2.kind === "set" && e2.value.params[0].type === "RestElement" && this.raiseRecoverable(e2.value.params[0].start, "Setter cannot use rest params");
      }
    }, Qa.parsePropertyName = function(e2) {
      if (this.options.ecmaVersion >= 6) {
        if (this.eat(pa.bracketL))
          return e2.computed = true, e2.key = this.parseMaybeAssign(), this.expect(pa.bracketR), e2.key;
        e2.computed = false;
      }
      return e2.key = this.type === pa.num || this.type === pa.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
    }, Qa.initFunction = function(e2) {
      e2.id = null, this.options.ecmaVersion >= 6 && (e2.generator = e2.expression = false), this.options.ecmaVersion >= 8 && (e2.async = false);
    }, Qa.parseMethod = function(e2, t, s2) {
      var i2 = this.startNode(), n3 = this.yieldPos, r2 = this.awaitPos, a2 = this.awaitIdentPos;
      return this.initFunction(i2), this.options.ecmaVersion >= 6 && (i2.generator = e2), this.options.ecmaVersion >= 8 && (i2.async = !!t), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(64 | Ra(t, i2.generator) | (s2 ? 128 : 0)), this.expect(pa.parenL), i2.params = this.parseBindingList(pa.parenR, false, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams(), this.parseFunctionBody(i2, false, true, false), this.yieldPos = n3, this.awaitPos = r2, this.awaitIdentPos = a2, this.finishNode(i2, "FunctionExpression");
    }, Qa.parseArrowExpression = function(e2, t, s2, i2) {
      var n3 = this.yieldPos, r2 = this.awaitPos, a2 = this.awaitIdentPos;
      return this.enterScope(16 | Ra(s2, false)), this.initFunction(e2), this.options.ecmaVersion >= 8 && (e2.async = !!s2), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, e2.params = this.toAssignableList(t, true), this.parseFunctionBody(e2, true, false, i2), this.yieldPos = n3, this.awaitPos = r2, this.awaitIdentPos = a2, this.finishNode(e2, "ArrowFunctionExpression");
    }, Qa.parseFunctionBody = function(e2, t, s2, i2) {
      var n3 = t && this.type !== pa.braceL, r2 = this.strict, a2 = false;
      if (n3)
        e2.body = this.parseMaybeAssign(i2), e2.expression = true, this.checkParams(e2, false);
      else {
        var o2 = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(e2.params);
        r2 && !o2 || (a2 = this.strictDirective(this.end)) && o2 && this.raiseRecoverable(e2.start, "Illegal 'use strict' directive in function with non-simple parameter list");
        var h3 = this.labels;
        this.labels = [], a2 && (this.strict = true), this.checkParams(e2, !r2 && !a2 && !t && !s2 && this.isSimpleParamList(e2.params)), this.strict && e2.id && this.checkLValSimple(e2.id, 5), e2.body = this.parseBlock(false, void 0, a2 && !r2), e2.expression = false, this.adaptDirectivePrologue(e2.body.body), this.labels = h3;
      }
      this.exitScope();
    }, Qa.isSimpleParamList = function(e2) {
      for (var t = 0, s2 = e2; t < s2.length; t += 1) {
        if (s2[t].type !== "Identifier")
          return false;
      }
      return true;
    }, Qa.checkParams = function(e2, t) {
      for (var s2 = /* @__PURE__ */ Object.create(null), i2 = 0, n3 = e2.params; i2 < n3.length; i2 += 1) {
        var r2 = n3[i2];
        this.checkLValInnerPattern(r2, 1, t ? null : s2);
      }
    }, Qa.parseExprList = function(e2, t, s2, i2) {
      for (var n3 = [], r2 = true; !this.eat(e2); ) {
        if (r2)
          r2 = false;
        else if (this.expect(pa.comma), t && this.afterTrailingComma(e2))
          break;
        var a2 = void 0;
        s2 && this.type === pa.comma ? a2 = null : this.type === pa.ellipsis ? (a2 = this.parseSpread(i2), i2 && this.type === pa.comma && i2.trailingComma < 0 && (i2.trailingComma = this.start)) : a2 = this.parseMaybeAssign(false, i2), n3.push(a2);
      }
      return n3;
    }, Qa.checkUnreserved = function(e2) {
      var t = e2.start, s2 = e2.end, i2 = e2.name;
      (this.inGenerator && i2 === "yield" && this.raiseRecoverable(t, "Cannot use 'yield' as identifier inside a generator"), this.inAsync && i2 === "await" && this.raiseRecoverable(t, "Cannot use 'await' as identifier inside an async function"), this.currentThisScope().inClassFieldInit && i2 === "arguments" && this.raiseRecoverable(t, "Cannot use 'arguments' in class field initializer"), !this.inClassStaticBlock || i2 !== "arguments" && i2 !== "await" || this.raise(t, "Cannot use " + i2 + " in class static initialization block"), this.keywords.test(i2) && this.raise(t, "Unexpected keyword '" + i2 + "'"), this.options.ecmaVersion < 6 && this.input.slice(t, s2).indexOf("\\") !== -1) || (this.strict ? this.reservedWordsStrict : this.reservedWords).test(i2) && (this.inAsync || i2 !== "await" || this.raiseRecoverable(t, "Cannot use keyword 'await' outside an async function"), this.raiseRecoverable(t, "The keyword '" + i2 + "' is reserved"));
    }, Qa.parseIdent = function(e2, t) {
      var s2 = this.startNode();
      return this.type === pa.name ? s2.name = this.value : this.type.keyword ? (s2.name = this.type.keyword, s2.name !== "class" && s2.name !== "function" || this.lastTokEnd === this.lastTokStart + 1 && this.input.charCodeAt(this.lastTokStart) === 46 || this.context.pop()) : this.unexpected(), this.next(!!e2), this.finishNode(s2, "Identifier"), e2 || (this.checkUnreserved(s2), s2.name !== "await" || this.awaitIdentPos || (this.awaitIdentPos = s2.start)), s2;
    }, Qa.parsePrivateIdent = function() {
      var e2 = this.startNode();
      return this.type === pa.privateId ? e2.name = this.value : this.unexpected(), this.next(), this.finishNode(e2, "PrivateIdentifier"), this.privateNameStack.length === 0 ? this.raise(e2.start, "Private field '#" + e2.name + "' must be declared in an enclosing class") : this.privateNameStack[this.privateNameStack.length - 1].used.push(e2), e2;
    }, Qa.parseYield = function(e2) {
      this.yieldPos || (this.yieldPos = this.start);
      var t = this.startNode();
      return this.next(), this.type === pa.semi || this.canInsertSemicolon() || this.type !== pa.star && !this.type.startsExpr ? (t.delegate = false, t.argument = null) : (t.delegate = this.eat(pa.star), t.argument = this.parseMaybeAssign(e2)), this.finishNode(t, "YieldExpression");
    }, Qa.parseAwait = function(e2) {
      this.awaitPos || (this.awaitPos = this.start);
      var t = this.startNode();
      return this.next(), t.argument = this.parseMaybeUnary(null, true, false, e2), this.finishNode(t, "AwaitExpression");
    };
    eo = Ma.prototype;
    eo.raise = function(e2, t) {
      var s2 = Na(this.input, e2);
      t += " (" + s2.line + ":" + s2.column + ")";
      var i2 = new SyntaxError(t);
      throw i2.pos = e2, i2.loc = s2, i2.raisedAt = this.pos, i2;
    }, eo.raiseRecoverable = eo.raise, eo.curPosition = function() {
      if (this.options.locations)
        return new Ca(this.curLine, this.pos - this.lineStart);
    };
    to = Ma.prototype;
    so = function(e2) {
      this.flags = e2, this.var = [], this.lexical = [], this.functions = [], this.inClassFieldInit = false;
    };
    to.enterScope = function(e2) {
      this.scopeStack.push(new so(e2));
    }, to.exitScope = function() {
      this.scopeStack.pop();
    }, to.treatFunctionsAsVarInScope = function(e2) {
      return 2 & e2.flags || !this.inModule && 1 & e2.flags;
    }, to.declareName = function(e2, t, s2) {
      var i2 = false;
      if (t === 2) {
        var n3 = this.currentScope();
        i2 = n3.lexical.indexOf(e2) > -1 || n3.functions.indexOf(e2) > -1 || n3.var.indexOf(e2) > -1, n3.lexical.push(e2), this.inModule && 1 & n3.flags && delete this.undefinedExports[e2];
      } else if (t === 4) {
        this.currentScope().lexical.push(e2);
      } else if (t === 3) {
        var r2 = this.currentScope();
        i2 = this.treatFunctionsAsVar ? r2.lexical.indexOf(e2) > -1 : r2.lexical.indexOf(e2) > -1 || r2.var.indexOf(e2) > -1, r2.functions.push(e2);
      } else
        for (var a2 = this.scopeStack.length - 1; a2 >= 0; --a2) {
          var o2 = this.scopeStack[a2];
          if (o2.lexical.indexOf(e2) > -1 && !(32 & o2.flags && o2.lexical[0] === e2) || !this.treatFunctionsAsVarInScope(o2) && o2.functions.indexOf(e2) > -1) {
            i2 = true;
            break;
          }
          if (o2.var.push(e2), this.inModule && 1 & o2.flags && delete this.undefinedExports[e2], 259 & o2.flags)
            break;
        }
      i2 && this.raiseRecoverable(s2, "Identifier '" + e2 + "' has already been declared");
    }, to.checkLocalExport = function(e2) {
      this.scopeStack[0].lexical.indexOf(e2.name) === -1 && this.scopeStack[0].var.indexOf(e2.name) === -1 && (this.undefinedExports[e2.name] = e2);
    }, to.currentScope = function() {
      return this.scopeStack[this.scopeStack.length - 1];
    }, to.currentVarScope = function() {
      for (var e2 = this.scopeStack.length - 1; ; e2--) {
        var t = this.scopeStack[e2];
        if (259 & t.flags)
          return t;
      }
    }, to.currentThisScope = function() {
      for (var e2 = this.scopeStack.length - 1; ; e2--) {
        var t = this.scopeStack[e2];
        if (259 & t.flags && !(16 & t.flags))
          return t;
      }
    };
    io = function(e2, t, s2) {
      this.type = "", this.start = t, this.end = 0, e2.options.locations && (this.loc = new Ia(e2, s2)), e2.options.directSourceFile && (this.sourceFile = e2.options.directSourceFile), e2.options.ranges && (this.range = [t, 0]);
    };
    no = Ma.prototype;
    no.startNode = function() {
      return new io(this, this.start, this.startLoc);
    }, no.startNodeAt = function(e2, t) {
      return new io(this, e2, t);
    }, no.finishNode = function(e2, t) {
      return ro.call(this, e2, t, this.lastTokEnd, this.lastTokEndLoc);
    }, no.finishNodeAt = function(e2, t, s2, i2) {
      return ro.call(this, e2, t, s2, i2);
    }, no.copyNode = function(e2) {
      var t = new io(this, e2.start, this.startLoc);
      for (var s2 in e2)
        t[s2] = e2[s2];
      return t;
    };
    ao = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
    oo = ao + " Extended_Pictographic";
    ho = oo + " EBase EComp EMod EPres ExtPict";
    lo = { 9: ao, 10: oo, 11: oo, 12: ho, 13: "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS Extended_Pictographic EBase EComp EMod EPres ExtPict" };
    co = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
    uo = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
    po = uo + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
    fo = po + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
    mo = fo + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
    go = { 9: uo, 10: po, 11: fo, 12: mo, 13: "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith" };
    yo = {};
    for (xo = 0, vo = [9, 10, 11, 12, 13]; xo < vo.length; xo += 1) {
      Eo(vo[xo]);
    }
    bo = Ma.prototype;
    So = function(e2) {
      this.parser = e2, this.validFlags = "gim" + (e2.options.ecmaVersion >= 6 ? "uy" : "") + (e2.options.ecmaVersion >= 9 ? "s" : "") + (e2.options.ecmaVersion >= 13 ? "d" : ""), this.unicodeProperties = yo[e2.options.ecmaVersion >= 13 ? 13 : e2.options.ecmaVersion], this.source = "", this.flags = "", this.start = 0, this.switchU = false, this.switchN = false, this.pos = 0, this.lastIntValue = 0, this.lastStringValue = "", this.lastAssertionIsQuantifiable = false, this.numCapturingParens = 0, this.maxBackReference = 0, this.groupNames = [], this.backReferenceNames = [];
    };
    So.prototype.reset = function(e2, t, s2) {
      var i2 = s2.indexOf("u") !== -1;
      this.start = 0 | e2, this.source = t + "", this.flags = s2, this.switchU = i2 && this.parser.options.ecmaVersion >= 6, this.switchN = i2 && this.parser.options.ecmaVersion >= 9;
    }, So.prototype.raise = function(e2) {
      this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + e2);
    }, So.prototype.at = function(e2, t) {
      t === void 0 && (t = false);
      var s2 = this.source, i2 = s2.length;
      if (e2 >= i2)
        return -1;
      var n3 = s2.charCodeAt(e2);
      if (!t && !this.switchU || n3 <= 55295 || n3 >= 57344 || e2 + 1 >= i2)
        return n3;
      var r2 = s2.charCodeAt(e2 + 1);
      return r2 >= 56320 && r2 <= 57343 ? (n3 << 10) + r2 - 56613888 : n3;
    }, So.prototype.nextIndex = function(e2, t) {
      t === void 0 && (t = false);
      var s2 = this.source, i2 = s2.length;
      if (e2 >= i2)
        return i2;
      var n3, r2 = s2.charCodeAt(e2);
      return !t && !this.switchU || r2 <= 55295 || r2 >= 57344 || e2 + 1 >= i2 || (n3 = s2.charCodeAt(e2 + 1)) < 56320 || n3 > 57343 ? e2 + 1 : e2 + 2;
    }, So.prototype.current = function(e2) {
      return e2 === void 0 && (e2 = false), this.at(this.pos, e2);
    }, So.prototype.lookahead = function(e2) {
      return e2 === void 0 && (e2 = false), this.at(this.nextIndex(this.pos, e2), e2);
    }, So.prototype.advance = function(e2) {
      e2 === void 0 && (e2 = false), this.pos = this.nextIndex(this.pos, e2);
    }, So.prototype.eat = function(e2, t) {
      return t === void 0 && (t = false), this.current(t) === e2 && (this.advance(t), true);
    }, bo.validateRegExpFlags = function(e2) {
      for (var t = e2.validFlags, s2 = e2.flags, i2 = 0; i2 < s2.length; i2++) {
        var n3 = s2.charAt(i2);
        t.indexOf(n3) === -1 && this.raise(e2.start, "Invalid regular expression flag"), s2.indexOf(n3, i2 + 1) > -1 && this.raise(e2.start, "Duplicate regular expression flag");
      }
    }, bo.validateRegExpPattern = function(e2) {
      this.regexp_pattern(e2), !e2.switchN && this.options.ecmaVersion >= 9 && e2.groupNames.length > 0 && (e2.switchN = true, this.regexp_pattern(e2));
    }, bo.regexp_pattern = function(e2) {
      e2.pos = 0, e2.lastIntValue = 0, e2.lastStringValue = "", e2.lastAssertionIsQuantifiable = false, e2.numCapturingParens = 0, e2.maxBackReference = 0, e2.groupNames.length = 0, e2.backReferenceNames.length = 0, this.regexp_disjunction(e2), e2.pos !== e2.source.length && (e2.eat(41) && e2.raise("Unmatched ')'"), (e2.eat(93) || e2.eat(125)) && e2.raise("Lone quantifier brackets")), e2.maxBackReference > e2.numCapturingParens && e2.raise("Invalid escape");
      for (var t = 0, s2 = e2.backReferenceNames; t < s2.length; t += 1) {
        var i2 = s2[t];
        e2.groupNames.indexOf(i2) === -1 && e2.raise("Invalid named capture referenced");
      }
    }, bo.regexp_disjunction = function(e2) {
      for (this.regexp_alternative(e2); e2.eat(124); )
        this.regexp_alternative(e2);
      this.regexp_eatQuantifier(e2, true) && e2.raise("Nothing to repeat"), e2.eat(123) && e2.raise("Lone quantifier brackets");
    }, bo.regexp_alternative = function(e2) {
      for (; e2.pos < e2.source.length && this.regexp_eatTerm(e2); )
        ;
    }, bo.regexp_eatTerm = function(e2) {
      return this.regexp_eatAssertion(e2) ? (e2.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(e2) && e2.switchU && e2.raise("Invalid quantifier"), true) : !!(e2.switchU ? this.regexp_eatAtom(e2) : this.regexp_eatExtendedAtom(e2)) && (this.regexp_eatQuantifier(e2), true);
    }, bo.regexp_eatAssertion = function(e2) {
      var t = e2.pos;
      if (e2.lastAssertionIsQuantifiable = false, e2.eat(94) || e2.eat(36))
        return true;
      if (e2.eat(92)) {
        if (e2.eat(66) || e2.eat(98))
          return true;
        e2.pos = t;
      }
      if (e2.eat(40) && e2.eat(63)) {
        var s2 = false;
        if (this.options.ecmaVersion >= 9 && (s2 = e2.eat(60)), e2.eat(61) || e2.eat(33))
          return this.regexp_disjunction(e2), e2.eat(41) || e2.raise("Unterminated group"), e2.lastAssertionIsQuantifiable = !s2, true;
      }
      return e2.pos = t, false;
    }, bo.regexp_eatQuantifier = function(e2, t) {
      return t === void 0 && (t = false), !!this.regexp_eatQuantifierPrefix(e2, t) && (e2.eat(63), true);
    }, bo.regexp_eatQuantifierPrefix = function(e2, t) {
      return e2.eat(42) || e2.eat(43) || e2.eat(63) || this.regexp_eatBracedQuantifier(e2, t);
    }, bo.regexp_eatBracedQuantifier = function(e2, t) {
      var s2 = e2.pos;
      if (e2.eat(123)) {
        var i2 = 0, n3 = -1;
        if (this.regexp_eatDecimalDigits(e2) && (i2 = e2.lastIntValue, e2.eat(44) && this.regexp_eatDecimalDigits(e2) && (n3 = e2.lastIntValue), e2.eat(125)))
          return n3 !== -1 && n3 < i2 && !t && e2.raise("numbers out of order in {} quantifier"), true;
        e2.switchU && !t && e2.raise("Incomplete quantifier"), e2.pos = s2;
      }
      return false;
    }, bo.regexp_eatAtom = function(e2) {
      return this.regexp_eatPatternCharacters(e2) || e2.eat(46) || this.regexp_eatReverseSolidusAtomEscape(e2) || this.regexp_eatCharacterClass(e2) || this.regexp_eatUncapturingGroup(e2) || this.regexp_eatCapturingGroup(e2);
    }, bo.regexp_eatReverseSolidusAtomEscape = function(e2) {
      var t = e2.pos;
      if (e2.eat(92)) {
        if (this.regexp_eatAtomEscape(e2))
          return true;
        e2.pos = t;
      }
      return false;
    }, bo.regexp_eatUncapturingGroup = function(e2) {
      var t = e2.pos;
      if (e2.eat(40)) {
        if (e2.eat(63) && e2.eat(58)) {
          if (this.regexp_disjunction(e2), e2.eat(41))
            return true;
          e2.raise("Unterminated group");
        }
        e2.pos = t;
      }
      return false;
    }, bo.regexp_eatCapturingGroup = function(e2) {
      if (e2.eat(40)) {
        if (this.options.ecmaVersion >= 9 ? this.regexp_groupSpecifier(e2) : e2.current() === 63 && e2.raise("Invalid group"), this.regexp_disjunction(e2), e2.eat(41))
          return e2.numCapturingParens += 1, true;
        e2.raise("Unterminated group");
      }
      return false;
    }, bo.regexp_eatExtendedAtom = function(e2) {
      return e2.eat(46) || this.regexp_eatReverseSolidusAtomEscape(e2) || this.regexp_eatCharacterClass(e2) || this.regexp_eatUncapturingGroup(e2) || this.regexp_eatCapturingGroup(e2) || this.regexp_eatInvalidBracedQuantifier(e2) || this.regexp_eatExtendedPatternCharacter(e2);
    }, bo.regexp_eatInvalidBracedQuantifier = function(e2) {
      return this.regexp_eatBracedQuantifier(e2, true) && e2.raise("Nothing to repeat"), false;
    }, bo.regexp_eatSyntaxCharacter = function(e2) {
      var t = e2.current();
      return !!Po(t) && (e2.lastIntValue = t, e2.advance(), true);
    }, bo.regexp_eatPatternCharacters = function(e2) {
      for (var t = e2.pos, s2 = 0; (s2 = e2.current()) !== -1 && !Po(s2); )
        e2.advance();
      return e2.pos !== t;
    }, bo.regexp_eatExtendedPatternCharacter = function(e2) {
      var t = e2.current();
      return !(t === -1 || t === 36 || t >= 40 && t <= 43 || t === 46 || t === 63 || t === 91 || t === 94 || t === 124) && (e2.advance(), true);
    }, bo.regexp_groupSpecifier = function(e2) {
      if (e2.eat(63)) {
        if (this.regexp_eatGroupName(e2))
          return e2.groupNames.indexOf(e2.lastStringValue) !== -1 && e2.raise("Duplicate capture group name"), void e2.groupNames.push(e2.lastStringValue);
        e2.raise("Invalid group");
      }
    }, bo.regexp_eatGroupName = function(e2) {
      if (e2.lastStringValue = "", e2.eat(60)) {
        if (this.regexp_eatRegExpIdentifierName(e2) && e2.eat(62))
          return true;
        e2.raise("Invalid capture group name");
      }
      return false;
    }, bo.regexp_eatRegExpIdentifierName = function(e2) {
      if (e2.lastStringValue = "", this.regexp_eatRegExpIdentifierStart(e2)) {
        for (e2.lastStringValue += Ao(e2.lastIntValue); this.regexp_eatRegExpIdentifierPart(e2); )
          e2.lastStringValue += Ao(e2.lastIntValue);
        return true;
      }
      return false;
    }, bo.regexp_eatRegExpIdentifierStart = function(e2) {
      var t = e2.pos, s2 = this.options.ecmaVersion >= 11, i2 = e2.current(s2);
      return e2.advance(s2), i2 === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(e2, s2) && (i2 = e2.lastIntValue), function(e3) {
        return ra(e3, true) || e3 === 36 || e3 === 95;
      }(i2) ? (e2.lastIntValue = i2, true) : (e2.pos = t, false);
    }, bo.regexp_eatRegExpIdentifierPart = function(e2) {
      var t = e2.pos, s2 = this.options.ecmaVersion >= 11, i2 = e2.current(s2);
      return e2.advance(s2), i2 === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(e2, s2) && (i2 = e2.lastIntValue), function(e3) {
        return aa(e3, true) || e3 === 36 || e3 === 95 || e3 === 8204 || e3 === 8205;
      }(i2) ? (e2.lastIntValue = i2, true) : (e2.pos = t, false);
    }, bo.regexp_eatAtomEscape = function(e2) {
      return !!(this.regexp_eatBackReference(e2) || this.regexp_eatCharacterClassEscape(e2) || this.regexp_eatCharacterEscape(e2) || e2.switchN && this.regexp_eatKGroupName(e2)) || (e2.switchU && (e2.current() === 99 && e2.raise("Invalid unicode escape"), e2.raise("Invalid escape")), false);
    }, bo.regexp_eatBackReference = function(e2) {
      var t = e2.pos;
      if (this.regexp_eatDecimalEscape(e2)) {
        var s2 = e2.lastIntValue;
        if (e2.switchU)
          return s2 > e2.maxBackReference && (e2.maxBackReference = s2), true;
        if (s2 <= e2.numCapturingParens)
          return true;
        e2.pos = t;
      }
      return false;
    }, bo.regexp_eatKGroupName = function(e2) {
      if (e2.eat(107)) {
        if (this.regexp_eatGroupName(e2))
          return e2.backReferenceNames.push(e2.lastStringValue), true;
        e2.raise("Invalid named reference");
      }
      return false;
    }, bo.regexp_eatCharacterEscape = function(e2) {
      return this.regexp_eatControlEscape(e2) || this.regexp_eatCControlLetter(e2) || this.regexp_eatZero(e2) || this.regexp_eatHexEscapeSequence(e2) || this.regexp_eatRegExpUnicodeEscapeSequence(e2, false) || !e2.switchU && this.regexp_eatLegacyOctalEscapeSequence(e2) || this.regexp_eatIdentityEscape(e2);
    }, bo.regexp_eatCControlLetter = function(e2) {
      var t = e2.pos;
      if (e2.eat(99)) {
        if (this.regexp_eatControlLetter(e2))
          return true;
        e2.pos = t;
      }
      return false;
    }, bo.regexp_eatZero = function(e2) {
      return e2.current() === 48 && !Io(e2.lookahead()) && (e2.lastIntValue = 0, e2.advance(), true);
    }, bo.regexp_eatControlEscape = function(e2) {
      var t = e2.current();
      return t === 116 ? (e2.lastIntValue = 9, e2.advance(), true) : t === 110 ? (e2.lastIntValue = 10, e2.advance(), true) : t === 118 ? (e2.lastIntValue = 11, e2.advance(), true) : t === 102 ? (e2.lastIntValue = 12, e2.advance(), true) : t === 114 && (e2.lastIntValue = 13, e2.advance(), true);
    }, bo.regexp_eatControlLetter = function(e2) {
      var t = e2.current();
      return !!ko(t) && (e2.lastIntValue = t % 32, e2.advance(), true);
    }, bo.regexp_eatRegExpUnicodeEscapeSequence = function(e2, t) {
      t === void 0 && (t = false);
      var s2, i2 = e2.pos, n3 = t || e2.switchU;
      if (e2.eat(117)) {
        if (this.regexp_eatFixedHexDigits(e2, 4)) {
          var r2 = e2.lastIntValue;
          if (n3 && r2 >= 55296 && r2 <= 56319) {
            var a2 = e2.pos;
            if (e2.eat(92) && e2.eat(117) && this.regexp_eatFixedHexDigits(e2, 4)) {
              var o2 = e2.lastIntValue;
              if (o2 >= 56320 && o2 <= 57343)
                return e2.lastIntValue = 1024 * (r2 - 55296) + (o2 - 56320) + 65536, true;
            }
            e2.pos = a2, e2.lastIntValue = r2;
          }
          return true;
        }
        if (n3 && e2.eat(123) && this.regexp_eatHexDigits(e2) && e2.eat(125) && ((s2 = e2.lastIntValue) >= 0 && s2 <= 1114111))
          return true;
        n3 && e2.raise("Invalid unicode escape"), e2.pos = i2;
      }
      return false;
    }, bo.regexp_eatIdentityEscape = function(e2) {
      if (e2.switchU)
        return !!this.regexp_eatSyntaxCharacter(e2) || !!e2.eat(47) && (e2.lastIntValue = 47, true);
      var t = e2.current();
      return !(t === 99 || e2.switchN && t === 107) && (e2.lastIntValue = t, e2.advance(), true);
    }, bo.regexp_eatDecimalEscape = function(e2) {
      e2.lastIntValue = 0;
      var t = e2.current();
      if (t >= 49 && t <= 57) {
        do {
          e2.lastIntValue = 10 * e2.lastIntValue + (t - 48), e2.advance();
        } while ((t = e2.current()) >= 48 && t <= 57);
        return true;
      }
      return false;
    }, bo.regexp_eatCharacterClassEscape = function(e2) {
      var t = e2.current();
      if (function(e3) {
        return e3 === 100 || e3 === 68 || e3 === 115 || e3 === 83 || e3 === 119 || e3 === 87;
      }(t))
        return e2.lastIntValue = -1, e2.advance(), true;
      if (e2.switchU && this.options.ecmaVersion >= 9 && (t === 80 || t === 112)) {
        if (e2.lastIntValue = -1, e2.advance(), e2.eat(123) && this.regexp_eatUnicodePropertyValueExpression(e2) && e2.eat(125))
          return true;
        e2.raise("Invalid property name");
      }
      return false;
    }, bo.regexp_eatUnicodePropertyValueExpression = function(e2) {
      var t = e2.pos;
      if (this.regexp_eatUnicodePropertyName(e2) && e2.eat(61)) {
        var s2 = e2.lastStringValue;
        if (this.regexp_eatUnicodePropertyValue(e2)) {
          var i2 = e2.lastStringValue;
          return this.regexp_validateUnicodePropertyNameAndValue(e2, s2, i2), true;
        }
      }
      if (e2.pos = t, this.regexp_eatLoneUnicodePropertyNameOrValue(e2)) {
        var n3 = e2.lastStringValue;
        return this.regexp_validateUnicodePropertyNameOrValue(e2, n3), true;
      }
      return false;
    }, bo.regexp_validateUnicodePropertyNameAndValue = function(e2, t, s2) {
      Aa(e2.unicodeProperties.nonBinary, t) || e2.raise("Invalid property name"), e2.unicodeProperties.nonBinary[t].test(s2) || e2.raise("Invalid property value");
    }, bo.regexp_validateUnicodePropertyNameOrValue = function(e2, t) {
      e2.unicodeProperties.binary.test(t) || e2.raise("Invalid property name");
    }, bo.regexp_eatUnicodePropertyName = function(e2) {
      var t = 0;
      for (e2.lastStringValue = ""; wo(t = e2.current()); )
        e2.lastStringValue += Ao(t), e2.advance();
      return e2.lastStringValue !== "";
    }, bo.regexp_eatUnicodePropertyValue = function(e2) {
      var t = 0;
      for (e2.lastStringValue = ""; Co(t = e2.current()); )
        e2.lastStringValue += Ao(t), e2.advance();
      return e2.lastStringValue !== "";
    }, bo.regexp_eatLoneUnicodePropertyNameOrValue = function(e2) {
      return this.regexp_eatUnicodePropertyValue(e2);
    }, bo.regexp_eatCharacterClass = function(e2) {
      if (e2.eat(91)) {
        if (e2.eat(94), this.regexp_classRanges(e2), e2.eat(93))
          return true;
        e2.raise("Unterminated character class");
      }
      return false;
    }, bo.regexp_classRanges = function(e2) {
      for (; this.regexp_eatClassAtom(e2); ) {
        var t = e2.lastIntValue;
        if (e2.eat(45) && this.regexp_eatClassAtom(e2)) {
          var s2 = e2.lastIntValue;
          !e2.switchU || t !== -1 && s2 !== -1 || e2.raise("Invalid character class"), t !== -1 && s2 !== -1 && t > s2 && e2.raise("Range out of order in character class");
        }
      }
    }, bo.regexp_eatClassAtom = function(e2) {
      var t = e2.pos;
      if (e2.eat(92)) {
        if (this.regexp_eatClassEscape(e2))
          return true;
        if (e2.switchU) {
          var s2 = e2.current();
          (s2 === 99 || $o(s2)) && e2.raise("Invalid class escape"), e2.raise("Invalid escape");
        }
        e2.pos = t;
      }
      var i2 = e2.current();
      return i2 !== 93 && (e2.lastIntValue = i2, e2.advance(), true);
    }, bo.regexp_eatClassEscape = function(e2) {
      var t = e2.pos;
      if (e2.eat(98))
        return e2.lastIntValue = 8, true;
      if (e2.switchU && e2.eat(45))
        return e2.lastIntValue = 45, true;
      if (!e2.switchU && e2.eat(99)) {
        if (this.regexp_eatClassControlLetter(e2))
          return true;
        e2.pos = t;
      }
      return this.regexp_eatCharacterClassEscape(e2) || this.regexp_eatCharacterEscape(e2);
    }, bo.regexp_eatClassControlLetter = function(e2) {
      var t = e2.current();
      return !(!Io(t) && t !== 95) && (e2.lastIntValue = t % 32, e2.advance(), true);
    }, bo.regexp_eatHexEscapeSequence = function(e2) {
      var t = e2.pos;
      if (e2.eat(120)) {
        if (this.regexp_eatFixedHexDigits(e2, 2))
          return true;
        e2.switchU && e2.raise("Invalid escape"), e2.pos = t;
      }
      return false;
    }, bo.regexp_eatDecimalDigits = function(e2) {
      var t = e2.pos, s2 = 0;
      for (e2.lastIntValue = 0; Io(s2 = e2.current()); )
        e2.lastIntValue = 10 * e2.lastIntValue + (s2 - 48), e2.advance();
      return e2.pos !== t;
    }, bo.regexp_eatHexDigits = function(e2) {
      var t = e2.pos, s2 = 0;
      for (e2.lastIntValue = 0; No(s2 = e2.current()); )
        e2.lastIntValue = 16 * e2.lastIntValue + _o(s2), e2.advance();
      return e2.pos !== t;
    }, bo.regexp_eatLegacyOctalEscapeSequence = function(e2) {
      if (this.regexp_eatOctalDigit(e2)) {
        var t = e2.lastIntValue;
        if (this.regexp_eatOctalDigit(e2)) {
          var s2 = e2.lastIntValue;
          t <= 3 && this.regexp_eatOctalDigit(e2) ? e2.lastIntValue = 64 * t + 8 * s2 + e2.lastIntValue : e2.lastIntValue = 8 * t + s2;
        } else
          e2.lastIntValue = t;
        return true;
      }
      return false;
    }, bo.regexp_eatOctalDigit = function(e2) {
      var t = e2.current();
      return $o(t) ? (e2.lastIntValue = t - 48, e2.advance(), true) : (e2.lastIntValue = 0, false);
    }, bo.regexp_eatFixedHexDigits = function(e2, t) {
      var s2 = e2.pos;
      e2.lastIntValue = 0;
      for (var i2 = 0; i2 < t; ++i2) {
        var n3 = e2.current();
        if (!No(n3))
          return e2.pos = s2, false;
        e2.lastIntValue = 16 * e2.lastIntValue + _o(n3), e2.advance();
      }
      return true;
    };
    To = function(e2) {
      this.type = e2.type, this.value = e2.value, this.start = e2.start, this.end = e2.end, e2.options.locations && (this.loc = new Ia(e2, e2.startLoc, e2.endLoc)), e2.options.ranges && (this.range = [e2.start, e2.end]);
    };
    Ro = Ma.prototype;
    Ro.next = function(e2) {
      !e2 && this.type.keyword && this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword), this.options.onToken && this.options.onToken(new To(this)), this.lastTokEnd = this.end, this.lastTokStart = this.start, this.lastTokEndLoc = this.endLoc, this.lastTokStartLoc = this.startLoc, this.nextToken();
    }, Ro.getToken = function() {
      return this.next(), new To(this);
    }, typeof Symbol != "undefined" && (Ro[Symbol.iterator] = function() {
      var e2 = this;
      return { next: function() {
        var t = e2.getToken();
        return { done: t.type === pa.eof, value: t };
      } };
    }), Ro.nextToken = function() {
      var e2 = this.curContext();
      return e2 && e2.preserveSpace || this.skipSpace(), this.start = this.pos, this.options.locations && (this.startLoc = this.curPosition()), this.pos >= this.input.length ? this.finishToken(pa.eof) : e2.override ? e2.override(this) : void this.readToken(this.fullCharCodeAtPos());
    }, Ro.readToken = function(e2) {
      return ra(e2, this.options.ecmaVersion >= 6) || e2 === 92 ? this.readWord() : this.getTokenFromCode(e2);
    }, Ro.fullCharCodeAtPos = function() {
      var e2 = this.input.charCodeAt(this.pos);
      if (e2 <= 55295 || e2 >= 56320)
        return e2;
      var t = this.input.charCodeAt(this.pos + 1);
      return t <= 56319 || t >= 57344 ? e2 : (e2 << 10) + t - 56613888;
    }, Ro.skipBlockComment = function() {
      var e2 = this.options.onComment && this.curPosition(), t = this.pos, s2 = this.input.indexOf("*/", this.pos += 2);
      if (s2 === -1 && this.raise(this.pos - 2, "Unterminated comment"), this.pos = s2 + 2, this.options.locations)
        for (var i2 = void 0, n3 = t; (i2 = ya(this.input, n3, this.pos)) > -1; )
          ++this.curLine, n3 = this.lineStart = i2;
      this.options.onComment && this.options.onComment(true, this.input.slice(t + 2, s2), t, this.pos, e2, this.curPosition());
    }, Ro.skipLineComment = function(e2) {
      for (var t = this.pos, s2 = this.options.onComment && this.curPosition(), i2 = this.input.charCodeAt(this.pos += e2); this.pos < this.input.length && !ga(i2); )
        i2 = this.input.charCodeAt(++this.pos);
      this.options.onComment && this.options.onComment(false, this.input.slice(t + e2, this.pos), t, this.pos, s2, this.curPosition());
    }, Ro.skipSpace = function() {
      e:
        for (; this.pos < this.input.length; ) {
          var e2 = this.input.charCodeAt(this.pos);
          switch (e2) {
            case 32:
            case 160:
              ++this.pos;
              break;
            case 13:
              this.input.charCodeAt(this.pos + 1) === 10 && ++this.pos;
            case 10:
            case 8232:
            case 8233:
              ++this.pos, this.options.locations && (++this.curLine, this.lineStart = this.pos);
              break;
            case 47:
              switch (this.input.charCodeAt(this.pos + 1)) {
                case 42:
                  this.skipBlockComment();
                  break;
                case 47:
                  this.skipLineComment(2);
                  break;
                default:
                  break e;
              }
              break;
            default:
              if (!(e2 > 8 && e2 < 14 || e2 >= 5760 && Ea.test(String.fromCharCode(e2))))
                break e;
              ++this.pos;
          }
        }
    }, Ro.finishToken = function(e2, t) {
      this.end = this.pos, this.options.locations && (this.endLoc = this.curPosition());
      var s2 = this.type;
      this.type = e2, this.value = t, this.updateContext(s2);
    }, Ro.readToken_dot = function() {
      var e2 = this.input.charCodeAt(this.pos + 1);
      if (e2 >= 48 && e2 <= 57)
        return this.readNumber(true);
      var t = this.input.charCodeAt(this.pos + 2);
      return this.options.ecmaVersion >= 6 && e2 === 46 && t === 46 ? (this.pos += 3, this.finishToken(pa.ellipsis)) : (++this.pos, this.finishToken(pa.dot));
    }, Ro.readToken_slash = function() {
      var e2 = this.input.charCodeAt(this.pos + 1);
      return this.exprAllowed ? (++this.pos, this.readRegexp()) : e2 === 61 ? this.finishOp(pa.assign, 2) : this.finishOp(pa.slash, 1);
    }, Ro.readToken_mult_modulo_exp = function(e2) {
      var t = this.input.charCodeAt(this.pos + 1), s2 = 1, i2 = e2 === 42 ? pa.star : pa.modulo;
      return this.options.ecmaVersion >= 7 && e2 === 42 && t === 42 && (++s2, i2 = pa.starstar, t = this.input.charCodeAt(this.pos + 2)), t === 61 ? this.finishOp(pa.assign, s2 + 1) : this.finishOp(i2, s2);
    }, Ro.readToken_pipe_amp = function(e2) {
      var t = this.input.charCodeAt(this.pos + 1);
      if (t === e2) {
        if (this.options.ecmaVersion >= 12) {
          if (this.input.charCodeAt(this.pos + 2) === 61)
            return this.finishOp(pa.assign, 3);
        }
        return this.finishOp(e2 === 124 ? pa.logicalOR : pa.logicalAND, 2);
      }
      return t === 61 ? this.finishOp(pa.assign, 2) : this.finishOp(e2 === 124 ? pa.bitwiseOR : pa.bitwiseAND, 1);
    }, Ro.readToken_caret = function() {
      return this.input.charCodeAt(this.pos + 1) === 61 ? this.finishOp(pa.assign, 2) : this.finishOp(pa.bitwiseXOR, 1);
    }, Ro.readToken_plus_min = function(e2) {
      var t = this.input.charCodeAt(this.pos + 1);
      return t === e2 ? t !== 45 || this.inModule || this.input.charCodeAt(this.pos + 2) !== 62 || this.lastTokEnd !== 0 && !fa.test(this.input.slice(this.lastTokEnd, this.pos)) ? this.finishOp(pa.incDec, 2) : (this.skipLineComment(3), this.skipSpace(), this.nextToken()) : t === 61 ? this.finishOp(pa.assign, 2) : this.finishOp(pa.plusMin, 1);
    }, Ro.readToken_lt_gt = function(e2) {
      var t = this.input.charCodeAt(this.pos + 1), s2 = 1;
      return t === e2 ? (s2 = e2 === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2, this.input.charCodeAt(this.pos + s2) === 61 ? this.finishOp(pa.assign, s2 + 1) : this.finishOp(pa.bitShift, s2)) : t !== 33 || e2 !== 60 || this.inModule || this.input.charCodeAt(this.pos + 2) !== 45 || this.input.charCodeAt(this.pos + 3) !== 45 ? (t === 61 && (s2 = 2), this.finishOp(pa.relational, s2)) : (this.skipLineComment(4), this.skipSpace(), this.nextToken());
    }, Ro.readToken_eq_excl = function(e2) {
      var t = this.input.charCodeAt(this.pos + 1);
      return t === 61 ? this.finishOp(pa.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) : e2 === 61 && t === 62 && this.options.ecmaVersion >= 6 ? (this.pos += 2, this.finishToken(pa.arrow)) : this.finishOp(e2 === 61 ? pa.eq : pa.prefix, 1);
    }, Ro.readToken_question = function() {
      var e2 = this.options.ecmaVersion;
      if (e2 >= 11) {
        var t = this.input.charCodeAt(this.pos + 1);
        if (t === 46) {
          var s2 = this.input.charCodeAt(this.pos + 2);
          if (s2 < 48 || s2 > 57)
            return this.finishOp(pa.questionDot, 2);
        }
        if (t === 63) {
          if (e2 >= 12) {
            if (this.input.charCodeAt(this.pos + 2) === 61)
              return this.finishOp(pa.assign, 3);
          }
          return this.finishOp(pa.coalesce, 2);
        }
      }
      return this.finishOp(pa.question, 1);
    }, Ro.readToken_numberSign = function() {
      var e2 = 35;
      if (this.options.ecmaVersion >= 13 && (++this.pos, ra(e2 = this.fullCharCodeAtPos(), true) || e2 === 92))
        return this.finishToken(pa.privateId, this.readWord1());
      this.raise(this.pos, "Unexpected character '" + Do(e2) + "'");
    }, Ro.getTokenFromCode = function(e2) {
      switch (e2) {
        case 46:
          return this.readToken_dot();
        case 40:
          return ++this.pos, this.finishToken(pa.parenL);
        case 41:
          return ++this.pos, this.finishToken(pa.parenR);
        case 59:
          return ++this.pos, this.finishToken(pa.semi);
        case 44:
          return ++this.pos, this.finishToken(pa.comma);
        case 91:
          return ++this.pos, this.finishToken(pa.bracketL);
        case 93:
          return ++this.pos, this.finishToken(pa.bracketR);
        case 123:
          return ++this.pos, this.finishToken(pa.braceL);
        case 125:
          return ++this.pos, this.finishToken(pa.braceR);
        case 58:
          return ++this.pos, this.finishToken(pa.colon);
        case 96:
          if (this.options.ecmaVersion < 6)
            break;
          return ++this.pos, this.finishToken(pa.backQuote);
        case 48:
          var t = this.input.charCodeAt(this.pos + 1);
          if (t === 120 || t === 88)
            return this.readRadixNumber(16);
          if (this.options.ecmaVersion >= 6) {
            if (t === 111 || t === 79)
              return this.readRadixNumber(8);
            if (t === 98 || t === 66)
              return this.readRadixNumber(2);
          }
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          return this.readNumber(false);
        case 34:
        case 39:
          return this.readString(e2);
        case 47:
          return this.readToken_slash();
        case 37:
        case 42:
          return this.readToken_mult_modulo_exp(e2);
        case 124:
        case 38:
          return this.readToken_pipe_amp(e2);
        case 94:
          return this.readToken_caret();
        case 43:
        case 45:
          return this.readToken_plus_min(e2);
        case 60:
        case 62:
          return this.readToken_lt_gt(e2);
        case 61:
        case 33:
          return this.readToken_eq_excl(e2);
        case 63:
          return this.readToken_question();
        case 126:
          return this.finishOp(pa.prefix, 1);
        case 35:
          return this.readToken_numberSign();
      }
      this.raise(this.pos, "Unexpected character '" + Do(e2) + "'");
    }, Ro.finishOp = function(e2, t) {
      var s2 = this.input.slice(this.pos, this.pos + t);
      return this.pos += t, this.finishToken(e2, s2);
    }, Ro.readRegexp = function() {
      for (var e2, t, s2 = this.pos; ; ) {
        this.pos >= this.input.length && this.raise(s2, "Unterminated regular expression");
        var i2 = this.input.charAt(this.pos);
        if (fa.test(i2) && this.raise(s2, "Unterminated regular expression"), e2)
          e2 = false;
        else {
          if (i2 === "[")
            t = true;
          else if (i2 === "]" && t)
            t = false;
          else if (i2 === "/" && !t)
            break;
          e2 = i2 === "\\";
        }
        ++this.pos;
      }
      var n3 = this.input.slice(s2, this.pos);
      ++this.pos;
      var r2 = this.pos, a2 = this.readWord1();
      this.containsEsc && this.unexpected(r2);
      var o2 = this.regexpState || (this.regexpState = new So(this));
      o2.reset(s2, n3, a2), this.validateRegExpFlags(o2), this.validateRegExpPattern(o2);
      var h3 = null;
      try {
        h3 = new RegExp(n3, a2);
      } catch (e3) {
      }
      return this.finishToken(pa.regexp, { pattern: n3, flags: a2, value: h3 });
    }, Ro.readInt = function(e2, t, s2) {
      for (var i2 = this.options.ecmaVersion >= 12 && t === void 0, n3 = s2 && this.input.charCodeAt(this.pos) === 48, r2 = this.pos, a2 = 0, o2 = 0, h3 = 0, l2 = t == null ? 1 / 0 : t; h3 < l2; ++h3, ++this.pos) {
        var c3 = this.input.charCodeAt(this.pos), u2 = void 0;
        if (i2 && c3 === 95)
          n3 && this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals"), o2 === 95 && this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore"), h3 === 0 && this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits"), o2 = c3;
        else {
          if ((u2 = c3 >= 97 ? c3 - 97 + 10 : c3 >= 65 ? c3 - 65 + 10 : c3 >= 48 && c3 <= 57 ? c3 - 48 : 1 / 0) >= e2)
            break;
          o2 = c3, a2 = a2 * e2 + u2;
        }
      }
      return i2 && o2 === 95 && this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits"), this.pos === r2 || t != null && this.pos - r2 !== t ? null : a2;
    }, Ro.readRadixNumber = function(e2) {
      var t = this.pos;
      this.pos += 2;
      var s2 = this.readInt(e2);
      return s2 == null && this.raise(this.start + 2, "Expected number in radix " + e2), this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110 ? (s2 = Mo(this.input.slice(t, this.pos)), ++this.pos) : ra(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(pa.num, s2);
    }, Ro.readNumber = function(e2) {
      var t = this.pos;
      e2 || this.readInt(10, void 0, true) !== null || this.raise(t, "Invalid number");
      var s2 = this.pos - t >= 2 && this.input.charCodeAt(t) === 48;
      s2 && this.strict && this.raise(t, "Invalid number");
      var i2 = this.input.charCodeAt(this.pos);
      if (!s2 && !e2 && this.options.ecmaVersion >= 11 && i2 === 110) {
        var n3 = Mo(this.input.slice(t, this.pos));
        return ++this.pos, ra(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(pa.num, n3);
      }
      s2 && /[89]/.test(this.input.slice(t, this.pos)) && (s2 = false), i2 !== 46 || s2 || (++this.pos, this.readInt(10), i2 = this.input.charCodeAt(this.pos)), i2 !== 69 && i2 !== 101 || s2 || ((i2 = this.input.charCodeAt(++this.pos)) !== 43 && i2 !== 45 || ++this.pos, this.readInt(10) === null && this.raise(t, "Invalid number")), ra(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number");
      var r2, a2 = (r2 = this.input.slice(t, this.pos), s2 ? parseInt(r2, 8) : parseFloat(r2.replace(/_/g, "")));
      return this.finishToken(pa.num, a2);
    }, Ro.readCodePoint = function() {
      var e2;
      if (this.input.charCodeAt(this.pos) === 123) {
        this.options.ecmaVersion < 6 && this.unexpected();
        var t = ++this.pos;
        e2 = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos), ++this.pos, e2 > 1114111 && this.invalidStringToken(t, "Code point out of bounds");
      } else
        e2 = this.readHexChar(4);
      return e2;
    }, Ro.readString = function(e2) {
      for (var t = "", s2 = ++this.pos; ; ) {
        this.pos >= this.input.length && this.raise(this.start, "Unterminated string constant");
        var i2 = this.input.charCodeAt(this.pos);
        if (i2 === e2)
          break;
        i2 === 92 ? (t += this.input.slice(s2, this.pos), t += this.readEscapedChar(false), s2 = this.pos) : i2 === 8232 || i2 === 8233 ? (this.options.ecmaVersion < 10 && this.raise(this.start, "Unterminated string constant"), ++this.pos, this.options.locations && (this.curLine++, this.lineStart = this.pos)) : (ga(i2) && this.raise(this.start, "Unterminated string constant"), ++this.pos);
      }
      return t += this.input.slice(s2, this.pos++), this.finishToken(pa.string, t);
    };
    Lo = {};
    Ro.tryReadTemplateToken = function() {
      this.inTemplateElement = true;
      try {
        this.readTmplToken();
      } catch (e2) {
        if (e2 !== Lo)
          throw e2;
        this.readInvalidTemplateToken();
      }
      this.inTemplateElement = false;
    }, Ro.invalidStringToken = function(e2, t) {
      if (this.inTemplateElement && this.options.ecmaVersion >= 9)
        throw Lo;
      this.raise(e2, t);
    }, Ro.readTmplToken = function() {
      for (var e2 = "", t = this.pos; ; ) {
        this.pos >= this.input.length && this.raise(this.start, "Unterminated template");
        var s2 = this.input.charCodeAt(this.pos);
        if (s2 === 96 || s2 === 36 && this.input.charCodeAt(this.pos + 1) === 123)
          return this.pos !== this.start || this.type !== pa.template && this.type !== pa.invalidTemplate ? (e2 += this.input.slice(t, this.pos), this.finishToken(pa.template, e2)) : s2 === 36 ? (this.pos += 2, this.finishToken(pa.dollarBraceL)) : (++this.pos, this.finishToken(pa.backQuote));
        if (s2 === 92)
          e2 += this.input.slice(t, this.pos), e2 += this.readEscapedChar(true), t = this.pos;
        else if (ga(s2)) {
          switch (e2 += this.input.slice(t, this.pos), ++this.pos, s2) {
            case 13:
              this.input.charCodeAt(this.pos) === 10 && ++this.pos;
            case 10:
              e2 += "\n";
              break;
            default:
              e2 += String.fromCharCode(s2);
          }
          this.options.locations && (++this.curLine, this.lineStart = this.pos), t = this.pos;
        } else
          ++this.pos;
      }
    }, Ro.readInvalidTemplateToken = function() {
      for (; this.pos < this.input.length; this.pos++)
        switch (this.input[this.pos]) {
          case "\\":
            ++this.pos;
            break;
          case "$":
            if (this.input[this.pos + 1] !== "{")
              break;
          case "`":
            return this.finishToken(pa.invalidTemplate, this.input.slice(this.start, this.pos));
        }
      this.raise(this.start, "Unterminated template");
    }, Ro.readEscapedChar = function(e2) {
      var t = this.input.charCodeAt(++this.pos);
      switch (++this.pos, t) {
        case 110:
          return "\n";
        case 114:
          return "\r";
        case 120:
          return String.fromCharCode(this.readHexChar(2));
        case 117:
          return Do(this.readCodePoint());
        case 116:
          return "	";
        case 98:
          return "\b";
        case 118:
          return "\v";
        case 102:
          return "\f";
        case 13:
          this.input.charCodeAt(this.pos) === 10 && ++this.pos;
        case 10:
          return this.options.locations && (this.lineStart = this.pos, ++this.curLine), "";
        case 56:
        case 57:
          if (this.strict && this.invalidStringToken(this.pos - 1, "Invalid escape sequence"), e2) {
            var s2 = this.pos - 1;
            return this.invalidStringToken(s2, "Invalid escape sequence in template string"), null;
          }
        default:
          if (t >= 48 && t <= 55) {
            var i2 = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0], n3 = parseInt(i2, 8);
            return n3 > 255 && (i2 = i2.slice(0, -1), n3 = parseInt(i2, 8)), this.pos += i2.length - 1, t = this.input.charCodeAt(this.pos), i2 === "0" && t !== 56 && t !== 57 || !this.strict && !e2 || this.invalidStringToken(this.pos - 1 - i2.length, e2 ? "Octal literal in template string" : "Octal literal in strict mode"), String.fromCharCode(n3);
          }
          return ga(t) ? "" : String.fromCharCode(t);
      }
    }, Ro.readHexChar = function(e2) {
      var t = this.pos, s2 = this.readInt(16, e2);
      return s2 === null && this.invalidStringToken(t, "Bad character escape sequence"), s2;
    }, Ro.readWord1 = function() {
      this.containsEsc = false;
      for (var e2 = "", t = true, s2 = this.pos, i2 = this.options.ecmaVersion >= 6; this.pos < this.input.length; ) {
        var n3 = this.fullCharCodeAtPos();
        if (aa(n3, i2))
          this.pos += n3 <= 65535 ? 1 : 2;
        else {
          if (n3 !== 92)
            break;
          this.containsEsc = true, e2 += this.input.slice(s2, this.pos);
          var r2 = this.pos;
          this.input.charCodeAt(++this.pos) !== 117 && this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"), ++this.pos;
          var a2 = this.readCodePoint();
          (t ? ra : aa)(a2, i2) || this.invalidStringToken(r2, "Invalid Unicode escape"), e2 += Do(a2), s2 = this.pos;
        }
        t = false;
      }
      return e2 + this.input.slice(s2, this.pos);
    }, Ro.readWord = function() {
      var e2 = this.readWord1(), t = pa.name;
      return this.keywords.test(e2) && (t = ua[e2]), this.finishToken(t, e2);
    };
    Ma.acorn = { Parser: Ma, version: "8.7.0", defaultOptions: _a, Position: Ca, SourceLocation: Ia, getLineInfo: Na, Node: io, TokenType: oa, tokTypes: pa, keywordTypes: ua, TokContext: Ka, tokContexts: Xa, isIdentifierChar: aa, isIdentifierStart: ra, Token: To, isNewLine: ga, lineBreak: fa, lineBreakG: ma, nonASCIIwhitespace: Ea };
    Oo = class {
      constructor(e2) {
        this.maxParallel = e2, this.queue = [], this.workerCount = 0;
      }
      run(e2) {
        return new Promise((t, s2) => {
          this.queue.push({ reject: s2, resolve: t, task: e2 }), this.work();
        });
      }
      async work() {
        if (this.workerCount >= this.maxParallel)
          return;
        let e2;
        for (this.workerCount++; e2 = this.queue.shift(); ) {
          const { reject: t, resolve: s2, task: i2 } = e2;
          try {
            s2(await i2());
          } catch (e3) {
            t(e3);
          }
        }
        this.workerCount--;
      }
    };
    Vo = (e2) => () => {
      oe({ code: "NO_FS_IN_BROWSER", message: `Cannot access the file system (via "${e2}") when using the browser build of Rollup. Make sure you supply a plugin with custom resolveId and load hooks to Rollup.`, url: "https://rollupjs.org/guide/en/#a-simple-example" });
    };
    Bo = { mkdir: Vo("fs.mkdir"), readFile: Vo("fs.readFile"), writeFile: Vo("fs.writeFile") };
    Wo = [{ active: true, deprecated: "resolveAssetUrl", replacement: "resolveFileUrl" }];
    Uo = { delete: () => false, get() {
    }, has: () => false, set() {
    } };
    Ho = class {
      constructor(e2, t, s2, i2) {
        this.graph = e2, this.modulesById = t, this.options = s2, this.pluginDriver = i2, this.implicitEntryModules = /* @__PURE__ */ new Set(), this.indexedEntryModules = [], this.latestLoadModulesPromise = Promise.resolve(), this.moduleLoadPromises = /* @__PURE__ */ new Map(), this.modulesWithLoadedDependencies = /* @__PURE__ */ new Set(), this.nextChunkNamePriority = 0, this.nextEntryModuleIndex = 0, this.resolveId = async (e3, t2, s3, i3, n3 = null) => this.getResolvedIdWithDefaults(this.getNormalizedResolvedIdWithoutDefaults(!this.options.external(e3, t2, false) && await Fo(e3, t2, this.options.preserveSymlinks, this.pluginDriver, this.resolveId, n3, s3, typeof i3 == "boolean" ? i3 : !t2), t2, e3)), this.hasModuleSideEffects = s2.treeshake ? s2.treeshake.moduleSideEffects : () => true, this.readQueue = new Oo(s2.maxParallelFileReads);
      }
      async addAdditionalModules(e2) {
        const t = this.extendLoadModulesPromise(Promise.all(e2.map((e3) => this.loadEntryModule(e3, false, void 0, null))));
        return await this.awaitLoadModulesPromise(), t;
      }
      async addEntryModules(e2, t) {
        const s2 = this.nextEntryModuleIndex;
        this.nextEntryModuleIndex += e2.length;
        const i2 = this.nextChunkNamePriority;
        this.nextChunkNamePriority += e2.length;
        const n3 = await this.extendLoadModulesPromise(Promise.all(e2.map(({ id: e3, importer: t2 }) => this.loadEntryModule(e3, true, t2, null))).then((n4) => {
          for (let r2 = 0; r2 < n4.length; r2++) {
            const a2 = n4[r2];
            a2.isUserDefinedEntryPoint = a2.isUserDefinedEntryPoint || t, Ko(a2, e2[r2], t, i2 + r2);
            const o2 = this.indexedEntryModules.find((e3) => e3.module === a2);
            o2 ? o2.index = Math.min(o2.index, s2 + r2) : this.indexedEntryModules.push({ index: s2 + r2, module: a2 });
          }
          return this.indexedEntryModules.sort(({ index: e3 }, { index: t2 }) => e3 > t2 ? 1 : -1), n4;
        }));
        return await this.awaitLoadModulesPromise(), { entryModules: this.indexedEntryModules.map(({ module: e3 }) => e3), implicitEntryModules: [...this.implicitEntryModules], newEntryModules: n3 };
      }
      async emitChunk({ fileName: e2, id: t, importer: s2, name: i2, implicitlyLoadedAfterOneOf: n3, preserveSignature: r2 }) {
        const a2 = { fileName: e2 || null, id: t, importer: s2, name: i2 || null }, o2 = n3 ? await this.addEntryWithImplicitDependants(a2, n3) : (await this.addEntryModules([a2], false)).newEntryModules[0];
        return r2 != null && (o2.preserveSignature = r2), o2;
      }
      async preloadModule(e2) {
        return (await this.fetchModule(this.getResolvedIdWithDefaults(e2), void 0, false, !e2.resolveDependencies || "resolveDependencies")).info;
      }
      addEntryWithImplicitDependants(e2, t) {
        const s2 = this.nextChunkNamePriority++;
        return this.extendLoadModulesPromise(this.loadEntryModule(e2.id, false, e2.importer, null).then(async (i2) => {
          if (Ko(i2, e2, false, s2), !i2.info.isEntry) {
            this.implicitEntryModules.add(i2);
            const s3 = await Promise.all(t.map((t2) => this.loadEntryModule(t2, false, e2.importer, i2.id)));
            for (const e3 of s3)
              i2.implicitlyLoadedAfter.add(e3);
            for (const e3 of i2.implicitlyLoadedAfter)
              e3.implicitlyLoadedBefore.add(i2);
          }
          return i2;
        }));
      }
      async addModuleSource(e2, t, s2) {
        let i2;
        ji("load modules", 3);
        try {
          i2 = await this.readQueue.run(async () => {
            var t2;
            return (t2 = await this.pluginDriver.hookFirst("load", [e2])) !== null && t2 !== void 0 ? t2 : await Bo.readFile(e2, "utf8");
          });
        } catch (s3) {
          Gi("load modules", 3);
          let i3 = `Could not load ${e2}`;
          throw t && (i3 += ` (imported by ${ie(t)})`), i3 += `: ${s3.message}`, s3.message = i3, s3;
        }
        Gi("load modules", 3);
        const n3 = typeof i2 == "string" ? { code: i2 } : i2 != null && typeof i2 == "object" && typeof i2.code == "string" ? i2 : oe(function(e3) {
          return { code: le.BAD_LOADER, message: `Error loading ${ie(e3)}: plugin load hook should return a string, a { code, map } object, or nothing/null` };
        }(e2)), r2 = this.graph.cachedModules.get(e2);
        if (!r2 || r2.customTransformCache || r2.originalCode !== n3.code || await this.pluginDriver.hookFirst("shouldTransformCachedModule", [{ ast: r2.ast, code: r2.code, id: r2.id, meta: r2.meta, moduleSideEffects: r2.moduleSideEffects, resolvedSources: r2.resolvedIds, syntheticNamedExports: r2.syntheticNamedExports }]))
          s2.updateOptions(n3), s2.setSource(await Go(n3, s2, this.pluginDriver, this.options.onwarn));
        else {
          if (r2.transformFiles)
            for (const e3 of r2.transformFiles)
              this.pluginDriver.emitFile(e3);
          s2.setSource(r2);
        }
      }
      async awaitLoadModulesPromise() {
        let e2;
        do {
          e2 = this.latestLoadModulesPromise, await e2;
        } while (e2 !== this.latestLoadModulesPromise);
      }
      extendLoadModulesPromise(e2) {
        return this.latestLoadModulesPromise = Promise.all([e2, this.latestLoadModulesPromise]), this.latestLoadModulesPromise.catch(() => {
        }), e2;
      }
      async fetchDynamicDependencies(e2, t) {
        const s2 = await Promise.all(t.map((t2) => t2.then(async ([t3, s3]) => s3 === null ? null : typeof s3 == "string" ? (t3.resolution = s3, null) : t3.resolution = await this.fetchResolvedDependency(ie(s3.id), e2.id, s3))));
        for (const t2 of s2)
          t2 && (e2.dynamicDependencies.add(t2), t2.dynamicImporters.push(e2.id));
      }
      async fetchModule({ id: e2, meta: t, moduleSideEffects: s2, syntheticNamedExports: i2 }, n3, r2, a2) {
        const o2 = this.modulesById.get(e2);
        if (o2 instanceof Qi)
          return await this.handleExistingModule(o2, r2, a2), o2;
        const h3 = new Qi(this.graph, e2, this.options, r2, s2, i2, t);
        this.modulesById.set(e2, h3), this.graph.watchFiles[e2] = true;
        const l2 = this.addModuleSource(e2, n3, h3).then(() => [this.getResolveStaticDependencyPromises(h3), this.getResolveDynamicImportPromises(h3), c3]), c3 = Yo(l2).then(() => this.pluginDriver.hookParallel("moduleParsed", [h3.info]));
        c3.catch(() => {
        }), this.moduleLoadPromises.set(h3, l2);
        const u2 = await l2;
        return a2 ? a2 === "resolveDependencies" && await c3 : await this.fetchModuleDependencies(h3, ...u2), h3;
      }
      async fetchModuleDependencies(e2, t, s2, i2) {
        this.modulesWithLoadedDependencies.has(e2) || (this.modulesWithLoadedDependencies.add(e2), await Promise.all([this.fetchStaticDependencies(e2, t), this.fetchDynamicDependencies(e2, s2)]), e2.linkImports(), await i2);
      }
      fetchResolvedDependency(e2, t, s2) {
        if (s2.external) {
          const { external: i2, id: n3, moduleSideEffects: r2, meta: a2 } = s2;
          this.modulesById.has(n3) || this.modulesById.set(n3, new ke(this.options, n3, r2, a2, i2 !== "absolute" && C2(n3)));
          const o2 = this.modulesById.get(n3);
          return o2 instanceof ke ? Promise.resolve(o2) : oe(function(e3, t2) {
            return { code: le.INVALID_EXTERNAL_ID, message: `'${e3}' is imported as an external by ${ie(t2)}, but is already an existing non-external module id.` };
          }(e2, t));
        }
        return this.fetchModule(s2, t, false, false);
      }
      async fetchStaticDependencies(e2, t) {
        for (const s2 of await Promise.all(t.map((t2) => t2.then(([t3, s3]) => this.fetchResolvedDependency(t3, e2.id, s3)))))
          e2.dependencies.add(s2), s2.importers.push(e2.id);
        if (!this.options.treeshake || e2.info.moduleSideEffects === "no-treeshake")
          for (const t2 of e2.dependencies)
            t2 instanceof Qi && (t2.importedFromNotTreeshaken = true);
      }
      getNormalizedResolvedIdWithoutDefaults(e2, t, s2) {
        const { makeAbsoluteExternalsRelative: i2 } = this.options;
        if (e2) {
          if (typeof e2 == "object") {
            const n5 = e2.external || this.options.external(e2.id, t, true);
            return __spreadProps2(__spreadValues2({}, e2), { external: n5 && (n5 === "relative" || !C2(e2.id) || n5 === true && Xo(e2.id, s2, i2) || "absolute") });
          }
          const n4 = this.options.external(e2, t, true);
          return { external: n4 && (Xo(e2, s2, i2) || "absolute"), id: n4 && i2 ? qo(e2, t) : e2 };
        }
        const n3 = i2 ? qo(s2, t) : s2;
        return e2 === false || this.options.external(n3, t, true) ? { external: Xo(n3, s2, i2) || "absolute", id: n3 } : null;
      }
      getResolveDynamicImportPromises(e2) {
        return e2.dynamicImports.map(async (t) => {
          const s2 = await this.resolveDynamicImport(e2, typeof t.argument == "string" ? t.argument : t.argument.esTreeNode, e2.id);
          return s2 && typeof s2 == "object" && (t.id = s2.id), [t, s2];
        });
      }
      getResolveStaticDependencyPromises(e2) {
        return Array.from(e2.sources, async (t) => [t, e2.resolvedIds[t] = e2.resolvedIds[t] || this.handleResolveId(await this.resolveId(t, e2.id, Q2, false), t, e2.id)]);
      }
      getResolvedIdWithDefaults(e2) {
        var t, s2;
        if (!e2)
          return null;
        const i2 = e2.external || false;
        return { external: i2, id: e2.id, meta: e2.meta || {}, moduleSideEffects: (t = e2.moduleSideEffects) !== null && t !== void 0 ? t : this.hasModuleSideEffects(e2.id, !!i2), syntheticNamedExports: (s2 = e2.syntheticNamedExports) !== null && s2 !== void 0 && s2 };
      }
      async handleExistingModule(e2, t, s2) {
        const i2 = this.moduleLoadPromises.get(e2);
        if (s2)
          return s2 === "resolveDependencies" ? Yo(i2) : i2;
        if (t) {
          e2.info.isEntry = true, this.implicitEntryModules.delete(e2);
          for (const t2 of e2.implicitlyLoadedAfter)
            t2.implicitlyLoadedBefore.delete(e2);
          e2.implicitlyLoadedAfter.clear();
        }
        return this.fetchModuleDependencies(e2, ...await i2);
      }
      handleResolveId(e2, t, s2) {
        return e2 === null ? I(t) ? oe(function(e3, t2) {
          return { code: le.UNRESOLVED_IMPORT, message: `Could not resolve '${e3}' from ${ie(t2)}` };
        }(t, s2)) : (this.options.onwarn(function(e3, t2) {
          return { code: le.UNRESOLVED_IMPORT, importer: ie(t2), message: `'${e3}' is imported by ${ie(t2)}, but could not be resolved \u2013 treating it as an external dependency`, source: e3, url: "https://rollupjs.org/guide/en/#warning-treating-module-as-external-dependency" };
        }(t, s2)), { external: true, id: t, meta: {}, moduleSideEffects: this.hasModuleSideEffects(t, true), syntheticNamedExports: false }) : (e2.external && e2.syntheticNamedExports && this.options.onwarn(function(e3, t2) {
          return { code: le.EXTERNAL_SYNTHETIC_EXPORTS, importer: ie(t2), message: `External '${e3}' can not have 'syntheticNamedExports' enabled.`, source: e3 };
        }(t, s2)), e2);
      }
      async loadEntryModule(e2, t, s2, i2) {
        const n3 = await Fo(e2, s2, this.options.preserveSymlinks, this.pluginDriver, this.resolveId, null, Q2, true);
        return n3 == null ? oe(i2 === null ? function(e3) {
          return { code: le.UNRESOLVED_ENTRY, message: `Could not resolve entry module (${ie(e3)}).` };
        }(e2) : function(e3, t2) {
          return { code: le.MISSING_IMPLICIT_DEPENDANT, message: `Module "${ie(e3)}" that should be implicitly loaded before "${ie(t2)}" could not be resolved.` };
        }(e2, i2)) : n3 === false || typeof n3 == "object" && n3.external ? oe(i2 === null ? function(e3) {
          return { code: le.UNRESOLVED_ENTRY, message: `Entry module cannot be external (${ie(e3)}).` };
        }(e2) : function(e3, t2) {
          return { code: le.MISSING_IMPLICIT_DEPENDANT, message: `Module "${ie(e3)}" that should be implicitly loaded before "${ie(t2)}" cannot be external.` };
        }(e2, i2)) : this.fetchModule(this.getResolvedIdWithDefaults(typeof n3 == "object" ? n3 : { id: n3 }), void 0, t, false);
      }
      async resolveDynamicImport(e2, t, s2) {
        var i2, n3;
        const r2 = await this.pluginDriver.hookFirst("resolveDynamicImport", [t, s2]);
        return typeof t != "string" ? typeof r2 == "string" ? r2 : r2 ? __spreadValues2({ external: false, moduleSideEffects: true }, r2) : null : r2 == null ? (i2 = (n3 = e2.resolvedIds)[t]) !== null && i2 !== void 0 ? i2 : n3[t] = this.handleResolveId(await this.resolveId(t, e2.id, Q2, false), t, e2.id) : this.handleResolveId(this.getResolvedIdWithDefaults(this.getNormalizedResolvedIdWithoutDefaults(r2, s2, t)), t, s2);
      }
    };
    Qo = class extends Rt {
      constructor() {
        super(), this.parent = null, this.variables.set("undefined", new Pi());
      }
      findVariable(e2) {
        let t = this.variables.get(e2);
        return t || (t = new hs(e2), this.variables.set(e2, t)), t;
      }
    };
    eh = Object.keys({ buildEnd: 1, buildStart: 1, closeBundle: 1, closeWatcher: 1, load: 1, moduleParsed: 1, options: 1, resolveDynamicImport: 1, resolveId: 1, shouldTransformCachedModule: 1, transform: 1, watchChange: 1 });
    sh = class {
      constructor(e2, t, s2, i2, n3) {
        this.graph = e2, this.options = t, this.unfulfilledActions = /* @__PURE__ */ new Set(), function(e3, t2) {
          for (const { active: s3, deprecated: i3, replacement: n4 } of Wo)
            for (const r3 of e3)
              i3 in r3 && xe({ message: `The "${i3}" hook used by plugin ${r3.name} is deprecated. The "${n4}" hook should be used instead.`, plugin: r3.name }, s3, t2);
        }(s2, t), this.pluginCache = i2, this.fileEmitter = new Dr(e2, t, n3 && n3.fileEmitter), this.emitFile = this.fileEmitter.emitFile.bind(this.fileEmitter), this.getFileName = this.fileEmitter.getFileName.bind(this.fileEmitter), this.finaliseAssets = this.fileEmitter.assertAssetsFinalized.bind(this.fileEmitter), this.setOutputBundle = this.fileEmitter.setOutputBundle.bind(this.fileEmitter), this.plugins = s2.concat(n3 ? n3.plugins : []);
        const r2 = /* @__PURE__ */ new Set();
        if (this.pluginContexts = new Map(this.plugins.map((s3) => [s3, Jo(s3, i2, e2, t, this.fileEmitter, r2)])), n3)
          for (const e3 of s2)
            for (const s3 of eh)
              s3 in e3 && t.onwarn((a2 = e3.name, o2 = s3, { code: le.INPUT_HOOK_IN_OUTPUT_PLUGIN, message: `The "${o2}" hook used by the output plugin ${a2} is a build time hook and will not be run for that plugin. Either this plugin cannot be used as an output plugin, or it should have an option to configure it as an output plugin.` }));
        var a2, o2;
      }
      createOutputPluginDriver(e2) {
        return new sh(this.graph, this.options, e2, this.pluginCache, this);
      }
      getUnfulfilledHookActions() {
        return this.unfulfilledActions;
      }
      hookFirst(e2, t, s2, i2) {
        let n3 = Promise.resolve(void 0);
        for (const r2 of this.plugins)
          i2 && i2.has(r2) || (n3 = n3.then((i3) => i3 != null ? i3 : this.runHook(e2, t, r2, false, s2)));
        return n3;
      }
      hookFirstSync(e2, t, s2) {
        for (const i2 of this.plugins) {
          const n3 = this.runHookSync(e2, t, i2, s2);
          if (n3 != null)
            return n3;
        }
        return null;
      }
      hookParallel(e2, t, s2) {
        const i2 = [];
        for (const n3 of this.plugins) {
          const r2 = this.runHook(e2, t, n3, false, s2);
          r2 && i2.push(r2);
        }
        return Promise.all(i2).then(() => {
        });
      }
      hookReduceArg0(e2, [t, ...s2], i2, n3) {
        let r2 = Promise.resolve(t);
        for (const t2 of this.plugins)
          r2 = r2.then((r3) => {
            const a2 = [r3, ...s2], o2 = this.runHook(e2, a2, t2, false, n3);
            return o2 ? o2.then((e3) => i2.call(this.pluginContexts.get(t2), r3, e3, t2)) : r3;
          });
        return r2;
      }
      hookReduceArg0Sync(e2, [t, ...s2], i2, n3) {
        for (const r2 of this.plugins) {
          const a2 = [t, ...s2], o2 = this.runHookSync(e2, a2, r2, n3);
          t = i2.call(this.pluginContexts.get(r2), t, o2, r2);
        }
        return t;
      }
      hookReduceValue(e2, t, s2, i2, n3) {
        let r2 = Promise.resolve(t);
        for (const t2 of this.plugins)
          r2 = r2.then((r3) => {
            const a2 = this.runHook(e2, s2, t2, true, n3);
            return a2 ? a2.then((e3) => i2.call(this.pluginContexts.get(t2), r3, e3, t2)) : r3;
          });
        return r2;
      }
      hookReduceValueSync(e2, t, s2, i2, n3) {
        let r2 = t;
        for (const t2 of this.plugins) {
          const a2 = this.runHookSync(e2, s2, t2, n3);
          r2 = i2.call(this.pluginContexts.get(t2), r2, a2, t2);
        }
        return r2;
      }
      hookSeq(e2, t, s2) {
        let i2 = Promise.resolve();
        for (const n3 of this.plugins)
          i2 = i2.then(() => this.runHook(e2, t, n3, false, s2));
        return i2;
      }
      runHook(e2, t, s2, i2, n3) {
        const r2 = s2[e2];
        if (!r2)
          return;
        let a2 = this.pluginContexts.get(s2);
        n3 && (a2 = n3(a2, s2));
        let o2 = null;
        return Promise.resolve().then(() => {
          if (typeof r2 != "function")
            return i2 ? r2 : th(e2, s2.name);
          const n4 = r2.apply(a2, t);
          return n4 && n4.then ? (o2 = [s2.name, e2, t], this.unfulfilledActions.add(o2), Promise.resolve(n4).then((e3) => (this.unfulfilledActions.delete(o2), e3))) : n4;
        }).catch((t2) => (o2 !== null && this.unfulfilledActions.delete(o2), zo(t2, s2.name, { hook: e2 })));
      }
      runHookSync(e2, t, s2, i2) {
        const n3 = s2[e2];
        if (!n3)
          return;
        let r2 = this.pluginContexts.get(s2);
        i2 && (r2 = i2(r2, s2));
        try {
          return typeof n3 != "function" ? th(e2, s2.name) : n3.apply(r2, t);
        } catch (t2) {
          return zo(t2, s2.name, { hook: e2 });
        }
      }
    };
    ih = class {
      constructor(e2, t) {
        var s2, i2;
        if (this.options = e2, this.cachedModules = /* @__PURE__ */ new Map(), this.deoptimizationTracker = new W(), this.entryModules = [], this.modulesById = /* @__PURE__ */ new Map(), this.needsTreeshakingPass = false, this.phase = Mi.LOAD_AND_PARSE, this.scope = new Qo(), this.watchFiles = /* @__PURE__ */ Object.create(null), this.watchMode = false, this.externalModules = [], this.implicitEntryModules = [], this.modules = [], this.getModuleInfo = (e3) => {
          const t2 = this.modulesById.get(e3);
          return t2 ? t2.info : null;
        }, e2.cache !== false) {
          if ((s2 = e2.cache) === null || s2 === void 0 ? void 0 : s2.modules)
            for (const t2 of e2.cache.modules)
              this.cachedModules.set(t2.id, t2);
          this.pluginCache = ((i2 = e2.cache) === null || i2 === void 0 ? void 0 : i2.plugins) || /* @__PURE__ */ Object.create(null);
          for (const e3 in this.pluginCache) {
            const t2 = this.pluginCache[e3];
            for (const e4 of Object.values(t2))
              e4[0]++;
          }
        }
        if (t) {
          this.watchMode = true;
          const e3 = (...e4) => this.pluginDriver.hookParallel("watchChange", e4), s3 = () => this.pluginDriver.hookParallel("closeWatcher", []);
          t.onCurrentAwaited("change", e3), t.onCurrentAwaited("close", s3);
        }
        this.pluginDriver = new sh(this, e2, e2.plugins, this.pluginCache), this.acornParser = Ma.extend(...e2.acornInjectPlugins), this.moduleLoader = new Ho(this, this.modulesById, this.options, this.pluginDriver);
      }
      async build() {
        ji("generate module graph", 2), await this.generateModuleGraph(), Gi("generate module graph", 2), ji("sort modules", 2), this.phase = Mi.ANALYSE, this.sortModules(), Gi("sort modules", 2), ji("mark included statements", 2), this.includeStatements(), Gi("mark included statements", 2), this.phase = Mi.GENERATE;
      }
      contextParse(e2, t = {}) {
        const s2 = t.onComment, i2 = [];
        t.onComment = s2 && typeof s2 == "function" ? (e3, n4, r2, a2, ...o2) => (i2.push({ end: a2, start: r2, type: e3 ? "Block" : "Line", value: n4 }), s2.call(t, e3, n4, r2, a2, ...o2)) : i2;
        const n3 = this.acornParser.parse(e2, __spreadValues2(__spreadValues2({}, this.options.acorn), t));
        return typeof s2 == "object" && s2.push(...i2), t.onComment = s2, function(e3, t2, s3) {
          const i3 = [], n4 = [];
          for (const t3 of e3)
            st.test(t3.value) ? i3.push(t3) : Ye.test(t3.value) && n4.push(t3);
          for (const e4 of n4)
            it(t2, e4, false);
          Qe(t2, { annotationIndex: 0, annotations: i3, code: s3 });
        }(i2, n3, e2), n3;
      }
      getCache() {
        for (const e2 in this.pluginCache) {
          const t = this.pluginCache[e2];
          let s2 = true;
          for (const [e3, i2] of Object.entries(t))
            i2[0] >= this.options.experimentalCacheExpiry ? delete t[e3] : s2 = false;
          s2 && delete this.pluginCache[e2];
        }
        return { modules: this.modules.map((e2) => e2.toJSON()), plugins: this.pluginCache };
      }
      async generateModuleGraph() {
        var e2;
        if ({ entryModules: this.entryModules, implicitEntryModules: this.implicitEntryModules } = await this.moduleLoader.addEntryModules((e2 = this.options.input, Array.isArray(e2) ? e2.map((e3) => ({ fileName: null, id: e3, implicitlyLoadedAfter: [], importer: void 0, name: null })) : Object.entries(e2).map(([e3, t]) => ({ fileName: null, id: t, implicitlyLoadedAfter: [], importer: void 0, name: e3 }))), true), this.entryModules.length === 0)
          throw new Error("You must supply options.input to rollup");
        for (const e3 of this.modulesById.values())
          e3 instanceof Qi ? this.modules.push(e3) : this.externalModules.push(e3);
      }
      includeStatements() {
        for (const e2 of [...this.entryModules, ...this.implicitEntryModules])
          Ki(e2);
        if (this.options.treeshake) {
          let e2 = 1;
          do {
            ji(`treeshaking pass ${e2}`, 3), this.needsTreeshakingPass = false;
            for (const e3 of this.modules)
              e3.isExecuted && (e3.info.moduleSideEffects === "no-treeshake" ? e3.includeAllInBundle() : e3.include());
            if (e2 === 1)
              for (const e3 of [...this.entryModules, ...this.implicitEntryModules])
                e3.preserveSignature !== false && (e3.includeAllExports(false), this.needsTreeshakingPass = true);
            Gi("treeshaking pass " + e2++, 3);
          } while (this.needsTreeshakingPass);
        } else
          for (const e2 of this.modules)
            e2.includeAllInBundle();
        for (const e2 of this.externalModules)
          e2.warnUnusedImports();
        for (const e2 of this.implicitEntryModules)
          for (const t of e2.implicitlyLoadedAfter)
            t.info.isEntry || t.isIncluded() || oe(fe(t));
      }
      sortModules() {
        const { orderedModules: e2, cyclePaths: t } = function(e3) {
          let t2 = 0;
          const s2 = [], i2 = /* @__PURE__ */ new Set(), n3 = /* @__PURE__ */ new Set(), r2 = /* @__PURE__ */ new Map(), a2 = [], o2 = (e4) => {
            if (e4 instanceof Qi) {
              for (const t3 of e4.dependencies)
                r2.has(t3) ? i2.has(t3) || s2.push(Wr(t3, e4, r2)) : (r2.set(t3, e4), o2(t3));
              for (const t3 of e4.implicitlyLoadedBefore)
                n3.add(t3);
              for (const { resolution: t3 } of e4.dynamicImports)
                t3 instanceof Qi && n3.add(t3);
              a2.push(e4);
            }
            e4.execIndex = t2++, i2.add(e4);
          };
          for (const t3 of e3)
            r2.has(t3) || (r2.set(t3, null), o2(t3));
          for (const e4 of n3)
            r2.has(e4) || (r2.set(e4, null), o2(e4));
          return { cyclePaths: s2, orderedModules: a2 };
        }(this.entryModules);
        for (const e3 of t)
          this.options.onwarn({ code: "CIRCULAR_DEPENDENCY", cycle: e3, importer: e3[0], message: `Circular dependency: ${e3.join(" -> ")}` });
        this.modules = e2;
        for (const e3 of this.modules)
          e3.bindReferences();
        this.warnForMissingExports();
      }
      warnForMissingExports() {
        for (const e2 of this.modules)
          for (const t of e2.importDescriptions.values())
            t.name === "*" || t.module.getVariableForExportName(t.name)[0] || e2.warn({ code: "NON_EXISTENT_EXPORT", message: `Non-existent export '${t.name}' is imported from ${ie(t.module.id)}`, name: t.name, source: t.module.id }, t.start);
      }
    };
    ah = (e2) => console.warn(e2.message || e2);
    hh = { recommended: { annotations: true, correctVarValueBeforeDeclaration: false, moduleSideEffects: () => true, propertyReadSideEffects: true, tryCatchDeoptimization: true, unknownGlobalSideEffects: false }, safest: { annotations: true, correctVarValueBeforeDeclaration: true, moduleSideEffects: () => true, propertyReadSideEffects: true, tryCatchDeoptimization: true, unknownGlobalSideEffects: true }, smallest: { annotations: true, correctVarValueBeforeDeclaration: false, moduleSideEffects: () => false, propertyReadSideEffects: false, tryCatchDeoptimization: false, unknownGlobalSideEffects: false } };
    lh = { es2015: { arrowFunctions: true, constBindings: true, objectShorthand: true, reservedNamesAsProps: true, symbols: true }, es5: { arrowFunctions: false, constBindings: false, objectShorthand: false, reservedNamesAsProps: true, symbols: false } };
    ch = (e2, t, s2, i2) => {
      var n3;
      const r2 = (n3 = e2) === null || n3 === void 0 ? void 0 : n3.preset;
      if (r2) {
        const i3 = t[r2];
        if (i3)
          return __spreadValues2(__spreadValues2({}, i3), e2);
        oe(de(`${s2}.preset`, uh(s2), `valid values are ${te(Object.keys(t))}`, r2));
      }
      return ((e3, t2, s3) => (i3) => {
        if (typeof i3 == "string") {
          const n4 = e3[i3];
          if (n4)
            return n4;
          oe(de(t2, uh(t2), `valid values are ${s3}${te(Object.keys(e3))}. You can also supply an object for more fine-grained control`, i3));
        }
        return ((e4) => e4 && typeof e4 == "object" ? e4 : {})(i3);
      })(t, s2, i2)(e2);
    };
    uh = (e2) => e2.split(".").join("").toLowerCase();
    dh = (e2) => {
      const { onwarn: t } = e2;
      return t ? (e3) => {
        e3.toString = () => {
          let t2 = "";
          return e3.plugin && (t2 += `(${e3.plugin} plugin) `), e3.loc && (t2 += `${ie(e3.loc.file)} (${e3.loc.line}:${e3.loc.column}) `), t2 += e3.message, t2;
        }, t(e3, ah);
      } : ah;
    };
    ph = (e2) => __spreadValues2({ allowAwaitOutsideFunction: true, ecmaVersion: "latest", preserveParens: false, sourceType: "module" }, e2.acorn);
    fh = (e2) => nh(e2.acornInjectPlugins);
    mh = (e2) => {
      var t;
      return ((t = e2.cache) === null || t === void 0 ? void 0 : t.cache) || e2.cache;
    };
    gh = (e2) => {
      if (e2 === true)
        return () => true;
      if (typeof e2 == "function")
        return (t, ...s2) => !t.startsWith("\0") && e2(t, ...s2) || false;
      if (e2) {
        const t = /* @__PURE__ */ new Set(), s2 = [];
        for (const i2 of nh(e2))
          i2 instanceof RegExp ? s2.push(i2) : t.add(i2);
        return (e3, ...i2) => t.has(e3) || s2.some((t2) => t2.test(e3));
      }
      return () => false;
    };
    yh = (e2, t, s2) => {
      const i2 = e2.inlineDynamicImports;
      return i2 && ve('The "inlineDynamicImports" option is deprecated. Use the "output.inlineDynamicImports" option instead.', false, t, s2), i2;
    };
    Eh = (e2) => {
      const t = e2.input;
      return t == null ? [] : typeof t == "string" ? [t] : t;
    };
    xh = (e2, t, s2) => {
      const i2 = e2.manualChunks;
      return i2 && ve('The "manualChunks" option is deprecated. Use the "output.manualChunks" option instead.', false, t, s2), i2;
    };
    vh = (e2) => {
      const t = e2.maxParallelFileReads;
      return typeof t == "number" ? t <= 0 ? 1 / 0 : t : 20;
    };
    bh = (e2, t) => {
      const s2 = e2.moduleContext;
      if (typeof s2 == "function")
        return (e3) => {
          var i2;
          return (i2 = s2(e3)) !== null && i2 !== void 0 ? i2 : t;
        };
      if (s2) {
        const e3 = /* @__PURE__ */ Object.create(null);
        for (const [t2, i2] of Object.entries(s2))
          e3[M(t2)] = i2;
        return (s3) => e3[s3] || t;
      }
      return () => t;
    };
    Sh = (e2, t) => {
      const s2 = e2.preserveEntrySignatures;
      return s2 == null && t.add("preserveEntrySignatures"), s2 != null ? s2 : "strict";
    };
    Ah = (e2, t, s2) => {
      const i2 = e2.preserveModules;
      return i2 && ve('The "preserveModules" option is deprecated. Use the "output.preserveModules" option instead.', false, t, s2), i2;
    };
    Ph = (e2, t, s2) => {
      const i2 = e2.treeshake;
      if (i2 === false)
        return false;
      const n3 = ch(e2.treeshake, hh, "treeshake", "false, true, ");
      return n3.pureExternalModules !== void 0 && ve(`The "treeshake.pureExternalModules" option is deprecated. The "treeshake.moduleSideEffects" option should be used instead. "treeshake.pureExternalModules: true" is equivalent to "treeshake.moduleSideEffects: 'no-external'"`, true, t, s2), { annotations: n3.annotations !== false, correctVarValueBeforeDeclaration: n3.correctVarValueBeforeDeclaration === true, moduleSideEffects: typeof i2 == "object" && i2.pureExternalModules ? kh(i2.moduleSideEffects, i2.pureExternalModules) : kh(n3.moduleSideEffects, void 0), propertyReadSideEffects: n3.propertyReadSideEffects === "always" ? "always" : n3.propertyReadSideEffects !== false, tryCatchDeoptimization: n3.tryCatchDeoptimization !== false, unknownGlobalSideEffects: n3.unknownGlobalSideEffects !== false };
    };
    kh = (e2, t) => {
      if (typeof e2 == "boolean")
        return () => e2;
      if (e2 === "no-external")
        return (e3, t2) => !t2;
      if (typeof e2 == "function")
        return (t2, s3) => !!t2.startsWith("\0") || e2(t2, s3) !== false;
      if (Array.isArray(e2)) {
        const t2 = new Set(e2);
        return (e3) => t2.has(e3);
      }
      e2 && oe(de("treeshake.moduleSideEffects", "treeshake", 'please use one of false, "no-external", a function or an array'));
      const s2 = gh(t);
      return (e3, t2) => !(t2 && s2(e3));
    };
    wh = /[\x00-\x1F\x7F<>*#"{}|^[\]`;?:&=+$,]/g;
    Ch = /^[a-z]:/i;
    Nh = (e2, t, s2) => {
      const { file: i2 } = e2;
      if (typeof i2 == "string") {
        if (t)
          return oe(de("output.file", "outputdir", 'you must set "output.dir" instead of "output.file" when using the "output.preserveModules" option'));
        if (!Array.isArray(s2.input))
          return oe(de("output.file", "outputdir", 'you must set "output.dir" instead of "output.file" when providing named inputs'));
      }
      return i2;
    };
    _h = (e2) => {
      const t = e2.format;
      switch (t) {
        case void 0:
        case "es":
        case "esm":
        case "module":
          return "es";
        case "cjs":
        case "commonjs":
          return "cjs";
        case "system":
        case "systemjs":
          return "system";
        case "amd":
        case "iife":
        case "umd":
          return t;
        default:
          return oe({ message: 'You must specify "output.format", which can be one of "amd", "cjs", "system", "es", "iife" or "umd".', url: "https://rollupjs.org/guide/en/#outputformat" });
      }
    };
    $h = (e2, t) => {
      var s2;
      const i2 = ((s2 = e2.inlineDynamicImports) !== null && s2 !== void 0 ? s2 : t.inlineDynamicImports) || false, { input: n3 } = t;
      return i2 && (Array.isArray(n3) ? n3 : Object.keys(n3)).length > 1 ? oe(de("output.inlineDynamicImports", "outputinlinedynamicimports", 'multiple inputs are not supported when "output.inlineDynamicImports" is true')) : i2;
    };
    Th = (e2, t, s2) => {
      var i2;
      const n3 = ((i2 = e2.preserveModules) !== null && i2 !== void 0 ? i2 : s2.preserveModules) || false;
      if (n3) {
        if (t)
          return oe(de("output.inlineDynamicImports", "outputinlinedynamicimports", 'this option is not supported for "output.preserveModules"'));
        if (s2.preserveEntrySignatures === false)
          return oe(de("preserveEntrySignatures", "preserveentrysignatures", 'setting this option to false is not supported for "output.preserveModules"'));
      }
      return n3;
    };
    Rh = (e2, t) => {
      const s2 = e2.preferConst;
      return s2 != null && xe('The "output.preferConst" option is deprecated. Use the "output.generatedCode.constBindings" option instead.', false, t), !!s2;
    };
    Mh = (e2) => {
      const { preserveModulesRoot: t } = e2;
      if (t != null)
        return M(t);
    };
    Dh = (e2) => {
      const t = __spreadValues2({ autoId: false, basePath: "", define: "define" }, e2.amd);
      if ((t.autoId || t.basePath) && t.id)
        return oe(de("output.amd.id", "outputamd", 'this option cannot be used together with "output.amd.autoId"/"output.amd.basePath"'));
      if (t.basePath && !t.autoId)
        return oe(de("output.amd.basePath", "outputamd", 'this option only works with "output.amd.autoId"'));
      let s2;
      return s2 = t.autoId ? { autoId: true, basePath: t.basePath, define: t.define } : { autoId: false, define: t.define, id: t.id }, s2;
    };
    Lh = (e2, t) => {
      const s2 = e2[t];
      return typeof s2 == "function" ? s2 : () => s2 || "";
    };
    Oh = (e2, t) => {
      const { dir: s2 } = e2;
      return typeof s2 == "string" && typeof t == "string" ? oe(de("output.dir", "outputdir", 'you must set either "output.file" for a single-file build or "output.dir" when generating multiple chunks')) : s2;
    };
    Vh = (e2, t) => {
      const s2 = e2.dynamicImportFunction;
      return s2 && xe('The "output.dynamicImportFunction" option is deprecated. Use the "renderDynamicImport" plugin hook instead.', false, t), s2;
    };
    Bh = (e2, t) => {
      const s2 = e2.entryFileNames;
      return s2 == null && t.add("entryFileNames"), s2 != null ? s2 : "[name].js";
    };
    zh = (e2, t) => {
      const s2 = ch(e2.generatedCode, lh, "output.generatedCode", "");
      return { arrowFunctions: s2.arrowFunctions === true, constBindings: s2.constBindings === true || t, objectShorthand: s2.objectShorthand === true, reservedNamesAsProps: s2.reservedNamesAsProps === true, symbols: s2.symbols === true };
    };
    Wh = (e2, t) => {
      if (t)
        return "";
      const s2 = e2.indent;
      return s2 === false ? "" : s2 == null || s2;
    };
    Uh = /* @__PURE__ */ new Set(["auto", "esModule", "default", "defaultOnly", true, false]);
    jh = (e2, t) => {
      const s2 = e2.interop, i2 = /* @__PURE__ */ new Set(), n3 = (e3) => {
        if (!i2.has(e3)) {
          if (i2.add(e3), !Uh.has(e3))
            return oe(de("output.interop", "outputinterop", `use one of ${Array.from(Uh, (e4) => JSON.stringify(e4)).join(", ")}`, e3));
          typeof e3 == "boolean" && xe({ message: `The boolean value "${e3}" for the "output.interop" option is deprecated. Use ${e3 ? '"auto"' : '"esModule", "default" or "defaultOnly"'} instead.`, url: "https://rollupjs.org/guide/en/#outputinterop" }, false, t);
        }
        return e3;
      };
      if (typeof s2 == "function") {
        const e3 = /* @__PURE__ */ Object.create(null);
        let t2 = null;
        return (i3) => i3 === null ? t2 || n3(t2 = s2(i3)) : i3 in e3 ? e3[i3] : n3(e3[i3] = s2(i3));
      }
      return s2 === void 0 ? () => true : () => n3(s2);
    };
    Gh = (e2, t, s2, i2) => {
      const n3 = e2.manualChunks || i2.manualChunks;
      if (n3) {
        if (t)
          return oe(de("output.manualChunks", "outputmanualchunks", 'this option is not supported for "output.inlineDynamicImports"'));
        if (s2)
          return oe(de("output.manualChunks", "outputmanualchunks", 'this option is not supported for "output.preserveModules"'));
      }
      return n3 || {};
    };
    Hh = (e2, t, s2) => {
      var i2;
      return (i2 = e2.minifyInternalExports) !== null && i2 !== void 0 ? i2 : s2 || t === "es" || t === "system";
    };
    qh = (e2, t, s2) => {
      const i2 = e2.namespaceToStringTag;
      return i2 != null ? (xe('The "output.namespaceToStringTag" option is deprecated. Use the "output.generatedCode.symbols" option instead.', false, s2), i2) : t.symbols || false;
    };
    !function(e2) {
      e2[e2.ENTRY_CHUNK = 0] = "ENTRY_CHUNK", e2[e2.SECONDARY_CHUNK = 1] = "SECONDARY_CHUNK", e2[e2.ASSET = 2] = "ASSET";
    }(Zh || (Zh = {}));
  }
});

// browser-external:http2
var http2_exports = {};
__export(http2_exports, {
  default: () => http2_default
});
var http2_default;
var init_http2 = __esm({
  "browser-external:http2"() {
    http2_default = new Proxy({}, {
      get() {
        throw new Error('Module "http2" has been externalized for browser compatibility and cannot be accessed in client code.');
      }
    });
  }
});

// node_modules/vite/dist/node/chunks/dep-958b75cb.js
var require_dep_958b75cb = __commonJS({
  "node_modules/vite/dist/node/chunks/dep-958b75cb.js"(exports2) {
    "use strict";
    var index2 = require_dep_611778e0();
    var require$$12 = (init_crypto(), __toCommonJS(crypto_exports));
    init_fs();
    init_path();
    init_tty();
    init_util();
    init_net();
    init_events();
    init_url();
    init_http();
    init_stream();
    init_os();
    require_resolve();
    init_module();
    init_perf_hooks();
    init_https();
    init_zlib();
    init_tls();
    init_assert();
    require_main();
    init_buffer();
    init_querystring();
    init_child_process();
    init_worker_threads();
    init_readline();
    function _interopDefaultLegacy2(e2) {
      return e2 && typeof e2 === "object" && "default" in e2 ? e2["default"] : e2;
    }
    var require$$1__default2 = _interopDefaultLegacy2(require$$12);
    var forge$s = {
      options: {
        usePureJavaScript: false
      }
    };
    var api = {};
    var baseN$1 = api;
    var _reverseAlphabets = {};
    api.encode = function(input, alphabet, maxline) {
      if (typeof alphabet !== "string") {
        throw new TypeError('"alphabet" must be a string.');
      }
      if (maxline !== void 0 && typeof maxline !== "number") {
        throw new TypeError('"maxline" must be a number.');
      }
      var output = "";
      if (!(input instanceof Uint8Array)) {
        output = _encodeWithByteBuffer(input, alphabet);
      } else {
        var i2 = 0;
        var base2 = alphabet.length;
        var first2 = alphabet.charAt(0);
        var digits = [0];
        for (i2 = 0; i2 < input.length; ++i2) {
          for (var j2 = 0, carry = input[i2]; j2 < digits.length; ++j2) {
            carry += digits[j2] << 8;
            digits[j2] = carry % base2;
            carry = carry / base2 | 0;
          }
          while (carry > 0) {
            digits.push(carry % base2);
            carry = carry / base2 | 0;
          }
        }
        for (i2 = 0; input[i2] === 0 && i2 < input.length - 1; ++i2) {
          output += first2;
        }
        for (i2 = digits.length - 1; i2 >= 0; --i2) {
          output += alphabet[digits[i2]];
        }
      }
      if (maxline) {
        var regex = new RegExp(".{1," + maxline + "}", "g");
        output = output.match(regex).join("\r\n");
      }
      return output;
    };
    api.decode = function(input, alphabet) {
      if (typeof input !== "string") {
        throw new TypeError('"input" must be a string.');
      }
      if (typeof alphabet !== "string") {
        throw new TypeError('"alphabet" must be a string.');
      }
      var table = _reverseAlphabets[alphabet];
      if (!table) {
        table = _reverseAlphabets[alphabet] = [];
        for (var i2 = 0; i2 < alphabet.length; ++i2) {
          table[alphabet.charCodeAt(i2)] = i2;
        }
      }
      input = input.replace(/\s/g, "");
      var base2 = alphabet.length;
      var first2 = alphabet.charAt(0);
      var bytes = [0];
      for (var i2 = 0; i2 < input.length; i2++) {
        var value = table[input.charCodeAt(i2)];
        if (value === void 0) {
          return;
        }
        for (var j2 = 0, carry = value; j2 < bytes.length; ++j2) {
          carry += bytes[j2] * base2;
          bytes[j2] = carry & 255;
          carry >>= 8;
        }
        while (carry > 0) {
          bytes.push(carry & 255);
          carry >>= 8;
        }
      }
      for (var k2 = 0; input[k2] === first2 && k2 < input.length - 1; ++k2) {
        bytes.push(0);
      }
      if (typeof Buffer !== "undefined") {
        return Buffer.from(bytes.reverse());
      }
      return new Uint8Array(bytes.reverse());
    };
    function _encodeWithByteBuffer(input, alphabet) {
      var i2 = 0;
      var base2 = alphabet.length;
      var first2 = alphabet.charAt(0);
      var digits = [0];
      for (i2 = 0; i2 < input.length(); ++i2) {
        for (var j2 = 0, carry = input.at(i2); j2 < digits.length; ++j2) {
          carry += digits[j2] << 8;
          digits[j2] = carry % base2;
          carry = carry / base2 | 0;
        }
        while (carry > 0) {
          digits.push(carry % base2);
          carry = carry / base2 | 0;
        }
      }
      var output = "";
      for (i2 = 0; input.at(i2) === 0 && i2 < input.length() - 1; ++i2) {
        output += first2;
      }
      for (i2 = digits.length - 1; i2 >= 0; --i2) {
        output += alphabet[digits[i2]];
      }
      return output;
    }
    var forge$r = forge$s;
    var baseN = baseN$1;
    var util$12 = forge$r.util = forge$r.util || {};
    (function() {
      if (typeof process !== "undefined" && process.nextTick && !process.browser) {
        util$12.nextTick = process.nextTick;
        if (typeof setImmediate === "function") {
          util$12.setImmediate = setImmediate;
        } else {
          util$12.setImmediate = util$12.nextTick;
        }
        return;
      }
      if (typeof setImmediate === "function") {
        util$12.setImmediate = function() {
          return setImmediate.apply(void 0, arguments);
        };
        util$12.nextTick = function(callback) {
          return setImmediate(callback);
        };
        return;
      }
      util$12.setImmediate = function(callback) {
        setTimeout(callback, 0);
      };
      if (typeof window !== "undefined" && typeof window.postMessage === "function") {
        let handler = function(event) {
          if (event.source === window && event.data === msg) {
            event.stopPropagation();
            var copy = callbacks.slice();
            callbacks.length = 0;
            copy.forEach(function(callback) {
              callback();
            });
          }
        };
        var msg = "forge.setImmediate";
        var callbacks = [];
        util$12.setImmediate = function(callback) {
          callbacks.push(callback);
          if (callbacks.length === 1) {
            window.postMessage(msg, "*");
          }
        };
        window.addEventListener("message", handler, true);
      }
      if (typeof MutationObserver !== "undefined") {
        var now = Date.now();
        var attr = true;
        var div = document.createElement("div");
        var callbacks = [];
        new MutationObserver(function() {
          var copy = callbacks.slice();
          callbacks.length = 0;
          copy.forEach(function(callback) {
            callback();
          });
        }).observe(div, { attributes: true });
        var oldSetImmediate = util$12.setImmediate;
        util$12.setImmediate = function(callback) {
          if (Date.now() - now > 15) {
            now = Date.now();
            oldSetImmediate(callback);
          } else {
            callbacks.push(callback);
            if (callbacks.length === 1) {
              div.setAttribute("a", attr = !attr);
            }
          }
        };
      }
      util$12.nextTick = util$12.setImmediate;
    })();
    util$12.isNodejs = typeof process !== "undefined" && process.versions && process.versions.node;
    util$12.globalScope = function() {
      if (util$12.isNodejs) {
        return index2.commonjsGlobal;
      }
      return typeof self === "undefined" ? window : self;
    }();
    util$12.isArray = Array.isArray || function(x2) {
      return Object.prototype.toString.call(x2) === "[object Array]";
    };
    util$12.isArrayBuffer = function(x2) {
      return typeof ArrayBuffer !== "undefined" && x2 instanceof ArrayBuffer;
    };
    util$12.isArrayBufferView = function(x2) {
      return x2 && util$12.isArrayBuffer(x2.buffer) && x2.byteLength !== void 0;
    };
    function _checkBitsParam(n3) {
      if (!(n3 === 8 || n3 === 16 || n3 === 24 || n3 === 32)) {
        throw new Error("Only 8, 16, 24, or 32 bits supported: " + n3);
      }
    }
    util$12.ByteBuffer = ByteStringBuffer;
    function ByteStringBuffer(b2) {
      this.data = "";
      this.read = 0;
      if (typeof b2 === "string") {
        this.data = b2;
      } else if (util$12.isArrayBuffer(b2) || util$12.isArrayBufferView(b2)) {
        if (typeof Buffer !== "undefined" && b2 instanceof Buffer) {
          this.data = b2.toString("binary");
        } else {
          var arr = new Uint8Array(b2);
          try {
            this.data = String.fromCharCode.apply(null, arr);
          } catch (e2) {
            for (var i2 = 0; i2 < arr.length; ++i2) {
              this.putByte(arr[i2]);
            }
          }
        }
      } else if (b2 instanceof ByteStringBuffer || typeof b2 === "object" && typeof b2.data === "string" && typeof b2.read === "number") {
        this.data = b2.data;
        this.read = b2.read;
      }
      this._constructedStringLength = 0;
    }
    util$12.ByteStringBuffer = ByteStringBuffer;
    var _MAX_CONSTRUCTED_STRING_LENGTH = 4096;
    util$12.ByteStringBuffer.prototype._optimizeConstructedString = function(x2) {
      this._constructedStringLength += x2;
      if (this._constructedStringLength > _MAX_CONSTRUCTED_STRING_LENGTH) {
        this.data.substr(0, 1);
        this._constructedStringLength = 0;
      }
    };
    util$12.ByteStringBuffer.prototype.length = function() {
      return this.data.length - this.read;
    };
    util$12.ByteStringBuffer.prototype.isEmpty = function() {
      return this.length() <= 0;
    };
    util$12.ByteStringBuffer.prototype.putByte = function(b2) {
      return this.putBytes(String.fromCharCode(b2));
    };
    util$12.ByteStringBuffer.prototype.fillWithByte = function(b2, n3) {
      b2 = String.fromCharCode(b2);
      var d3 = this.data;
      while (n3 > 0) {
        if (n3 & 1) {
          d3 += b2;
        }
        n3 >>>= 1;
        if (n3 > 0) {
          b2 += b2;
        }
      }
      this.data = d3;
      this._optimizeConstructedString(n3);
      return this;
    };
    util$12.ByteStringBuffer.prototype.putBytes = function(bytes) {
      this.data += bytes;
      this._optimizeConstructedString(bytes.length);
      return this;
    };
    util$12.ByteStringBuffer.prototype.putString = function(str) {
      return this.putBytes(util$12.encodeUtf8(str));
    };
    util$12.ByteStringBuffer.prototype.putInt16 = function(i2) {
      return this.putBytes(String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 & 255));
    };
    util$12.ByteStringBuffer.prototype.putInt24 = function(i2) {
      return this.putBytes(String.fromCharCode(i2 >> 16 & 255) + String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 & 255));
    };
    util$12.ByteStringBuffer.prototype.putInt32 = function(i2) {
      return this.putBytes(String.fromCharCode(i2 >> 24 & 255) + String.fromCharCode(i2 >> 16 & 255) + String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 & 255));
    };
    util$12.ByteStringBuffer.prototype.putInt16Le = function(i2) {
      return this.putBytes(String.fromCharCode(i2 & 255) + String.fromCharCode(i2 >> 8 & 255));
    };
    util$12.ByteStringBuffer.prototype.putInt24Le = function(i2) {
      return this.putBytes(String.fromCharCode(i2 & 255) + String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 >> 16 & 255));
    };
    util$12.ByteStringBuffer.prototype.putInt32Le = function(i2) {
      return this.putBytes(String.fromCharCode(i2 & 255) + String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 >> 16 & 255) + String.fromCharCode(i2 >> 24 & 255));
    };
    util$12.ByteStringBuffer.prototype.putInt = function(i2, n3) {
      _checkBitsParam(n3);
      var bytes = "";
      do {
        n3 -= 8;
        bytes += String.fromCharCode(i2 >> n3 & 255);
      } while (n3 > 0);
      return this.putBytes(bytes);
    };
    util$12.ByteStringBuffer.prototype.putSignedInt = function(i2, n3) {
      if (i2 < 0) {
        i2 += 2 << n3 - 1;
      }
      return this.putInt(i2, n3);
    };
    util$12.ByteStringBuffer.prototype.putBuffer = function(buffer2) {
      return this.putBytes(buffer2.getBytes());
    };
    util$12.ByteStringBuffer.prototype.getByte = function() {
      return this.data.charCodeAt(this.read++);
    };
    util$12.ByteStringBuffer.prototype.getInt16 = function() {
      var rval = this.data.charCodeAt(this.read) << 8 ^ this.data.charCodeAt(this.read + 1);
      this.read += 2;
      return rval;
    };
    util$12.ByteStringBuffer.prototype.getInt24 = function() {
      var rval = this.data.charCodeAt(this.read) << 16 ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2);
      this.read += 3;
      return rval;
    };
    util$12.ByteStringBuffer.prototype.getInt32 = function() {
      var rval = this.data.charCodeAt(this.read) << 24 ^ this.data.charCodeAt(this.read + 1) << 16 ^ this.data.charCodeAt(this.read + 2) << 8 ^ this.data.charCodeAt(this.read + 3);
      this.read += 4;
      return rval;
    };
    util$12.ByteStringBuffer.prototype.getInt16Le = function() {
      var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8;
      this.read += 2;
      return rval;
    };
    util$12.ByteStringBuffer.prototype.getInt24Le = function() {
      var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16;
      this.read += 3;
      return rval;
    };
    util$12.ByteStringBuffer.prototype.getInt32Le = function() {
      var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16 ^ this.data.charCodeAt(this.read + 3) << 24;
      this.read += 4;
      return rval;
    };
    util$12.ByteStringBuffer.prototype.getInt = function(n3) {
      _checkBitsParam(n3);
      var rval = 0;
      do {
        rval = (rval << 8) + this.data.charCodeAt(this.read++);
        n3 -= 8;
      } while (n3 > 0);
      return rval;
    };
    util$12.ByteStringBuffer.prototype.getSignedInt = function(n3) {
      var x2 = this.getInt(n3);
      var max = 2 << n3 - 2;
      if (x2 >= max) {
        x2 -= max << 1;
      }
      return x2;
    };
    util$12.ByteStringBuffer.prototype.getBytes = function(count) {
      var rval;
      if (count) {
        count = Math.min(this.length(), count);
        rval = this.data.slice(this.read, this.read + count);
        this.read += count;
      } else if (count === 0) {
        rval = "";
      } else {
        rval = this.read === 0 ? this.data : this.data.slice(this.read);
        this.clear();
      }
      return rval;
    };
    util$12.ByteStringBuffer.prototype.bytes = function(count) {
      return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
    };
    util$12.ByteStringBuffer.prototype.at = function(i2) {
      return this.data.charCodeAt(this.read + i2);
    };
    util$12.ByteStringBuffer.prototype.setAt = function(i2, b2) {
      this.data = this.data.substr(0, this.read + i2) + String.fromCharCode(b2) + this.data.substr(this.read + i2 + 1);
      return this;
    };
    util$12.ByteStringBuffer.prototype.last = function() {
      return this.data.charCodeAt(this.data.length - 1);
    };
    util$12.ByteStringBuffer.prototype.copy = function() {
      var c3 = util$12.createBuffer(this.data);
      c3.read = this.read;
      return c3;
    };
    util$12.ByteStringBuffer.prototype.compact = function() {
      if (this.read > 0) {
        this.data = this.data.slice(this.read);
        this.read = 0;
      }
      return this;
    };
    util$12.ByteStringBuffer.prototype.clear = function() {
      this.data = "";
      this.read = 0;
      return this;
    };
    util$12.ByteStringBuffer.prototype.truncate = function(count) {
      var len = Math.max(0, this.length() - count);
      this.data = this.data.substr(this.read, len);
      this.read = 0;
      return this;
    };
    util$12.ByteStringBuffer.prototype.toHex = function() {
      var rval = "";
      for (var i2 = this.read; i2 < this.data.length; ++i2) {
        var b2 = this.data.charCodeAt(i2);
        if (b2 < 16) {
          rval += "0";
        }
        rval += b2.toString(16);
      }
      return rval;
    };
    util$12.ByteStringBuffer.prototype.toString = function() {
      return util$12.decodeUtf8(this.bytes());
    };
    function DataBuffer(b2, options2) {
      options2 = options2 || {};
      this.read = options2.readOffset || 0;
      this.growSize = options2.growSize || 1024;
      var isArrayBuffer = util$12.isArrayBuffer(b2);
      var isArrayBufferView = util$12.isArrayBufferView(b2);
      if (isArrayBuffer || isArrayBufferView) {
        if (isArrayBuffer) {
          this.data = new DataView(b2);
        } else {
          this.data = new DataView(b2.buffer, b2.byteOffset, b2.byteLength);
        }
        this.write = "writeOffset" in options2 ? options2.writeOffset : this.data.byteLength;
        return;
      }
      this.data = new DataView(new ArrayBuffer(0));
      this.write = 0;
      if (b2 !== null && b2 !== void 0) {
        this.putBytes(b2);
      }
      if ("writeOffset" in options2) {
        this.write = options2.writeOffset;
      }
    }
    util$12.DataBuffer = DataBuffer;
    util$12.DataBuffer.prototype.length = function() {
      return this.write - this.read;
    };
    util$12.DataBuffer.prototype.isEmpty = function() {
      return this.length() <= 0;
    };
    util$12.DataBuffer.prototype.accommodate = function(amount, growSize) {
      if (this.length() >= amount) {
        return this;
      }
      growSize = Math.max(growSize || this.growSize, amount);
      var src2 = new Uint8Array(this.data.buffer, this.data.byteOffset, this.data.byteLength);
      var dst = new Uint8Array(this.length() + growSize);
      dst.set(src2);
      this.data = new DataView(dst.buffer);
      return this;
    };
    util$12.DataBuffer.prototype.putByte = function(b2) {
      this.accommodate(1);
      this.data.setUint8(this.write++, b2);
      return this;
    };
    util$12.DataBuffer.prototype.fillWithByte = function(b2, n3) {
      this.accommodate(n3);
      for (var i2 = 0; i2 < n3; ++i2) {
        this.data.setUint8(b2);
      }
      return this;
    };
    util$12.DataBuffer.prototype.putBytes = function(bytes, encoding) {
      if (util$12.isArrayBufferView(bytes)) {
        var src2 = new Uint8Array(bytes.buffer, bytes.byteOffset, bytes.byteLength);
        var len = src2.byteLength - src2.byteOffset;
        this.accommodate(len);
        var dst = new Uint8Array(this.data.buffer, this.write);
        dst.set(src2);
        this.write += len;
        return this;
      }
      if (util$12.isArrayBuffer(bytes)) {
        var src2 = new Uint8Array(bytes);
        this.accommodate(src2.byteLength);
        var dst = new Uint8Array(this.data.buffer);
        dst.set(src2, this.write);
        this.write += src2.byteLength;
        return this;
      }
      if (bytes instanceof util$12.DataBuffer || typeof bytes === "object" && typeof bytes.read === "number" && typeof bytes.write === "number" && util$12.isArrayBufferView(bytes.data)) {
        var src2 = new Uint8Array(bytes.data.byteLength, bytes.read, bytes.length());
        this.accommodate(src2.byteLength);
        var dst = new Uint8Array(bytes.data.byteLength, this.write);
        dst.set(src2);
        this.write += src2.byteLength;
        return this;
      }
      if (bytes instanceof util$12.ByteStringBuffer) {
        bytes = bytes.data;
        encoding = "binary";
      }
      encoding = encoding || "binary";
      if (typeof bytes === "string") {
        var view;
        if (encoding === "hex") {
          this.accommodate(Math.ceil(bytes.length / 2));
          view = new Uint8Array(this.data.buffer, this.write);
          this.write += util$12.binary.hex.decode(bytes, view, this.write);
          return this;
        }
        if (encoding === "base64") {
          this.accommodate(Math.ceil(bytes.length / 4) * 3);
          view = new Uint8Array(this.data.buffer, this.write);
          this.write += util$12.binary.base64.decode(bytes, view, this.write);
          return this;
        }
        if (encoding === "utf8") {
          bytes = util$12.encodeUtf8(bytes);
          encoding = "binary";
        }
        if (encoding === "binary" || encoding === "raw") {
          this.accommodate(bytes.length);
          view = new Uint8Array(this.data.buffer, this.write);
          this.write += util$12.binary.raw.decode(view);
          return this;
        }
        if (encoding === "utf16") {
          this.accommodate(bytes.length * 2);
          view = new Uint16Array(this.data.buffer, this.write);
          this.write += util$12.text.utf16.encode(view);
          return this;
        }
        throw new Error("Invalid encoding: " + encoding);
      }
      throw Error("Invalid parameter: " + bytes);
    };
    util$12.DataBuffer.prototype.putBuffer = function(buffer2) {
      this.putBytes(buffer2);
      buffer2.clear();
      return this;
    };
    util$12.DataBuffer.prototype.putString = function(str) {
      return this.putBytes(str, "utf16");
    };
    util$12.DataBuffer.prototype.putInt16 = function(i2) {
      this.accommodate(2);
      this.data.setInt16(this.write, i2);
      this.write += 2;
      return this;
    };
    util$12.DataBuffer.prototype.putInt24 = function(i2) {
      this.accommodate(3);
      this.data.setInt16(this.write, i2 >> 8 & 65535);
      this.data.setInt8(this.write, i2 >> 16 & 255);
      this.write += 3;
      return this;
    };
    util$12.DataBuffer.prototype.putInt32 = function(i2) {
      this.accommodate(4);
      this.data.setInt32(this.write, i2);
      this.write += 4;
      return this;
    };
    util$12.DataBuffer.prototype.putInt16Le = function(i2) {
      this.accommodate(2);
      this.data.setInt16(this.write, i2, true);
      this.write += 2;
      return this;
    };
    util$12.DataBuffer.prototype.putInt24Le = function(i2) {
      this.accommodate(3);
      this.data.setInt8(this.write, i2 >> 16 & 255);
      this.data.setInt16(this.write, i2 >> 8 & 65535, true);
      this.write += 3;
      return this;
    };
    util$12.DataBuffer.prototype.putInt32Le = function(i2) {
      this.accommodate(4);
      this.data.setInt32(this.write, i2, true);
      this.write += 4;
      return this;
    };
    util$12.DataBuffer.prototype.putInt = function(i2, n3) {
      _checkBitsParam(n3);
      this.accommodate(n3 / 8);
      do {
        n3 -= 8;
        this.data.setInt8(this.write++, i2 >> n3 & 255);
      } while (n3 > 0);
      return this;
    };
    util$12.DataBuffer.prototype.putSignedInt = function(i2, n3) {
      _checkBitsParam(n3);
      this.accommodate(n3 / 8);
      if (i2 < 0) {
        i2 += 2 << n3 - 1;
      }
      return this.putInt(i2, n3);
    };
    util$12.DataBuffer.prototype.getByte = function() {
      return this.data.getInt8(this.read++);
    };
    util$12.DataBuffer.prototype.getInt16 = function() {
      var rval = this.data.getInt16(this.read);
      this.read += 2;
      return rval;
    };
    util$12.DataBuffer.prototype.getInt24 = function() {
      var rval = this.data.getInt16(this.read) << 8 ^ this.data.getInt8(this.read + 2);
      this.read += 3;
      return rval;
    };
    util$12.DataBuffer.prototype.getInt32 = function() {
      var rval = this.data.getInt32(this.read);
      this.read += 4;
      return rval;
    };
    util$12.DataBuffer.prototype.getInt16Le = function() {
      var rval = this.data.getInt16(this.read, true);
      this.read += 2;
      return rval;
    };
    util$12.DataBuffer.prototype.getInt24Le = function() {
      var rval = this.data.getInt8(this.read) ^ this.data.getInt16(this.read + 1, true) << 8;
      this.read += 3;
      return rval;
    };
    util$12.DataBuffer.prototype.getInt32Le = function() {
      var rval = this.data.getInt32(this.read, true);
      this.read += 4;
      return rval;
    };
    util$12.DataBuffer.prototype.getInt = function(n3) {
      _checkBitsParam(n3);
      var rval = 0;
      do {
        rval = (rval << 8) + this.data.getInt8(this.read++);
        n3 -= 8;
      } while (n3 > 0);
      return rval;
    };
    util$12.DataBuffer.prototype.getSignedInt = function(n3) {
      var x2 = this.getInt(n3);
      var max = 2 << n3 - 2;
      if (x2 >= max) {
        x2 -= max << 1;
      }
      return x2;
    };
    util$12.DataBuffer.prototype.getBytes = function(count) {
      var rval;
      if (count) {
        count = Math.min(this.length(), count);
        rval = this.data.slice(this.read, this.read + count);
        this.read += count;
      } else if (count === 0) {
        rval = "";
      } else {
        rval = this.read === 0 ? this.data : this.data.slice(this.read);
        this.clear();
      }
      return rval;
    };
    util$12.DataBuffer.prototype.bytes = function(count) {
      return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
    };
    util$12.DataBuffer.prototype.at = function(i2) {
      return this.data.getUint8(this.read + i2);
    };
    util$12.DataBuffer.prototype.setAt = function(i2, b2) {
      this.data.setUint8(i2, b2);
      return this;
    };
    util$12.DataBuffer.prototype.last = function() {
      return this.data.getUint8(this.write - 1);
    };
    util$12.DataBuffer.prototype.copy = function() {
      return new util$12.DataBuffer(this);
    };
    util$12.DataBuffer.prototype.compact = function() {
      if (this.read > 0) {
        var src2 = new Uint8Array(this.data.buffer, this.read);
        var dst = new Uint8Array(src2.byteLength);
        dst.set(src2);
        this.data = new DataView(dst);
        this.write -= this.read;
        this.read = 0;
      }
      return this;
    };
    util$12.DataBuffer.prototype.clear = function() {
      this.data = new DataView(new ArrayBuffer(0));
      this.read = this.write = 0;
      return this;
    };
    util$12.DataBuffer.prototype.truncate = function(count) {
      this.write = Math.max(0, this.length() - count);
      this.read = Math.min(this.read, this.write);
      return this;
    };
    util$12.DataBuffer.prototype.toHex = function() {
      var rval = "";
      for (var i2 = this.read; i2 < this.data.byteLength; ++i2) {
        var b2 = this.data.getUint8(i2);
        if (b2 < 16) {
          rval += "0";
        }
        rval += b2.toString(16);
      }
      return rval;
    };
    util$12.DataBuffer.prototype.toString = function(encoding) {
      var view = new Uint8Array(this.data, this.read, this.length());
      encoding = encoding || "utf8";
      if (encoding === "binary" || encoding === "raw") {
        return util$12.binary.raw.encode(view);
      }
      if (encoding === "hex") {
        return util$12.binary.hex.encode(view);
      }
      if (encoding === "base64") {
        return util$12.binary.base64.encode(view);
      }
      if (encoding === "utf8") {
        return util$12.text.utf8.decode(view);
      }
      if (encoding === "utf16") {
        return util$12.text.utf16.decode(view);
      }
      throw new Error("Invalid encoding: " + encoding);
    };
    util$12.createBuffer = function(input, encoding) {
      encoding = encoding || "raw";
      if (input !== void 0 && encoding === "utf8") {
        input = util$12.encodeUtf8(input);
      }
      return new util$12.ByteBuffer(input);
    };
    util$12.fillString = function(c3, n3) {
      var s3 = "";
      while (n3 > 0) {
        if (n3 & 1) {
          s3 += c3;
        }
        n3 >>>= 1;
        if (n3 > 0) {
          c3 += c3;
        }
      }
      return s3;
    };
    util$12.xorBytes = function(s1, s22, n3) {
      var s3 = "";
      var b2 = "";
      var t = "";
      var i2 = 0;
      var c3 = 0;
      for (; n3 > 0; --n3, ++i2) {
        b2 = s1.charCodeAt(i2) ^ s22.charCodeAt(i2);
        if (c3 >= 10) {
          s3 += t;
          t = "";
          c3 = 0;
        }
        t += String.fromCharCode(b2);
        ++c3;
      }
      s3 += t;
      return s3;
    };
    util$12.hexToBytes = function(hex) {
      var rval = "";
      var i2 = 0;
      if (hex.length & true) {
        i2 = 1;
        rval += String.fromCharCode(parseInt(hex[0], 16));
      }
      for (; i2 < hex.length; i2 += 2) {
        rval += String.fromCharCode(parseInt(hex.substr(i2, 2), 16));
      }
      return rval;
    };
    util$12.bytesToHex = function(bytes) {
      return util$12.createBuffer(bytes).toHex();
    };
    util$12.int32ToBytes = function(i2) {
      return String.fromCharCode(i2 >> 24 & 255) + String.fromCharCode(i2 >> 16 & 255) + String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 & 255);
    };
    var _base64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    var _base64Idx = [
      62,
      -1,
      -1,
      -1,
      63,
      52,
      53,
      54,
      55,
      56,
      57,
      58,
      59,
      60,
      61,
      -1,
      -1,
      -1,
      64,
      -1,
      -1,
      -1,
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      26,
      27,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37,
      38,
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      46,
      47,
      48,
      49,
      50,
      51
    ];
    var _base58 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    util$12.encode64 = function(input, maxline) {
      var line2 = "";
      var output = "";
      var chr1, chr2, chr3;
      var i2 = 0;
      while (i2 < input.length) {
        chr1 = input.charCodeAt(i2++);
        chr2 = input.charCodeAt(i2++);
        chr3 = input.charCodeAt(i2++);
        line2 += _base64.charAt(chr1 >> 2);
        line2 += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);
        if (isNaN(chr2)) {
          line2 += "==";
        } else {
          line2 += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
          line2 += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63);
        }
        if (maxline && line2.length > maxline) {
          output += line2.substr(0, maxline) + "\r\n";
          line2 = line2.substr(maxline);
        }
      }
      output += line2;
      return output;
    };
    util$12.decode64 = function(input) {
      input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
      var output = "";
      var enc1, enc2, enc3, enc4;
      var i2 = 0;
      while (i2 < input.length) {
        enc1 = _base64Idx[input.charCodeAt(i2++) - 43];
        enc2 = _base64Idx[input.charCodeAt(i2++) - 43];
        enc3 = _base64Idx[input.charCodeAt(i2++) - 43];
        enc4 = _base64Idx[input.charCodeAt(i2++) - 43];
        output += String.fromCharCode(enc1 << 2 | enc2 >> 4);
        if (enc3 !== 64) {
          output += String.fromCharCode((enc2 & 15) << 4 | enc3 >> 2);
          if (enc4 !== 64) {
            output += String.fromCharCode((enc3 & 3) << 6 | enc4);
          }
        }
      }
      return output;
    };
    util$12.encodeUtf8 = function(str) {
      return unescape(encodeURIComponent(str));
    };
    util$12.decodeUtf8 = function(str) {
      return decodeURIComponent(escape(str));
    };
    util$12.binary = {
      raw: {},
      hex: {},
      base64: {},
      base58: {},
      baseN: {
        encode: baseN.encode,
        decode: baseN.decode
      }
    };
    util$12.binary.raw.encode = function(bytes) {
      return String.fromCharCode.apply(null, bytes);
    };
    util$12.binary.raw.decode = function(str, output, offset2) {
      var out2 = output;
      if (!out2) {
        out2 = new Uint8Array(str.length);
      }
      offset2 = offset2 || 0;
      var j2 = offset2;
      for (var i2 = 0; i2 < str.length; ++i2) {
        out2[j2++] = str.charCodeAt(i2);
      }
      return output ? j2 - offset2 : out2;
    };
    util$12.binary.hex.encode = util$12.bytesToHex;
    util$12.binary.hex.decode = function(hex, output, offset2) {
      var out2 = output;
      if (!out2) {
        out2 = new Uint8Array(Math.ceil(hex.length / 2));
      }
      offset2 = offset2 || 0;
      var i2 = 0, j2 = offset2;
      if (hex.length & 1) {
        i2 = 1;
        out2[j2++] = parseInt(hex[0], 16);
      }
      for (; i2 < hex.length; i2 += 2) {
        out2[j2++] = parseInt(hex.substr(i2, 2), 16);
      }
      return output ? j2 - offset2 : out2;
    };
    util$12.binary.base64.encode = function(input, maxline) {
      var line2 = "";
      var output = "";
      var chr1, chr2, chr3;
      var i2 = 0;
      while (i2 < input.byteLength) {
        chr1 = input[i2++];
        chr2 = input[i2++];
        chr3 = input[i2++];
        line2 += _base64.charAt(chr1 >> 2);
        line2 += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);
        if (isNaN(chr2)) {
          line2 += "==";
        } else {
          line2 += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
          line2 += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63);
        }
        if (maxline && line2.length > maxline) {
          output += line2.substr(0, maxline) + "\r\n";
          line2 = line2.substr(maxline);
        }
      }
      output += line2;
      return output;
    };
    util$12.binary.base64.decode = function(input, output, offset2) {
      var out2 = output;
      if (!out2) {
        out2 = new Uint8Array(Math.ceil(input.length / 4) * 3);
      }
      input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
      offset2 = offset2 || 0;
      var enc1, enc2, enc3, enc4;
      var i2 = 0, j2 = offset2;
      while (i2 < input.length) {
        enc1 = _base64Idx[input.charCodeAt(i2++) - 43];
        enc2 = _base64Idx[input.charCodeAt(i2++) - 43];
        enc3 = _base64Idx[input.charCodeAt(i2++) - 43];
        enc4 = _base64Idx[input.charCodeAt(i2++) - 43];
        out2[j2++] = enc1 << 2 | enc2 >> 4;
        if (enc3 !== 64) {
          out2[j2++] = (enc2 & 15) << 4 | enc3 >> 2;
          if (enc4 !== 64) {
            out2[j2++] = (enc3 & 3) << 6 | enc4;
          }
        }
      }
      return output ? j2 - offset2 : out2.subarray(0, j2);
    };
    util$12.binary.base58.encode = function(input, maxline) {
      return util$12.binary.baseN.encode(input, _base58, maxline);
    };
    util$12.binary.base58.decode = function(input, maxline) {
      return util$12.binary.baseN.decode(input, _base58, maxline);
    };
    util$12.text = {
      utf8: {},
      utf16: {}
    };
    util$12.text.utf8.encode = function(str, output, offset2) {
      str = util$12.encodeUtf8(str);
      var out2 = output;
      if (!out2) {
        out2 = new Uint8Array(str.length);
      }
      offset2 = offset2 || 0;
      var j2 = offset2;
      for (var i2 = 0; i2 < str.length; ++i2) {
        out2[j2++] = str.charCodeAt(i2);
      }
      return output ? j2 - offset2 : out2;
    };
    util$12.text.utf8.decode = function(bytes) {
      return util$12.decodeUtf8(String.fromCharCode.apply(null, bytes));
    };
    util$12.text.utf16.encode = function(str, output, offset2) {
      var out2 = output;
      if (!out2) {
        out2 = new Uint8Array(str.length * 2);
      }
      var view = new Uint16Array(out2.buffer);
      offset2 = offset2 || 0;
      var j2 = offset2;
      var k2 = offset2;
      for (var i2 = 0; i2 < str.length; ++i2) {
        view[k2++] = str.charCodeAt(i2);
        j2 += 2;
      }
      return output ? j2 - offset2 : out2;
    };
    util$12.text.utf16.decode = function(bytes) {
      return String.fromCharCode.apply(null, new Uint16Array(bytes.buffer));
    };
    util$12.deflate = function(api2, bytes, raw) {
      bytes = util$12.decode64(api2.deflate(util$12.encode64(bytes)).rval);
      if (raw) {
        var start = 2;
        var flg = bytes.charCodeAt(1);
        if (flg & 32) {
          start = 6;
        }
        bytes = bytes.substring(start, bytes.length - 4);
      }
      return bytes;
    };
    util$12.inflate = function(api2, bytes, raw) {
      var rval = api2.inflate(util$12.encode64(bytes)).rval;
      return rval === null ? null : util$12.decode64(rval);
    };
    var _setStorageObject = function(api2, id, obj) {
      if (!api2) {
        throw new Error("WebStorage not available.");
      }
      var rval;
      if (obj === null) {
        rval = api2.removeItem(id);
      } else {
        obj = util$12.encode64(JSON.stringify(obj));
        rval = api2.setItem(id, obj);
      }
      if (typeof rval !== "undefined" && rval.rval !== true) {
        var error2 = new Error(rval.error.message);
        error2.id = rval.error.id;
        error2.name = rval.error.name;
        throw error2;
      }
    };
    var _getStorageObject = function(api2, id) {
      if (!api2) {
        throw new Error("WebStorage not available.");
      }
      var rval = api2.getItem(id);
      if (api2.init) {
        if (rval.rval === null) {
          if (rval.error) {
            var error2 = new Error(rval.error.message);
            error2.id = rval.error.id;
            error2.name = rval.error.name;
            throw error2;
          }
          rval = null;
        } else {
          rval = rval.rval;
        }
      }
      if (rval !== null) {
        rval = JSON.parse(util$12.decode64(rval));
      }
      return rval;
    };
    var _setItem = function(api2, id, key2, data2) {
      var obj = _getStorageObject(api2, id);
      if (obj === null) {
        obj = {};
      }
      obj[key2] = data2;
      _setStorageObject(api2, id, obj);
    };
    var _getItem = function(api2, id, key2) {
      var rval = _getStorageObject(api2, id);
      if (rval !== null) {
        rval = key2 in rval ? rval[key2] : null;
      }
      return rval;
    };
    var _removeItem = function(api2, id, key2) {
      var obj = _getStorageObject(api2, id);
      if (obj !== null && key2 in obj) {
        delete obj[key2];
        var empty2 = true;
        for (var prop in obj) {
          empty2 = false;
          break;
        }
        if (empty2) {
          obj = null;
        }
        _setStorageObject(api2, id, obj);
      }
    };
    var _clearItems = function(api2, id) {
      _setStorageObject(api2, id, null);
    };
    var _callStorageFunction = function(func, args, location) {
      var rval = null;
      if (typeof location === "undefined") {
        location = ["web", "flash"];
      }
      var type;
      var done = false;
      var exception = null;
      for (var idx in location) {
        type = location[idx];
        try {
          if (type === "flash" || type === "both") {
            if (args[0] === null) {
              throw new Error("Flash local storage not available.");
            }
            rval = func.apply(this, args);
            done = type === "flash";
          }
          if (type === "web" || type === "both") {
            args[0] = localStorage;
            rval = func.apply(this, args);
            done = true;
          }
        } catch (ex) {
          exception = ex;
        }
        if (done) {
          break;
        }
      }
      if (!done) {
        throw exception;
      }
      return rval;
    };
    util$12.setItem = function(api2, id, key2, data2, location) {
      _callStorageFunction(_setItem, arguments, location);
    };
    util$12.getItem = function(api2, id, key2, location) {
      return _callStorageFunction(_getItem, arguments, location);
    };
    util$12.removeItem = function(api2, id, key2, location) {
      _callStorageFunction(_removeItem, arguments, location);
    };
    util$12.clearItems = function(api2, id, location) {
      _callStorageFunction(_clearItems, arguments, location);
    };
    util$12.isEmpty = function(obj) {
      for (var prop in obj) {
        if (obj.hasOwnProperty(prop)) {
          return false;
        }
      }
      return true;
    };
    util$12.format = function(format2) {
      var re2 = /%./g;
      var match2;
      var part;
      var argi = 0;
      var parts = [];
      var last = 0;
      while (match2 = re2.exec(format2)) {
        part = format2.substring(last, re2.lastIndex - 2);
        if (part.length > 0) {
          parts.push(part);
        }
        last = re2.lastIndex;
        var code = match2[0][1];
        switch (code) {
          case "s":
          case "o":
            if (argi < arguments.length) {
              parts.push(arguments[argi++ + 1]);
            } else {
              parts.push("<?>");
            }
            break;
          case "%":
            parts.push("%");
            break;
          default:
            parts.push("<%" + code + "?>");
        }
      }
      parts.push(format2.substring(last));
      return parts.join("");
    };
    util$12.formatNumber = function(number, decimals, dec_point, thousands_sep) {
      var n3 = number, c3 = isNaN(decimals = Math.abs(decimals)) ? 2 : decimals;
      var d3 = dec_point === void 0 ? "," : dec_point;
      var t = thousands_sep === void 0 ? "." : thousands_sep, s3 = n3 < 0 ? "-" : "";
      var i2 = parseInt(n3 = Math.abs(+n3 || 0).toFixed(c3), 10) + "";
      var j2 = i2.length > 3 ? i2.length % 3 : 0;
      return s3 + (j2 ? i2.substr(0, j2) + t : "") + i2.substr(j2).replace(/(\d{3})(?=\d)/g, "$1" + t) + (c3 ? d3 + Math.abs(n3 - i2).toFixed(c3).slice(2) : "");
    };
    util$12.formatSize = function(size) {
      if (size >= 1073741824) {
        size = util$12.formatNumber(size / 1073741824, 2, ".", "") + " GiB";
      } else if (size >= 1048576) {
        size = util$12.formatNumber(size / 1048576, 2, ".", "") + " MiB";
      } else if (size >= 1024) {
        size = util$12.formatNumber(size / 1024, 0) + " KiB";
      } else {
        size = util$12.formatNumber(size, 0) + " bytes";
      }
      return size;
    };
    util$12.bytesFromIP = function(ip) {
      if (ip.indexOf(".") !== -1) {
        return util$12.bytesFromIPv4(ip);
      }
      if (ip.indexOf(":") !== -1) {
        return util$12.bytesFromIPv6(ip);
      }
      return null;
    };
    util$12.bytesFromIPv4 = function(ip) {
      ip = ip.split(".");
      if (ip.length !== 4) {
        return null;
      }
      var b2 = util$12.createBuffer();
      for (var i2 = 0; i2 < ip.length; ++i2) {
        var num = parseInt(ip[i2], 10);
        if (isNaN(num)) {
          return null;
        }
        b2.putByte(num);
      }
      return b2.getBytes();
    };
    util$12.bytesFromIPv6 = function(ip) {
      var blanks = 0;
      ip = ip.split(":").filter(function(e2) {
        if (e2.length === 0)
          ++blanks;
        return true;
      });
      var zeros2 = (8 - ip.length + blanks) * 2;
      var b2 = util$12.createBuffer();
      for (var i2 = 0; i2 < 8; ++i2) {
        if (!ip[i2] || ip[i2].length === 0) {
          b2.fillWithByte(0, zeros2);
          zeros2 = 0;
          continue;
        }
        var bytes = util$12.hexToBytes(ip[i2]);
        if (bytes.length < 2) {
          b2.putByte(0);
        }
        b2.putBytes(bytes);
      }
      return b2.getBytes();
    };
    util$12.bytesToIP = function(bytes) {
      if (bytes.length === 4) {
        return util$12.bytesToIPv4(bytes);
      }
      if (bytes.length === 16) {
        return util$12.bytesToIPv6(bytes);
      }
      return null;
    };
    util$12.bytesToIPv4 = function(bytes) {
      if (bytes.length !== 4) {
        return null;
      }
      var ip = [];
      for (var i2 = 0; i2 < bytes.length; ++i2) {
        ip.push(bytes.charCodeAt(i2));
      }
      return ip.join(".");
    };
    util$12.bytesToIPv6 = function(bytes) {
      if (bytes.length !== 16) {
        return null;
      }
      var ip = [];
      var zeroGroups = [];
      var zeroMaxGroup = 0;
      for (var i2 = 0; i2 < bytes.length; i2 += 2) {
        var hex = util$12.bytesToHex(bytes[i2] + bytes[i2 + 1]);
        while (hex[0] === "0" && hex !== "0") {
          hex = hex.substr(1);
        }
        if (hex === "0") {
          var last = zeroGroups[zeroGroups.length - 1];
          var idx = ip.length;
          if (!last || idx !== last.end + 1) {
            zeroGroups.push({ start: idx, end: idx });
          } else {
            last.end = idx;
            if (last.end - last.start > zeroGroups[zeroMaxGroup].end - zeroGroups[zeroMaxGroup].start) {
              zeroMaxGroup = zeroGroups.length - 1;
            }
          }
        }
        ip.push(hex);
      }
      if (zeroGroups.length > 0) {
        var group = zeroGroups[zeroMaxGroup];
        if (group.end - group.start > 0) {
          ip.splice(group.start, group.end - group.start + 1, "");
          if (group.start === 0) {
            ip.unshift("");
          }
          if (group.end === 7) {
            ip.push("");
          }
        }
      }
      return ip.join(":");
    };
    util$12.estimateCores = function(options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
        options2 = {};
      }
      options2 = options2 || {};
      if ("cores" in util$12 && !options2.update) {
        return callback(null, util$12.cores);
      }
      if (typeof navigator !== "undefined" && "hardwareConcurrency" in navigator && navigator.hardwareConcurrency > 0) {
        util$12.cores = navigator.hardwareConcurrency;
        return callback(null, util$12.cores);
      }
      if (typeof Worker === "undefined") {
        util$12.cores = 1;
        return callback(null, util$12.cores);
      }
      if (typeof Blob === "undefined") {
        util$12.cores = 2;
        return callback(null, util$12.cores);
      }
      var blobUrl = URL.createObjectURL(new Blob([
        "(",
        function() {
          self.addEventListener("message", function(e2) {
            var st2 = Date.now();
            var et2 = st2 + 4;
            self.postMessage({ st: st2, et: et2 });
          });
        }.toString(),
        ")()"
      ], { type: "application/javascript" }));
      sample([], 5, 16);
      function sample(max, samples, numWorkers) {
        if (samples === 0) {
          var avg = Math.floor(max.reduce(function(avg2, x2) {
            return avg2 + x2;
          }, 0) / max.length);
          util$12.cores = Math.max(1, avg);
          URL.revokeObjectURL(blobUrl);
          return callback(null, util$12.cores);
        }
        map2(numWorkers, function(err, results) {
          max.push(reduce(numWorkers, results));
          sample(max, samples - 1, numWorkers);
        });
      }
      function map2(numWorkers, callback2) {
        var workers = [];
        var results = [];
        for (var i2 = 0; i2 < numWorkers; ++i2) {
          var worker = new Worker(blobUrl);
          worker.addEventListener("message", function(e2) {
            results.push(e2.data);
            if (results.length === numWorkers) {
              for (var i3 = 0; i3 < numWorkers; ++i3) {
                workers[i3].terminate();
              }
              callback2(null, results);
            }
          });
          workers.push(worker);
        }
        for (var i2 = 0; i2 < numWorkers; ++i2) {
          workers[i2].postMessage(i2);
        }
      }
      function reduce(numWorkers, results) {
        var overlaps = [];
        for (var n3 = 0; n3 < numWorkers; ++n3) {
          var r1 = results[n3];
          var overlap = overlaps[n3] = [];
          for (var i2 = 0; i2 < numWorkers; ++i2) {
            if (n3 === i2) {
              continue;
            }
            var r2 = results[i2];
            if (r1.st > r2.st && r1.st < r2.et || r2.st > r1.st && r2.st < r1.et) {
              overlap.push(i2);
            }
          }
        }
        return overlaps.reduce(function(max, overlap2) {
          return Math.max(max, overlap2.length);
        }, 0);
      }
    };
    var forge$q = forge$s;
    forge$q.pki = forge$q.pki || {};
    var oids$2 = forge$q.pki.oids = forge$q.oids = forge$q.oids || {};
    function _IN(id, name) {
      oids$2[id] = name;
      oids$2[name] = id;
    }
    function _I_(id, name) {
      oids$2[id] = name;
    }
    _IN("1.2.840.113549.1.1.1", "rsaEncryption");
    _IN("1.2.840.113549.1.1.4", "md5WithRSAEncryption");
    _IN("1.2.840.113549.1.1.5", "sha1WithRSAEncryption");
    _IN("1.2.840.113549.1.1.7", "RSAES-OAEP");
    _IN("1.2.840.113549.1.1.8", "mgf1");
    _IN("1.2.840.113549.1.1.9", "pSpecified");
    _IN("1.2.840.113549.1.1.10", "RSASSA-PSS");
    _IN("1.2.840.113549.1.1.11", "sha256WithRSAEncryption");
    _IN("1.2.840.113549.1.1.12", "sha384WithRSAEncryption");
    _IN("1.2.840.113549.1.1.13", "sha512WithRSAEncryption");
    _IN("1.3.101.112", "EdDSA25519");
    _IN("1.2.840.10040.4.3", "dsa-with-sha1");
    _IN("1.3.14.3.2.7", "desCBC");
    _IN("1.3.14.3.2.26", "sha1");
    _IN("1.3.14.3.2.29", "sha1WithRSASignature");
    _IN("2.16.840.1.101.3.4.2.1", "sha256");
    _IN("2.16.840.1.101.3.4.2.2", "sha384");
    _IN("2.16.840.1.101.3.4.2.3", "sha512");
    _IN("2.16.840.1.101.3.4.2.4", "sha224");
    _IN("2.16.840.1.101.3.4.2.5", "sha512-224");
    _IN("2.16.840.1.101.3.4.2.6", "sha512-256");
    _IN("1.2.840.113549.2.2", "md2");
    _IN("1.2.840.113549.2.5", "md5");
    _IN("1.2.840.113549.1.7.1", "data");
    _IN("1.2.840.113549.1.7.2", "signedData");
    _IN("1.2.840.113549.1.7.3", "envelopedData");
    _IN("1.2.840.113549.1.7.4", "signedAndEnvelopedData");
    _IN("1.2.840.113549.1.7.5", "digestedData");
    _IN("1.2.840.113549.1.7.6", "encryptedData");
    _IN("1.2.840.113549.1.9.1", "emailAddress");
    _IN("1.2.840.113549.1.9.2", "unstructuredName");
    _IN("1.2.840.113549.1.9.3", "contentType");
    _IN("1.2.840.113549.1.9.4", "messageDigest");
    _IN("1.2.840.113549.1.9.5", "signingTime");
    _IN("1.2.840.113549.1.9.6", "counterSignature");
    _IN("1.2.840.113549.1.9.7", "challengePassword");
    _IN("1.2.840.113549.1.9.8", "unstructuredAddress");
    _IN("1.2.840.113549.1.9.14", "extensionRequest");
    _IN("1.2.840.113549.1.9.20", "friendlyName");
    _IN("1.2.840.113549.1.9.21", "localKeyId");
    _IN("1.2.840.113549.1.9.22.1", "x509Certificate");
    _IN("1.2.840.113549.1.12.10.1.1", "keyBag");
    _IN("1.2.840.113549.1.12.10.1.2", "pkcs8ShroudedKeyBag");
    _IN("1.2.840.113549.1.12.10.1.3", "certBag");
    _IN("1.2.840.113549.1.12.10.1.4", "crlBag");
    _IN("1.2.840.113549.1.12.10.1.5", "secretBag");
    _IN("1.2.840.113549.1.12.10.1.6", "safeContentsBag");
    _IN("1.2.840.113549.1.5.13", "pkcs5PBES2");
    _IN("1.2.840.113549.1.5.12", "pkcs5PBKDF2");
    _IN("1.2.840.113549.1.12.1.1", "pbeWithSHAAnd128BitRC4");
    _IN("1.2.840.113549.1.12.1.2", "pbeWithSHAAnd40BitRC4");
    _IN("1.2.840.113549.1.12.1.3", "pbeWithSHAAnd3-KeyTripleDES-CBC");
    _IN("1.2.840.113549.1.12.1.4", "pbeWithSHAAnd2-KeyTripleDES-CBC");
    _IN("1.2.840.113549.1.12.1.5", "pbeWithSHAAnd128BitRC2-CBC");
    _IN("1.2.840.113549.1.12.1.6", "pbewithSHAAnd40BitRC2-CBC");
    _IN("1.2.840.113549.2.7", "hmacWithSHA1");
    _IN("1.2.840.113549.2.8", "hmacWithSHA224");
    _IN("1.2.840.113549.2.9", "hmacWithSHA256");
    _IN("1.2.840.113549.2.10", "hmacWithSHA384");
    _IN("1.2.840.113549.2.11", "hmacWithSHA512");
    _IN("1.2.840.113549.3.7", "des-EDE3-CBC");
    _IN("2.16.840.1.101.3.4.1.2", "aes128-CBC");
    _IN("2.16.840.1.101.3.4.1.22", "aes192-CBC");
    _IN("2.16.840.1.101.3.4.1.42", "aes256-CBC");
    _IN("2.5.4.3", "commonName");
    _IN("2.5.4.4", "surname");
    _IN("2.5.4.5", "serialNumber");
    _IN("2.5.4.6", "countryName");
    _IN("2.5.4.7", "localityName");
    _IN("2.5.4.8", "stateOrProvinceName");
    _IN("2.5.4.9", "streetAddress");
    _IN("2.5.4.10", "organizationName");
    _IN("2.5.4.11", "organizationalUnitName");
    _IN("2.5.4.12", "title");
    _IN("2.5.4.13", "description");
    _IN("2.5.4.15", "businessCategory");
    _IN("2.5.4.17", "postalCode");
    _IN("2.5.4.42", "givenName");
    _IN("1.3.6.1.4.1.311.60.2.1.2", "jurisdictionOfIncorporationStateOrProvinceName");
    _IN("1.3.6.1.4.1.311.60.2.1.3", "jurisdictionOfIncorporationCountryName");
    _IN("2.16.840.1.113730.1.1", "nsCertType");
    _IN("2.16.840.1.113730.1.13", "nsComment");
    _I_("2.5.29.1", "authorityKeyIdentifier");
    _I_("2.5.29.2", "keyAttributes");
    _I_("2.5.29.3", "certificatePolicies");
    _I_("2.5.29.4", "keyUsageRestriction");
    _I_("2.5.29.5", "policyMapping");
    _I_("2.5.29.6", "subtreesConstraint");
    _I_("2.5.29.7", "subjectAltName");
    _I_("2.5.29.8", "issuerAltName");
    _I_("2.5.29.9", "subjectDirectoryAttributes");
    _I_("2.5.29.10", "basicConstraints");
    _I_("2.5.29.11", "nameConstraints");
    _I_("2.5.29.12", "policyConstraints");
    _I_("2.5.29.13", "basicConstraints");
    _IN("2.5.29.14", "subjectKeyIdentifier");
    _IN("2.5.29.15", "keyUsage");
    _I_("2.5.29.16", "privateKeyUsagePeriod");
    _IN("2.5.29.17", "subjectAltName");
    _IN("2.5.29.18", "issuerAltName");
    _IN("2.5.29.19", "basicConstraints");
    _I_("2.5.29.20", "cRLNumber");
    _I_("2.5.29.21", "cRLReason");
    _I_("2.5.29.22", "expirationDate");
    _I_("2.5.29.23", "instructionCode");
    _I_("2.5.29.24", "invalidityDate");
    _I_("2.5.29.25", "cRLDistributionPoints");
    _I_("2.5.29.26", "issuingDistributionPoint");
    _I_("2.5.29.27", "deltaCRLIndicator");
    _I_("2.5.29.28", "issuingDistributionPoint");
    _I_("2.5.29.29", "certificateIssuer");
    _I_("2.5.29.30", "nameConstraints");
    _IN("2.5.29.31", "cRLDistributionPoints");
    _IN("2.5.29.32", "certificatePolicies");
    _I_("2.5.29.33", "policyMappings");
    _I_("2.5.29.34", "policyConstraints");
    _IN("2.5.29.35", "authorityKeyIdentifier");
    _I_("2.5.29.36", "policyConstraints");
    _IN("2.5.29.37", "extKeyUsage");
    _I_("2.5.29.46", "freshestCRL");
    _I_("2.5.29.54", "inhibitAnyPolicy");
    _IN("1.3.6.1.4.1.11129.2.4.2", "timestampList");
    _IN("1.3.6.1.5.5.7.1.1", "authorityInfoAccess");
    _IN("1.3.6.1.5.5.7.3.1", "serverAuth");
    _IN("1.3.6.1.5.5.7.3.2", "clientAuth");
    _IN("1.3.6.1.5.5.7.3.3", "codeSigning");
    _IN("1.3.6.1.5.5.7.3.4", "emailProtection");
    _IN("1.3.6.1.5.5.7.3.8", "timeStamping");
    var forge$p = forge$s;
    var asn1$6 = forge$p.asn1 = forge$p.asn1 || {};
    asn1$6.Class = {
      UNIVERSAL: 0,
      APPLICATION: 64,
      CONTEXT_SPECIFIC: 128,
      PRIVATE: 192
    };
    asn1$6.Type = {
      NONE: 0,
      BOOLEAN: 1,
      INTEGER: 2,
      BITSTRING: 3,
      OCTETSTRING: 4,
      NULL: 5,
      OID: 6,
      ODESC: 7,
      EXTERNAL: 8,
      REAL: 9,
      ENUMERATED: 10,
      EMBEDDED: 11,
      UTF8: 12,
      ROID: 13,
      SEQUENCE: 16,
      SET: 17,
      PRINTABLESTRING: 19,
      IA5STRING: 22,
      UTCTIME: 23,
      GENERALIZEDTIME: 24,
      BMPSTRING: 30
    };
    asn1$6.create = function(tagClass, type, constructed, value, options2) {
      if (forge$p.util.isArray(value)) {
        var tmp = [];
        for (var i2 = 0; i2 < value.length; ++i2) {
          if (value[i2] !== void 0) {
            tmp.push(value[i2]);
          }
        }
        value = tmp;
      }
      var obj = {
        tagClass,
        type,
        constructed,
        composed: constructed || forge$p.util.isArray(value),
        value
      };
      if (options2 && "bitStringContents" in options2) {
        obj.bitStringContents = options2.bitStringContents;
        obj.original = asn1$6.copy(obj);
      }
      return obj;
    };
    asn1$6.copy = function(obj, options2) {
      var copy;
      if (forge$p.util.isArray(obj)) {
        copy = [];
        for (var i2 = 0; i2 < obj.length; ++i2) {
          copy.push(asn1$6.copy(obj[i2], options2));
        }
        return copy;
      }
      if (typeof obj === "string") {
        return obj;
      }
      copy = {
        tagClass: obj.tagClass,
        type: obj.type,
        constructed: obj.constructed,
        composed: obj.composed,
        value: asn1$6.copy(obj.value, options2)
      };
      if (options2 && !options2.excludeBitStringContents) {
        copy.bitStringContents = obj.bitStringContents;
      }
      return copy;
    };
    asn1$6.equals = function(obj1, obj2, options2) {
      if (forge$p.util.isArray(obj1)) {
        if (!forge$p.util.isArray(obj2)) {
          return false;
        }
        if (obj1.length !== obj2.length) {
          return false;
        }
        for (var i2 = 0; i2 < obj1.length; ++i2) {
          if (!asn1$6.equals(obj1[i2], obj2[i2])) {
            return false;
          }
        }
        return true;
      }
      if (typeof obj1 !== typeof obj2) {
        return false;
      }
      if (typeof obj1 === "string") {
        return obj1 === obj2;
      }
      var equal = obj1.tagClass === obj2.tagClass && obj1.type === obj2.type && obj1.constructed === obj2.constructed && obj1.composed === obj2.composed && asn1$6.equals(obj1.value, obj2.value);
      if (options2 && options2.includeBitStringContents) {
        equal = equal && obj1.bitStringContents === obj2.bitStringContents;
      }
      return equal;
    };
    asn1$6.getBerValueLength = function(b2) {
      var b22 = b2.getByte();
      if (b22 === 128) {
        return void 0;
      }
      var length;
      var longForm = b22 & 128;
      if (!longForm) {
        length = b22;
      } else {
        length = b2.getInt((b22 & 127) << 3);
      }
      return length;
    };
    function _checkBufferLength(bytes, remaining, n3) {
      if (n3 > remaining) {
        var error2 = new Error("Too few bytes to parse DER.");
        error2.available = bytes.length();
        error2.remaining = remaining;
        error2.requested = n3;
        throw error2;
      }
    }
    var _getValueLength = function(bytes, remaining) {
      var b2 = bytes.getByte();
      remaining--;
      if (b2 === 128) {
        return void 0;
      }
      var length;
      var longForm = b2 & 128;
      if (!longForm) {
        length = b2;
      } else {
        var longFormBytes = b2 & 127;
        _checkBufferLength(bytes, remaining, longFormBytes);
        length = bytes.getInt(longFormBytes << 3);
      }
      if (length < 0) {
        throw new Error("Negative length: " + length);
      }
      return length;
    };
    asn1$6.fromDer = function(bytes, options2) {
      if (options2 === void 0) {
        options2 = {
          strict: true,
          parseAllBytes: true,
          decodeBitStrings: true
        };
      }
      if (typeof options2 === "boolean") {
        options2 = {
          strict: options2,
          parseAllBytes: true,
          decodeBitStrings: true
        };
      }
      if (!("strict" in options2)) {
        options2.strict = true;
      }
      if (!("parseAllBytes" in options2)) {
        options2.parseAllBytes = true;
      }
      if (!("decodeBitStrings" in options2)) {
        options2.decodeBitStrings = true;
      }
      if (typeof bytes === "string") {
        bytes = forge$p.util.createBuffer(bytes);
      }
      var byteCount = bytes.length();
      var value = _fromDer(bytes, bytes.length(), 0, options2);
      if (options2.parseAllBytes && bytes.length() !== 0) {
        var error2 = new Error("Unparsed DER bytes remain after ASN.1 parsing.");
        error2.byteCount = byteCount;
        error2.remaining = bytes.length();
        throw error2;
      }
      return value;
    };
    function _fromDer(bytes, remaining, depth2, options2) {
      var start;
      _checkBufferLength(bytes, remaining, 2);
      var b1 = bytes.getByte();
      remaining--;
      var tagClass = b1 & 192;
      var type = b1 & 31;
      start = bytes.length();
      var length = _getValueLength(bytes, remaining);
      remaining -= start - bytes.length();
      if (length !== void 0 && length > remaining) {
        if (options2.strict) {
          var error2 = new Error("Too few bytes to read ASN.1 value.");
          error2.available = bytes.length();
          error2.remaining = remaining;
          error2.requested = length;
          throw error2;
        }
        length = remaining;
      }
      var value;
      var bitStringContents;
      var constructed = (b1 & 32) === 32;
      if (constructed) {
        value = [];
        if (length === void 0) {
          for (; ; ) {
            _checkBufferLength(bytes, remaining, 2);
            if (bytes.bytes(2) === String.fromCharCode(0, 0)) {
              bytes.getBytes(2);
              remaining -= 2;
              break;
            }
            start = bytes.length();
            value.push(_fromDer(bytes, remaining, depth2 + 1, options2));
            remaining -= start - bytes.length();
          }
        } else {
          while (length > 0) {
            start = bytes.length();
            value.push(_fromDer(bytes, length, depth2 + 1, options2));
            remaining -= start - bytes.length();
            length -= start - bytes.length();
          }
        }
      }
      if (value === void 0 && tagClass === asn1$6.Class.UNIVERSAL && type === asn1$6.Type.BITSTRING) {
        bitStringContents = bytes.bytes(length);
      }
      if (value === void 0 && options2.decodeBitStrings && tagClass === asn1$6.Class.UNIVERSAL && type === asn1$6.Type.BITSTRING && length > 1) {
        var savedRead = bytes.read;
        var savedRemaining = remaining;
        var unused = 0;
        if (type === asn1$6.Type.BITSTRING) {
          _checkBufferLength(bytes, remaining, 1);
          unused = bytes.getByte();
          remaining--;
        }
        if (unused === 0) {
          try {
            start = bytes.length();
            var subOptions = {
              strict: true,
              decodeBitStrings: true
            };
            var composed = _fromDer(bytes, remaining, depth2 + 1, subOptions);
            var used = start - bytes.length();
            remaining -= used;
            if (type == asn1$6.Type.BITSTRING) {
              used++;
            }
            var tc = composed.tagClass;
            if (used === length && (tc === asn1$6.Class.UNIVERSAL || tc === asn1$6.Class.CONTEXT_SPECIFIC)) {
              value = [composed];
            }
          } catch (ex) {
          }
        }
        if (value === void 0) {
          bytes.read = savedRead;
          remaining = savedRemaining;
        }
      }
      if (value === void 0) {
        if (length === void 0) {
          if (options2.strict) {
            throw new Error("Non-constructed ASN.1 object of indefinite length.");
          }
          length = remaining;
        }
        if (type === asn1$6.Type.BMPSTRING) {
          value = "";
          for (; length > 0; length -= 2) {
            _checkBufferLength(bytes, remaining, 2);
            value += String.fromCharCode(bytes.getInt16());
            remaining -= 2;
          }
        } else {
          value = bytes.getBytes(length);
          remaining -= length;
        }
      }
      var asn1Options = bitStringContents === void 0 ? null : {
        bitStringContents
      };
      return asn1$6.create(tagClass, type, constructed, value, asn1Options);
    }
    asn1$6.toDer = function(obj) {
      var bytes = forge$p.util.createBuffer();
      var b1 = obj.tagClass | obj.type;
      var value = forge$p.util.createBuffer();
      var useBitStringContents = false;
      if ("bitStringContents" in obj) {
        useBitStringContents = true;
        if (obj.original) {
          useBitStringContents = asn1$6.equals(obj, obj.original);
        }
      }
      if (useBitStringContents) {
        value.putBytes(obj.bitStringContents);
      } else if (obj.composed) {
        if (obj.constructed) {
          b1 |= 32;
        } else {
          value.putByte(0);
        }
        for (var i2 = 0; i2 < obj.value.length; ++i2) {
          if (obj.value[i2] !== void 0) {
            value.putBuffer(asn1$6.toDer(obj.value[i2]));
          }
        }
      } else {
        if (obj.type === asn1$6.Type.BMPSTRING) {
          for (var i2 = 0; i2 < obj.value.length; ++i2) {
            value.putInt16(obj.value.charCodeAt(i2));
          }
        } else {
          if (obj.type === asn1$6.Type.INTEGER && obj.value.length > 1 && (obj.value.charCodeAt(0) === 0 && (obj.value.charCodeAt(1) & 128) === 0 || obj.value.charCodeAt(0) === 255 && (obj.value.charCodeAt(1) & 128) === 128)) {
            value.putBytes(obj.value.substr(1));
          } else {
            value.putBytes(obj.value);
          }
        }
      }
      bytes.putByte(b1);
      if (value.length() <= 127) {
        bytes.putByte(value.length() & 127);
      } else {
        var len = value.length();
        var lenBytes = "";
        do {
          lenBytes += String.fromCharCode(len & 255);
          len = len >>> 8;
        } while (len > 0);
        bytes.putByte(lenBytes.length | 128);
        for (var i2 = lenBytes.length - 1; i2 >= 0; --i2) {
          bytes.putByte(lenBytes.charCodeAt(i2));
        }
      }
      bytes.putBuffer(value);
      return bytes;
    };
    asn1$6.oidToDer = function(oid) {
      var values = oid.split(".");
      var bytes = forge$p.util.createBuffer();
      bytes.putByte(40 * parseInt(values[0], 10) + parseInt(values[1], 10));
      var last, valueBytes, value, b2;
      for (var i2 = 2; i2 < values.length; ++i2) {
        last = true;
        valueBytes = [];
        value = parseInt(values[i2], 10);
        do {
          b2 = value & 127;
          value = value >>> 7;
          if (!last) {
            b2 |= 128;
          }
          valueBytes.push(b2);
          last = false;
        } while (value > 0);
        for (var n3 = valueBytes.length - 1; n3 >= 0; --n3) {
          bytes.putByte(valueBytes[n3]);
        }
      }
      return bytes;
    };
    asn1$6.derToOid = function(bytes) {
      var oid;
      if (typeof bytes === "string") {
        bytes = forge$p.util.createBuffer(bytes);
      }
      var b2 = bytes.getByte();
      oid = Math.floor(b2 / 40) + "." + b2 % 40;
      var value = 0;
      while (bytes.length() > 0) {
        b2 = bytes.getByte();
        value = value << 7;
        if (b2 & 128) {
          value += b2 & 127;
        } else {
          oid += "." + (value + b2);
          value = 0;
        }
      }
      return oid;
    };
    asn1$6.utcTimeToDate = function(utc) {
      var date = new Date();
      var year = parseInt(utc.substr(0, 2), 10);
      year = year >= 50 ? 1900 + year : 2e3 + year;
      var MM = parseInt(utc.substr(2, 2), 10) - 1;
      var DD = parseInt(utc.substr(4, 2), 10);
      var hh2 = parseInt(utc.substr(6, 2), 10);
      var mm = parseInt(utc.substr(8, 2), 10);
      var ss2 = 0;
      if (utc.length > 11) {
        var c3 = utc.charAt(10);
        var end = 10;
        if (c3 !== "+" && c3 !== "-") {
          ss2 = parseInt(utc.substr(10, 2), 10);
          end += 2;
        }
      }
      date.setUTCFullYear(year, MM, DD);
      date.setUTCHours(hh2, mm, ss2, 0);
      if (end) {
        c3 = utc.charAt(end);
        if (c3 === "+" || c3 === "-") {
          var hhoffset = parseInt(utc.substr(end + 1, 2), 10);
          var mmoffset = parseInt(utc.substr(end + 4, 2), 10);
          var offset2 = hhoffset * 60 + mmoffset;
          offset2 *= 6e4;
          if (c3 === "+") {
            date.setTime(+date - offset2);
          } else {
            date.setTime(+date + offset2);
          }
        }
      }
      return date;
    };
    asn1$6.generalizedTimeToDate = function(gentime) {
      var date = new Date();
      var YYYY = parseInt(gentime.substr(0, 4), 10);
      var MM = parseInt(gentime.substr(4, 2), 10) - 1;
      var DD = parseInt(gentime.substr(6, 2), 10);
      var hh2 = parseInt(gentime.substr(8, 2), 10);
      var mm = parseInt(gentime.substr(10, 2), 10);
      var ss2 = parseInt(gentime.substr(12, 2), 10);
      var fff = 0;
      var offset2 = 0;
      var isUTC = false;
      if (gentime.charAt(gentime.length - 1) === "Z") {
        isUTC = true;
      }
      var end = gentime.length - 5, c3 = gentime.charAt(end);
      if (c3 === "+" || c3 === "-") {
        var hhoffset = parseInt(gentime.substr(end + 1, 2), 10);
        var mmoffset = parseInt(gentime.substr(end + 4, 2), 10);
        offset2 = hhoffset * 60 + mmoffset;
        offset2 *= 6e4;
        if (c3 === "+") {
          offset2 *= -1;
        }
        isUTC = true;
      }
      if (gentime.charAt(14) === ".") {
        fff = parseFloat(gentime.substr(14), 10) * 1e3;
      }
      if (isUTC) {
        date.setUTCFullYear(YYYY, MM, DD);
        date.setUTCHours(hh2, mm, ss2, fff);
        date.setTime(+date + offset2);
      } else {
        date.setFullYear(YYYY, MM, DD);
        date.setHours(hh2, mm, ss2, fff);
      }
      return date;
    };
    asn1$6.dateToUtcTime = function(date) {
      if (typeof date === "string") {
        return date;
      }
      var rval = "";
      var format2 = [];
      format2.push(("" + date.getUTCFullYear()).substr(2));
      format2.push("" + (date.getUTCMonth() + 1));
      format2.push("" + date.getUTCDate());
      format2.push("" + date.getUTCHours());
      format2.push("" + date.getUTCMinutes());
      format2.push("" + date.getUTCSeconds());
      for (var i2 = 0; i2 < format2.length; ++i2) {
        if (format2[i2].length < 2) {
          rval += "0";
        }
        rval += format2[i2];
      }
      rval += "Z";
      return rval;
    };
    asn1$6.dateToGeneralizedTime = function(date) {
      if (typeof date === "string") {
        return date;
      }
      var rval = "";
      var format2 = [];
      format2.push("" + date.getUTCFullYear());
      format2.push("" + (date.getUTCMonth() + 1));
      format2.push("" + date.getUTCDate());
      format2.push("" + date.getUTCHours());
      format2.push("" + date.getUTCMinutes());
      format2.push("" + date.getUTCSeconds());
      for (var i2 = 0; i2 < format2.length; ++i2) {
        if (format2[i2].length < 2) {
          rval += "0";
        }
        rval += format2[i2];
      }
      rval += "Z";
      return rval;
    };
    asn1$6.integerToDer = function(x2) {
      var rval = forge$p.util.createBuffer();
      if (x2 >= -128 && x2 < 128) {
        return rval.putSignedInt(x2, 8);
      }
      if (x2 >= -32768 && x2 < 32768) {
        return rval.putSignedInt(x2, 16);
      }
      if (x2 >= -8388608 && x2 < 8388608) {
        return rval.putSignedInt(x2, 24);
      }
      if (x2 >= -2147483648 && x2 < 2147483648) {
        return rval.putSignedInt(x2, 32);
      }
      var error2 = new Error("Integer too large; max is 32-bits.");
      error2.integer = x2;
      throw error2;
    };
    asn1$6.derToInteger = function(bytes) {
      if (typeof bytes === "string") {
        bytes = forge$p.util.createBuffer(bytes);
      }
      var n3 = bytes.length() * 8;
      if (n3 > 32) {
        throw new Error("Integer too large; max is 32-bits.");
      }
      return bytes.getSignedInt(n3);
    };
    asn1$6.validate = function(obj, v2, capture, errors) {
      var rval = false;
      if ((obj.tagClass === v2.tagClass || typeof v2.tagClass === "undefined") && (obj.type === v2.type || typeof v2.type === "undefined")) {
        if (obj.constructed === v2.constructed || typeof v2.constructed === "undefined") {
          rval = true;
          if (v2.value && forge$p.util.isArray(v2.value)) {
            var j2 = 0;
            for (var i2 = 0; rval && i2 < v2.value.length; ++i2) {
              rval = v2.value[i2].optional || false;
              if (obj.value[j2]) {
                rval = asn1$6.validate(obj.value[j2], v2.value[i2], capture, errors);
                if (rval) {
                  ++j2;
                } else if (v2.value[i2].optional) {
                  rval = true;
                }
              }
              if (!rval && errors) {
                errors.push("[" + v2.name + '] Tag class "' + v2.tagClass + '", type "' + v2.type + '" expected value length "' + v2.value.length + '", got "' + obj.value.length + '"');
              }
            }
          }
          if (rval && capture) {
            if (v2.capture) {
              capture[v2.capture] = obj.value;
            }
            if (v2.captureAsn1) {
              capture[v2.captureAsn1] = obj;
            }
            if (v2.captureBitStringContents && "bitStringContents" in obj) {
              capture[v2.captureBitStringContents] = obj.bitStringContents;
            }
            if (v2.captureBitStringValue && "bitStringContents" in obj) {
              if (obj.bitStringContents.length < 2) {
                capture[v2.captureBitStringValue] = "";
              } else {
                var unused = obj.bitStringContents.charCodeAt(0);
                if (unused !== 0) {
                  throw new Error("captureBitStringValue only supported for zero unused bits");
                }
                capture[v2.captureBitStringValue] = obj.bitStringContents.slice(1);
              }
            }
          }
        } else if (errors) {
          errors.push("[" + v2.name + '] Expected constructed "' + v2.constructed + '", got "' + obj.constructed + '"');
        }
      } else if (errors) {
        if (obj.tagClass !== v2.tagClass) {
          errors.push("[" + v2.name + '] Expected tag class "' + v2.tagClass + '", got "' + obj.tagClass + '"');
        }
        if (obj.type !== v2.type) {
          errors.push("[" + v2.name + '] Expected type "' + v2.type + '", got "' + obj.type + '"');
        }
      }
      return rval;
    };
    var _nonLatinRegex = /[^\\u0000-\\u00ff]/;
    asn1$6.prettyPrint = function(obj, level2, indentation) {
      var rval = "";
      level2 = level2 || 0;
      indentation = indentation || 2;
      if (level2 > 0) {
        rval += "\n";
      }
      var indent = "";
      for (var i2 = 0; i2 < level2 * indentation; ++i2) {
        indent += " ";
      }
      rval += indent + "Tag: ";
      switch (obj.tagClass) {
        case asn1$6.Class.UNIVERSAL:
          rval += "Universal:";
          break;
        case asn1$6.Class.APPLICATION:
          rval += "Application:";
          break;
        case asn1$6.Class.CONTEXT_SPECIFIC:
          rval += "Context-Specific:";
          break;
        case asn1$6.Class.PRIVATE:
          rval += "Private:";
          break;
      }
      if (obj.tagClass === asn1$6.Class.UNIVERSAL) {
        rval += obj.type;
        switch (obj.type) {
          case asn1$6.Type.NONE:
            rval += " (None)";
            break;
          case asn1$6.Type.BOOLEAN:
            rval += " (Boolean)";
            break;
          case asn1$6.Type.INTEGER:
            rval += " (Integer)";
            break;
          case asn1$6.Type.BITSTRING:
            rval += " (Bit string)";
            break;
          case asn1$6.Type.OCTETSTRING:
            rval += " (Octet string)";
            break;
          case asn1$6.Type.NULL:
            rval += " (Null)";
            break;
          case asn1$6.Type.OID:
            rval += " (Object Identifier)";
            break;
          case asn1$6.Type.ODESC:
            rval += " (Object Descriptor)";
            break;
          case asn1$6.Type.EXTERNAL:
            rval += " (External or Instance of)";
            break;
          case asn1$6.Type.REAL:
            rval += " (Real)";
            break;
          case asn1$6.Type.ENUMERATED:
            rval += " (Enumerated)";
            break;
          case asn1$6.Type.EMBEDDED:
            rval += " (Embedded PDV)";
            break;
          case asn1$6.Type.UTF8:
            rval += " (UTF8)";
            break;
          case asn1$6.Type.ROID:
            rval += " (Relative Object Identifier)";
            break;
          case asn1$6.Type.SEQUENCE:
            rval += " (Sequence)";
            break;
          case asn1$6.Type.SET:
            rval += " (Set)";
            break;
          case asn1$6.Type.PRINTABLESTRING:
            rval += " (Printable String)";
            break;
          case asn1$6.Type.IA5String:
            rval += " (IA5String (ASCII))";
            break;
          case asn1$6.Type.UTCTIME:
            rval += " (UTC time)";
            break;
          case asn1$6.Type.GENERALIZEDTIME:
            rval += " (Generalized time)";
            break;
          case asn1$6.Type.BMPSTRING:
            rval += " (BMP String)";
            break;
        }
      } else {
        rval += obj.type;
      }
      rval += "\n";
      rval += indent + "Constructed: " + obj.constructed + "\n";
      if (obj.composed) {
        var subvalues = 0;
        var sub = "";
        for (var i2 = 0; i2 < obj.value.length; ++i2) {
          if (obj.value[i2] !== void 0) {
            subvalues += 1;
            sub += asn1$6.prettyPrint(obj.value[i2], level2 + 1, indentation);
            if (i2 + 1 < obj.value.length) {
              sub += ",";
            }
          }
        }
        rval += indent + "Sub values: " + subvalues + sub;
      } else {
        rval += indent + "Value: ";
        if (obj.type === asn1$6.Type.OID) {
          var oid = asn1$6.derToOid(obj.value);
          rval += oid;
          if (forge$p.pki && forge$p.pki.oids) {
            if (oid in forge$p.pki.oids) {
              rval += " (" + forge$p.pki.oids[oid] + ") ";
            }
          }
        }
        if (obj.type === asn1$6.Type.INTEGER) {
          try {
            rval += asn1$6.derToInteger(obj.value);
          } catch (ex) {
            rval += "0x" + forge$p.util.bytesToHex(obj.value);
          }
        } else if (obj.type === asn1$6.Type.BITSTRING) {
          if (obj.value.length > 1) {
            rval += "0x" + forge$p.util.bytesToHex(obj.value.slice(1));
          } else {
            rval += "(none)";
          }
          if (obj.value.length > 0) {
            var unused = obj.value.charCodeAt(0);
            if (unused == 1) {
              rval += " (1 unused bit shown)";
            } else if (unused > 1) {
              rval += " (" + unused + " unused bits shown)";
            }
          }
        } else if (obj.type === asn1$6.Type.OCTETSTRING) {
          if (!_nonLatinRegex.test(obj.value)) {
            rval += "(" + obj.value + ") ";
          }
          rval += "0x" + forge$p.util.bytesToHex(obj.value);
        } else if (obj.type === asn1$6.Type.UTF8) {
          try {
            rval += forge$p.util.decodeUtf8(obj.value);
          } catch (e2) {
            if (e2.message === "URI malformed") {
              rval += "0x" + forge$p.util.bytesToHex(obj.value) + " (malformed UTF8)";
            } else {
              throw e2;
            }
          }
        } else if (obj.type === asn1$6.Type.PRINTABLESTRING || obj.type === asn1$6.Type.IA5String) {
          rval += obj.value;
        } else if (_nonLatinRegex.test(obj.value)) {
          rval += "0x" + forge$p.util.bytesToHex(obj.value);
        } else if (obj.value.length === 0) {
          rval += "[null]";
        } else {
          rval += obj.value;
        }
      }
      return rval;
    };
    var forge$o = forge$s;
    forge$o.cipher = forge$o.cipher || {};
    forge$o.cipher.algorithms = forge$o.cipher.algorithms || {};
    forge$o.cipher.createCipher = function(algorithm, key2) {
      var api2 = algorithm;
      if (typeof api2 === "string") {
        api2 = forge$o.cipher.getAlgorithm(api2);
        if (api2) {
          api2 = api2();
        }
      }
      if (!api2) {
        throw new Error("Unsupported algorithm: " + algorithm);
      }
      return new forge$o.cipher.BlockCipher({
        algorithm: api2,
        key: key2,
        decrypt: false
      });
    };
    forge$o.cipher.createDecipher = function(algorithm, key2) {
      var api2 = algorithm;
      if (typeof api2 === "string") {
        api2 = forge$o.cipher.getAlgorithm(api2);
        if (api2) {
          api2 = api2();
        }
      }
      if (!api2) {
        throw new Error("Unsupported algorithm: " + algorithm);
      }
      return new forge$o.cipher.BlockCipher({
        algorithm: api2,
        key: key2,
        decrypt: true
      });
    };
    forge$o.cipher.registerAlgorithm = function(name, algorithm) {
      name = name.toUpperCase();
      forge$o.cipher.algorithms[name] = algorithm;
    };
    forge$o.cipher.getAlgorithm = function(name) {
      name = name.toUpperCase();
      if (name in forge$o.cipher.algorithms) {
        return forge$o.cipher.algorithms[name];
      }
      return null;
    };
    var BlockCipher = forge$o.cipher.BlockCipher = function(options2) {
      this.algorithm = options2.algorithm;
      this.mode = this.algorithm.mode;
      this.blockSize = this.mode.blockSize;
      this._finish = false;
      this._input = null;
      this.output = null;
      this._op = options2.decrypt ? this.mode.decrypt : this.mode.encrypt;
      this._decrypt = options2.decrypt;
      this.algorithm.initialize(options2);
    };
    BlockCipher.prototype.start = function(options2) {
      options2 = options2 || {};
      var opts = {};
      for (var key2 in options2) {
        opts[key2] = options2[key2];
      }
      opts.decrypt = this._decrypt;
      this._finish = false;
      this._input = forge$o.util.createBuffer();
      this.output = options2.output || forge$o.util.createBuffer();
      this.mode.start(opts);
    };
    BlockCipher.prototype.update = function(input) {
      if (input) {
        this._input.putBuffer(input);
      }
      while (!this._op.call(this.mode, this._input, this.output, this._finish) && !this._finish) {
      }
      this._input.compact();
    };
    BlockCipher.prototype.finish = function(pad2) {
      if (pad2 && (this.mode.name === "ECB" || this.mode.name === "CBC")) {
        this.mode.pad = function(input) {
          return pad2(this.blockSize, input, false);
        };
        this.mode.unpad = function(output) {
          return pad2(this.blockSize, output, true);
        };
      }
      var options2 = {};
      options2.decrypt = this._decrypt;
      options2.overflow = this._input.length() % this.blockSize;
      if (!this._decrypt && this.mode.pad) {
        if (!this.mode.pad(this._input, options2)) {
          return false;
        }
      }
      this._finish = true;
      this.update();
      if (this._decrypt && this.mode.unpad) {
        if (!this.mode.unpad(this.output, options2)) {
          return false;
        }
      }
      if (this.mode.afterFinish) {
        if (!this.mode.afterFinish(this.output, options2)) {
          return false;
        }
      }
      return true;
    };
    var forge$n = forge$s;
    forge$n.cipher = forge$n.cipher || {};
    var modes = forge$n.cipher.modes = forge$n.cipher.modes || {};
    modes.ecb = function(options2) {
      options2 = options2 || {};
      this.name = "ECB";
      this.cipher = options2.cipher;
      this.blockSize = options2.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = new Array(this._ints);
      this._outBlock = new Array(this._ints);
    };
    modes.ecb.prototype.start = function(options2) {
    };
    modes.ecb.prototype.encrypt = function(input, output, finish2) {
      if (input.length() < this.blockSize && !(finish2 && input.length() > 0)) {
        return true;
      }
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this._inBlock[i2] = input.getInt32();
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      for (var i2 = 0; i2 < this._ints; ++i2) {
        output.putInt32(this._outBlock[i2]);
      }
    };
    modes.ecb.prototype.decrypt = function(input, output, finish2) {
      if (input.length() < this.blockSize && !(finish2 && input.length() > 0)) {
        return true;
      }
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this._inBlock[i2] = input.getInt32();
      }
      this.cipher.decrypt(this._inBlock, this._outBlock);
      for (var i2 = 0; i2 < this._ints; ++i2) {
        output.putInt32(this._outBlock[i2]);
      }
    };
    modes.ecb.prototype.pad = function(input, options2) {
      var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
      input.fillWithByte(padding, padding);
      return true;
    };
    modes.ecb.prototype.unpad = function(output, options2) {
      if (options2.overflow > 0) {
        return false;
      }
      var len = output.length();
      var count = output.at(len - 1);
      if (count > this.blockSize << 2) {
        return false;
      }
      output.truncate(count);
      return true;
    };
    modes.cbc = function(options2) {
      options2 = options2 || {};
      this.name = "CBC";
      this.cipher = options2.cipher;
      this.blockSize = options2.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = new Array(this._ints);
      this._outBlock = new Array(this._ints);
    };
    modes.cbc.prototype.start = function(options2) {
      if (options2.iv === null) {
        if (!this._prev) {
          throw new Error("Invalid IV parameter.");
        }
        this._iv = this._prev.slice(0);
      } else if (!("iv" in options2)) {
        throw new Error("Invalid IV parameter.");
      } else {
        this._iv = transformIV(options2.iv, this.blockSize);
        this._prev = this._iv.slice(0);
      }
    };
    modes.cbc.prototype.encrypt = function(input, output, finish2) {
      if (input.length() < this.blockSize && !(finish2 && input.length() > 0)) {
        return true;
      }
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this._inBlock[i2] = this._prev[i2] ^ input.getInt32();
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      for (var i2 = 0; i2 < this._ints; ++i2) {
        output.putInt32(this._outBlock[i2]);
      }
      this._prev = this._outBlock;
    };
    modes.cbc.prototype.decrypt = function(input, output, finish2) {
      if (input.length() < this.blockSize && !(finish2 && input.length() > 0)) {
        return true;
      }
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this._inBlock[i2] = input.getInt32();
      }
      this.cipher.decrypt(this._inBlock, this._outBlock);
      for (var i2 = 0; i2 < this._ints; ++i2) {
        output.putInt32(this._prev[i2] ^ this._outBlock[i2]);
      }
      this._prev = this._inBlock.slice(0);
    };
    modes.cbc.prototype.pad = function(input, options2) {
      var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
      input.fillWithByte(padding, padding);
      return true;
    };
    modes.cbc.prototype.unpad = function(output, options2) {
      if (options2.overflow > 0) {
        return false;
      }
      var len = output.length();
      var count = output.at(len - 1);
      if (count > this.blockSize << 2) {
        return false;
      }
      output.truncate(count);
      return true;
    };
    modes.cfb = function(options2) {
      options2 = options2 || {};
      this.name = "CFB";
      this.cipher = options2.cipher;
      this.blockSize = options2.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = null;
      this._outBlock = new Array(this._ints);
      this._partialBlock = new Array(this._ints);
      this._partialOutput = forge$n.util.createBuffer();
      this._partialBytes = 0;
    };
    modes.cfb.prototype.start = function(options2) {
      if (!("iv" in options2)) {
        throw new Error("Invalid IV parameter.");
      }
      this._iv = transformIV(options2.iv, this.blockSize);
      this._inBlock = this._iv.slice(0);
      this._partialBytes = 0;
    };
    modes.cfb.prototype.encrypt = function(input, output, finish2) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          this._inBlock[i2] = input.getInt32() ^ this._outBlock[i2];
          output.putInt32(this._inBlock[i2]);
        }
        return;
      }
      var partialBytes = (this.blockSize - inputLength) % this.blockSize;
      if (partialBytes > 0) {
        partialBytes = this.blockSize - partialBytes;
      }
      this._partialOutput.clear();
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this._partialBlock[i2] = input.getInt32() ^ this._outBlock[i2];
        this._partialOutput.putInt32(this._partialBlock[i2]);
      }
      if (partialBytes > 0) {
        input.read -= this.blockSize;
      } else {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          this._inBlock[i2] = this._partialBlock[i2];
        }
      }
      if (this._partialBytes > 0) {
        this._partialOutput.getBytes(this._partialBytes);
      }
      if (partialBytes > 0 && !finish2) {
        output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
        this._partialBytes = partialBytes;
        return true;
      }
      output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
      this._partialBytes = 0;
    };
    modes.cfb.prototype.decrypt = function(input, output, finish2) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          this._inBlock[i2] = input.getInt32();
          output.putInt32(this._inBlock[i2] ^ this._outBlock[i2]);
        }
        return;
      }
      var partialBytes = (this.blockSize - inputLength) % this.blockSize;
      if (partialBytes > 0) {
        partialBytes = this.blockSize - partialBytes;
      }
      this._partialOutput.clear();
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this._partialBlock[i2] = input.getInt32();
        this._partialOutput.putInt32(this._partialBlock[i2] ^ this._outBlock[i2]);
      }
      if (partialBytes > 0) {
        input.read -= this.blockSize;
      } else {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          this._inBlock[i2] = this._partialBlock[i2];
        }
      }
      if (this._partialBytes > 0) {
        this._partialOutput.getBytes(this._partialBytes);
      }
      if (partialBytes > 0 && !finish2) {
        output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
        this._partialBytes = partialBytes;
        return true;
      }
      output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
      this._partialBytes = 0;
    };
    modes.ofb = function(options2) {
      options2 = options2 || {};
      this.name = "OFB";
      this.cipher = options2.cipher;
      this.blockSize = options2.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = null;
      this._outBlock = new Array(this._ints);
      this._partialOutput = forge$n.util.createBuffer();
      this._partialBytes = 0;
    };
    modes.ofb.prototype.start = function(options2) {
      if (!("iv" in options2)) {
        throw new Error("Invalid IV parameter.");
      }
      this._iv = transformIV(options2.iv, this.blockSize);
      this._inBlock = this._iv.slice(0);
      this._partialBytes = 0;
    };
    modes.ofb.prototype.encrypt = function(input, output, finish2) {
      var inputLength = input.length();
      if (input.length() === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          output.putInt32(input.getInt32() ^ this._outBlock[i2]);
          this._inBlock[i2] = this._outBlock[i2];
        }
        return;
      }
      var partialBytes = (this.blockSize - inputLength) % this.blockSize;
      if (partialBytes > 0) {
        partialBytes = this.blockSize - partialBytes;
      }
      this._partialOutput.clear();
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i2]);
      }
      if (partialBytes > 0) {
        input.read -= this.blockSize;
      } else {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          this._inBlock[i2] = this._outBlock[i2];
        }
      }
      if (this._partialBytes > 0) {
        this._partialOutput.getBytes(this._partialBytes);
      }
      if (partialBytes > 0 && !finish2) {
        output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
        this._partialBytes = partialBytes;
        return true;
      }
      output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
      this._partialBytes = 0;
    };
    modes.ofb.prototype.decrypt = modes.ofb.prototype.encrypt;
    modes.ctr = function(options2) {
      options2 = options2 || {};
      this.name = "CTR";
      this.cipher = options2.cipher;
      this.blockSize = options2.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = null;
      this._outBlock = new Array(this._ints);
      this._partialOutput = forge$n.util.createBuffer();
      this._partialBytes = 0;
    };
    modes.ctr.prototype.start = function(options2) {
      if (!("iv" in options2)) {
        throw new Error("Invalid IV parameter.");
      }
      this._iv = transformIV(options2.iv, this.blockSize);
      this._inBlock = this._iv.slice(0);
      this._partialBytes = 0;
    };
    modes.ctr.prototype.encrypt = function(input, output, finish2) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          output.putInt32(input.getInt32() ^ this._outBlock[i2]);
        }
      } else {
        var partialBytes = (this.blockSize - inputLength) % this.blockSize;
        if (partialBytes > 0) {
          partialBytes = this.blockSize - partialBytes;
        }
        this._partialOutput.clear();
        for (var i2 = 0; i2 < this._ints; ++i2) {
          this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i2]);
        }
        if (partialBytes > 0) {
          input.read -= this.blockSize;
        }
        if (this._partialBytes > 0) {
          this._partialOutput.getBytes(this._partialBytes);
        }
        if (partialBytes > 0 && !finish2) {
          output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
          this._partialBytes = partialBytes;
          return true;
        }
        output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
        this._partialBytes = 0;
      }
      inc32(this._inBlock);
    };
    modes.ctr.prototype.decrypt = modes.ctr.prototype.encrypt;
    modes.gcm = function(options2) {
      options2 = options2 || {};
      this.name = "GCM";
      this.cipher = options2.cipher;
      this.blockSize = options2.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = new Array(this._ints);
      this._outBlock = new Array(this._ints);
      this._partialOutput = forge$n.util.createBuffer();
      this._partialBytes = 0;
      this._R = 3774873600;
    };
    modes.gcm.prototype.start = function(options2) {
      if (!("iv" in options2)) {
        throw new Error("Invalid IV parameter.");
      }
      var iv = forge$n.util.createBuffer(options2.iv);
      this._cipherLength = 0;
      var additionalData;
      if ("additionalData" in options2) {
        additionalData = forge$n.util.createBuffer(options2.additionalData);
      } else {
        additionalData = forge$n.util.createBuffer();
      }
      if ("tagLength" in options2) {
        this._tagLength = options2.tagLength;
      } else {
        this._tagLength = 128;
      }
      this._tag = null;
      if (options2.decrypt) {
        this._tag = forge$n.util.createBuffer(options2.tag).getBytes();
        if (this._tag.length !== this._tagLength / 8) {
          throw new Error("Authentication tag does not match tag length.");
        }
      }
      this._hashBlock = new Array(this._ints);
      this.tag = null;
      this._hashSubkey = new Array(this._ints);
      this.cipher.encrypt([0, 0, 0, 0], this._hashSubkey);
      this.componentBits = 4;
      this._m = this.generateHashTable(this._hashSubkey, this.componentBits);
      var ivLength = iv.length();
      if (ivLength === 12) {
        this._j0 = [iv.getInt32(), iv.getInt32(), iv.getInt32(), 1];
      } else {
        this._j0 = [0, 0, 0, 0];
        while (iv.length() > 0) {
          this._j0 = this.ghash(this._hashSubkey, this._j0, [iv.getInt32(), iv.getInt32(), iv.getInt32(), iv.getInt32()]);
        }
        this._j0 = this.ghash(this._hashSubkey, this._j0, [0, 0].concat(from64To32(ivLength * 8)));
      }
      this._inBlock = this._j0.slice(0);
      inc32(this._inBlock);
      this._partialBytes = 0;
      additionalData = forge$n.util.createBuffer(additionalData);
      this._aDataLength = from64To32(additionalData.length() * 8);
      var overflow = additionalData.length() % this.blockSize;
      if (overflow) {
        additionalData.fillWithByte(0, this.blockSize - overflow);
      }
      this._s = [0, 0, 0, 0];
      while (additionalData.length() > 0) {
        this._s = this.ghash(this._hashSubkey, this._s, [
          additionalData.getInt32(),
          additionalData.getInt32(),
          additionalData.getInt32(),
          additionalData.getInt32()
        ]);
      }
    };
    modes.gcm.prototype.encrypt = function(input, output, finish2) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          output.putInt32(this._outBlock[i2] ^= input.getInt32());
        }
        this._cipherLength += this.blockSize;
      } else {
        var partialBytes = (this.blockSize - inputLength) % this.blockSize;
        if (partialBytes > 0) {
          partialBytes = this.blockSize - partialBytes;
        }
        this._partialOutput.clear();
        for (var i2 = 0; i2 < this._ints; ++i2) {
          this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i2]);
        }
        if (partialBytes <= 0 || finish2) {
          if (finish2) {
            var overflow = inputLength % this.blockSize;
            this._cipherLength += overflow;
            this._partialOutput.truncate(this.blockSize - overflow);
          } else {
            this._cipherLength += this.blockSize;
          }
          for (var i2 = 0; i2 < this._ints; ++i2) {
            this._outBlock[i2] = this._partialOutput.getInt32();
          }
          this._partialOutput.read -= this.blockSize;
        }
        if (this._partialBytes > 0) {
          this._partialOutput.getBytes(this._partialBytes);
        }
        if (partialBytes > 0 && !finish2) {
          input.read -= this.blockSize;
          output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
          this._partialBytes = partialBytes;
          return true;
        }
        output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
        this._partialBytes = 0;
      }
      this._s = this.ghash(this._hashSubkey, this._s, this._outBlock);
      inc32(this._inBlock);
    };
    modes.gcm.prototype.decrypt = function(input, output, finish2) {
      var inputLength = input.length();
      if (inputLength < this.blockSize && !(finish2 && inputLength > 0)) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      inc32(this._inBlock);
      this._hashBlock[0] = input.getInt32();
      this._hashBlock[1] = input.getInt32();
      this._hashBlock[2] = input.getInt32();
      this._hashBlock[3] = input.getInt32();
      this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock);
      for (var i2 = 0; i2 < this._ints; ++i2) {
        output.putInt32(this._outBlock[i2] ^ this._hashBlock[i2]);
      }
      if (inputLength < this.blockSize) {
        this._cipherLength += inputLength % this.blockSize;
      } else {
        this._cipherLength += this.blockSize;
      }
    };
    modes.gcm.prototype.afterFinish = function(output, options2) {
      var rval = true;
      if (options2.decrypt && options2.overflow) {
        output.truncate(this.blockSize - options2.overflow);
      }
      this.tag = forge$n.util.createBuffer();
      var lengths = this._aDataLength.concat(from64To32(this._cipherLength * 8));
      this._s = this.ghash(this._hashSubkey, this._s, lengths);
      var tag = [];
      this.cipher.encrypt(this._j0, tag);
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this.tag.putInt32(this._s[i2] ^ tag[i2]);
      }
      this.tag.truncate(this.tag.length() % (this._tagLength / 8));
      if (options2.decrypt && this.tag.bytes() !== this._tag) {
        rval = false;
      }
      return rval;
    };
    modes.gcm.prototype.multiply = function(x2, y3) {
      var z_i = [0, 0, 0, 0];
      var v_i = y3.slice(0);
      for (var i2 = 0; i2 < 128; ++i2) {
        var x_i = x2[i2 / 32 | 0] & 1 << 31 - i2 % 32;
        if (x_i) {
          z_i[0] ^= v_i[0];
          z_i[1] ^= v_i[1];
          z_i[2] ^= v_i[2];
          z_i[3] ^= v_i[3];
        }
        this.pow(v_i, v_i);
      }
      return z_i;
    };
    modes.gcm.prototype.pow = function(x2, out2) {
      var lsb = x2[3] & 1;
      for (var i2 = 3; i2 > 0; --i2) {
        out2[i2] = x2[i2] >>> 1 | (x2[i2 - 1] & 1) << 31;
      }
      out2[0] = x2[0] >>> 1;
      if (lsb) {
        out2[0] ^= this._R;
      }
    };
    modes.gcm.prototype.tableMultiply = function(x2) {
      var z2 = [0, 0, 0, 0];
      for (var i2 = 0; i2 < 32; ++i2) {
        var idx = i2 / 8 | 0;
        var x_i = x2[idx] >>> (7 - i2 % 8) * 4 & 15;
        var ah2 = this._m[i2][x_i];
        z2[0] ^= ah2[0];
        z2[1] ^= ah2[1];
        z2[2] ^= ah2[2];
        z2[3] ^= ah2[3];
      }
      return z2;
    };
    modes.gcm.prototype.ghash = function(h3, y3, x2) {
      y3[0] ^= x2[0];
      y3[1] ^= x2[1];
      y3[2] ^= x2[2];
      y3[3] ^= x2[3];
      return this.tableMultiply(y3);
    };
    modes.gcm.prototype.generateHashTable = function(h3, bits) {
      var multiplier = 8 / bits;
      var perInt = 4 * multiplier;
      var size = 16 * multiplier;
      var m3 = new Array(size);
      for (var i2 = 0; i2 < size; ++i2) {
        var tmp = [0, 0, 0, 0];
        var idx = i2 / perInt | 0;
        var shft = (perInt - 1 - i2 % perInt) * bits;
        tmp[idx] = 1 << bits - 1 << shft;
        m3[i2] = this.generateSubHashTable(this.multiply(tmp, h3), bits);
      }
      return m3;
    };
    modes.gcm.prototype.generateSubHashTable = function(mid, bits) {
      var size = 1 << bits;
      var half = size >>> 1;
      var m3 = new Array(size);
      m3[half] = mid.slice(0);
      var i2 = half >>> 1;
      while (i2 > 0) {
        this.pow(m3[2 * i2], m3[i2] = []);
        i2 >>= 1;
      }
      i2 = 2;
      while (i2 < half) {
        for (var j2 = 1; j2 < i2; ++j2) {
          var m_i = m3[i2];
          var m_j = m3[j2];
          m3[i2 + j2] = [
            m_i[0] ^ m_j[0],
            m_i[1] ^ m_j[1],
            m_i[2] ^ m_j[2],
            m_i[3] ^ m_j[3]
          ];
        }
        i2 *= 2;
      }
      m3[0] = [0, 0, 0, 0];
      for (i2 = half + 1; i2 < size; ++i2) {
        var c3 = m3[i2 ^ half];
        m3[i2] = [mid[0] ^ c3[0], mid[1] ^ c3[1], mid[2] ^ c3[2], mid[3] ^ c3[3]];
      }
      return m3;
    };
    function transformIV(iv, blockSize) {
      if (typeof iv === "string") {
        iv = forge$n.util.createBuffer(iv);
      }
      if (forge$n.util.isArray(iv) && iv.length > 4) {
        var tmp = iv;
        iv = forge$n.util.createBuffer();
        for (var i2 = 0; i2 < tmp.length; ++i2) {
          iv.putByte(tmp[i2]);
        }
      }
      if (iv.length() < blockSize) {
        throw new Error("Invalid IV length; got " + iv.length() + " bytes and expected " + blockSize + " bytes.");
      }
      if (!forge$n.util.isArray(iv)) {
        var ints = [];
        var blocks = blockSize / 4;
        for (var i2 = 0; i2 < blocks; ++i2) {
          ints.push(iv.getInt32());
        }
        iv = ints;
      }
      return iv;
    }
    function inc32(block) {
      block[block.length - 1] = block[block.length - 1] + 1 & 4294967295;
    }
    function from64To32(num) {
      return [num / 4294967296 | 0, num & 4294967295];
    }
    var forge$m = forge$s;
    forge$m.aes = forge$m.aes || {};
    forge$m.aes.startEncrypting = function(key2, iv, output, mode2) {
      var cipher = _createCipher$1({
        key: key2,
        output,
        decrypt: false,
        mode: mode2
      });
      cipher.start(iv);
      return cipher;
    };
    forge$m.aes.createEncryptionCipher = function(key2, mode2) {
      return _createCipher$1({
        key: key2,
        output: null,
        decrypt: false,
        mode: mode2
      });
    };
    forge$m.aes.startDecrypting = function(key2, iv, output, mode2) {
      var cipher = _createCipher$1({
        key: key2,
        output,
        decrypt: true,
        mode: mode2
      });
      cipher.start(iv);
      return cipher;
    };
    forge$m.aes.createDecryptionCipher = function(key2, mode2) {
      return _createCipher$1({
        key: key2,
        output: null,
        decrypt: true,
        mode: mode2
      });
    };
    forge$m.aes.Algorithm = function(name, mode2) {
      if (!init2) {
        initialize();
      }
      var self2 = this;
      self2.name = name;
      self2.mode = new mode2({
        blockSize: 16,
        cipher: {
          encrypt: function(inBlock, outBlock) {
            return _updateBlock$1(self2._w, inBlock, outBlock, false);
          },
          decrypt: function(inBlock, outBlock) {
            return _updateBlock$1(self2._w, inBlock, outBlock, true);
          }
        }
      });
      self2._init = false;
    };
    forge$m.aes.Algorithm.prototype.initialize = function(options2) {
      if (this._init) {
        return;
      }
      var key2 = options2.key;
      var tmp;
      if (typeof key2 === "string" && (key2.length === 16 || key2.length === 24 || key2.length === 32)) {
        key2 = forge$m.util.createBuffer(key2);
      } else if (forge$m.util.isArray(key2) && (key2.length === 16 || key2.length === 24 || key2.length === 32)) {
        tmp = key2;
        key2 = forge$m.util.createBuffer();
        for (var i2 = 0; i2 < tmp.length; ++i2) {
          key2.putByte(tmp[i2]);
        }
      }
      if (!forge$m.util.isArray(key2)) {
        tmp = key2;
        key2 = [];
        var len = tmp.length();
        if (len === 16 || len === 24 || len === 32) {
          len = len >>> 2;
          for (var i2 = 0; i2 < len; ++i2) {
            key2.push(tmp.getInt32());
          }
        }
      }
      if (!forge$m.util.isArray(key2) || !(key2.length === 4 || key2.length === 6 || key2.length === 8)) {
        throw new Error("Invalid key parameter.");
      }
      var mode2 = this.mode.name;
      var encryptOp = ["CFB", "OFB", "CTR", "GCM"].indexOf(mode2) !== -1;
      this._w = _expandKey(key2, options2.decrypt && !encryptOp);
      this._init = true;
    };
    forge$m.aes._expandKey = function(key2, decrypt) {
      if (!init2) {
        initialize();
      }
      return _expandKey(key2, decrypt);
    };
    forge$m.aes._updateBlock = _updateBlock$1;
    registerAlgorithm$1("AES-ECB", forge$m.cipher.modes.ecb);
    registerAlgorithm$1("AES-CBC", forge$m.cipher.modes.cbc);
    registerAlgorithm$1("AES-CFB", forge$m.cipher.modes.cfb);
    registerAlgorithm$1("AES-OFB", forge$m.cipher.modes.ofb);
    registerAlgorithm$1("AES-CTR", forge$m.cipher.modes.ctr);
    registerAlgorithm$1("AES-GCM", forge$m.cipher.modes.gcm);
    function registerAlgorithm$1(name, mode2) {
      var factory = function() {
        return new forge$m.aes.Algorithm(name, mode2);
      };
      forge$m.cipher.registerAlgorithm(name, factory);
    }
    var init2 = false;
    var Nb = 4;
    var sbox;
    var isbox;
    var rcon;
    var mix;
    var imix;
    function initialize() {
      init2 = true;
      rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
      var xtime = new Array(256);
      for (var i2 = 0; i2 < 128; ++i2) {
        xtime[i2] = i2 << 1;
        xtime[i2 + 128] = i2 + 128 << 1 ^ 283;
      }
      sbox = new Array(256);
      isbox = new Array(256);
      mix = new Array(4);
      imix = new Array(4);
      for (var i2 = 0; i2 < 4; ++i2) {
        mix[i2] = new Array(256);
        imix[i2] = new Array(256);
      }
      var e2 = 0, ei2 = 0, e22, e4, e8, sx, sx2, me2, ime;
      for (var i2 = 0; i2 < 256; ++i2) {
        sx = ei2 ^ ei2 << 1 ^ ei2 << 2 ^ ei2 << 3 ^ ei2 << 4;
        sx = sx >> 8 ^ sx & 255 ^ 99;
        sbox[e2] = sx;
        isbox[sx] = e2;
        sx2 = xtime[sx];
        e22 = xtime[e2];
        e4 = xtime[e22];
        e8 = xtime[e4];
        me2 = sx2 << 24 ^ sx << 16 ^ sx << 8 ^ (sx ^ sx2);
        ime = (e22 ^ e4 ^ e8) << 24 ^ (e2 ^ e8) << 16 ^ (e2 ^ e4 ^ e8) << 8 ^ (e2 ^ e22 ^ e8);
        for (var n3 = 0; n3 < 4; ++n3) {
          mix[n3][e2] = me2;
          imix[n3][sx] = ime;
          me2 = me2 << 24 | me2 >>> 8;
          ime = ime << 24 | ime >>> 8;
        }
        if (e2 === 0) {
          e2 = ei2 = 1;
        } else {
          e2 = e22 ^ xtime[xtime[xtime[e22 ^ e8]]];
          ei2 ^= xtime[xtime[ei2]];
        }
      }
    }
    function _expandKey(key2, decrypt) {
      var w3 = key2.slice(0);
      var temp, iNk = 1;
      var Nk = w3.length;
      var Nr1 = Nk + 6 + 1;
      var end = Nb * Nr1;
      for (var i2 = Nk; i2 < end; ++i2) {
        temp = w3[i2 - 1];
        if (i2 % Nk === 0) {
          temp = sbox[temp >>> 16 & 255] << 24 ^ sbox[temp >>> 8 & 255] << 16 ^ sbox[temp & 255] << 8 ^ sbox[temp >>> 24] ^ rcon[iNk] << 24;
          iNk++;
        } else if (Nk > 6 && i2 % Nk === 4) {
          temp = sbox[temp >>> 24] << 24 ^ sbox[temp >>> 16 & 255] << 16 ^ sbox[temp >>> 8 & 255] << 8 ^ sbox[temp & 255];
        }
        w3[i2] = w3[i2 - Nk] ^ temp;
      }
      if (decrypt) {
        var tmp;
        var m0 = imix[0];
        var m1 = imix[1];
        var m22 = imix[2];
        var m3 = imix[3];
        var wnew = w3.slice(0);
        end = w3.length;
        for (var i2 = 0, wi2 = end - Nb; i2 < end; i2 += Nb, wi2 -= Nb) {
          if (i2 === 0 || i2 === end - Nb) {
            wnew[i2] = w3[wi2];
            wnew[i2 + 1] = w3[wi2 + 3];
            wnew[i2 + 2] = w3[wi2 + 2];
            wnew[i2 + 3] = w3[wi2 + 1];
          } else {
            for (var n3 = 0; n3 < Nb; ++n3) {
              tmp = w3[wi2 + n3];
              wnew[i2 + (3 & -n3)] = m0[sbox[tmp >>> 24]] ^ m1[sbox[tmp >>> 16 & 255]] ^ m22[sbox[tmp >>> 8 & 255]] ^ m3[sbox[tmp & 255]];
            }
          }
        }
        w3 = wnew;
      }
      return w3;
    }
    function _updateBlock$1(w3, input, output, decrypt) {
      var Nr2 = w3.length / 4 - 1;
      var m0, m1, m22, m3, sub;
      if (decrypt) {
        m0 = imix[0];
        m1 = imix[1];
        m22 = imix[2];
        m3 = imix[3];
        sub = isbox;
      } else {
        m0 = mix[0];
        m1 = mix[1];
        m22 = mix[2];
        m3 = mix[3];
        sub = sbox;
      }
      var a2, b2, c3, d3, a22, b22, c22;
      a2 = input[0] ^ w3[0];
      b2 = input[decrypt ? 3 : 1] ^ w3[1];
      c3 = input[2] ^ w3[2];
      d3 = input[decrypt ? 1 : 3] ^ w3[3];
      var i2 = 3;
      for (var round = 1; round < Nr2; ++round) {
        a22 = m0[a2 >>> 24] ^ m1[b2 >>> 16 & 255] ^ m22[c3 >>> 8 & 255] ^ m3[d3 & 255] ^ w3[++i2];
        b22 = m0[b2 >>> 24] ^ m1[c3 >>> 16 & 255] ^ m22[d3 >>> 8 & 255] ^ m3[a2 & 255] ^ w3[++i2];
        c22 = m0[c3 >>> 24] ^ m1[d3 >>> 16 & 255] ^ m22[a2 >>> 8 & 255] ^ m3[b2 & 255] ^ w3[++i2];
        d3 = m0[d3 >>> 24] ^ m1[a2 >>> 16 & 255] ^ m22[b2 >>> 8 & 255] ^ m3[c3 & 255] ^ w3[++i2];
        a2 = a22;
        b2 = b22;
        c3 = c22;
      }
      output[0] = sub[a2 >>> 24] << 24 ^ sub[b2 >>> 16 & 255] << 16 ^ sub[c3 >>> 8 & 255] << 8 ^ sub[d3 & 255] ^ w3[++i2];
      output[decrypt ? 3 : 1] = sub[b2 >>> 24] << 24 ^ sub[c3 >>> 16 & 255] << 16 ^ sub[d3 >>> 8 & 255] << 8 ^ sub[a2 & 255] ^ w3[++i2];
      output[2] = sub[c3 >>> 24] << 24 ^ sub[d3 >>> 16 & 255] << 16 ^ sub[a2 >>> 8 & 255] << 8 ^ sub[b2 & 255] ^ w3[++i2];
      output[decrypt ? 1 : 3] = sub[d3 >>> 24] << 24 ^ sub[a2 >>> 16 & 255] << 16 ^ sub[b2 >>> 8 & 255] << 8 ^ sub[c3 & 255] ^ w3[++i2];
    }
    function _createCipher$1(options2) {
      options2 = options2 || {};
      var mode2 = (options2.mode || "CBC").toUpperCase();
      var algorithm = "AES-" + mode2;
      var cipher;
      if (options2.decrypt) {
        cipher = forge$m.cipher.createDecipher(algorithm, options2.key);
      } else {
        cipher = forge$m.cipher.createCipher(algorithm, options2.key);
      }
      var start = cipher.start;
      cipher.start = function(iv, options3) {
        var output = null;
        if (options3 instanceof forge$m.util.ByteBuffer) {
          output = options3;
          options3 = {};
        }
        options3 = options3 || {};
        options3.output = output;
        options3.iv = iv;
        start.call(cipher, options3);
      };
      return cipher;
    }
    var forge$l = forge$s;
    forge$l.des = forge$l.des || {};
    forge$l.des.startEncrypting = function(key2, iv, output, mode2) {
      var cipher = _createCipher({
        key: key2,
        output,
        decrypt: false,
        mode: mode2 || (iv === null ? "ECB" : "CBC")
      });
      cipher.start(iv);
      return cipher;
    };
    forge$l.des.createEncryptionCipher = function(key2, mode2) {
      return _createCipher({
        key: key2,
        output: null,
        decrypt: false,
        mode: mode2
      });
    };
    forge$l.des.startDecrypting = function(key2, iv, output, mode2) {
      var cipher = _createCipher({
        key: key2,
        output,
        decrypt: true,
        mode: mode2 || (iv === null ? "ECB" : "CBC")
      });
      cipher.start(iv);
      return cipher;
    };
    forge$l.des.createDecryptionCipher = function(key2, mode2) {
      return _createCipher({
        key: key2,
        output: null,
        decrypt: true,
        mode: mode2
      });
    };
    forge$l.des.Algorithm = function(name, mode2) {
      var self2 = this;
      self2.name = name;
      self2.mode = new mode2({
        blockSize: 8,
        cipher: {
          encrypt: function(inBlock, outBlock) {
            return _updateBlock(self2._keys, inBlock, outBlock, false);
          },
          decrypt: function(inBlock, outBlock) {
            return _updateBlock(self2._keys, inBlock, outBlock, true);
          }
        }
      });
      self2._init = false;
    };
    forge$l.des.Algorithm.prototype.initialize = function(options2) {
      if (this._init) {
        return;
      }
      var key2 = forge$l.util.createBuffer(options2.key);
      if (this.name.indexOf("3DES") === 0) {
        if (key2.length() !== 24) {
          throw new Error("Invalid Triple-DES key size: " + key2.length() * 8);
        }
      }
      this._keys = _createKeys(key2);
      this._init = true;
    };
    registerAlgorithm("DES-ECB", forge$l.cipher.modes.ecb);
    registerAlgorithm("DES-CBC", forge$l.cipher.modes.cbc);
    registerAlgorithm("DES-CFB", forge$l.cipher.modes.cfb);
    registerAlgorithm("DES-OFB", forge$l.cipher.modes.ofb);
    registerAlgorithm("DES-CTR", forge$l.cipher.modes.ctr);
    registerAlgorithm("3DES-ECB", forge$l.cipher.modes.ecb);
    registerAlgorithm("3DES-CBC", forge$l.cipher.modes.cbc);
    registerAlgorithm("3DES-CFB", forge$l.cipher.modes.cfb);
    registerAlgorithm("3DES-OFB", forge$l.cipher.modes.ofb);
    registerAlgorithm("3DES-CTR", forge$l.cipher.modes.ctr);
    function registerAlgorithm(name, mode2) {
      var factory = function() {
        return new forge$l.des.Algorithm(name, mode2);
      };
      forge$l.cipher.registerAlgorithm(name, factory);
    }
    var spfunction1 = [16843776, 0, 65536, 16843780, 16842756, 66564, 4, 65536, 1024, 16843776, 16843780, 1024, 16778244, 16842756, 16777216, 4, 1028, 16778240, 16778240, 66560, 66560, 16842752, 16842752, 16778244, 65540, 16777220, 16777220, 65540, 0, 1028, 66564, 16777216, 65536, 16843780, 4, 16842752, 16843776, 16777216, 16777216, 1024, 16842756, 65536, 66560, 16777220, 1024, 4, 16778244, 66564, 16843780, 65540, 16842752, 16778244, 16777220, 1028, 66564, 16843776, 1028, 16778240, 16778240, 0, 65540, 66560, 0, 16842756];
    var spfunction2 = [-2146402272, -2147450880, 32768, 1081376, 1048576, 32, -2146435040, -2147450848, -2147483616, -2146402272, -2146402304, -2147483648, -2147450880, 1048576, 32, -2146435040, 1081344, 1048608, -2147450848, 0, -2147483648, 32768, 1081376, -2146435072, 1048608, -2147483616, 0, 1081344, 32800, -2146402304, -2146435072, 32800, 0, 1081376, -2146435040, 1048576, -2147450848, -2146435072, -2146402304, 32768, -2146435072, -2147450880, 32, -2146402272, 1081376, 32, 32768, -2147483648, 32800, -2146402304, 1048576, -2147483616, 1048608, -2147450848, -2147483616, 1048608, 1081344, 0, -2147450880, 32800, -2147483648, -2146435040, -2146402272, 1081344];
    var spfunction3 = [520, 134349312, 0, 134348808, 134218240, 0, 131592, 134218240, 131080, 134217736, 134217736, 131072, 134349320, 131080, 134348800, 520, 134217728, 8, 134349312, 512, 131584, 134348800, 134348808, 131592, 134218248, 131584, 131072, 134218248, 8, 134349320, 512, 134217728, 134349312, 134217728, 131080, 520, 131072, 134349312, 134218240, 0, 512, 131080, 134349320, 134218240, 134217736, 512, 0, 134348808, 134218248, 131072, 134217728, 134349320, 8, 131592, 131584, 134217736, 134348800, 134218248, 520, 134348800, 131592, 8, 134348808, 131584];
    var spfunction4 = [8396801, 8321, 8321, 128, 8396928, 8388737, 8388609, 8193, 0, 8396800, 8396800, 8396929, 129, 0, 8388736, 8388609, 1, 8192, 8388608, 8396801, 128, 8388608, 8193, 8320, 8388737, 1, 8320, 8388736, 8192, 8396928, 8396929, 129, 8388736, 8388609, 8396800, 8396929, 129, 0, 0, 8396800, 8320, 8388736, 8388737, 1, 8396801, 8321, 8321, 128, 8396929, 129, 1, 8192, 8388609, 8193, 8396928, 8388737, 8193, 8320, 8388608, 8396801, 128, 8388608, 8192, 8396928];
    var spfunction5 = [256, 34078976, 34078720, 1107296512, 524288, 256, 1073741824, 34078720, 1074266368, 524288, 33554688, 1074266368, 1107296512, 1107820544, 524544, 1073741824, 33554432, 1074266112, 1074266112, 0, 1073742080, 1107820800, 1107820800, 33554688, 1107820544, 1073742080, 0, 1107296256, 34078976, 33554432, 1107296256, 524544, 524288, 1107296512, 256, 33554432, 1073741824, 34078720, 1107296512, 1074266368, 33554688, 1073741824, 1107820544, 34078976, 1074266368, 256, 33554432, 1107820544, 1107820800, 524544, 1107296256, 1107820800, 34078720, 0, 1074266112, 1107296256, 524544, 33554688, 1073742080, 524288, 0, 1074266112, 34078976, 1073742080];
    var spfunction6 = [536870928, 541065216, 16384, 541081616, 541065216, 16, 541081616, 4194304, 536887296, 4210704, 4194304, 536870928, 4194320, 536887296, 536870912, 16400, 0, 4194320, 536887312, 16384, 4210688, 536887312, 16, 541065232, 541065232, 0, 4210704, 541081600, 16400, 4210688, 541081600, 536870912, 536887296, 16, 541065232, 4210688, 541081616, 4194304, 16400, 536870928, 4194304, 536887296, 536870912, 16400, 536870928, 541081616, 4210688, 541065216, 4210704, 541081600, 0, 541065232, 16, 16384, 541065216, 4210704, 16384, 4194320, 536887312, 0, 541081600, 536870912, 4194320, 536887312];
    var spfunction7 = [2097152, 69206018, 67110914, 0, 2048, 67110914, 2099202, 69208064, 69208066, 2097152, 0, 67108866, 2, 67108864, 69206018, 2050, 67110912, 2099202, 2097154, 67110912, 67108866, 69206016, 69208064, 2097154, 69206016, 2048, 2050, 69208066, 2099200, 2, 67108864, 2099200, 67108864, 2099200, 2097152, 67110914, 67110914, 69206018, 69206018, 2, 2097154, 67108864, 67110912, 2097152, 69208064, 2050, 2099202, 69208064, 2050, 67108866, 69208066, 69206016, 2099200, 0, 2, 69208066, 0, 2099202, 69206016, 2048, 67108866, 67110912, 2048, 2097154];
    var spfunction8 = [268439616, 4096, 262144, 268701760, 268435456, 268439616, 64, 268435456, 262208, 268697600, 268701760, 266240, 268701696, 266304, 4096, 64, 268697600, 268435520, 268439552, 4160, 266240, 262208, 268697664, 268701696, 4160, 0, 0, 268697664, 268435520, 268439552, 266304, 262144, 266304, 262144, 268701696, 4096, 64, 268697664, 4096, 266304, 268439552, 64, 268435520, 268697600, 268697664, 268435456, 262144, 268439616, 0, 268701760, 262208, 268435520, 268697600, 268439552, 268439616, 0, 268701760, 266240, 266240, 4160, 4160, 262208, 268435456, 268701696];
    function _createKeys(key2) {
      var pc2bytes0 = [0, 4, 536870912, 536870916, 65536, 65540, 536936448, 536936452, 512, 516, 536871424, 536871428, 66048, 66052, 536936960, 536936964], pc2bytes1 = [0, 1, 1048576, 1048577, 67108864, 67108865, 68157440, 68157441, 256, 257, 1048832, 1048833, 67109120, 67109121, 68157696, 68157697], pc2bytes2 = [0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272, 0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272], pc2bytes3 = [0, 2097152, 134217728, 136314880, 8192, 2105344, 134225920, 136323072, 131072, 2228224, 134348800, 136445952, 139264, 2236416, 134356992, 136454144], pc2bytes4 = [0, 262144, 16, 262160, 0, 262144, 16, 262160, 4096, 266240, 4112, 266256, 4096, 266240, 4112, 266256], pc2bytes5 = [0, 1024, 32, 1056, 0, 1024, 32, 1056, 33554432, 33555456, 33554464, 33555488, 33554432, 33555456, 33554464, 33555488], pc2bytes6 = [0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746, 0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746], pc2bytes7 = [0, 65536, 2048, 67584, 536870912, 536936448, 536872960, 536938496, 131072, 196608, 133120, 198656, 537001984, 537067520, 537004032, 537069568], pc2bytes8 = [0, 262144, 0, 262144, 2, 262146, 2, 262146, 33554432, 33816576, 33554432, 33816576, 33554434, 33816578, 33554434, 33816578], pc2bytes9 = [0, 268435456, 8, 268435464, 0, 268435456, 8, 268435464, 1024, 268436480, 1032, 268436488, 1024, 268436480, 1032, 268436488], pc2bytes10 = [0, 32, 0, 32, 1048576, 1048608, 1048576, 1048608, 8192, 8224, 8192, 8224, 1056768, 1056800, 1056768, 1056800], pc2bytes11 = [0, 16777216, 512, 16777728, 2097152, 18874368, 2097664, 18874880, 67108864, 83886080, 67109376, 83886592, 69206016, 85983232, 69206528, 85983744], pc2bytes12 = [0, 4096, 134217728, 134221824, 524288, 528384, 134742016, 134746112, 16, 4112, 134217744, 134221840, 524304, 528400, 134742032, 134746128], pc2bytes13 = [0, 4, 256, 260, 0, 4, 256, 260, 1, 5, 257, 261, 1, 5, 257, 261];
      var iterations = key2.length() > 8 ? 3 : 1;
      var keys = [];
      var shifts = [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0];
      var n3 = 0, tmp;
      for (var j2 = 0; j2 < iterations; j2++) {
        var left = key2.getInt32();
        var right = key2.getInt32();
        tmp = (left >>> 4 ^ right) & 252645135;
        right ^= tmp;
        left ^= tmp << 4;
        tmp = (right >>> -16 ^ left) & 65535;
        left ^= tmp;
        right ^= tmp << -16;
        tmp = (left >>> 2 ^ right) & 858993459;
        right ^= tmp;
        left ^= tmp << 2;
        tmp = (right >>> -16 ^ left) & 65535;
        left ^= tmp;
        right ^= tmp << -16;
        tmp = (left >>> 1 ^ right) & 1431655765;
        right ^= tmp;
        left ^= tmp << 1;
        tmp = (right >>> 8 ^ left) & 16711935;
        left ^= tmp;
        right ^= tmp << 8;
        tmp = (left >>> 1 ^ right) & 1431655765;
        right ^= tmp;
        left ^= tmp << 1;
        tmp = left << 8 | right >>> 20 & 240;
        left = right << 24 | right << 8 & 16711680 | right >>> 8 & 65280 | right >>> 24 & 240;
        right = tmp;
        for (var i2 = 0; i2 < shifts.length; ++i2) {
          if (shifts[i2]) {
            left = left << 2 | left >>> 26;
            right = right << 2 | right >>> 26;
          } else {
            left = left << 1 | left >>> 27;
            right = right << 1 | right >>> 27;
          }
          left &= -15;
          right &= -15;
          var lefttmp = pc2bytes0[left >>> 28] | pc2bytes1[left >>> 24 & 15] | pc2bytes2[left >>> 20 & 15] | pc2bytes3[left >>> 16 & 15] | pc2bytes4[left >>> 12 & 15] | pc2bytes5[left >>> 8 & 15] | pc2bytes6[left >>> 4 & 15];
          var righttmp = pc2bytes7[right >>> 28] | pc2bytes8[right >>> 24 & 15] | pc2bytes9[right >>> 20 & 15] | pc2bytes10[right >>> 16 & 15] | pc2bytes11[right >>> 12 & 15] | pc2bytes12[right >>> 8 & 15] | pc2bytes13[right >>> 4 & 15];
          tmp = (righttmp >>> 16 ^ lefttmp) & 65535;
          keys[n3++] = lefttmp ^ tmp;
          keys[n3++] = righttmp ^ tmp << 16;
        }
      }
      return keys;
    }
    function _updateBlock(keys, input, output, decrypt) {
      var iterations = keys.length === 32 ? 3 : 9;
      var looping;
      if (iterations === 3) {
        looping = decrypt ? [30, -2, -2] : [0, 32, 2];
      } else {
        looping = decrypt ? [94, 62, -2, 32, 64, 2, 30, -2, -2] : [0, 32, 2, 62, 30, -2, 64, 96, 2];
      }
      var tmp;
      var left = input[0];
      var right = input[1];
      tmp = (left >>> 4 ^ right) & 252645135;
      right ^= tmp;
      left ^= tmp << 4;
      tmp = (left >>> 16 ^ right) & 65535;
      right ^= tmp;
      left ^= tmp << 16;
      tmp = (right >>> 2 ^ left) & 858993459;
      left ^= tmp;
      right ^= tmp << 2;
      tmp = (right >>> 8 ^ left) & 16711935;
      left ^= tmp;
      right ^= tmp << 8;
      tmp = (left >>> 1 ^ right) & 1431655765;
      right ^= tmp;
      left ^= tmp << 1;
      left = left << 1 | left >>> 31;
      right = right << 1 | right >>> 31;
      for (var j2 = 0; j2 < iterations; j2 += 3) {
        var endloop = looping[j2 + 1];
        var loopinc = looping[j2 + 2];
        for (var i2 = looping[j2]; i2 != endloop; i2 += loopinc) {
          var right1 = right ^ keys[i2];
          var right2 = (right >>> 4 | right << 28) ^ keys[i2 + 1];
          tmp = left;
          left = right;
          right = tmp ^ (spfunction2[right1 >>> 24 & 63] | spfunction4[right1 >>> 16 & 63] | spfunction6[right1 >>> 8 & 63] | spfunction8[right1 & 63] | spfunction1[right2 >>> 24 & 63] | spfunction3[right2 >>> 16 & 63] | spfunction5[right2 >>> 8 & 63] | spfunction7[right2 & 63]);
        }
        tmp = left;
        left = right;
        right = tmp;
      }
      left = left >>> 1 | left << 31;
      right = right >>> 1 | right << 31;
      tmp = (left >>> 1 ^ right) & 1431655765;
      right ^= tmp;
      left ^= tmp << 1;
      tmp = (right >>> 8 ^ left) & 16711935;
      left ^= tmp;
      right ^= tmp << 8;
      tmp = (right >>> 2 ^ left) & 858993459;
      left ^= tmp;
      right ^= tmp << 2;
      tmp = (left >>> 16 ^ right) & 65535;
      right ^= tmp;
      left ^= tmp << 16;
      tmp = (left >>> 4 ^ right) & 252645135;
      right ^= tmp;
      left ^= tmp << 4;
      output[0] = left;
      output[1] = right;
    }
    function _createCipher(options2) {
      options2 = options2 || {};
      var mode2 = (options2.mode || "CBC").toUpperCase();
      var algorithm = "DES-" + mode2;
      var cipher;
      if (options2.decrypt) {
        cipher = forge$l.cipher.createDecipher(algorithm, options2.key);
      } else {
        cipher = forge$l.cipher.createCipher(algorithm, options2.key);
      }
      var start = cipher.start;
      cipher.start = function(iv, options3) {
        var output = null;
        if (options3 instanceof forge$l.util.ByteBuffer) {
          output = options3;
          options3 = {};
        }
        options3 = options3 || {};
        options3.output = output;
        options3.iv = iv;
        start.call(cipher, options3);
      };
      return cipher;
    }
    var forge$k = forge$s;
    forge$k.md = forge$k.md || {};
    forge$k.md.algorithms = forge$k.md.algorithms || {};
    var forge$j = forge$s;
    var hmac = forge$j.hmac = forge$j.hmac || {};
    hmac.create = function() {
      var _key = null;
      var _md = null;
      var _ipadding = null;
      var _opadding = null;
      var ctx = {};
      ctx.start = function(md, key2) {
        if (md !== null) {
          if (typeof md === "string") {
            md = md.toLowerCase();
            if (md in forge$j.md.algorithms) {
              _md = forge$j.md.algorithms[md].create();
            } else {
              throw new Error('Unknown hash algorithm "' + md + '"');
            }
          } else {
            _md = md;
          }
        }
        if (key2 === null) {
          key2 = _key;
        } else {
          if (typeof key2 === "string") {
            key2 = forge$j.util.createBuffer(key2);
          } else if (forge$j.util.isArray(key2)) {
            var tmp = key2;
            key2 = forge$j.util.createBuffer();
            for (var i2 = 0; i2 < tmp.length; ++i2) {
              key2.putByte(tmp[i2]);
            }
          }
          var keylen = key2.length();
          if (keylen > _md.blockLength) {
            _md.start();
            _md.update(key2.bytes());
            key2 = _md.digest();
          }
          _ipadding = forge$j.util.createBuffer();
          _opadding = forge$j.util.createBuffer();
          keylen = key2.length();
          for (var i2 = 0; i2 < keylen; ++i2) {
            var tmp = key2.at(i2);
            _ipadding.putByte(54 ^ tmp);
            _opadding.putByte(92 ^ tmp);
          }
          if (keylen < _md.blockLength) {
            var tmp = _md.blockLength - keylen;
            for (var i2 = 0; i2 < tmp; ++i2) {
              _ipadding.putByte(54);
              _opadding.putByte(92);
            }
          }
          _key = key2;
          _ipadding = _ipadding.bytes();
          _opadding = _opadding.bytes();
        }
        _md.start();
        _md.update(_ipadding);
      };
      ctx.update = function(bytes) {
        _md.update(bytes);
      };
      ctx.getMac = function() {
        var inner = _md.digest().bytes();
        _md.start();
        _md.update(_opadding);
        _md.update(inner);
        return _md.digest();
      };
      ctx.digest = ctx.getMac;
      return ctx;
    };
    var forge$i = forge$s;
    var pkcs5 = forge$i.pkcs5 = forge$i.pkcs5 || {};
    var crypto2;
    if (forge$i.util.isNodejs && !forge$i.options.usePureJavaScript) {
      crypto2 = require$$1__default2;
    }
    forge$i.pbkdf2 = pkcs5.pbkdf2 = function(p2, s3, c3, dkLen, md, callback) {
      if (typeof md === "function") {
        callback = md;
        md = null;
      }
      if (forge$i.util.isNodejs && !forge$i.options.usePureJavaScript && crypto2.pbkdf2 && (md === null || typeof md !== "object") && (crypto2.pbkdf2Sync.length > 4 || (!md || md === "sha1"))) {
        if (typeof md !== "string") {
          md = "sha1";
        }
        p2 = Buffer.from(p2, "binary");
        s3 = Buffer.from(s3, "binary");
        if (!callback) {
          if (crypto2.pbkdf2Sync.length === 4) {
            return crypto2.pbkdf2Sync(p2, s3, c3, dkLen).toString("binary");
          }
          return crypto2.pbkdf2Sync(p2, s3, c3, dkLen, md).toString("binary");
        }
        if (crypto2.pbkdf2Sync.length === 4) {
          return crypto2.pbkdf2(p2, s3, c3, dkLen, function(err2, key2) {
            if (err2) {
              return callback(err2);
            }
            callback(null, key2.toString("binary"));
          });
        }
        return crypto2.pbkdf2(p2, s3, c3, dkLen, md, function(err2, key2) {
          if (err2) {
            return callback(err2);
          }
          callback(null, key2.toString("binary"));
        });
      }
      if (typeof md === "undefined" || md === null) {
        md = "sha1";
      }
      if (typeof md === "string") {
        if (!(md in forge$i.md.algorithms)) {
          throw new Error("Unknown hash algorithm: " + md);
        }
        md = forge$i.md[md].create();
      }
      var hLen = md.digestLength;
      if (dkLen > 4294967295 * hLen) {
        var err = new Error("Derived key is too long.");
        if (callback) {
          return callback(err);
        }
        throw err;
      }
      var len = Math.ceil(dkLen / hLen);
      var r2 = dkLen - (len - 1) * hLen;
      var prf = forge$i.hmac.create();
      prf.start(md, p2);
      var dk = "";
      var xor, u_c, u_c1;
      if (!callback) {
        for (var i2 = 1; i2 <= len; ++i2) {
          prf.start(null, null);
          prf.update(s3);
          prf.update(forge$i.util.int32ToBytes(i2));
          xor = u_c1 = prf.digest().getBytes();
          for (var j2 = 2; j2 <= c3; ++j2) {
            prf.start(null, null);
            prf.update(u_c1);
            u_c = prf.digest().getBytes();
            xor = forge$i.util.xorBytes(xor, u_c, hLen);
            u_c1 = u_c;
          }
          dk += i2 < len ? xor : xor.substr(0, r2);
        }
        return dk;
      }
      var i2 = 1, j2;
      function outer() {
        if (i2 > len) {
          return callback(null, dk);
        }
        prf.start(null, null);
        prf.update(s3);
        prf.update(forge$i.util.int32ToBytes(i2));
        xor = u_c1 = prf.digest().getBytes();
        j2 = 2;
        inner();
      }
      function inner() {
        if (j2 <= c3) {
          prf.start(null, null);
          prf.update(u_c1);
          u_c = prf.digest().getBytes();
          xor = forge$i.util.xorBytes(xor, u_c, hLen);
          u_c1 = u_c;
          ++j2;
          return forge$i.util.setImmediate(inner);
        }
        dk += i2 < len ? xor : xor.substr(0, r2);
        ++i2;
        outer();
      }
      outer();
    };
    var forge$h = forge$s;
    var pem = forge$h.pem = forge$h.pem || {};
    pem.encode = function(msg, options2) {
      options2 = options2 || {};
      var rval = "-----BEGIN " + msg.type + "-----\r\n";
      var header;
      if (msg.procType) {
        header = {
          name: "Proc-Type",
          values: [String(msg.procType.version), msg.procType.type]
        };
        rval += foldHeader(header);
      }
      if (msg.contentDomain) {
        header = { name: "Content-Domain", values: [msg.contentDomain] };
        rval += foldHeader(header);
      }
      if (msg.dekInfo) {
        header = { name: "DEK-Info", values: [msg.dekInfo.algorithm] };
        if (msg.dekInfo.parameters) {
          header.values.push(msg.dekInfo.parameters);
        }
        rval += foldHeader(header);
      }
      if (msg.headers) {
        for (var i2 = 0; i2 < msg.headers.length; ++i2) {
          rval += foldHeader(msg.headers[i2]);
        }
      }
      if (msg.procType) {
        rval += "\r\n";
      }
      rval += forge$h.util.encode64(msg.body, options2.maxline || 64) + "\r\n";
      rval += "-----END " + msg.type + "-----\r\n";
      return rval;
    };
    pem.decode = function(str) {
      var rval = [];
      var rMessage = /\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g;
      var rHeader = /([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/;
      var rCRLF = /\r?\n/;
      var match2;
      while (true) {
        match2 = rMessage.exec(str);
        if (!match2) {
          break;
        }
        var type = match2[1];
        if (type === "NEW CERTIFICATE REQUEST") {
          type = "CERTIFICATE REQUEST";
        }
        var msg = {
          type,
          procType: null,
          contentDomain: null,
          dekInfo: null,
          headers: [],
          body: forge$h.util.decode64(match2[3])
        };
        rval.push(msg);
        if (!match2[2]) {
          continue;
        }
        var lines = match2[2].split(rCRLF);
        var li2 = 0;
        while (match2 && li2 < lines.length) {
          var line2 = lines[li2].replace(/\s+$/, "");
          for (var nl = li2 + 1; nl < lines.length; ++nl) {
            var next = lines[nl];
            if (!/\s/.test(next[0])) {
              break;
            }
            line2 += next;
            li2 = nl;
          }
          match2 = line2.match(rHeader);
          if (match2) {
            var header = { name: match2[1], values: [] };
            var values = match2[2].split(",");
            for (var vi2 = 0; vi2 < values.length; ++vi2) {
              header.values.push(ltrim(values[vi2]));
            }
            if (!msg.procType) {
              if (header.name !== "Proc-Type") {
                throw new Error('Invalid PEM formatted message. The first encapsulated header must be "Proc-Type".');
              } else if (header.values.length !== 2) {
                throw new Error('Invalid PEM formatted message. The "Proc-Type" header must have two subfields.');
              }
              msg.procType = { version: values[0], type: values[1] };
            } else if (!msg.contentDomain && header.name === "Content-Domain") {
              msg.contentDomain = values[0] || "";
            } else if (!msg.dekInfo && header.name === "DEK-Info") {
              if (header.values.length === 0) {
                throw new Error('Invalid PEM formatted message. The "DEK-Info" header must have at least one subfield.');
              }
              msg.dekInfo = { algorithm: values[0], parameters: values[1] || null };
            } else {
              msg.headers.push(header);
            }
          }
          ++li2;
        }
        if (msg.procType === "ENCRYPTED" && !msg.dekInfo) {
          throw new Error('Invalid PEM formatted message. The "DEK-Info" header must be present if "Proc-Type" is "ENCRYPTED".');
        }
      }
      if (rval.length === 0) {
        throw new Error("Invalid PEM formatted message.");
      }
      return rval;
    };
    function foldHeader(header) {
      var rval = header.name + ": ";
      var values = [];
      var insertSpace = function(match2, $1) {
        return " " + $1;
      };
      for (var i2 = 0; i2 < header.values.length; ++i2) {
        values.push(header.values[i2].replace(/^(\S+\r\n)/, insertSpace));
      }
      rval += values.join(",") + "\r\n";
      var length = 0;
      var candidate = -1;
      for (var i2 = 0; i2 < rval.length; ++i2, ++length) {
        if (length > 65 && candidate !== -1) {
          var insert = rval[candidate];
          if (insert === ",") {
            ++candidate;
            rval = rval.substr(0, candidate) + "\r\n " + rval.substr(candidate);
          } else {
            rval = rval.substr(0, candidate) + "\r\n" + insert + rval.substr(candidate + 1);
          }
          length = i2 - candidate - 1;
          candidate = -1;
          ++i2;
        } else if (rval[i2] === " " || rval[i2] === "	" || rval[i2] === ",") {
          candidate = i2;
        }
      }
      return rval;
    }
    function ltrim(str) {
      return str.replace(/^\s+/, "");
    }
    var forge$g = forge$s;
    var sha256 = forge$g.sha256 = forge$g.sha256 || {};
    forge$g.md.sha256 = forge$g.md.algorithms.sha256 = sha256;
    sha256.create = function() {
      if (!_initialized$1) {
        _init$1();
      }
      var _state = null;
      var _input = forge$g.util.createBuffer();
      var _w = new Array(64);
      var md = {
        algorithm: "sha256",
        blockLength: 64,
        digestLength: 32,
        messageLength: 0,
        fullMessageLength: null,
        messageLengthSize: 8
      };
      md.start = function() {
        md.messageLength = 0;
        md.fullMessageLength = md.messageLength64 = [];
        var int32s = md.messageLengthSize / 4;
        for (var i2 = 0; i2 < int32s; ++i2) {
          md.fullMessageLength.push(0);
        }
        _input = forge$g.util.createBuffer();
        _state = {
          h0: 1779033703,
          h1: 3144134277,
          h2: 1013904242,
          h3: 2773480762,
          h4: 1359893119,
          h5: 2600822924,
          h6: 528734635,
          h7: 1541459225
        };
        return md;
      };
      md.start();
      md.update = function(msg, encoding) {
        if (encoding === "utf8") {
          msg = forge$g.util.encodeUtf8(msg);
        }
        var len = msg.length;
        md.messageLength += len;
        len = [len / 4294967296 >>> 0, len >>> 0];
        for (var i2 = md.fullMessageLength.length - 1; i2 >= 0; --i2) {
          md.fullMessageLength[i2] += len[1];
          len[1] = len[0] + (md.fullMessageLength[i2] / 4294967296 >>> 0);
          md.fullMessageLength[i2] = md.fullMessageLength[i2] >>> 0;
          len[0] = len[1] / 4294967296 >>> 0;
        }
        _input.putBytes(msg);
        _update$1(_state, _w, _input);
        if (_input.read > 2048 || _input.length() === 0) {
          _input.compact();
        }
        return md;
      };
      md.digest = function() {
        var finalBlock = forge$g.util.createBuffer();
        finalBlock.putBytes(_input.bytes());
        var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
        var overflow = remaining & md.blockLength - 1;
        finalBlock.putBytes(_padding$1.substr(0, md.blockLength - overflow));
        var next, carry;
        var bits = md.fullMessageLength[0] * 8;
        for (var i2 = 0; i2 < md.fullMessageLength.length - 1; ++i2) {
          next = md.fullMessageLength[i2 + 1] * 8;
          carry = next / 4294967296 >>> 0;
          bits += carry;
          finalBlock.putInt32(bits >>> 0);
          bits = next >>> 0;
        }
        finalBlock.putInt32(bits);
        var s22 = {
          h0: _state.h0,
          h1: _state.h1,
          h2: _state.h2,
          h3: _state.h3,
          h4: _state.h4,
          h5: _state.h5,
          h6: _state.h6,
          h7: _state.h7
        };
        _update$1(s22, _w, finalBlock);
        var rval = forge$g.util.createBuffer();
        rval.putInt32(s22.h0);
        rval.putInt32(s22.h1);
        rval.putInt32(s22.h2);
        rval.putInt32(s22.h3);
        rval.putInt32(s22.h4);
        rval.putInt32(s22.h5);
        rval.putInt32(s22.h6);
        rval.putInt32(s22.h7);
        return rval;
      };
      return md;
    };
    var _padding$1 = null;
    var _initialized$1 = false;
    var _k = null;
    function _init$1() {
      _padding$1 = String.fromCharCode(128);
      _padding$1 += forge$g.util.fillString(String.fromCharCode(0), 64);
      _k = [
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ];
      _initialized$1 = true;
    }
    function _update$1(s3, w3, bytes) {
      var t1, t2, s0, s1, ch2, maj2, i2, a2, b2, c3, d3, e2, f2, g2, h3;
      var len = bytes.length();
      while (len >= 64) {
        for (i2 = 0; i2 < 16; ++i2) {
          w3[i2] = bytes.getInt32();
        }
        for (; i2 < 64; ++i2) {
          t1 = w3[i2 - 2];
          t1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;
          t2 = w3[i2 - 15];
          t2 = (t2 >>> 7 | t2 << 25) ^ (t2 >>> 18 | t2 << 14) ^ t2 >>> 3;
          w3[i2] = t1 + w3[i2 - 7] + t2 + w3[i2 - 16] | 0;
        }
        a2 = s3.h0;
        b2 = s3.h1;
        c3 = s3.h2;
        d3 = s3.h3;
        e2 = s3.h4;
        f2 = s3.h5;
        g2 = s3.h6;
        h3 = s3.h7;
        for (i2 = 0; i2 < 64; ++i2) {
          s1 = (e2 >>> 6 | e2 << 26) ^ (e2 >>> 11 | e2 << 21) ^ (e2 >>> 25 | e2 << 7);
          ch2 = g2 ^ e2 & (f2 ^ g2);
          s0 = (a2 >>> 2 | a2 << 30) ^ (a2 >>> 13 | a2 << 19) ^ (a2 >>> 22 | a2 << 10);
          maj2 = a2 & b2 | c3 & (a2 ^ b2);
          t1 = h3 + s1 + ch2 + _k[i2] + w3[i2];
          t2 = s0 + maj2;
          h3 = g2;
          g2 = f2;
          f2 = e2;
          e2 = d3 + t1 >>> 0;
          d3 = c3;
          c3 = b2;
          b2 = a2;
          a2 = t1 + t2 >>> 0;
        }
        s3.h0 = s3.h0 + a2 | 0;
        s3.h1 = s3.h1 + b2 | 0;
        s3.h2 = s3.h2 + c3 | 0;
        s3.h3 = s3.h3 + d3 | 0;
        s3.h4 = s3.h4 + e2 | 0;
        s3.h5 = s3.h5 + f2 | 0;
        s3.h6 = s3.h6 + g2 | 0;
        s3.h7 = s3.h7 + h3 | 0;
        len -= 64;
      }
    }
    var forge$f = forge$s;
    var _crypto$1 = null;
    if (forge$f.util.isNodejs && !forge$f.options.usePureJavaScript && !process.versions["node-webkit"]) {
      _crypto$1 = require$$1__default2;
    }
    var prng = forge$f.prng = forge$f.prng || {};
    prng.create = function(plugin) {
      var ctx = {
        plugin,
        key: null,
        seed: null,
        time: null,
        reseeds: 0,
        generated: 0,
        keyBytes: ""
      };
      var md = plugin.md;
      var pools = new Array(32);
      for (var i2 = 0; i2 < 32; ++i2) {
        pools[i2] = md.create();
      }
      ctx.pools = pools;
      ctx.pool = 0;
      ctx.generate = function(count, callback) {
        if (!callback) {
          return ctx.generateSync(count);
        }
        var cipher = ctx.plugin.cipher;
        var increment = ctx.plugin.increment;
        var formatKey = ctx.plugin.formatKey;
        var formatSeed = ctx.plugin.formatSeed;
        var b2 = forge$f.util.createBuffer();
        ctx.key = null;
        generate2();
        function generate2(err) {
          if (err) {
            return callback(err);
          }
          if (b2.length() >= count) {
            return callback(null, b2.getBytes(count));
          }
          if (ctx.generated > 1048575) {
            ctx.key = null;
          }
          if (ctx.key === null) {
            return forge$f.util.nextTick(function() {
              _reseed(generate2);
            });
          }
          var bytes = cipher(ctx.key, ctx.seed);
          ctx.generated += bytes.length;
          b2.putBytes(bytes);
          ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
          ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
          forge$f.util.setImmediate(generate2);
        }
      };
      ctx.generateSync = function(count) {
        var cipher = ctx.plugin.cipher;
        var increment = ctx.plugin.increment;
        var formatKey = ctx.plugin.formatKey;
        var formatSeed = ctx.plugin.formatSeed;
        ctx.key = null;
        var b2 = forge$f.util.createBuffer();
        while (b2.length() < count) {
          if (ctx.generated > 1048575) {
            ctx.key = null;
          }
          if (ctx.key === null) {
            _reseedSync();
          }
          var bytes = cipher(ctx.key, ctx.seed);
          ctx.generated += bytes.length;
          b2.putBytes(bytes);
          ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
          ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
        }
        return b2.getBytes(count);
      };
      function _reseed(callback) {
        if (ctx.pools[0].messageLength >= 32) {
          _seed();
          return callback();
        }
        var needed = 32 - ctx.pools[0].messageLength << 5;
        ctx.seedFile(needed, function(err, bytes) {
          if (err) {
            return callback(err);
          }
          ctx.collect(bytes);
          _seed();
          callback();
        });
      }
      function _reseedSync() {
        if (ctx.pools[0].messageLength >= 32) {
          return _seed();
        }
        var needed = 32 - ctx.pools[0].messageLength << 5;
        ctx.collect(ctx.seedFileSync(needed));
        _seed();
      }
      function _seed() {
        ctx.reseeds = ctx.reseeds === 4294967295 ? 0 : ctx.reseeds + 1;
        var md2 = ctx.plugin.md.create();
        md2.update(ctx.keyBytes);
        var _2powK = 1;
        for (var k2 = 0; k2 < 32; ++k2) {
          if (ctx.reseeds % _2powK === 0) {
            md2.update(ctx.pools[k2].digest().getBytes());
            ctx.pools[k2].start();
          }
          _2powK = _2powK << 1;
        }
        ctx.keyBytes = md2.digest().getBytes();
        md2.start();
        md2.update(ctx.keyBytes);
        var seedBytes = md2.digest().getBytes();
        ctx.key = ctx.plugin.formatKey(ctx.keyBytes);
        ctx.seed = ctx.plugin.formatSeed(seedBytes);
        ctx.generated = 0;
      }
      function defaultSeedFile(needed) {
        var getRandomValues = null;
        var globalScope = forge$f.util.globalScope;
        var _crypto2 = globalScope.crypto || globalScope.msCrypto;
        if (_crypto2 && _crypto2.getRandomValues) {
          getRandomValues = function(arr) {
            return _crypto2.getRandomValues(arr);
          };
        }
        var b2 = forge$f.util.createBuffer();
        if (getRandomValues) {
          while (b2.length() < needed) {
            var count = Math.max(1, Math.min(needed - b2.length(), 65536) / 4);
            var entropy = new Uint32Array(Math.floor(count));
            try {
              getRandomValues(entropy);
              for (var i3 = 0; i3 < entropy.length; ++i3) {
                b2.putInt32(entropy[i3]);
              }
            } catch (e2) {
              if (!(typeof QuotaExceededError !== "undefined" && e2 instanceof QuotaExceededError)) {
                throw e2;
              }
            }
          }
        }
        if (b2.length() < needed) {
          var hi2, lo2, next;
          var seed = Math.floor(Math.random() * 65536);
          while (b2.length() < needed) {
            lo2 = 16807 * (seed & 65535);
            hi2 = 16807 * (seed >> 16);
            lo2 += (hi2 & 32767) << 16;
            lo2 += hi2 >> 15;
            lo2 = (lo2 & 2147483647) + (lo2 >> 31);
            seed = lo2 & 4294967295;
            for (var i3 = 0; i3 < 3; ++i3) {
              next = seed >>> (i3 << 3);
              next ^= Math.floor(Math.random() * 256);
              b2.putByte(next & 255);
            }
          }
        }
        return b2.getBytes(needed);
      }
      if (_crypto$1) {
        ctx.seedFile = function(needed, callback) {
          _crypto$1.randomBytes(needed, function(err, bytes) {
            if (err) {
              return callback(err);
            }
            callback(null, bytes.toString());
          });
        };
        ctx.seedFileSync = function(needed) {
          return _crypto$1.randomBytes(needed).toString();
        };
      } else {
        ctx.seedFile = function(needed, callback) {
          try {
            callback(null, defaultSeedFile(needed));
          } catch (e2) {
            callback(e2);
          }
        };
        ctx.seedFileSync = defaultSeedFile;
      }
      ctx.collect = function(bytes) {
        var count = bytes.length;
        for (var i3 = 0; i3 < count; ++i3) {
          ctx.pools[ctx.pool].update(bytes.substr(i3, 1));
          ctx.pool = ctx.pool === 31 ? 0 : ctx.pool + 1;
        }
      };
      ctx.collectInt = function(i3, n3) {
        var bytes = "";
        for (var x2 = 0; x2 < n3; x2 += 8) {
          bytes += String.fromCharCode(i3 >> x2 & 255);
        }
        ctx.collect(bytes);
      };
      ctx.registerWorker = function(worker) {
        if (worker === self) {
          ctx.seedFile = function(needed, callback) {
            function listener3(e2) {
              var data2 = e2.data;
              if (data2.forge && data2.forge.prng) {
                self.removeEventListener("message", listener3);
                callback(data2.forge.prng.err, data2.forge.prng.bytes);
              }
            }
            self.addEventListener("message", listener3);
            self.postMessage({ forge: { prng: { needed } } });
          };
        } else {
          var listener2 = function(e2) {
            var data2 = e2.data;
            if (data2.forge && data2.forge.prng) {
              ctx.seedFile(data2.forge.prng.needed, function(err, bytes) {
                worker.postMessage({ forge: { prng: { err, bytes } } });
              });
            }
          };
          worker.addEventListener("message", listener2);
        }
      };
      return ctx;
    };
    var forge$e = forge$s;
    (function() {
      if (forge$e.random && forge$e.random.getBytes) {
        return;
      }
      (function(jQuery2) {
        var prng_aes = {};
        var _prng_aes_output = new Array(4);
        var _prng_aes_buffer = forge$e.util.createBuffer();
        prng_aes.formatKey = function(key3) {
          var tmp = forge$e.util.createBuffer(key3);
          key3 = new Array(4);
          key3[0] = tmp.getInt32();
          key3[1] = tmp.getInt32();
          key3[2] = tmp.getInt32();
          key3[3] = tmp.getInt32();
          return forge$e.aes._expandKey(key3, false);
        };
        prng_aes.formatSeed = function(seed) {
          var tmp = forge$e.util.createBuffer(seed);
          seed = new Array(4);
          seed[0] = tmp.getInt32();
          seed[1] = tmp.getInt32();
          seed[2] = tmp.getInt32();
          seed[3] = tmp.getInt32();
          return seed;
        };
        prng_aes.cipher = function(key3, seed) {
          forge$e.aes._updateBlock(key3, seed, _prng_aes_output, false);
          _prng_aes_buffer.putInt32(_prng_aes_output[0]);
          _prng_aes_buffer.putInt32(_prng_aes_output[1]);
          _prng_aes_buffer.putInt32(_prng_aes_output[2]);
          _prng_aes_buffer.putInt32(_prng_aes_output[3]);
          return _prng_aes_buffer.getBytes();
        };
        prng_aes.increment = function(seed) {
          ++seed[3];
          return seed;
        };
        prng_aes.md = forge$e.md.sha256;
        function spawnPrng() {
          var ctx = forge$e.prng.create(prng_aes);
          ctx.getBytes = function(count, callback) {
            return ctx.generate(count, callback);
          };
          ctx.getBytesSync = function(count) {
            return ctx.generate(count);
          };
          return ctx;
        }
        var _ctx = spawnPrng();
        var getRandomValues = null;
        var globalScope = forge$e.util.globalScope;
        var _crypto2 = globalScope.crypto || globalScope.msCrypto;
        if (_crypto2 && _crypto2.getRandomValues) {
          getRandomValues = function(arr) {
            return _crypto2.getRandomValues(arr);
          };
        }
        if (!forge$e.util.isNodejs && !getRandomValues) {
          _ctx.collectInt(+new Date(), 32);
          if (typeof navigator !== "undefined") {
            var _navBytes = "";
            for (var key2 in navigator) {
              try {
                if (typeof navigator[key2] == "string") {
                  _navBytes += navigator[key2];
                }
              } catch (e2) {
              }
            }
            _ctx.collect(_navBytes);
            _navBytes = null;
          }
          if (jQuery2) {
            jQuery2().mousemove(function(e2) {
              _ctx.collectInt(e2.clientX, 16);
              _ctx.collectInt(e2.clientY, 16);
            });
            jQuery2().keypress(function(e2) {
              _ctx.collectInt(e2.charCode, 8);
            });
          }
        }
        if (!forge$e.random) {
          forge$e.random = _ctx;
        } else {
          for (var key2 in _ctx) {
            forge$e.random[key2] = _ctx[key2];
          }
        }
        forge$e.random.createInstance = spawnPrng;
      })(typeof jQuery !== "undefined" ? jQuery : null);
    })();
    var forge$d = forge$s;
    var piTable = [
      217,
      120,
      249,
      196,
      25,
      221,
      181,
      237,
      40,
      233,
      253,
      121,
      74,
      160,
      216,
      157,
      198,
      126,
      55,
      131,
      43,
      118,
      83,
      142,
      98,
      76,
      100,
      136,
      68,
      139,
      251,
      162,
      23,
      154,
      89,
      245,
      135,
      179,
      79,
      19,
      97,
      69,
      109,
      141,
      9,
      129,
      125,
      50,
      189,
      143,
      64,
      235,
      134,
      183,
      123,
      11,
      240,
      149,
      33,
      34,
      92,
      107,
      78,
      130,
      84,
      214,
      101,
      147,
      206,
      96,
      178,
      28,
      115,
      86,
      192,
      20,
      167,
      140,
      241,
      220,
      18,
      117,
      202,
      31,
      59,
      190,
      228,
      209,
      66,
      61,
      212,
      48,
      163,
      60,
      182,
      38,
      111,
      191,
      14,
      218,
      70,
      105,
      7,
      87,
      39,
      242,
      29,
      155,
      188,
      148,
      67,
      3,
      248,
      17,
      199,
      246,
      144,
      239,
      62,
      231,
      6,
      195,
      213,
      47,
      200,
      102,
      30,
      215,
      8,
      232,
      234,
      222,
      128,
      82,
      238,
      247,
      132,
      170,
      114,
      172,
      53,
      77,
      106,
      42,
      150,
      26,
      210,
      113,
      90,
      21,
      73,
      116,
      75,
      159,
      208,
      94,
      4,
      24,
      164,
      236,
      194,
      224,
      65,
      110,
      15,
      81,
      203,
      204,
      36,
      145,
      175,
      80,
      161,
      244,
      112,
      57,
      153,
      124,
      58,
      133,
      35,
      184,
      180,
      122,
      252,
      2,
      54,
      91,
      37,
      85,
      151,
      49,
      45,
      93,
      250,
      152,
      227,
      138,
      146,
      174,
      5,
      223,
      41,
      16,
      103,
      108,
      186,
      201,
      211,
      0,
      230,
      207,
      225,
      158,
      168,
      44,
      99,
      22,
      1,
      63,
      88,
      226,
      137,
      169,
      13,
      56,
      52,
      27,
      171,
      51,
      255,
      176,
      187,
      72,
      12,
      95,
      185,
      177,
      205,
      46,
      197,
      243,
      219,
      71,
      229,
      165,
      156,
      119,
      10,
      166,
      32,
      104,
      254,
      127,
      193,
      173
    ];
    var s2 = [1, 2, 3, 5];
    var rol = function(word, bits) {
      return word << bits & 65535 | (word & 65535) >> 16 - bits;
    };
    var ror = function(word, bits) {
      return (word & 65535) >> bits | word << 16 - bits & 65535;
    };
    forge$d.rc2 = forge$d.rc2 || {};
    forge$d.rc2.expandKey = function(key2, effKeyBits) {
      if (typeof key2 === "string") {
        key2 = forge$d.util.createBuffer(key2);
      }
      effKeyBits = effKeyBits || 128;
      var L2 = key2;
      var T2 = key2.length();
      var T1 = effKeyBits;
      var T8 = Math.ceil(T1 / 8);
      var TM = 255 >> (T1 & 7);
      var i2;
      for (i2 = T2; i2 < 128; i2++) {
        L2.putByte(piTable[L2.at(i2 - 1) + L2.at(i2 - T2) & 255]);
      }
      L2.setAt(128 - T8, piTable[L2.at(128 - T8) & TM]);
      for (i2 = 127 - T8; i2 >= 0; i2--) {
        L2.setAt(i2, piTable[L2.at(i2 + 1) ^ L2.at(i2 + T8)]);
      }
      return L2;
    };
    var createCipher = function(key2, bits, encrypt) {
      var _finish = false, _input = null, _output = null, _iv = null;
      var mixRound, mashRound;
      var i2, j2, K2 = [];
      key2 = forge$d.rc2.expandKey(key2, bits);
      for (i2 = 0; i2 < 64; i2++) {
        K2.push(key2.getInt16Le());
      }
      if (encrypt) {
        mixRound = function(R2) {
          for (i2 = 0; i2 < 4; i2++) {
            R2[i2] += K2[j2] + (R2[(i2 + 3) % 4] & R2[(i2 + 2) % 4]) + (~R2[(i2 + 3) % 4] & R2[(i2 + 1) % 4]);
            R2[i2] = rol(R2[i2], s2[i2]);
            j2++;
          }
        };
        mashRound = function(R2) {
          for (i2 = 0; i2 < 4; i2++) {
            R2[i2] += K2[R2[(i2 + 3) % 4] & 63];
          }
        };
      } else {
        mixRound = function(R2) {
          for (i2 = 3; i2 >= 0; i2--) {
            R2[i2] = ror(R2[i2], s2[i2]);
            R2[i2] -= K2[j2] + (R2[(i2 + 3) % 4] & R2[(i2 + 2) % 4]) + (~R2[(i2 + 3) % 4] & R2[(i2 + 1) % 4]);
            j2--;
          }
        };
        mashRound = function(R2) {
          for (i2 = 3; i2 >= 0; i2--) {
            R2[i2] -= K2[R2[(i2 + 3) % 4] & 63];
          }
        };
      }
      var runPlan = function(plan) {
        var R2 = [];
        for (i2 = 0; i2 < 4; i2++) {
          var val = _input.getInt16Le();
          if (_iv !== null) {
            if (encrypt) {
              val ^= _iv.getInt16Le();
            } else {
              _iv.putInt16Le(val);
            }
          }
          R2.push(val & 65535);
        }
        j2 = encrypt ? 0 : 63;
        for (var ptr = 0; ptr < plan.length; ptr++) {
          for (var ctr = 0; ctr < plan[ptr][0]; ctr++) {
            plan[ptr][1](R2);
          }
        }
        for (i2 = 0; i2 < 4; i2++) {
          if (_iv !== null) {
            if (encrypt) {
              _iv.putInt16Le(R2[i2]);
            } else {
              R2[i2] ^= _iv.getInt16Le();
            }
          }
          _output.putInt16Le(R2[i2]);
        }
      };
      var cipher = null;
      cipher = {
        start: function(iv, output) {
          if (iv) {
            if (typeof iv === "string") {
              iv = forge$d.util.createBuffer(iv);
            }
          }
          _finish = false;
          _input = forge$d.util.createBuffer();
          _output = output || new forge$d.util.createBuffer();
          _iv = iv;
          cipher.output = _output;
        },
        update: function(input) {
          if (!_finish) {
            _input.putBuffer(input);
          }
          while (_input.length() >= 8) {
            runPlan([
              [5, mixRound],
              [1, mashRound],
              [6, mixRound],
              [1, mashRound],
              [5, mixRound]
            ]);
          }
        },
        finish: function(pad2) {
          var rval = true;
          if (encrypt) {
            if (pad2) {
              rval = pad2(8, _input, !encrypt);
            } else {
              var padding = _input.length() === 8 ? 8 : 8 - _input.length();
              _input.fillWithByte(padding, padding);
            }
          }
          if (rval) {
            _finish = true;
            cipher.update();
          }
          if (!encrypt) {
            rval = _input.length() === 0;
            if (rval) {
              if (pad2) {
                rval = pad2(8, _output, !encrypt);
              } else {
                var len = _output.length();
                var count = _output.at(len - 1);
                if (count > len) {
                  rval = false;
                } else {
                  _output.truncate(count);
                }
              }
            }
          }
          return rval;
        }
      };
      return cipher;
    };
    forge$d.rc2.startEncrypting = function(key2, iv, output) {
      var cipher = forge$d.rc2.createEncryptionCipher(key2, 128);
      cipher.start(iv, output);
      return cipher;
    };
    forge$d.rc2.createEncryptionCipher = function(key2, bits) {
      return createCipher(key2, bits, true);
    };
    forge$d.rc2.startDecrypting = function(key2, iv, output) {
      var cipher = forge$d.rc2.createDecryptionCipher(key2, 128);
      cipher.start(iv, output);
      return cipher;
    };
    forge$d.rc2.createDecryptionCipher = function(key2, bits) {
      return createCipher(key2, bits, false);
    };
    var forge$c = forge$s;
    forge$c.jsbn = forge$c.jsbn || {};
    var dbits;
    function BigInteger$1(a2, b2, c3) {
      this.data = [];
      if (a2 != null)
        if (typeof a2 == "number")
          this.fromNumber(a2, b2, c3);
        else if (b2 == null && typeof a2 != "string")
          this.fromString(a2, 256);
        else
          this.fromString(a2, b2);
    }
    forge$c.jsbn.BigInteger = BigInteger$1;
    function nbi() {
      return new BigInteger$1(null);
    }
    function am1(i2, x2, w3, j2, c3, n3) {
      while (--n3 >= 0) {
        var v2 = x2 * this.data[i2++] + w3.data[j2] + c3;
        c3 = Math.floor(v2 / 67108864);
        w3.data[j2++] = v2 & 67108863;
      }
      return c3;
    }
    function am2(i2, x2, w3, j2, c3, n3) {
      var xl = x2 & 32767, xh2 = x2 >> 15;
      while (--n3 >= 0) {
        var l2 = this.data[i2] & 32767;
        var h3 = this.data[i2++] >> 15;
        var m3 = xh2 * l2 + h3 * xl;
        l2 = xl * l2 + ((m3 & 32767) << 15) + w3.data[j2] + (c3 & 1073741823);
        c3 = (l2 >>> 30) + (m3 >>> 15) + xh2 * h3 + (c3 >>> 30);
        w3.data[j2++] = l2 & 1073741823;
      }
      return c3;
    }
    function am3(i2, x2, w3, j2, c3, n3) {
      var xl = x2 & 16383, xh2 = x2 >> 14;
      while (--n3 >= 0) {
        var l2 = this.data[i2] & 16383;
        var h3 = this.data[i2++] >> 14;
        var m3 = xh2 * l2 + h3 * xl;
        l2 = xl * l2 + ((m3 & 16383) << 14) + w3.data[j2] + c3;
        c3 = (l2 >> 28) + (m3 >> 14) + xh2 * h3;
        w3.data[j2++] = l2 & 268435455;
      }
      return c3;
    }
    if (typeof navigator === "undefined") {
      BigInteger$1.prototype.am = am3;
      dbits = 28;
    } else if (navigator.appName == "Microsoft Internet Explorer") {
      BigInteger$1.prototype.am = am2;
      dbits = 30;
    } else if (navigator.appName != "Netscape") {
      BigInteger$1.prototype.am = am1;
      dbits = 26;
    } else {
      BigInteger$1.prototype.am = am3;
      dbits = 28;
    }
    BigInteger$1.prototype.DB = dbits;
    BigInteger$1.prototype.DM = (1 << dbits) - 1;
    BigInteger$1.prototype.DV = 1 << dbits;
    var BI_FP = 52;
    BigInteger$1.prototype.FV = Math.pow(2, BI_FP);
    BigInteger$1.prototype.F1 = BI_FP - dbits;
    BigInteger$1.prototype.F2 = 2 * dbits - BI_FP;
    var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
    var BI_RC = new Array();
    var rr2;
    var vv;
    rr2 = "0".charCodeAt(0);
    for (vv = 0; vv <= 9; ++vv)
      BI_RC[rr2++] = vv;
    rr2 = "a".charCodeAt(0);
    for (vv = 10; vv < 36; ++vv)
      BI_RC[rr2++] = vv;
    rr2 = "A".charCodeAt(0);
    for (vv = 10; vv < 36; ++vv)
      BI_RC[rr2++] = vv;
    function int2char(n3) {
      return BI_RM.charAt(n3);
    }
    function intAt(s3, i2) {
      var c3 = BI_RC[s3.charCodeAt(i2)];
      return c3 == null ? -1 : c3;
    }
    function bnpCopyTo(r2) {
      for (var i2 = this.t - 1; i2 >= 0; --i2)
        r2.data[i2] = this.data[i2];
      r2.t = this.t;
      r2.s = this.s;
    }
    function bnpFromInt(x2) {
      this.t = 1;
      this.s = x2 < 0 ? -1 : 0;
      if (x2 > 0)
        this.data[0] = x2;
      else if (x2 < -1)
        this.data[0] = x2 + this.DV;
      else
        this.t = 0;
    }
    function nbv(i2) {
      var r2 = nbi();
      r2.fromInt(i2);
      return r2;
    }
    function bnpFromString(s3, b2) {
      var k2;
      if (b2 == 16)
        k2 = 4;
      else if (b2 == 8)
        k2 = 3;
      else if (b2 == 256)
        k2 = 8;
      else if (b2 == 2)
        k2 = 1;
      else if (b2 == 32)
        k2 = 5;
      else if (b2 == 4)
        k2 = 2;
      else {
        this.fromRadix(s3, b2);
        return;
      }
      this.t = 0;
      this.s = 0;
      var i2 = s3.length, mi2 = false, sh2 = 0;
      while (--i2 >= 0) {
        var x2 = k2 == 8 ? s3[i2] & 255 : intAt(s3, i2);
        if (x2 < 0) {
          if (s3.charAt(i2) == "-")
            mi2 = true;
          continue;
        }
        mi2 = false;
        if (sh2 == 0)
          this.data[this.t++] = x2;
        else if (sh2 + k2 > this.DB) {
          this.data[this.t - 1] |= (x2 & (1 << this.DB - sh2) - 1) << sh2;
          this.data[this.t++] = x2 >> this.DB - sh2;
        } else
          this.data[this.t - 1] |= x2 << sh2;
        sh2 += k2;
        if (sh2 >= this.DB)
          sh2 -= this.DB;
      }
      if (k2 == 8 && (s3[0] & 128) != 0) {
        this.s = -1;
        if (sh2 > 0)
          this.data[this.t - 1] |= (1 << this.DB - sh2) - 1 << sh2;
      }
      this.clamp();
      if (mi2)
        BigInteger$1.ZERO.subTo(this, this);
    }
    function bnpClamp() {
      var c3 = this.s & this.DM;
      while (this.t > 0 && this.data[this.t - 1] == c3)
        --this.t;
    }
    function bnToString(b2) {
      if (this.s < 0)
        return "-" + this.negate().toString(b2);
      var k2;
      if (b2 == 16)
        k2 = 4;
      else if (b2 == 8)
        k2 = 3;
      else if (b2 == 2)
        k2 = 1;
      else if (b2 == 32)
        k2 = 5;
      else if (b2 == 4)
        k2 = 2;
      else
        return this.toRadix(b2);
      var km = (1 << k2) - 1, d3, m3 = false, r2 = "", i2 = this.t;
      var p2 = this.DB - i2 * this.DB % k2;
      if (i2-- > 0) {
        if (p2 < this.DB && (d3 = this.data[i2] >> p2) > 0) {
          m3 = true;
          r2 = int2char(d3);
        }
        while (i2 >= 0) {
          if (p2 < k2) {
            d3 = (this.data[i2] & (1 << p2) - 1) << k2 - p2;
            d3 |= this.data[--i2] >> (p2 += this.DB - k2);
          } else {
            d3 = this.data[i2] >> (p2 -= k2) & km;
            if (p2 <= 0) {
              p2 += this.DB;
              --i2;
            }
          }
          if (d3 > 0)
            m3 = true;
          if (m3)
            r2 += int2char(d3);
        }
      }
      return m3 ? r2 : "0";
    }
    function bnNegate() {
      var r2 = nbi();
      BigInteger$1.ZERO.subTo(this, r2);
      return r2;
    }
    function bnAbs() {
      return this.s < 0 ? this.negate() : this;
    }
    function bnCompareTo(a2) {
      var r2 = this.s - a2.s;
      if (r2 != 0)
        return r2;
      var i2 = this.t;
      r2 = i2 - a2.t;
      if (r2 != 0)
        return this.s < 0 ? -r2 : r2;
      while (--i2 >= 0)
        if ((r2 = this.data[i2] - a2.data[i2]) != 0)
          return r2;
      return 0;
    }
    function nbits(x2) {
      var r2 = 1, t;
      if ((t = x2 >>> 16) != 0) {
        x2 = t;
        r2 += 16;
      }
      if ((t = x2 >> 8) != 0) {
        x2 = t;
        r2 += 8;
      }
      if ((t = x2 >> 4) != 0) {
        x2 = t;
        r2 += 4;
      }
      if ((t = x2 >> 2) != 0) {
        x2 = t;
        r2 += 2;
      }
      if ((t = x2 >> 1) != 0) {
        x2 = t;
        r2 += 1;
      }
      return r2;
    }
    function bnBitLength() {
      if (this.t <= 0)
        return 0;
      return this.DB * (this.t - 1) + nbits(this.data[this.t - 1] ^ this.s & this.DM);
    }
    function bnpDLShiftTo(n3, r2) {
      var i2;
      for (i2 = this.t - 1; i2 >= 0; --i2)
        r2.data[i2 + n3] = this.data[i2];
      for (i2 = n3 - 1; i2 >= 0; --i2)
        r2.data[i2] = 0;
      r2.t = this.t + n3;
      r2.s = this.s;
    }
    function bnpDRShiftTo(n3, r2) {
      for (var i2 = n3; i2 < this.t; ++i2)
        r2.data[i2 - n3] = this.data[i2];
      r2.t = Math.max(this.t - n3, 0);
      r2.s = this.s;
    }
    function bnpLShiftTo(n3, r2) {
      var bs2 = n3 % this.DB;
      var cbs = this.DB - bs2;
      var bm = (1 << cbs) - 1;
      var ds2 = Math.floor(n3 / this.DB), c3 = this.s << bs2 & this.DM, i2;
      for (i2 = this.t - 1; i2 >= 0; --i2) {
        r2.data[i2 + ds2 + 1] = this.data[i2] >> cbs | c3;
        c3 = (this.data[i2] & bm) << bs2;
      }
      for (i2 = ds2 - 1; i2 >= 0; --i2)
        r2.data[i2] = 0;
      r2.data[ds2] = c3;
      r2.t = this.t + ds2 + 1;
      r2.s = this.s;
      r2.clamp();
    }
    function bnpRShiftTo(n3, r2) {
      r2.s = this.s;
      var ds2 = Math.floor(n3 / this.DB);
      if (ds2 >= this.t) {
        r2.t = 0;
        return;
      }
      var bs2 = n3 % this.DB;
      var cbs = this.DB - bs2;
      var bm = (1 << bs2) - 1;
      r2.data[0] = this.data[ds2] >> bs2;
      for (var i2 = ds2 + 1; i2 < this.t; ++i2) {
        r2.data[i2 - ds2 - 1] |= (this.data[i2] & bm) << cbs;
        r2.data[i2 - ds2] = this.data[i2] >> bs2;
      }
      if (bs2 > 0)
        r2.data[this.t - ds2 - 1] |= (this.s & bm) << cbs;
      r2.t = this.t - ds2;
      r2.clamp();
    }
    function bnpSubTo(a2, r2) {
      var i2 = 0, c3 = 0, m3 = Math.min(a2.t, this.t);
      while (i2 < m3) {
        c3 += this.data[i2] - a2.data[i2];
        r2.data[i2++] = c3 & this.DM;
        c3 >>= this.DB;
      }
      if (a2.t < this.t) {
        c3 -= a2.s;
        while (i2 < this.t) {
          c3 += this.data[i2];
          r2.data[i2++] = c3 & this.DM;
          c3 >>= this.DB;
        }
        c3 += this.s;
      } else {
        c3 += this.s;
        while (i2 < a2.t) {
          c3 -= a2.data[i2];
          r2.data[i2++] = c3 & this.DM;
          c3 >>= this.DB;
        }
        c3 -= a2.s;
      }
      r2.s = c3 < 0 ? -1 : 0;
      if (c3 < -1)
        r2.data[i2++] = this.DV + c3;
      else if (c3 > 0)
        r2.data[i2++] = c3;
      r2.t = i2;
      r2.clamp();
    }
    function bnpMultiplyTo(a2, r2) {
      var x2 = this.abs(), y3 = a2.abs();
      var i2 = x2.t;
      r2.t = i2 + y3.t;
      while (--i2 >= 0)
        r2.data[i2] = 0;
      for (i2 = 0; i2 < y3.t; ++i2)
        r2.data[i2 + x2.t] = x2.am(0, y3.data[i2], r2, i2, 0, x2.t);
      r2.s = 0;
      r2.clamp();
      if (this.s != a2.s)
        BigInteger$1.ZERO.subTo(r2, r2);
    }
    function bnpSquareTo(r2) {
      var x2 = this.abs();
      var i2 = r2.t = 2 * x2.t;
      while (--i2 >= 0)
        r2.data[i2] = 0;
      for (i2 = 0; i2 < x2.t - 1; ++i2) {
        var c3 = x2.am(i2, x2.data[i2], r2, 2 * i2, 0, 1);
        if ((r2.data[i2 + x2.t] += x2.am(i2 + 1, 2 * x2.data[i2], r2, 2 * i2 + 1, c3, x2.t - i2 - 1)) >= x2.DV) {
          r2.data[i2 + x2.t] -= x2.DV;
          r2.data[i2 + x2.t + 1] = 1;
        }
      }
      if (r2.t > 0)
        r2.data[r2.t - 1] += x2.am(i2, x2.data[i2], r2, 2 * i2, 0, 1);
      r2.s = 0;
      r2.clamp();
    }
    function bnpDivRemTo(m3, q2, r2) {
      var pm = m3.abs();
      if (pm.t <= 0)
        return;
      var pt2 = this.abs();
      if (pt2.t < pm.t) {
        if (q2 != null)
          q2.fromInt(0);
        if (r2 != null)
          this.copyTo(r2);
        return;
      }
      if (r2 == null)
        r2 = nbi();
      var y3 = nbi(), ts2 = this.s, ms3 = m3.s;
      var nsh = this.DB - nbits(pm.data[pm.t - 1]);
      if (nsh > 0) {
        pm.lShiftTo(nsh, y3);
        pt2.lShiftTo(nsh, r2);
      } else {
        pm.copyTo(y3);
        pt2.copyTo(r2);
      }
      var ys2 = y3.t;
      var y0 = y3.data[ys2 - 1];
      if (y0 == 0)
        return;
      var yt2 = y0 * (1 << this.F1) + (ys2 > 1 ? y3.data[ys2 - 2] >> this.F2 : 0);
      var d1 = this.FV / yt2, d22 = (1 << this.F1) / yt2, e2 = 1 << this.F2;
      var i2 = r2.t, j2 = i2 - ys2, t = q2 == null ? nbi() : q2;
      y3.dlShiftTo(j2, t);
      if (r2.compareTo(t) >= 0) {
        r2.data[r2.t++] = 1;
        r2.subTo(t, r2);
      }
      BigInteger$1.ONE.dlShiftTo(ys2, t);
      t.subTo(y3, y3);
      while (y3.t < ys2)
        y3.data[y3.t++] = 0;
      while (--j2 >= 0) {
        var qd = r2.data[--i2] == y0 ? this.DM : Math.floor(r2.data[i2] * d1 + (r2.data[i2 - 1] + e2) * d22);
        if ((r2.data[i2] += y3.am(0, qd, r2, j2, 0, ys2)) < qd) {
          y3.dlShiftTo(j2, t);
          r2.subTo(t, r2);
          while (r2.data[i2] < --qd)
            r2.subTo(t, r2);
        }
      }
      if (q2 != null) {
        r2.drShiftTo(ys2, q2);
        if (ts2 != ms3)
          BigInteger$1.ZERO.subTo(q2, q2);
      }
      r2.t = ys2;
      r2.clamp();
      if (nsh > 0)
        r2.rShiftTo(nsh, r2);
      if (ts2 < 0)
        BigInteger$1.ZERO.subTo(r2, r2);
    }
    function bnMod(a2) {
      var r2 = nbi();
      this.abs().divRemTo(a2, null, r2);
      if (this.s < 0 && r2.compareTo(BigInteger$1.ZERO) > 0)
        a2.subTo(r2, r2);
      return r2;
    }
    function Classic(m3) {
      this.m = m3;
    }
    function cConvert(x2) {
      if (x2.s < 0 || x2.compareTo(this.m) >= 0)
        return x2.mod(this.m);
      else
        return x2;
    }
    function cRevert(x2) {
      return x2;
    }
    function cReduce(x2) {
      x2.divRemTo(this.m, null, x2);
    }
    function cMulTo(x2, y3, r2) {
      x2.multiplyTo(y3, r2);
      this.reduce(r2);
    }
    function cSqrTo(x2, r2) {
      x2.squareTo(r2);
      this.reduce(r2);
    }
    Classic.prototype.convert = cConvert;
    Classic.prototype.revert = cRevert;
    Classic.prototype.reduce = cReduce;
    Classic.prototype.mulTo = cMulTo;
    Classic.prototype.sqrTo = cSqrTo;
    function bnpInvDigit() {
      if (this.t < 1)
        return 0;
      var x2 = this.data[0];
      if ((x2 & 1) == 0)
        return 0;
      var y3 = x2 & 3;
      y3 = y3 * (2 - (x2 & 15) * y3) & 15;
      y3 = y3 * (2 - (x2 & 255) * y3) & 255;
      y3 = y3 * (2 - ((x2 & 65535) * y3 & 65535)) & 65535;
      y3 = y3 * (2 - x2 * y3 % this.DV) % this.DV;
      return y3 > 0 ? this.DV - y3 : -y3;
    }
    function Montgomery(m3) {
      this.m = m3;
      this.mp = m3.invDigit();
      this.mpl = this.mp & 32767;
      this.mph = this.mp >> 15;
      this.um = (1 << m3.DB - 15) - 1;
      this.mt2 = 2 * m3.t;
    }
    function montConvert(x2) {
      var r2 = nbi();
      x2.abs().dlShiftTo(this.m.t, r2);
      r2.divRemTo(this.m, null, r2);
      if (x2.s < 0 && r2.compareTo(BigInteger$1.ZERO) > 0)
        this.m.subTo(r2, r2);
      return r2;
    }
    function montRevert(x2) {
      var r2 = nbi();
      x2.copyTo(r2);
      this.reduce(r2);
      return r2;
    }
    function montReduce(x2) {
      while (x2.t <= this.mt2)
        x2.data[x2.t++] = 0;
      for (var i2 = 0; i2 < this.m.t; ++i2) {
        var j2 = x2.data[i2] & 32767;
        var u0 = j2 * this.mpl + ((j2 * this.mph + (x2.data[i2] >> 15) * this.mpl & this.um) << 15) & x2.DM;
        j2 = i2 + this.m.t;
        x2.data[j2] += this.m.am(0, u0, x2, i2, 0, this.m.t);
        while (x2.data[j2] >= x2.DV) {
          x2.data[j2] -= x2.DV;
          x2.data[++j2]++;
        }
      }
      x2.clamp();
      x2.drShiftTo(this.m.t, x2);
      if (x2.compareTo(this.m) >= 0)
        x2.subTo(this.m, x2);
    }
    function montSqrTo(x2, r2) {
      x2.squareTo(r2);
      this.reduce(r2);
    }
    function montMulTo(x2, y3, r2) {
      x2.multiplyTo(y3, r2);
      this.reduce(r2);
    }
    Montgomery.prototype.convert = montConvert;
    Montgomery.prototype.revert = montRevert;
    Montgomery.prototype.reduce = montReduce;
    Montgomery.prototype.mulTo = montMulTo;
    Montgomery.prototype.sqrTo = montSqrTo;
    function bnpIsEven() {
      return (this.t > 0 ? this.data[0] & 1 : this.s) == 0;
    }
    function bnpExp(e2, z2) {
      if (e2 > 4294967295 || e2 < 1)
        return BigInteger$1.ONE;
      var r2 = nbi(), r22 = nbi(), g2 = z2.convert(this), i2 = nbits(e2) - 1;
      g2.copyTo(r2);
      while (--i2 >= 0) {
        z2.sqrTo(r2, r22);
        if ((e2 & 1 << i2) > 0)
          z2.mulTo(r22, g2, r2);
        else {
          var t = r2;
          r2 = r22;
          r22 = t;
        }
      }
      return z2.revert(r2);
    }
    function bnModPowInt(e2, m3) {
      var z2;
      if (e2 < 256 || m3.isEven())
        z2 = new Classic(m3);
      else
        z2 = new Montgomery(m3);
      return this.exp(e2, z2);
    }
    BigInteger$1.prototype.copyTo = bnpCopyTo;
    BigInteger$1.prototype.fromInt = bnpFromInt;
    BigInteger$1.prototype.fromString = bnpFromString;
    BigInteger$1.prototype.clamp = bnpClamp;
    BigInteger$1.prototype.dlShiftTo = bnpDLShiftTo;
    BigInteger$1.prototype.drShiftTo = bnpDRShiftTo;
    BigInteger$1.prototype.lShiftTo = bnpLShiftTo;
    BigInteger$1.prototype.rShiftTo = bnpRShiftTo;
    BigInteger$1.prototype.subTo = bnpSubTo;
    BigInteger$1.prototype.multiplyTo = bnpMultiplyTo;
    BigInteger$1.prototype.squareTo = bnpSquareTo;
    BigInteger$1.prototype.divRemTo = bnpDivRemTo;
    BigInteger$1.prototype.invDigit = bnpInvDigit;
    BigInteger$1.prototype.isEven = bnpIsEven;
    BigInteger$1.prototype.exp = bnpExp;
    BigInteger$1.prototype.toString = bnToString;
    BigInteger$1.prototype.negate = bnNegate;
    BigInteger$1.prototype.abs = bnAbs;
    BigInteger$1.prototype.compareTo = bnCompareTo;
    BigInteger$1.prototype.bitLength = bnBitLength;
    BigInteger$1.prototype.mod = bnMod;
    BigInteger$1.prototype.modPowInt = bnModPowInt;
    BigInteger$1.ZERO = nbv(0);
    BigInteger$1.ONE = nbv(1);
    function bnClone() {
      var r2 = nbi();
      this.copyTo(r2);
      return r2;
    }
    function bnIntValue() {
      if (this.s < 0) {
        if (this.t == 1)
          return this.data[0] - this.DV;
        else if (this.t == 0)
          return -1;
      } else if (this.t == 1)
        return this.data[0];
      else if (this.t == 0)
        return 0;
      return (this.data[1] & (1 << 32 - this.DB) - 1) << this.DB | this.data[0];
    }
    function bnByteValue() {
      return this.t == 0 ? this.s : this.data[0] << 24 >> 24;
    }
    function bnShortValue() {
      return this.t == 0 ? this.s : this.data[0] << 16 >> 16;
    }
    function bnpChunkSize(r2) {
      return Math.floor(Math.LN2 * this.DB / Math.log(r2));
    }
    function bnSigNum() {
      if (this.s < 0)
        return -1;
      else if (this.t <= 0 || this.t == 1 && this.data[0] <= 0)
        return 0;
      else
        return 1;
    }
    function bnpToRadix(b2) {
      if (b2 == null)
        b2 = 10;
      if (this.signum() == 0 || b2 < 2 || b2 > 36)
        return "0";
      var cs2 = this.chunkSize(b2);
      var a2 = Math.pow(b2, cs2);
      var d3 = nbv(a2), y3 = nbi(), z2 = nbi(), r2 = "";
      this.divRemTo(d3, y3, z2);
      while (y3.signum() > 0) {
        r2 = (a2 + z2.intValue()).toString(b2).substr(1) + r2;
        y3.divRemTo(d3, y3, z2);
      }
      return z2.intValue().toString(b2) + r2;
    }
    function bnpFromRadix(s3, b2) {
      this.fromInt(0);
      if (b2 == null)
        b2 = 10;
      var cs2 = this.chunkSize(b2);
      var d3 = Math.pow(b2, cs2), mi2 = false, j2 = 0, w3 = 0;
      for (var i2 = 0; i2 < s3.length; ++i2) {
        var x2 = intAt(s3, i2);
        if (x2 < 0) {
          if (s3.charAt(i2) == "-" && this.signum() == 0)
            mi2 = true;
          continue;
        }
        w3 = b2 * w3 + x2;
        if (++j2 >= cs2) {
          this.dMultiply(d3);
          this.dAddOffset(w3, 0);
          j2 = 0;
          w3 = 0;
        }
      }
      if (j2 > 0) {
        this.dMultiply(Math.pow(b2, j2));
        this.dAddOffset(w3, 0);
      }
      if (mi2)
        BigInteger$1.ZERO.subTo(this, this);
    }
    function bnpFromNumber(a2, b2, c3) {
      if (typeof b2 == "number") {
        if (a2 < 2)
          this.fromInt(1);
        else {
          this.fromNumber(a2, c3);
          if (!this.testBit(a2 - 1))
            this.bitwiseTo(BigInteger$1.ONE.shiftLeft(a2 - 1), op_or, this);
          if (this.isEven())
            this.dAddOffset(1, 0);
          while (!this.isProbablePrime(b2)) {
            this.dAddOffset(2, 0);
            if (this.bitLength() > a2)
              this.subTo(BigInteger$1.ONE.shiftLeft(a2 - 1), this);
          }
        }
      } else {
        var x2 = new Array(), t = a2 & 7;
        x2.length = (a2 >> 3) + 1;
        b2.nextBytes(x2);
        if (t > 0)
          x2[0] &= (1 << t) - 1;
        else
          x2[0] = 0;
        this.fromString(x2, 256);
      }
    }
    function bnToByteArray() {
      var i2 = this.t, r2 = new Array();
      r2[0] = this.s;
      var p2 = this.DB - i2 * this.DB % 8, d3, k2 = 0;
      if (i2-- > 0) {
        if (p2 < this.DB && (d3 = this.data[i2] >> p2) != (this.s & this.DM) >> p2)
          r2[k2++] = d3 | this.s << this.DB - p2;
        while (i2 >= 0) {
          if (p2 < 8) {
            d3 = (this.data[i2] & (1 << p2) - 1) << 8 - p2;
            d3 |= this.data[--i2] >> (p2 += this.DB - 8);
          } else {
            d3 = this.data[i2] >> (p2 -= 8) & 255;
            if (p2 <= 0) {
              p2 += this.DB;
              --i2;
            }
          }
          if ((d3 & 128) != 0)
            d3 |= -256;
          if (k2 == 0 && (this.s & 128) != (d3 & 128))
            ++k2;
          if (k2 > 0 || d3 != this.s)
            r2[k2++] = d3;
        }
      }
      return r2;
    }
    function bnEquals(a2) {
      return this.compareTo(a2) == 0;
    }
    function bnMin(a2) {
      return this.compareTo(a2) < 0 ? this : a2;
    }
    function bnMax(a2) {
      return this.compareTo(a2) > 0 ? this : a2;
    }
    function bnpBitwiseTo(a2, op, r2) {
      var i2, f2, m3 = Math.min(a2.t, this.t);
      for (i2 = 0; i2 < m3; ++i2)
        r2.data[i2] = op(this.data[i2], a2.data[i2]);
      if (a2.t < this.t) {
        f2 = a2.s & this.DM;
        for (i2 = m3; i2 < this.t; ++i2)
          r2.data[i2] = op(this.data[i2], f2);
        r2.t = this.t;
      } else {
        f2 = this.s & this.DM;
        for (i2 = m3; i2 < a2.t; ++i2)
          r2.data[i2] = op(f2, a2.data[i2]);
        r2.t = a2.t;
      }
      r2.s = op(this.s, a2.s);
      r2.clamp();
    }
    function op_and(x2, y3) {
      return x2 & y3;
    }
    function bnAnd(a2) {
      var r2 = nbi();
      this.bitwiseTo(a2, op_and, r2);
      return r2;
    }
    function op_or(x2, y3) {
      return x2 | y3;
    }
    function bnOr(a2) {
      var r2 = nbi();
      this.bitwiseTo(a2, op_or, r2);
      return r2;
    }
    function op_xor(x2, y3) {
      return x2 ^ y3;
    }
    function bnXor(a2) {
      var r2 = nbi();
      this.bitwiseTo(a2, op_xor, r2);
      return r2;
    }
    function op_andnot(x2, y3) {
      return x2 & ~y3;
    }
    function bnAndNot(a2) {
      var r2 = nbi();
      this.bitwiseTo(a2, op_andnot, r2);
      return r2;
    }
    function bnNot() {
      var r2 = nbi();
      for (var i2 = 0; i2 < this.t; ++i2)
        r2.data[i2] = this.DM & ~this.data[i2];
      r2.t = this.t;
      r2.s = ~this.s;
      return r2;
    }
    function bnShiftLeft(n3) {
      var r2 = nbi();
      if (n3 < 0)
        this.rShiftTo(-n3, r2);
      else
        this.lShiftTo(n3, r2);
      return r2;
    }
    function bnShiftRight(n3) {
      var r2 = nbi();
      if (n3 < 0)
        this.lShiftTo(-n3, r2);
      else
        this.rShiftTo(n3, r2);
      return r2;
    }
    function lbit(x2) {
      if (x2 == 0)
        return -1;
      var r2 = 0;
      if ((x2 & 65535) == 0) {
        x2 >>= 16;
        r2 += 16;
      }
      if ((x2 & 255) == 0) {
        x2 >>= 8;
        r2 += 8;
      }
      if ((x2 & 15) == 0) {
        x2 >>= 4;
        r2 += 4;
      }
      if ((x2 & 3) == 0) {
        x2 >>= 2;
        r2 += 2;
      }
      if ((x2 & 1) == 0)
        ++r2;
      return r2;
    }
    function bnGetLowestSetBit() {
      for (var i2 = 0; i2 < this.t; ++i2)
        if (this.data[i2] != 0)
          return i2 * this.DB + lbit(this.data[i2]);
      if (this.s < 0)
        return this.t * this.DB;
      return -1;
    }
    function cbit(x2) {
      var r2 = 0;
      while (x2 != 0) {
        x2 &= x2 - 1;
        ++r2;
      }
      return r2;
    }
    function bnBitCount() {
      var r2 = 0, x2 = this.s & this.DM;
      for (var i2 = 0; i2 < this.t; ++i2)
        r2 += cbit(this.data[i2] ^ x2);
      return r2;
    }
    function bnTestBit(n3) {
      var j2 = Math.floor(n3 / this.DB);
      if (j2 >= this.t)
        return this.s != 0;
      return (this.data[j2] & 1 << n3 % this.DB) != 0;
    }
    function bnpChangeBit(n3, op) {
      var r2 = BigInteger$1.ONE.shiftLeft(n3);
      this.bitwiseTo(r2, op, r2);
      return r2;
    }
    function bnSetBit(n3) {
      return this.changeBit(n3, op_or);
    }
    function bnClearBit(n3) {
      return this.changeBit(n3, op_andnot);
    }
    function bnFlipBit(n3) {
      return this.changeBit(n3, op_xor);
    }
    function bnpAddTo(a2, r2) {
      var i2 = 0, c3 = 0, m3 = Math.min(a2.t, this.t);
      while (i2 < m3) {
        c3 += this.data[i2] + a2.data[i2];
        r2.data[i2++] = c3 & this.DM;
        c3 >>= this.DB;
      }
      if (a2.t < this.t) {
        c3 += a2.s;
        while (i2 < this.t) {
          c3 += this.data[i2];
          r2.data[i2++] = c3 & this.DM;
          c3 >>= this.DB;
        }
        c3 += this.s;
      } else {
        c3 += this.s;
        while (i2 < a2.t) {
          c3 += a2.data[i2];
          r2.data[i2++] = c3 & this.DM;
          c3 >>= this.DB;
        }
        c3 += a2.s;
      }
      r2.s = c3 < 0 ? -1 : 0;
      if (c3 > 0)
        r2.data[i2++] = c3;
      else if (c3 < -1)
        r2.data[i2++] = this.DV + c3;
      r2.t = i2;
      r2.clamp();
    }
    function bnAdd(a2) {
      var r2 = nbi();
      this.addTo(a2, r2);
      return r2;
    }
    function bnSubtract(a2) {
      var r2 = nbi();
      this.subTo(a2, r2);
      return r2;
    }
    function bnMultiply(a2) {
      var r2 = nbi();
      this.multiplyTo(a2, r2);
      return r2;
    }
    function bnDivide(a2) {
      var r2 = nbi();
      this.divRemTo(a2, r2, null);
      return r2;
    }
    function bnRemainder(a2) {
      var r2 = nbi();
      this.divRemTo(a2, null, r2);
      return r2;
    }
    function bnDivideAndRemainder(a2) {
      var q2 = nbi(), r2 = nbi();
      this.divRemTo(a2, q2, r2);
      return new Array(q2, r2);
    }
    function bnpDMultiply(n3) {
      this.data[this.t] = this.am(0, n3 - 1, this, 0, 0, this.t);
      ++this.t;
      this.clamp();
    }
    function bnpDAddOffset(n3, w3) {
      if (n3 == 0)
        return;
      while (this.t <= w3)
        this.data[this.t++] = 0;
      this.data[w3] += n3;
      while (this.data[w3] >= this.DV) {
        this.data[w3] -= this.DV;
        if (++w3 >= this.t)
          this.data[this.t++] = 0;
        ++this.data[w3];
      }
    }
    function NullExp() {
    }
    function nNop(x2) {
      return x2;
    }
    function nMulTo(x2, y3, r2) {
      x2.multiplyTo(y3, r2);
    }
    function nSqrTo(x2, r2) {
      x2.squareTo(r2);
    }
    NullExp.prototype.convert = nNop;
    NullExp.prototype.revert = nNop;
    NullExp.prototype.mulTo = nMulTo;
    NullExp.prototype.sqrTo = nSqrTo;
    function bnPow(e2) {
      return this.exp(e2, new NullExp());
    }
    function bnpMultiplyLowerTo(a2, n3, r2) {
      var i2 = Math.min(this.t + a2.t, n3);
      r2.s = 0;
      r2.t = i2;
      while (i2 > 0)
        r2.data[--i2] = 0;
      var j2;
      for (j2 = r2.t - this.t; i2 < j2; ++i2)
        r2.data[i2 + this.t] = this.am(0, a2.data[i2], r2, i2, 0, this.t);
      for (j2 = Math.min(a2.t, n3); i2 < j2; ++i2)
        this.am(0, a2.data[i2], r2, i2, 0, n3 - i2);
      r2.clamp();
    }
    function bnpMultiplyUpperTo(a2, n3, r2) {
      --n3;
      var i2 = r2.t = this.t + a2.t - n3;
      r2.s = 0;
      while (--i2 >= 0)
        r2.data[i2] = 0;
      for (i2 = Math.max(n3 - this.t, 0); i2 < a2.t; ++i2)
        r2.data[this.t + i2 - n3] = this.am(n3 - i2, a2.data[i2], r2, 0, 0, this.t + i2 - n3);
      r2.clamp();
      r2.drShiftTo(1, r2);
    }
    function Barrett(m3) {
      this.r2 = nbi();
      this.q3 = nbi();
      BigInteger$1.ONE.dlShiftTo(2 * m3.t, this.r2);
      this.mu = this.r2.divide(m3);
      this.m = m3;
    }
    function barrettConvert(x2) {
      if (x2.s < 0 || x2.t > 2 * this.m.t)
        return x2.mod(this.m);
      else if (x2.compareTo(this.m) < 0)
        return x2;
      else {
        var r2 = nbi();
        x2.copyTo(r2);
        this.reduce(r2);
        return r2;
      }
    }
    function barrettRevert(x2) {
      return x2;
    }
    function barrettReduce(x2) {
      x2.drShiftTo(this.m.t - 1, this.r2);
      if (x2.t > this.m.t + 1) {
        x2.t = this.m.t + 1;
        x2.clamp();
      }
      this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
      this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
      while (x2.compareTo(this.r2) < 0)
        x2.dAddOffset(1, this.m.t + 1);
      x2.subTo(this.r2, x2);
      while (x2.compareTo(this.m) >= 0)
        x2.subTo(this.m, x2);
    }
    function barrettSqrTo(x2, r2) {
      x2.squareTo(r2);
      this.reduce(r2);
    }
    function barrettMulTo(x2, y3, r2) {
      x2.multiplyTo(y3, r2);
      this.reduce(r2);
    }
    Barrett.prototype.convert = barrettConvert;
    Barrett.prototype.revert = barrettRevert;
    Barrett.prototype.reduce = barrettReduce;
    Barrett.prototype.mulTo = barrettMulTo;
    Barrett.prototype.sqrTo = barrettSqrTo;
    function bnModPow(e2, m3) {
      var i2 = e2.bitLength(), k2, r2 = nbv(1), z2;
      if (i2 <= 0)
        return r2;
      else if (i2 < 18)
        k2 = 1;
      else if (i2 < 48)
        k2 = 3;
      else if (i2 < 144)
        k2 = 4;
      else if (i2 < 768)
        k2 = 5;
      else
        k2 = 6;
      if (i2 < 8)
        z2 = new Classic(m3);
      else if (m3.isEven())
        z2 = new Barrett(m3);
      else
        z2 = new Montgomery(m3);
      var g2 = new Array(), n3 = 3, k1 = k2 - 1, km = (1 << k2) - 1;
      g2[1] = z2.convert(this);
      if (k2 > 1) {
        var g22 = nbi();
        z2.sqrTo(g2[1], g22);
        while (n3 <= km) {
          g2[n3] = nbi();
          z2.mulTo(g22, g2[n3 - 2], g2[n3]);
          n3 += 2;
        }
      }
      var j2 = e2.t - 1, w3, is1 = true, r22 = nbi(), t;
      i2 = nbits(e2.data[j2]) - 1;
      while (j2 >= 0) {
        if (i2 >= k1)
          w3 = e2.data[j2] >> i2 - k1 & km;
        else {
          w3 = (e2.data[j2] & (1 << i2 + 1) - 1) << k1 - i2;
          if (j2 > 0)
            w3 |= e2.data[j2 - 1] >> this.DB + i2 - k1;
        }
        n3 = k2;
        while ((w3 & 1) == 0) {
          w3 >>= 1;
          --n3;
        }
        if ((i2 -= n3) < 0) {
          i2 += this.DB;
          --j2;
        }
        if (is1) {
          g2[w3].copyTo(r2);
          is1 = false;
        } else {
          while (n3 > 1) {
            z2.sqrTo(r2, r22);
            z2.sqrTo(r22, r2);
            n3 -= 2;
          }
          if (n3 > 0)
            z2.sqrTo(r2, r22);
          else {
            t = r2;
            r2 = r22;
            r22 = t;
          }
          z2.mulTo(r22, g2[w3], r2);
        }
        while (j2 >= 0 && (e2.data[j2] & 1 << i2) == 0) {
          z2.sqrTo(r2, r22);
          t = r2;
          r2 = r22;
          r22 = t;
          if (--i2 < 0) {
            i2 = this.DB - 1;
            --j2;
          }
        }
      }
      return z2.revert(r2);
    }
    function bnGCD(a2) {
      var x2 = this.s < 0 ? this.negate() : this.clone();
      var y3 = a2.s < 0 ? a2.negate() : a2.clone();
      if (x2.compareTo(y3) < 0) {
        var t = x2;
        x2 = y3;
        y3 = t;
      }
      var i2 = x2.getLowestSetBit(), g2 = y3.getLowestSetBit();
      if (g2 < 0)
        return x2;
      if (i2 < g2)
        g2 = i2;
      if (g2 > 0) {
        x2.rShiftTo(g2, x2);
        y3.rShiftTo(g2, y3);
      }
      while (x2.signum() > 0) {
        if ((i2 = x2.getLowestSetBit()) > 0)
          x2.rShiftTo(i2, x2);
        if ((i2 = y3.getLowestSetBit()) > 0)
          y3.rShiftTo(i2, y3);
        if (x2.compareTo(y3) >= 0) {
          x2.subTo(y3, x2);
          x2.rShiftTo(1, x2);
        } else {
          y3.subTo(x2, y3);
          y3.rShiftTo(1, y3);
        }
      }
      if (g2 > 0)
        y3.lShiftTo(g2, y3);
      return y3;
    }
    function bnpModInt(n3) {
      if (n3 <= 0)
        return 0;
      var d3 = this.DV % n3, r2 = this.s < 0 ? n3 - 1 : 0;
      if (this.t > 0)
        if (d3 == 0)
          r2 = this.data[0] % n3;
        else
          for (var i2 = this.t - 1; i2 >= 0; --i2)
            r2 = (d3 * r2 + this.data[i2]) % n3;
      return r2;
    }
    function bnModInverse(m3) {
      var ac = m3.isEven();
      if (this.isEven() && ac || m3.signum() == 0)
        return BigInteger$1.ZERO;
      var u2 = m3.clone(), v2 = this.clone();
      var a2 = nbv(1), b2 = nbv(0), c3 = nbv(0), d3 = nbv(1);
      while (u2.signum() != 0) {
        while (u2.isEven()) {
          u2.rShiftTo(1, u2);
          if (ac) {
            if (!a2.isEven() || !b2.isEven()) {
              a2.addTo(this, a2);
              b2.subTo(m3, b2);
            }
            a2.rShiftTo(1, a2);
          } else if (!b2.isEven())
            b2.subTo(m3, b2);
          b2.rShiftTo(1, b2);
        }
        while (v2.isEven()) {
          v2.rShiftTo(1, v2);
          if (ac) {
            if (!c3.isEven() || !d3.isEven()) {
              c3.addTo(this, c3);
              d3.subTo(m3, d3);
            }
            c3.rShiftTo(1, c3);
          } else if (!d3.isEven())
            d3.subTo(m3, d3);
          d3.rShiftTo(1, d3);
        }
        if (u2.compareTo(v2) >= 0) {
          u2.subTo(v2, u2);
          if (ac)
            a2.subTo(c3, a2);
          b2.subTo(d3, b2);
        } else {
          v2.subTo(u2, v2);
          if (ac)
            c3.subTo(a2, c3);
          d3.subTo(b2, d3);
        }
      }
      if (v2.compareTo(BigInteger$1.ONE) != 0)
        return BigInteger$1.ZERO;
      if (d3.compareTo(m3) >= 0)
        return d3.subtract(m3);
      if (d3.signum() < 0)
        d3.addTo(m3, d3);
      else
        return d3;
      if (d3.signum() < 0)
        return d3.add(m3);
      else
        return d3;
    }
    var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509];
    var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
    function bnIsProbablePrime(t) {
      var i2, x2 = this.abs();
      if (x2.t == 1 && x2.data[0] <= lowprimes[lowprimes.length - 1]) {
        for (i2 = 0; i2 < lowprimes.length; ++i2)
          if (x2.data[0] == lowprimes[i2])
            return true;
        return false;
      }
      if (x2.isEven())
        return false;
      i2 = 1;
      while (i2 < lowprimes.length) {
        var m3 = lowprimes[i2], j2 = i2 + 1;
        while (j2 < lowprimes.length && m3 < lplim)
          m3 *= lowprimes[j2++];
        m3 = x2.modInt(m3);
        while (i2 < j2)
          if (m3 % lowprimes[i2++] == 0)
            return false;
      }
      return x2.millerRabin(t);
    }
    function bnpMillerRabin(t) {
      var n1 = this.subtract(BigInteger$1.ONE);
      var k2 = n1.getLowestSetBit();
      if (k2 <= 0)
        return false;
      var r2 = n1.shiftRight(k2);
      var prng2 = bnGetPrng();
      var a2;
      for (var i2 = 0; i2 < t; ++i2) {
        do {
          a2 = new BigInteger$1(this.bitLength(), prng2);
        } while (a2.compareTo(BigInteger$1.ONE) <= 0 || a2.compareTo(n1) >= 0);
        var y3 = a2.modPow(r2, this);
        if (y3.compareTo(BigInteger$1.ONE) != 0 && y3.compareTo(n1) != 0) {
          var j2 = 1;
          while (j2++ < k2 && y3.compareTo(n1) != 0) {
            y3 = y3.modPowInt(2, this);
            if (y3.compareTo(BigInteger$1.ONE) == 0)
              return false;
          }
          if (y3.compareTo(n1) != 0)
            return false;
        }
      }
      return true;
    }
    function bnGetPrng() {
      return {
        nextBytes: function(x2) {
          for (var i2 = 0; i2 < x2.length; ++i2) {
            x2[i2] = Math.floor(Math.random() * 256);
          }
        }
      };
    }
    BigInteger$1.prototype.chunkSize = bnpChunkSize;
    BigInteger$1.prototype.toRadix = bnpToRadix;
    BigInteger$1.prototype.fromRadix = bnpFromRadix;
    BigInteger$1.prototype.fromNumber = bnpFromNumber;
    BigInteger$1.prototype.bitwiseTo = bnpBitwiseTo;
    BigInteger$1.prototype.changeBit = bnpChangeBit;
    BigInteger$1.prototype.addTo = bnpAddTo;
    BigInteger$1.prototype.dMultiply = bnpDMultiply;
    BigInteger$1.prototype.dAddOffset = bnpDAddOffset;
    BigInteger$1.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
    BigInteger$1.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
    BigInteger$1.prototype.modInt = bnpModInt;
    BigInteger$1.prototype.millerRabin = bnpMillerRabin;
    BigInteger$1.prototype.clone = bnClone;
    BigInteger$1.prototype.intValue = bnIntValue;
    BigInteger$1.prototype.byteValue = bnByteValue;
    BigInteger$1.prototype.shortValue = bnShortValue;
    BigInteger$1.prototype.signum = bnSigNum;
    BigInteger$1.prototype.toByteArray = bnToByteArray;
    BigInteger$1.prototype.equals = bnEquals;
    BigInteger$1.prototype.min = bnMin;
    BigInteger$1.prototype.max = bnMax;
    BigInteger$1.prototype.and = bnAnd;
    BigInteger$1.prototype.or = bnOr;
    BigInteger$1.prototype.xor = bnXor;
    BigInteger$1.prototype.andNot = bnAndNot;
    BigInteger$1.prototype.not = bnNot;
    BigInteger$1.prototype.shiftLeft = bnShiftLeft;
    BigInteger$1.prototype.shiftRight = bnShiftRight;
    BigInteger$1.prototype.getLowestSetBit = bnGetLowestSetBit;
    BigInteger$1.prototype.bitCount = bnBitCount;
    BigInteger$1.prototype.testBit = bnTestBit;
    BigInteger$1.prototype.setBit = bnSetBit;
    BigInteger$1.prototype.clearBit = bnClearBit;
    BigInteger$1.prototype.flipBit = bnFlipBit;
    BigInteger$1.prototype.add = bnAdd;
    BigInteger$1.prototype.subtract = bnSubtract;
    BigInteger$1.prototype.multiply = bnMultiply;
    BigInteger$1.prototype.divide = bnDivide;
    BigInteger$1.prototype.remainder = bnRemainder;
    BigInteger$1.prototype.divideAndRemainder = bnDivideAndRemainder;
    BigInteger$1.prototype.modPow = bnModPow;
    BigInteger$1.prototype.modInverse = bnModInverse;
    BigInteger$1.prototype.pow = bnPow;
    BigInteger$1.prototype.gcd = bnGCD;
    BigInteger$1.prototype.isProbablePrime = bnIsProbablePrime;
    var forge$b = forge$s;
    var sha1 = forge$b.sha1 = forge$b.sha1 || {};
    forge$b.md.sha1 = forge$b.md.algorithms.sha1 = sha1;
    sha1.create = function() {
      if (!_initialized) {
        _init();
      }
      var _state = null;
      var _input = forge$b.util.createBuffer();
      var _w = new Array(80);
      var md = {
        algorithm: "sha1",
        blockLength: 64,
        digestLength: 20,
        messageLength: 0,
        fullMessageLength: null,
        messageLengthSize: 8
      };
      md.start = function() {
        md.messageLength = 0;
        md.fullMessageLength = md.messageLength64 = [];
        var int32s = md.messageLengthSize / 4;
        for (var i2 = 0; i2 < int32s; ++i2) {
          md.fullMessageLength.push(0);
        }
        _input = forge$b.util.createBuffer();
        _state = {
          h0: 1732584193,
          h1: 4023233417,
          h2: 2562383102,
          h3: 271733878,
          h4: 3285377520
        };
        return md;
      };
      md.start();
      md.update = function(msg, encoding) {
        if (encoding === "utf8") {
          msg = forge$b.util.encodeUtf8(msg);
        }
        var len = msg.length;
        md.messageLength += len;
        len = [len / 4294967296 >>> 0, len >>> 0];
        for (var i2 = md.fullMessageLength.length - 1; i2 >= 0; --i2) {
          md.fullMessageLength[i2] += len[1];
          len[1] = len[0] + (md.fullMessageLength[i2] / 4294967296 >>> 0);
          md.fullMessageLength[i2] = md.fullMessageLength[i2] >>> 0;
          len[0] = len[1] / 4294967296 >>> 0;
        }
        _input.putBytes(msg);
        _update(_state, _w, _input);
        if (_input.read > 2048 || _input.length() === 0) {
          _input.compact();
        }
        return md;
      };
      md.digest = function() {
        var finalBlock = forge$b.util.createBuffer();
        finalBlock.putBytes(_input.bytes());
        var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
        var overflow = remaining & md.blockLength - 1;
        finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
        var next, carry;
        var bits = md.fullMessageLength[0] * 8;
        for (var i2 = 0; i2 < md.fullMessageLength.length - 1; ++i2) {
          next = md.fullMessageLength[i2 + 1] * 8;
          carry = next / 4294967296 >>> 0;
          bits += carry;
          finalBlock.putInt32(bits >>> 0);
          bits = next >>> 0;
        }
        finalBlock.putInt32(bits);
        var s22 = {
          h0: _state.h0,
          h1: _state.h1,
          h2: _state.h2,
          h3: _state.h3,
          h4: _state.h4
        };
        _update(s22, _w, finalBlock);
        var rval = forge$b.util.createBuffer();
        rval.putInt32(s22.h0);
        rval.putInt32(s22.h1);
        rval.putInt32(s22.h2);
        rval.putInt32(s22.h3);
        rval.putInt32(s22.h4);
        return rval;
      };
      return md;
    };
    var _padding = null;
    var _initialized = false;
    function _init() {
      _padding = String.fromCharCode(128);
      _padding += forge$b.util.fillString(String.fromCharCode(0), 64);
      _initialized = true;
    }
    function _update(s3, w3, bytes) {
      var t, a2, b2, c3, d3, e2, f2, i2;
      var len = bytes.length();
      while (len >= 64) {
        a2 = s3.h0;
        b2 = s3.h1;
        c3 = s3.h2;
        d3 = s3.h3;
        e2 = s3.h4;
        for (i2 = 0; i2 < 16; ++i2) {
          t = bytes.getInt32();
          w3[i2] = t;
          f2 = d3 ^ b2 & (c3 ^ d3);
          t = (a2 << 5 | a2 >>> 27) + f2 + e2 + 1518500249 + t;
          e2 = d3;
          d3 = c3;
          c3 = (b2 << 30 | b2 >>> 2) >>> 0;
          b2 = a2;
          a2 = t;
        }
        for (; i2 < 20; ++i2) {
          t = w3[i2 - 3] ^ w3[i2 - 8] ^ w3[i2 - 14] ^ w3[i2 - 16];
          t = t << 1 | t >>> 31;
          w3[i2] = t;
          f2 = d3 ^ b2 & (c3 ^ d3);
          t = (a2 << 5 | a2 >>> 27) + f2 + e2 + 1518500249 + t;
          e2 = d3;
          d3 = c3;
          c3 = (b2 << 30 | b2 >>> 2) >>> 0;
          b2 = a2;
          a2 = t;
        }
        for (; i2 < 32; ++i2) {
          t = w3[i2 - 3] ^ w3[i2 - 8] ^ w3[i2 - 14] ^ w3[i2 - 16];
          t = t << 1 | t >>> 31;
          w3[i2] = t;
          f2 = b2 ^ c3 ^ d3;
          t = (a2 << 5 | a2 >>> 27) + f2 + e2 + 1859775393 + t;
          e2 = d3;
          d3 = c3;
          c3 = (b2 << 30 | b2 >>> 2) >>> 0;
          b2 = a2;
          a2 = t;
        }
        for (; i2 < 40; ++i2) {
          t = w3[i2 - 6] ^ w3[i2 - 16] ^ w3[i2 - 28] ^ w3[i2 - 32];
          t = t << 2 | t >>> 30;
          w3[i2] = t;
          f2 = b2 ^ c3 ^ d3;
          t = (a2 << 5 | a2 >>> 27) + f2 + e2 + 1859775393 + t;
          e2 = d3;
          d3 = c3;
          c3 = (b2 << 30 | b2 >>> 2) >>> 0;
          b2 = a2;
          a2 = t;
        }
        for (; i2 < 60; ++i2) {
          t = w3[i2 - 6] ^ w3[i2 - 16] ^ w3[i2 - 28] ^ w3[i2 - 32];
          t = t << 2 | t >>> 30;
          w3[i2] = t;
          f2 = b2 & c3 | d3 & (b2 ^ c3);
          t = (a2 << 5 | a2 >>> 27) + f2 + e2 + 2400959708 + t;
          e2 = d3;
          d3 = c3;
          c3 = (b2 << 30 | b2 >>> 2) >>> 0;
          b2 = a2;
          a2 = t;
        }
        for (; i2 < 80; ++i2) {
          t = w3[i2 - 6] ^ w3[i2 - 16] ^ w3[i2 - 28] ^ w3[i2 - 32];
          t = t << 2 | t >>> 30;
          w3[i2] = t;
          f2 = b2 ^ c3 ^ d3;
          t = (a2 << 5 | a2 >>> 27) + f2 + e2 + 3395469782 + t;
          e2 = d3;
          d3 = c3;
          c3 = (b2 << 30 | b2 >>> 2) >>> 0;
          b2 = a2;
          a2 = t;
        }
        s3.h0 = s3.h0 + a2 | 0;
        s3.h1 = s3.h1 + b2 | 0;
        s3.h2 = s3.h2 + c3 | 0;
        s3.h3 = s3.h3 + d3 | 0;
        s3.h4 = s3.h4 + e2 | 0;
        len -= 64;
      }
    }
    var forge$a = forge$s;
    var pkcs1 = forge$a.pkcs1 = forge$a.pkcs1 || {};
    pkcs1.encode_rsa_oaep = function(key2, message, options2) {
      var label;
      var seed;
      var md;
      var mgf1Md;
      if (typeof options2 === "string") {
        label = options2;
        seed = arguments[3] || void 0;
        md = arguments[4] || void 0;
      } else if (options2) {
        label = options2.label || void 0;
        seed = options2.seed || void 0;
        md = options2.md || void 0;
        if (options2.mgf1 && options2.mgf1.md) {
          mgf1Md = options2.mgf1.md;
        }
      }
      if (!md) {
        md = forge$a.md.sha1.create();
      } else {
        md.start();
      }
      if (!mgf1Md) {
        mgf1Md = md;
      }
      var keyLength = Math.ceil(key2.n.bitLength() / 8);
      var maxLength = keyLength - 2 * md.digestLength - 2;
      if (message.length > maxLength) {
        var error2 = new Error("RSAES-OAEP input message length is too long.");
        error2.length = message.length;
        error2.maxLength = maxLength;
        throw error2;
      }
      if (!label) {
        label = "";
      }
      md.update(label, "raw");
      var lHash = md.digest();
      var PS = "";
      var PS_length = maxLength - message.length;
      for (var i2 = 0; i2 < PS_length; i2++) {
        PS += "\0";
      }
      var DB = lHash.getBytes() + PS + "" + message;
      if (!seed) {
        seed = forge$a.random.getBytes(md.digestLength);
      } else if (seed.length !== md.digestLength) {
        var error2 = new Error("Invalid RSAES-OAEP seed. The seed length must match the digest length.");
        error2.seedLength = seed.length;
        error2.digestLength = md.digestLength;
        throw error2;
      }
      var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);
      var maskedDB = forge$a.util.xorBytes(DB, dbMask, DB.length);
      var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);
      var maskedSeed = forge$a.util.xorBytes(seed, seedMask, seed.length);
      return "\0" + maskedSeed + maskedDB;
    };
    pkcs1.decode_rsa_oaep = function(key2, em, options2) {
      var label;
      var md;
      var mgf1Md;
      if (typeof options2 === "string") {
        label = options2;
        md = arguments[3] || void 0;
      } else if (options2) {
        label = options2.label || void 0;
        md = options2.md || void 0;
        if (options2.mgf1 && options2.mgf1.md) {
          mgf1Md = options2.mgf1.md;
        }
      }
      var keyLength = Math.ceil(key2.n.bitLength() / 8);
      if (em.length !== keyLength) {
        var error2 = new Error("RSAES-OAEP encoded message length is invalid.");
        error2.length = em.length;
        error2.expectedLength = keyLength;
        throw error2;
      }
      if (md === void 0) {
        md = forge$a.md.sha1.create();
      } else {
        md.start();
      }
      if (!mgf1Md) {
        mgf1Md = md;
      }
      if (keyLength < 2 * md.digestLength + 2) {
        throw new Error("RSAES-OAEP key is too short for the hash function.");
      }
      if (!label) {
        label = "";
      }
      md.update(label, "raw");
      var lHash = md.digest().getBytes();
      var y3 = em.charAt(0);
      var maskedSeed = em.substring(1, md.digestLength + 1);
      var maskedDB = em.substring(1 + md.digestLength);
      var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);
      var seed = forge$a.util.xorBytes(maskedSeed, seedMask, maskedSeed.length);
      var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);
      var db = forge$a.util.xorBytes(maskedDB, dbMask, maskedDB.length);
      var lHashPrime = db.substring(0, md.digestLength);
      var error2 = y3 !== "\0";
      for (var i2 = 0; i2 < md.digestLength; ++i2) {
        error2 |= lHash.charAt(i2) !== lHashPrime.charAt(i2);
      }
      var in_ps = 1;
      var index3 = md.digestLength;
      for (var j2 = md.digestLength; j2 < db.length; j2++) {
        var code = db.charCodeAt(j2);
        var is_0 = code & 1 ^ 1;
        var error_mask = in_ps ? 65534 : 0;
        error2 |= code & error_mask;
        in_ps = in_ps & is_0;
        index3 += in_ps;
      }
      if (error2 || db.charCodeAt(index3) !== 1) {
        throw new Error("Invalid RSAES-OAEP padding.");
      }
      return db.substring(index3 + 1);
    };
    function rsa_mgf1(seed, maskLength, hash2) {
      if (!hash2) {
        hash2 = forge$a.md.sha1.create();
      }
      var t = "";
      var count = Math.ceil(maskLength / hash2.digestLength);
      for (var i2 = 0; i2 < count; ++i2) {
        var c3 = String.fromCharCode(i2 >> 24 & 255, i2 >> 16 & 255, i2 >> 8 & 255, i2 & 255);
        hash2.start();
        hash2.update(seed + c3);
        t += hash2.digest().getBytes();
      }
      return t.substring(0, maskLength);
    }
    var forge$9 = forge$s;
    (function() {
      if (forge$9.prime) {
        return;
      }
      var prime = forge$9.prime = forge$9.prime || {};
      var BigInteger2 = forge$9.jsbn.BigInteger;
      var GCD_30_DELTA2 = [6, 4, 2, 4, 2, 4, 6, 2];
      var THIRTY = new BigInteger2(null);
      THIRTY.fromInt(30);
      var op_or2 = function(x2, y3) {
        return x2 | y3;
      };
      prime.generateProbablePrime = function(bits, options2, callback) {
        if (typeof options2 === "function") {
          callback = options2;
          options2 = {};
        }
        options2 = options2 || {};
        var algorithm = options2.algorithm || "PRIMEINC";
        if (typeof algorithm === "string") {
          algorithm = { name: algorithm };
        }
        algorithm.options = algorithm.options || {};
        var prng2 = options2.prng || forge$9.random;
        var rng = {
          nextBytes: function(x2) {
            var b2 = prng2.getBytesSync(x2.length);
            for (var i2 = 0; i2 < x2.length; ++i2) {
              x2[i2] = b2.charCodeAt(i2);
            }
          }
        };
        if (algorithm.name === "PRIMEINC") {
          return primeincFindPrime(bits, rng, algorithm.options, callback);
        }
        throw new Error("Invalid prime generation algorithm: " + algorithm.name);
      };
      function primeincFindPrime(bits, rng, options2, callback) {
        if ("workers" in options2) {
          return primeincFindPrimeWithWorkers(bits, rng, options2, callback);
        }
        return primeincFindPrimeWithoutWorkers(bits, rng, options2, callback);
      }
      function primeincFindPrimeWithoutWorkers(bits, rng, options2, callback) {
        var num = generateRandom(bits, rng);
        var deltaIdx = 0;
        var mrTests = getMillerRabinTests(num.bitLength());
        if ("millerRabinTests" in options2) {
          mrTests = options2.millerRabinTests;
        }
        var maxBlockTime = 10;
        if ("maxBlockTime" in options2) {
          maxBlockTime = options2.maxBlockTime;
        }
        _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback);
      }
      function _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback) {
        var start = +new Date();
        do {
          if (num.bitLength() > bits) {
            num = generateRandom(bits, rng);
          }
          if (num.isProbablePrime(mrTests)) {
            return callback(null, num);
          }
          num.dAddOffset(GCD_30_DELTA2[deltaIdx++ % 8], 0);
        } while (maxBlockTime < 0 || +new Date() - start < maxBlockTime);
        forge$9.util.setImmediate(function() {
          _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback);
        });
      }
      function primeincFindPrimeWithWorkers(bits, rng, options2, callback) {
        if (typeof Worker === "undefined") {
          return primeincFindPrimeWithoutWorkers(bits, rng, options2, callback);
        }
        var num = generateRandom(bits, rng);
        var numWorkers = options2.workers;
        var workLoad = options2.workLoad || 100;
        var range2 = workLoad * 30 / 8;
        var workerScript = options2.workerScript || "forge/prime.worker.js";
        if (numWorkers === -1) {
          return forge$9.util.estimateCores(function(err, cores) {
            if (err) {
              cores = 2;
            }
            numWorkers = cores - 1;
            generate2();
          });
        }
        generate2();
        function generate2() {
          numWorkers = Math.max(1, numWorkers);
          var workers = [];
          for (var i2 = 0; i2 < numWorkers; ++i2) {
            workers[i2] = new Worker(workerScript);
          }
          for (var i2 = 0; i2 < numWorkers; ++i2) {
            workers[i2].addEventListener("message", workerMessage);
          }
          var found = false;
          function workerMessage(e2) {
            if (found) {
              return;
            }
            var data2 = e2.data;
            if (data2.found) {
              for (var i3 = 0; i3 < workers.length; ++i3) {
                workers[i3].terminate();
              }
              found = true;
              return callback(null, new BigInteger2(data2.prime, 16));
            }
            if (num.bitLength() > bits) {
              num = generateRandom(bits, rng);
            }
            var hex = num.toString(16);
            e2.target.postMessage({
              hex,
              workLoad
            });
            num.dAddOffset(range2, 0);
          }
        }
      }
      function generateRandom(bits, rng) {
        var num = new BigInteger2(bits, rng);
        var bits1 = bits - 1;
        if (!num.testBit(bits1)) {
          num.bitwiseTo(BigInteger2.ONE.shiftLeft(bits1), op_or2, num);
        }
        num.dAddOffset(31 - num.mod(THIRTY).byteValue(), 0);
        return num;
      }
      function getMillerRabinTests(bits) {
        if (bits <= 100)
          return 27;
        if (bits <= 150)
          return 18;
        if (bits <= 200)
          return 15;
        if (bits <= 250)
          return 12;
        if (bits <= 300)
          return 9;
        if (bits <= 350)
          return 8;
        if (bits <= 400)
          return 7;
        if (bits <= 500)
          return 6;
        if (bits <= 600)
          return 5;
        if (bits <= 800)
          return 4;
        if (bits <= 1250)
          return 3;
        return 2;
      }
    })();
    var forge$8 = forge$s;
    if (typeof BigInteger === "undefined") {
      BigInteger = forge$8.jsbn.BigInteger;
    }
    var BigInteger;
    var _crypto = forge$8.util.isNodejs ? require$$1__default2 : null;
    var asn1$5 = forge$8.asn1;
    var util2 = forge$8.util;
    forge$8.pki = forge$8.pki || {};
    forge$8.pki.rsa = forge$8.rsa = forge$8.rsa || {};
    var pki$4 = forge$8.pki;
    var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];
    var privateKeyValidator = {
      name: "PrivateKeyInfo",
      tagClass: asn1$5.Class.UNIVERSAL,
      type: asn1$5.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "PrivateKeyInfo.version",
        tagClass: asn1$5.Class.UNIVERSAL,
        type: asn1$5.Type.INTEGER,
        constructed: false,
        capture: "privateKeyVersion"
      }, {
        name: "PrivateKeyInfo.privateKeyAlgorithm",
        tagClass: asn1$5.Class.UNIVERSAL,
        type: asn1$5.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn1$5.Class.UNIVERSAL,
          type: asn1$5.Type.OID,
          constructed: false,
          capture: "privateKeyOid"
        }]
      }, {
        name: "PrivateKeyInfo",
        tagClass: asn1$5.Class.UNIVERSAL,
        type: asn1$5.Type.OCTETSTRING,
        constructed: false,
        capture: "privateKey"
      }]
    };
    var rsaPrivateKeyValidator = {
      name: "RSAPrivateKey",
      tagClass: asn1$5.Class.UNIVERSAL,
      type: asn1$5.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "RSAPrivateKey.version",
        tagClass: asn1$5.Class.UNIVERSAL,
        type: asn1$5.Type.INTEGER,
        constructed: false,
        capture: "privateKeyVersion"
      }, {
        name: "RSAPrivateKey.modulus",
        tagClass: asn1$5.Class.UNIVERSAL,
        type: asn1$5.Type.INTEGER,
        constructed: false,
        capture: "privateKeyModulus"
      }, {
        name: "RSAPrivateKey.publicExponent",
        tagClass: asn1$5.Class.UNIVERSAL,
        type: asn1$5.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPublicExponent"
      }, {
        name: "RSAPrivateKey.privateExponent",
        tagClass: asn1$5.Class.UNIVERSAL,
        type: asn1$5.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPrivateExponent"
      }, {
        name: "RSAPrivateKey.prime1",
        tagClass: asn1$5.Class.UNIVERSAL,
        type: asn1$5.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPrime1"
      }, {
        name: "RSAPrivateKey.prime2",
        tagClass: asn1$5.Class.UNIVERSAL,
        type: asn1$5.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPrime2"
      }, {
        name: "RSAPrivateKey.exponent1",
        tagClass: asn1$5.Class.UNIVERSAL,
        type: asn1$5.Type.INTEGER,
        constructed: false,
        capture: "privateKeyExponent1"
      }, {
        name: "RSAPrivateKey.exponent2",
        tagClass: asn1$5.Class.UNIVERSAL,
        type: asn1$5.Type.INTEGER,
        constructed: false,
        capture: "privateKeyExponent2"
      }, {
        name: "RSAPrivateKey.coefficient",
        tagClass: asn1$5.Class.UNIVERSAL,
        type: asn1$5.Type.INTEGER,
        constructed: false,
        capture: "privateKeyCoefficient"
      }]
    };
    var rsaPublicKeyValidator = {
      name: "RSAPublicKey",
      tagClass: asn1$5.Class.UNIVERSAL,
      type: asn1$5.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "RSAPublicKey.modulus",
        tagClass: asn1$5.Class.UNIVERSAL,
        type: asn1$5.Type.INTEGER,
        constructed: false,
        capture: "publicKeyModulus"
      }, {
        name: "RSAPublicKey.exponent",
        tagClass: asn1$5.Class.UNIVERSAL,
        type: asn1$5.Type.INTEGER,
        constructed: false,
        capture: "publicKeyExponent"
      }]
    };
    var publicKeyValidator$1 = forge$8.pki.rsa.publicKeyValidator = {
      name: "SubjectPublicKeyInfo",
      tagClass: asn1$5.Class.UNIVERSAL,
      type: asn1$5.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "subjectPublicKeyInfo",
      value: [{
        name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
        tagClass: asn1$5.Class.UNIVERSAL,
        type: asn1$5.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn1$5.Class.UNIVERSAL,
          type: asn1$5.Type.OID,
          constructed: false,
          capture: "publicKeyOid"
        }]
      }, {
        name: "SubjectPublicKeyInfo.subjectPublicKey",
        tagClass: asn1$5.Class.UNIVERSAL,
        type: asn1$5.Type.BITSTRING,
        constructed: false,
        value: [{
          name: "SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey",
          tagClass: asn1$5.Class.UNIVERSAL,
          type: asn1$5.Type.SEQUENCE,
          constructed: true,
          optional: true,
          captureAsn1: "rsaPublicKey"
        }]
      }]
    };
    var digestInfoValidator = {
      name: "DigestInfo",
      tagClass: asn1$5.Class.UNIVERSAL,
      type: asn1$5.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "DigestInfo.DigestAlgorithm",
        tagClass: asn1$5.Class.UNIVERSAL,
        type: asn1$5.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "DigestInfo.DigestAlgorithm.algorithmIdentifier",
          tagClass: asn1$5.Class.UNIVERSAL,
          type: asn1$5.Type.OID,
          constructed: false,
          capture: "algorithmIdentifier"
        }, {
          name: "DigestInfo.DigestAlgorithm.parameters",
          tagClass: asn1$5.Class.UNIVERSAL,
          type: asn1$5.Type.NULL,
          constructed: false
        }]
      }, {
        name: "DigestInfo.digest",
        tagClass: asn1$5.Class.UNIVERSAL,
        type: asn1$5.Type.OCTETSTRING,
        constructed: false,
        capture: "digest"
      }]
    };
    var emsaPkcs1v15encode = function(md) {
      var oid;
      if (md.algorithm in pki$4.oids) {
        oid = pki$4.oids[md.algorithm];
      } else {
        var error2 = new Error("Unknown message digest algorithm.");
        error2.algorithm = md.algorithm;
        throw error2;
      }
      var oidBytes = asn1$5.oidToDer(oid).getBytes();
      var digestInfo = asn1$5.create(asn1$5.Class.UNIVERSAL, asn1$5.Type.SEQUENCE, true, []);
      var digestAlgorithm = asn1$5.create(asn1$5.Class.UNIVERSAL, asn1$5.Type.SEQUENCE, true, []);
      digestAlgorithm.value.push(asn1$5.create(asn1$5.Class.UNIVERSAL, asn1$5.Type.OID, false, oidBytes));
      digestAlgorithm.value.push(asn1$5.create(asn1$5.Class.UNIVERSAL, asn1$5.Type.NULL, false, ""));
      var digest = asn1$5.create(asn1$5.Class.UNIVERSAL, asn1$5.Type.OCTETSTRING, false, md.digest().getBytes());
      digestInfo.value.push(digestAlgorithm);
      digestInfo.value.push(digest);
      return asn1$5.toDer(digestInfo).getBytes();
    };
    var _modPow = function(x2, key2, pub) {
      if (pub) {
        return x2.modPow(key2.e, key2.n);
      }
      if (!key2.p || !key2.q) {
        return x2.modPow(key2.d, key2.n);
      }
      if (!key2.dP) {
        key2.dP = key2.d.mod(key2.p.subtract(BigInteger.ONE));
      }
      if (!key2.dQ) {
        key2.dQ = key2.d.mod(key2.q.subtract(BigInteger.ONE));
      }
      if (!key2.qInv) {
        key2.qInv = key2.q.modInverse(key2.p);
      }
      var r2;
      do {
        r2 = new BigInteger(forge$8.util.bytesToHex(forge$8.random.getBytes(key2.n.bitLength() / 8)), 16);
      } while (r2.compareTo(key2.n) >= 0 || !r2.gcd(key2.n).equals(BigInteger.ONE));
      x2 = x2.multiply(r2.modPow(key2.e, key2.n)).mod(key2.n);
      var xp = x2.mod(key2.p).modPow(key2.dP, key2.p);
      var xq = x2.mod(key2.q).modPow(key2.dQ, key2.q);
      while (xp.compareTo(xq) < 0) {
        xp = xp.add(key2.p);
      }
      var y3 = xp.subtract(xq).multiply(key2.qInv).mod(key2.p).multiply(key2.q).add(xq);
      y3 = y3.multiply(r2.modInverse(key2.n)).mod(key2.n);
      return y3;
    };
    pki$4.rsa.encrypt = function(m3, key2, bt2) {
      var pub = bt2;
      var eb;
      var k2 = Math.ceil(key2.n.bitLength() / 8);
      if (bt2 !== false && bt2 !== true) {
        pub = bt2 === 2;
        eb = _encodePkcs1_v1_5(m3, key2, bt2);
      } else {
        eb = forge$8.util.createBuffer();
        eb.putBytes(m3);
      }
      var x2 = new BigInteger(eb.toHex(), 16);
      var y3 = _modPow(x2, key2, pub);
      var yhex = y3.toString(16);
      var ed = forge$8.util.createBuffer();
      var zeros2 = k2 - Math.ceil(yhex.length / 2);
      while (zeros2 > 0) {
        ed.putByte(0);
        --zeros2;
      }
      ed.putBytes(forge$8.util.hexToBytes(yhex));
      return ed.getBytes();
    };
    pki$4.rsa.decrypt = function(ed, key2, pub, ml) {
      var k2 = Math.ceil(key2.n.bitLength() / 8);
      if (ed.length !== k2) {
        var error2 = new Error("Encrypted message length is invalid.");
        error2.length = ed.length;
        error2.expected = k2;
        throw error2;
      }
      var y3 = new BigInteger(forge$8.util.createBuffer(ed).toHex(), 16);
      if (y3.compareTo(key2.n) >= 0) {
        throw new Error("Encrypted message is invalid.");
      }
      var x2 = _modPow(y3, key2, pub);
      var xhex = x2.toString(16);
      var eb = forge$8.util.createBuffer();
      var zeros2 = k2 - Math.ceil(xhex.length / 2);
      while (zeros2 > 0) {
        eb.putByte(0);
        --zeros2;
      }
      eb.putBytes(forge$8.util.hexToBytes(xhex));
      if (ml !== false) {
        return _decodePkcs1_v1_5(eb.getBytes(), key2, pub);
      }
      return eb.getBytes();
    };
    pki$4.rsa.createKeyPairGenerationState = function(bits, e2, options2) {
      if (typeof bits === "string") {
        bits = parseInt(bits, 10);
      }
      bits = bits || 2048;
      options2 = options2 || {};
      var prng2 = options2.prng || forge$8.random;
      var rng = {
        nextBytes: function(x2) {
          var b2 = prng2.getBytesSync(x2.length);
          for (var i2 = 0; i2 < x2.length; ++i2) {
            x2[i2] = b2.charCodeAt(i2);
          }
        }
      };
      var algorithm = options2.algorithm || "PRIMEINC";
      var rval;
      if (algorithm === "PRIMEINC") {
        rval = {
          algorithm,
          state: 0,
          bits,
          rng,
          eInt: e2 || 65537,
          e: new BigInteger(null),
          p: null,
          q: null,
          qBits: bits >> 1,
          pBits: bits - (bits >> 1),
          pqState: 0,
          num: null,
          keys: null
        };
        rval.e.fromInt(rval.eInt);
      } else {
        throw new Error("Invalid key generation algorithm: " + algorithm);
      }
      return rval;
    };
    pki$4.rsa.stepKeyPairGenerationState = function(state, n3) {
      if (!("algorithm" in state)) {
        state.algorithm = "PRIMEINC";
      }
      var THIRTY = new BigInteger(null);
      THIRTY.fromInt(30);
      var deltaIdx = 0;
      var op_or2 = function(x2, y3) {
        return x2 | y3;
      };
      var t1 = +new Date();
      var t2;
      var total = 0;
      while (state.keys === null && (n3 <= 0 || total < n3)) {
        if (state.state === 0) {
          var bits = state.p === null ? state.pBits : state.qBits;
          var bits1 = bits - 1;
          if (state.pqState === 0) {
            state.num = new BigInteger(bits, state.rng);
            if (!state.num.testBit(bits1)) {
              state.num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1), op_or2, state.num);
            }
            state.num.dAddOffset(31 - state.num.mod(THIRTY).byteValue(), 0);
            deltaIdx = 0;
            ++state.pqState;
          } else if (state.pqState === 1) {
            if (state.num.bitLength() > bits) {
              state.pqState = 0;
            } else if (state.num.isProbablePrime(_getMillerRabinTests(state.num.bitLength()))) {
              ++state.pqState;
            } else {
              state.num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);
            }
          } else if (state.pqState === 2) {
            state.pqState = state.num.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) === 0 ? 3 : 0;
          } else if (state.pqState === 3) {
            state.pqState = 0;
            if (state.p === null) {
              state.p = state.num;
            } else {
              state.q = state.num;
            }
            if (state.p !== null && state.q !== null) {
              ++state.state;
            }
            state.num = null;
          }
        } else if (state.state === 1) {
          if (state.p.compareTo(state.q) < 0) {
            state.num = state.p;
            state.p = state.q;
            state.q = state.num;
          }
          ++state.state;
        } else if (state.state === 2) {
          state.p1 = state.p.subtract(BigInteger.ONE);
          state.q1 = state.q.subtract(BigInteger.ONE);
          state.phi = state.p1.multiply(state.q1);
          ++state.state;
        } else if (state.state === 3) {
          if (state.phi.gcd(state.e).compareTo(BigInteger.ONE) === 0) {
            ++state.state;
          } else {
            state.p = null;
            state.q = null;
            state.state = 0;
          }
        } else if (state.state === 4) {
          state.n = state.p.multiply(state.q);
          if (state.n.bitLength() === state.bits) {
            ++state.state;
          } else {
            state.q = null;
            state.state = 0;
          }
        } else if (state.state === 5) {
          var d3 = state.e.modInverse(state.phi);
          state.keys = {
            privateKey: pki$4.rsa.setPrivateKey(state.n, state.e, d3, state.p, state.q, d3.mod(state.p1), d3.mod(state.q1), state.q.modInverse(state.p)),
            publicKey: pki$4.rsa.setPublicKey(state.n, state.e)
          };
        }
        t2 = +new Date();
        total += t2 - t1;
        t1 = t2;
      }
      return state.keys !== null;
    };
    pki$4.rsa.generateKeyPair = function(bits, e2, options2, callback) {
      if (arguments.length === 1) {
        if (typeof bits === "object") {
          options2 = bits;
          bits = void 0;
        } else if (typeof bits === "function") {
          callback = bits;
          bits = void 0;
        }
      } else if (arguments.length === 2) {
        if (typeof bits === "number") {
          if (typeof e2 === "function") {
            callback = e2;
            e2 = void 0;
          } else if (typeof e2 !== "number") {
            options2 = e2;
            e2 = void 0;
          }
        } else {
          options2 = bits;
          callback = e2;
          bits = void 0;
          e2 = void 0;
        }
      } else if (arguments.length === 3) {
        if (typeof e2 === "number") {
          if (typeof options2 === "function") {
            callback = options2;
            options2 = void 0;
          }
        } else {
          callback = options2;
          options2 = e2;
          e2 = void 0;
        }
      }
      options2 = options2 || {};
      if (bits === void 0) {
        bits = options2.bits || 2048;
      }
      if (e2 === void 0) {
        e2 = options2.e || 65537;
      }
      if (!options2.prng && bits >= 256 && bits <= 16384 && (e2 === 65537 || e2 === 3)) {
        if (callback) {
          if (_detectNodeCrypto("generateKeyPair")) {
            return _crypto.generateKeyPair("rsa", {
              modulusLength: bits,
              publicExponent: e2,
              publicKeyEncoding: {
                type: "spki",
                format: "pem"
              },
              privateKeyEncoding: {
                type: "pkcs8",
                format: "pem"
              }
            }, function(err, pub, priv) {
              if (err) {
                return callback(err);
              }
              callback(null, {
                privateKey: pki$4.privateKeyFromPem(priv),
                publicKey: pki$4.publicKeyFromPem(pub)
              });
            });
          }
          if (_detectSubtleCrypto("generateKey") && _detectSubtleCrypto("exportKey")) {
            return util2.globalScope.crypto.subtle.generateKey({
              name: "RSASSA-PKCS1-v1_5",
              modulusLength: bits,
              publicExponent: _intToUint8Array(e2),
              hash: { name: "SHA-256" }
            }, true, ["sign", "verify"]).then(function(pair) {
              return util2.globalScope.crypto.subtle.exportKey("pkcs8", pair.privateKey);
            }).then(void 0, function(err) {
              callback(err);
            }).then(function(pkcs8) {
              if (pkcs8) {
                var privateKey = pki$4.privateKeyFromAsn1(asn1$5.fromDer(forge$8.util.createBuffer(pkcs8)));
                callback(null, {
                  privateKey,
                  publicKey: pki$4.setRsaPublicKey(privateKey.n, privateKey.e)
                });
              }
            });
          }
          if (_detectSubtleMsCrypto("generateKey") && _detectSubtleMsCrypto("exportKey")) {
            var genOp = util2.globalScope.msCrypto.subtle.generateKey({
              name: "RSASSA-PKCS1-v1_5",
              modulusLength: bits,
              publicExponent: _intToUint8Array(e2),
              hash: { name: "SHA-256" }
            }, true, ["sign", "verify"]);
            genOp.oncomplete = function(e3) {
              var pair = e3.target.result;
              var exportOp = util2.globalScope.msCrypto.subtle.exportKey("pkcs8", pair.privateKey);
              exportOp.oncomplete = function(e4) {
                var pkcs8 = e4.target.result;
                var privateKey = pki$4.privateKeyFromAsn1(asn1$5.fromDer(forge$8.util.createBuffer(pkcs8)));
                callback(null, {
                  privateKey,
                  publicKey: pki$4.setRsaPublicKey(privateKey.n, privateKey.e)
                });
              };
              exportOp.onerror = function(err) {
                callback(err);
              };
            };
            genOp.onerror = function(err) {
              callback(err);
            };
            return;
          }
        } else {
          if (_detectNodeCrypto("generateKeyPairSync")) {
            var keypair = _crypto.generateKeyPairSync("rsa", {
              modulusLength: bits,
              publicExponent: e2,
              publicKeyEncoding: {
                type: "spki",
                format: "pem"
              },
              privateKeyEncoding: {
                type: "pkcs8",
                format: "pem"
              }
            });
            return {
              privateKey: pki$4.privateKeyFromPem(keypair.privateKey),
              publicKey: pki$4.publicKeyFromPem(keypair.publicKey)
            };
          }
        }
      }
      var state = pki$4.rsa.createKeyPairGenerationState(bits, e2, options2);
      if (!callback) {
        pki$4.rsa.stepKeyPairGenerationState(state, 0);
        return state.keys;
      }
      _generateKeyPair(state, options2, callback);
    };
    pki$4.setRsaPublicKey = pki$4.rsa.setPublicKey = function(n3, e2) {
      var key2 = {
        n: n3,
        e: e2
      };
      key2.encrypt = function(data2, scheme, schemeOptions) {
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        } else if (scheme === void 0) {
          scheme = "RSAES-PKCS1-V1_5";
        }
        if (scheme === "RSAES-PKCS1-V1_5") {
          scheme = {
            encode: function(m3, key3, pub) {
              return _encodePkcs1_v1_5(m3, key3, 2).getBytes();
            }
          };
        } else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") {
          scheme = {
            encode: function(m3, key3) {
              return forge$8.pkcs1.encode_rsa_oaep(key3, m3, schemeOptions);
            }
          };
        } else if (["RAW", "NONE", "NULL", null].indexOf(scheme) !== -1) {
          scheme = { encode: function(e4) {
            return e4;
          } };
        } else if (typeof scheme === "string") {
          throw new Error('Unsupported encryption scheme: "' + scheme + '".');
        }
        var e3 = scheme.encode(data2, key2, true);
        return pki$4.rsa.encrypt(e3, key2, true);
      };
      key2.verify = function(digest, signature, scheme, options2) {
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        } else if (scheme === void 0) {
          scheme = "RSASSA-PKCS1-V1_5";
        }
        if (options2 === void 0) {
          options2 = {
            _parseAllDigestBytes: true
          };
        }
        if (!("_parseAllDigestBytes" in options2)) {
          options2._parseAllDigestBytes = true;
        }
        if (scheme === "RSASSA-PKCS1-V1_5") {
          scheme = {
            verify: function(digest2, d4) {
              d4 = _decodePkcs1_v1_5(d4, key2, true);
              var obj = asn1$5.fromDer(d4, {
                parseAllBytes: options2._parseAllDigestBytes
              });
              var capture = {};
              var errors = [];
              if (!asn1$5.validate(obj, digestInfoValidator, capture, errors)) {
                var error2 = new Error("ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value.");
                error2.errors = errors;
                throw error2;
              }
              var oid = asn1$5.derToOid(capture.algorithmIdentifier);
              if (!(oid === forge$8.oids.md2 || oid === forge$8.oids.md5 || oid === forge$8.oids.sha1 || oid === forge$8.oids.sha224 || oid === forge$8.oids.sha256 || oid === forge$8.oids.sha384 || oid === forge$8.oids.sha512 || oid === forge$8.oids["sha512-224"] || oid === forge$8.oids["sha512-256"])) {
                var error2 = new Error("Unknown RSASSA-PKCS1-v1_5 DigestAlgorithm identifier.");
                error2.oid = oid;
                throw error2;
              }
              return digest2 === capture.digest;
            }
          };
        } else if (scheme === "NONE" || scheme === "NULL" || scheme === null) {
          scheme = {
            verify: function(digest2, d4) {
              d4 = _decodePkcs1_v1_5(d4, key2, true);
              return digest2 === d4;
            }
          };
        }
        var d3 = pki$4.rsa.decrypt(signature, key2, true, false);
        return scheme.verify(digest, d3, key2.n.bitLength());
      };
      return key2;
    };
    pki$4.setRsaPrivateKey = pki$4.rsa.setPrivateKey = function(n3, e2, d3, p2, q2, dP, dQ, qInv) {
      var key2 = {
        n: n3,
        e: e2,
        d: d3,
        p: p2,
        q: q2,
        dP,
        dQ,
        qInv
      };
      key2.decrypt = function(data2, scheme, schemeOptions) {
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        } else if (scheme === void 0) {
          scheme = "RSAES-PKCS1-V1_5";
        }
        var d4 = pki$4.rsa.decrypt(data2, key2, false, false);
        if (scheme === "RSAES-PKCS1-V1_5") {
          scheme = { decode: _decodePkcs1_v1_5 };
        } else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") {
          scheme = {
            decode: function(d5, key3) {
              return forge$8.pkcs1.decode_rsa_oaep(key3, d5, schemeOptions);
            }
          };
        } else if (["RAW", "NONE", "NULL", null].indexOf(scheme) !== -1) {
          scheme = { decode: function(d5) {
            return d5;
          } };
        } else {
          throw new Error('Unsupported encryption scheme: "' + scheme + '".');
        }
        return scheme.decode(d4, key2, false);
      };
      key2.sign = function(md, scheme) {
        var bt2 = false;
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        }
        if (scheme === void 0 || scheme === "RSASSA-PKCS1-V1_5") {
          scheme = { encode: emsaPkcs1v15encode };
          bt2 = 1;
        } else if (scheme === "NONE" || scheme === "NULL" || scheme === null) {
          scheme = { encode: function() {
            return md;
          } };
          bt2 = 1;
        }
        var d4 = scheme.encode(md, key2.n.bitLength());
        return pki$4.rsa.encrypt(d4, key2, bt2);
      };
      return key2;
    };
    pki$4.wrapRsaPrivateKey = function(rsaKey) {
      return asn1$5.create(asn1$5.Class.UNIVERSAL, asn1$5.Type.SEQUENCE, true, [
        asn1$5.create(asn1$5.Class.UNIVERSAL, asn1$5.Type.INTEGER, false, asn1$5.integerToDer(0).getBytes()),
        asn1$5.create(asn1$5.Class.UNIVERSAL, asn1$5.Type.SEQUENCE, true, [
          asn1$5.create(asn1$5.Class.UNIVERSAL, asn1$5.Type.OID, false, asn1$5.oidToDer(pki$4.oids.rsaEncryption).getBytes()),
          asn1$5.create(asn1$5.Class.UNIVERSAL, asn1$5.Type.NULL, false, "")
        ]),
        asn1$5.create(asn1$5.Class.UNIVERSAL, asn1$5.Type.OCTETSTRING, false, asn1$5.toDer(rsaKey).getBytes())
      ]);
    };
    pki$4.privateKeyFromAsn1 = function(obj) {
      var capture = {};
      var errors = [];
      if (asn1$5.validate(obj, privateKeyValidator, capture, errors)) {
        obj = asn1$5.fromDer(forge$8.util.createBuffer(capture.privateKey));
      }
      capture = {};
      errors = [];
      if (!asn1$5.validate(obj, rsaPrivateKeyValidator, capture, errors)) {
        var error2 = new Error("Cannot read private key. ASN.1 object does not contain an RSAPrivateKey.");
        error2.errors = errors;
        throw error2;
      }
      var n3, e2, d3, p2, q2, dP, dQ, qInv;
      n3 = forge$8.util.createBuffer(capture.privateKeyModulus).toHex();
      e2 = forge$8.util.createBuffer(capture.privateKeyPublicExponent).toHex();
      d3 = forge$8.util.createBuffer(capture.privateKeyPrivateExponent).toHex();
      p2 = forge$8.util.createBuffer(capture.privateKeyPrime1).toHex();
      q2 = forge$8.util.createBuffer(capture.privateKeyPrime2).toHex();
      dP = forge$8.util.createBuffer(capture.privateKeyExponent1).toHex();
      dQ = forge$8.util.createBuffer(capture.privateKeyExponent2).toHex();
      qInv = forge$8.util.createBuffer(capture.privateKeyCoefficient).toHex();
      return pki$4.setRsaPrivateKey(new BigInteger(n3, 16), new BigInteger(e2, 16), new BigInteger(d3, 16), new BigInteger(p2, 16), new BigInteger(q2, 16), new BigInteger(dP, 16), new BigInteger(dQ, 16), new BigInteger(qInv, 16));
    };
    pki$4.privateKeyToAsn1 = pki$4.privateKeyToRSAPrivateKey = function(key2) {
      return asn1$5.create(asn1$5.Class.UNIVERSAL, asn1$5.Type.SEQUENCE, true, [
        asn1$5.create(asn1$5.Class.UNIVERSAL, asn1$5.Type.INTEGER, false, asn1$5.integerToDer(0).getBytes()),
        asn1$5.create(asn1$5.Class.UNIVERSAL, asn1$5.Type.INTEGER, false, _bnToBytes(key2.n)),
        asn1$5.create(asn1$5.Class.UNIVERSAL, asn1$5.Type.INTEGER, false, _bnToBytes(key2.e)),
        asn1$5.create(asn1$5.Class.UNIVERSAL, asn1$5.Type.INTEGER, false, _bnToBytes(key2.d)),
        asn1$5.create(asn1$5.Class.UNIVERSAL, asn1$5.Type.INTEGER, false, _bnToBytes(key2.p)),
        asn1$5.create(asn1$5.Class.UNIVERSAL, asn1$5.Type.INTEGER, false, _bnToBytes(key2.q)),
        asn1$5.create(asn1$5.Class.UNIVERSAL, asn1$5.Type.INTEGER, false, _bnToBytes(key2.dP)),
        asn1$5.create(asn1$5.Class.UNIVERSAL, asn1$5.Type.INTEGER, false, _bnToBytes(key2.dQ)),
        asn1$5.create(asn1$5.Class.UNIVERSAL, asn1$5.Type.INTEGER, false, _bnToBytes(key2.qInv))
      ]);
    };
    pki$4.publicKeyFromAsn1 = function(obj) {
      var capture = {};
      var errors = [];
      if (asn1$5.validate(obj, publicKeyValidator$1, capture, errors)) {
        var oid = asn1$5.derToOid(capture.publicKeyOid);
        if (oid !== pki$4.oids.rsaEncryption) {
          var error2 = new Error("Cannot read public key. Unknown OID.");
          error2.oid = oid;
          throw error2;
        }
        obj = capture.rsaPublicKey;
      }
      errors = [];
      if (!asn1$5.validate(obj, rsaPublicKeyValidator, capture, errors)) {
        var error2 = new Error("Cannot read public key. ASN.1 object does not contain an RSAPublicKey.");
        error2.errors = errors;
        throw error2;
      }
      var n3 = forge$8.util.createBuffer(capture.publicKeyModulus).toHex();
      var e2 = forge$8.util.createBuffer(capture.publicKeyExponent).toHex();
      return pki$4.setRsaPublicKey(new BigInteger(n3, 16), new BigInteger(e2, 16));
    };
    pki$4.publicKeyToAsn1 = pki$4.publicKeyToSubjectPublicKeyInfo = function(key2) {
      return asn1$5.create(asn1$5.Class.UNIVERSAL, asn1$5.Type.SEQUENCE, true, [
        asn1$5.create(asn1$5.Class.UNIVERSAL, asn1$5.Type.SEQUENCE, true, [
          asn1$5.create(asn1$5.Class.UNIVERSAL, asn1$5.Type.OID, false, asn1$5.oidToDer(pki$4.oids.rsaEncryption).getBytes()),
          asn1$5.create(asn1$5.Class.UNIVERSAL, asn1$5.Type.NULL, false, "")
        ]),
        asn1$5.create(asn1$5.Class.UNIVERSAL, asn1$5.Type.BITSTRING, false, [
          pki$4.publicKeyToRSAPublicKey(key2)
        ])
      ]);
    };
    pki$4.publicKeyToRSAPublicKey = function(key2) {
      return asn1$5.create(asn1$5.Class.UNIVERSAL, asn1$5.Type.SEQUENCE, true, [
        asn1$5.create(asn1$5.Class.UNIVERSAL, asn1$5.Type.INTEGER, false, _bnToBytes(key2.n)),
        asn1$5.create(asn1$5.Class.UNIVERSAL, asn1$5.Type.INTEGER, false, _bnToBytes(key2.e))
      ]);
    };
    function _encodePkcs1_v1_5(m3, key2, bt2) {
      var eb = forge$8.util.createBuffer();
      var k2 = Math.ceil(key2.n.bitLength() / 8);
      if (m3.length > k2 - 11) {
        var error2 = new Error("Message is too long for PKCS#1 v1.5 padding.");
        error2.length = m3.length;
        error2.max = k2 - 11;
        throw error2;
      }
      eb.putByte(0);
      eb.putByte(bt2);
      var padNum = k2 - 3 - m3.length;
      var padByte;
      if (bt2 === 0 || bt2 === 1) {
        padByte = bt2 === 0 ? 0 : 255;
        for (var i2 = 0; i2 < padNum; ++i2) {
          eb.putByte(padByte);
        }
      } else {
        while (padNum > 0) {
          var numZeros = 0;
          var padBytes = forge$8.random.getBytes(padNum);
          for (var i2 = 0; i2 < padNum; ++i2) {
            padByte = padBytes.charCodeAt(i2);
            if (padByte === 0) {
              ++numZeros;
            } else {
              eb.putByte(padByte);
            }
          }
          padNum = numZeros;
        }
      }
      eb.putByte(0);
      eb.putBytes(m3);
      return eb;
    }
    function _decodePkcs1_v1_5(em, key2, pub, ml) {
      var k2 = Math.ceil(key2.n.bitLength() / 8);
      var eb = forge$8.util.createBuffer(em);
      var first2 = eb.getByte();
      var bt2 = eb.getByte();
      if (first2 !== 0 || pub && bt2 !== 0 && bt2 !== 1 || !pub && bt2 != 2 || pub && bt2 === 0 && typeof ml === "undefined") {
        throw new Error("Encryption block is invalid.");
      }
      var padNum = 0;
      if (bt2 === 0) {
        padNum = k2 - 3 - ml;
        for (var i2 = 0; i2 < padNum; ++i2) {
          if (eb.getByte() !== 0) {
            throw new Error("Encryption block is invalid.");
          }
        }
      } else if (bt2 === 1) {
        padNum = 0;
        while (eb.length() > 1) {
          if (eb.getByte() !== 255) {
            --eb.read;
            break;
          }
          ++padNum;
        }
      } else if (bt2 === 2) {
        padNum = 0;
        while (eb.length() > 1) {
          if (eb.getByte() === 0) {
            --eb.read;
            break;
          }
          ++padNum;
        }
      }
      var zero = eb.getByte();
      if (zero !== 0 || padNum !== k2 - 3 - eb.length()) {
        throw new Error("Encryption block is invalid.");
      }
      return eb.getBytes();
    }
    function _generateKeyPair(state, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
        options2 = {};
      }
      options2 = options2 || {};
      var opts = {
        algorithm: {
          name: options2.algorithm || "PRIMEINC",
          options: {
            workers: options2.workers || 2,
            workLoad: options2.workLoad || 100,
            workerScript: options2.workerScript
          }
        }
      };
      if ("prng" in options2) {
        opts.prng = options2.prng;
      }
      generate2();
      function generate2() {
        getPrime(state.pBits, function(err, num) {
          if (err) {
            return callback(err);
          }
          state.p = num;
          if (state.q !== null) {
            return finish2(err, state.q);
          }
          getPrime(state.qBits, finish2);
        });
      }
      function getPrime(bits, callback2) {
        forge$8.prime.generateProbablePrime(bits, opts, callback2);
      }
      function finish2(err, num) {
        if (err) {
          return callback(err);
        }
        state.q = num;
        if (state.p.compareTo(state.q) < 0) {
          var tmp = state.p;
          state.p = state.q;
          state.q = tmp;
        }
        if (state.p.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
          state.p = null;
          generate2();
          return;
        }
        if (state.q.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
          state.q = null;
          getPrime(state.qBits, finish2);
          return;
        }
        state.p1 = state.p.subtract(BigInteger.ONE);
        state.q1 = state.q.subtract(BigInteger.ONE);
        state.phi = state.p1.multiply(state.q1);
        if (state.phi.gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
          state.p = state.q = null;
          generate2();
          return;
        }
        state.n = state.p.multiply(state.q);
        if (state.n.bitLength() !== state.bits) {
          state.q = null;
          getPrime(state.qBits, finish2);
          return;
        }
        var d3 = state.e.modInverse(state.phi);
        state.keys = {
          privateKey: pki$4.rsa.setPrivateKey(state.n, state.e, d3, state.p, state.q, d3.mod(state.p1), d3.mod(state.q1), state.q.modInverse(state.p)),
          publicKey: pki$4.rsa.setPublicKey(state.n, state.e)
        };
        callback(null, state.keys);
      }
    }
    function _bnToBytes(b2) {
      var hex = b2.toString(16);
      if (hex[0] >= "8") {
        hex = "00" + hex;
      }
      var bytes = forge$8.util.hexToBytes(hex);
      if (bytes.length > 1 && (bytes.charCodeAt(0) === 0 && (bytes.charCodeAt(1) & 128) === 0 || bytes.charCodeAt(0) === 255 && (bytes.charCodeAt(1) & 128) === 128)) {
        return bytes.substr(1);
      }
      return bytes;
    }
    function _getMillerRabinTests(bits) {
      if (bits <= 100)
        return 27;
      if (bits <= 150)
        return 18;
      if (bits <= 200)
        return 15;
      if (bits <= 250)
        return 12;
      if (bits <= 300)
        return 9;
      if (bits <= 350)
        return 8;
      if (bits <= 400)
        return 7;
      if (bits <= 500)
        return 6;
      if (bits <= 600)
        return 5;
      if (bits <= 800)
        return 4;
      if (bits <= 1250)
        return 3;
      return 2;
    }
    function _detectNodeCrypto(fn2) {
      return forge$8.util.isNodejs && typeof _crypto[fn2] === "function";
    }
    function _detectSubtleCrypto(fn2) {
      return typeof util2.globalScope !== "undefined" && typeof util2.globalScope.crypto === "object" && typeof util2.globalScope.crypto.subtle === "object" && typeof util2.globalScope.crypto.subtle[fn2] === "function";
    }
    function _detectSubtleMsCrypto(fn2) {
      return typeof util2.globalScope !== "undefined" && typeof util2.globalScope.msCrypto === "object" && typeof util2.globalScope.msCrypto.subtle === "object" && typeof util2.globalScope.msCrypto.subtle[fn2] === "function";
    }
    function _intToUint8Array(x2) {
      var bytes = forge$8.util.hexToBytes(x2.toString(16));
      var buffer2 = new Uint8Array(bytes.length);
      for (var i2 = 0; i2 < bytes.length; ++i2) {
        buffer2[i2] = bytes.charCodeAt(i2);
      }
      return buffer2;
    }
    var forge$7 = forge$s;
    var asn1$4 = forge$7.asn1;
    var pki$3 = forge$7.pki = forge$7.pki || {};
    pki$3.pbe = forge$7.pbe = forge$7.pbe || {};
    var oids$1 = pki$3.oids;
    var encryptedPrivateKeyValidator = {
      name: "EncryptedPrivateKeyInfo",
      tagClass: asn1$4.Class.UNIVERSAL,
      type: asn1$4.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "EncryptedPrivateKeyInfo.encryptionAlgorithm",
        tagClass: asn1$4.Class.UNIVERSAL,
        type: asn1$4.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn1$4.Class.UNIVERSAL,
          type: asn1$4.Type.OID,
          constructed: false,
          capture: "encryptionOid"
        }, {
          name: "AlgorithmIdentifier.parameters",
          tagClass: asn1$4.Class.UNIVERSAL,
          type: asn1$4.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "encryptionParams"
        }]
      }, {
        name: "EncryptedPrivateKeyInfo.encryptedData",
        tagClass: asn1$4.Class.UNIVERSAL,
        type: asn1$4.Type.OCTETSTRING,
        constructed: false,
        capture: "encryptedData"
      }]
    };
    var PBES2AlgorithmsValidator = {
      name: "PBES2Algorithms",
      tagClass: asn1$4.Class.UNIVERSAL,
      type: asn1$4.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "PBES2Algorithms.keyDerivationFunc",
        tagClass: asn1$4.Class.UNIVERSAL,
        type: asn1$4.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "PBES2Algorithms.keyDerivationFunc.oid",
          tagClass: asn1$4.Class.UNIVERSAL,
          type: asn1$4.Type.OID,
          constructed: false,
          capture: "kdfOid"
        }, {
          name: "PBES2Algorithms.params",
          tagClass: asn1$4.Class.UNIVERSAL,
          type: asn1$4.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "PBES2Algorithms.params.salt",
            tagClass: asn1$4.Class.UNIVERSAL,
            type: asn1$4.Type.OCTETSTRING,
            constructed: false,
            capture: "kdfSalt"
          }, {
            name: "PBES2Algorithms.params.iterationCount",
            tagClass: asn1$4.Class.UNIVERSAL,
            type: asn1$4.Type.INTEGER,
            constructed: false,
            capture: "kdfIterationCount"
          }, {
            name: "PBES2Algorithms.params.keyLength",
            tagClass: asn1$4.Class.UNIVERSAL,
            type: asn1$4.Type.INTEGER,
            constructed: false,
            optional: true,
            capture: "keyLength"
          }, {
            name: "PBES2Algorithms.params.prf",
            tagClass: asn1$4.Class.UNIVERSAL,
            type: asn1$4.Type.SEQUENCE,
            constructed: true,
            optional: true,
            value: [{
              name: "PBES2Algorithms.params.prf.algorithm",
              tagClass: asn1$4.Class.UNIVERSAL,
              type: asn1$4.Type.OID,
              constructed: false,
              capture: "prfOid"
            }]
          }]
        }]
      }, {
        name: "PBES2Algorithms.encryptionScheme",
        tagClass: asn1$4.Class.UNIVERSAL,
        type: asn1$4.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "PBES2Algorithms.encryptionScheme.oid",
          tagClass: asn1$4.Class.UNIVERSAL,
          type: asn1$4.Type.OID,
          constructed: false,
          capture: "encOid"
        }, {
          name: "PBES2Algorithms.encryptionScheme.iv",
          tagClass: asn1$4.Class.UNIVERSAL,
          type: asn1$4.Type.OCTETSTRING,
          constructed: false,
          capture: "encIv"
        }]
      }]
    };
    var pkcs12PbeParamsValidator = {
      name: "pkcs-12PbeParams",
      tagClass: asn1$4.Class.UNIVERSAL,
      type: asn1$4.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "pkcs-12PbeParams.salt",
        tagClass: asn1$4.Class.UNIVERSAL,
        type: asn1$4.Type.OCTETSTRING,
        constructed: false,
        capture: "salt"
      }, {
        name: "pkcs-12PbeParams.iterations",
        tagClass: asn1$4.Class.UNIVERSAL,
        type: asn1$4.Type.INTEGER,
        constructed: false,
        capture: "iterations"
      }]
    };
    pki$3.encryptPrivateKeyInfo = function(obj, password, options2) {
      options2 = options2 || {};
      options2.saltSize = options2.saltSize || 8;
      options2.count = options2.count || 2048;
      options2.algorithm = options2.algorithm || "aes128";
      options2.prfAlgorithm = options2.prfAlgorithm || "sha1";
      var salt = forge$7.random.getBytesSync(options2.saltSize);
      var count = options2.count;
      var countBytes = asn1$4.integerToDer(count);
      var dkLen;
      var encryptionAlgorithm;
      var encryptedData;
      if (options2.algorithm.indexOf("aes") === 0 || options2.algorithm === "des") {
        var ivLen, encOid, cipherFn;
        switch (options2.algorithm) {
          case "aes128":
            dkLen = 16;
            ivLen = 16;
            encOid = oids$1["aes128-CBC"];
            cipherFn = forge$7.aes.createEncryptionCipher;
            break;
          case "aes192":
            dkLen = 24;
            ivLen = 16;
            encOid = oids$1["aes192-CBC"];
            cipherFn = forge$7.aes.createEncryptionCipher;
            break;
          case "aes256":
            dkLen = 32;
            ivLen = 16;
            encOid = oids$1["aes256-CBC"];
            cipherFn = forge$7.aes.createEncryptionCipher;
            break;
          case "des":
            dkLen = 8;
            ivLen = 8;
            encOid = oids$1["desCBC"];
            cipherFn = forge$7.des.createEncryptionCipher;
            break;
          default:
            var error2 = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
            error2.algorithm = options2.algorithm;
            throw error2;
        }
        var prfAlgorithm = "hmacWith" + options2.prfAlgorithm.toUpperCase();
        var md = prfAlgorithmToMessageDigest(prfAlgorithm);
        var dk = forge$7.pkcs5.pbkdf2(password, salt, count, dkLen, md);
        var iv = forge$7.random.getBytesSync(ivLen);
        var cipher = cipherFn(dk);
        cipher.start(iv);
        cipher.update(asn1$4.toDer(obj));
        cipher.finish();
        encryptedData = cipher.output.getBytes();
        var params = createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm);
        encryptionAlgorithm = asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, [
          asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.OID, false, asn1$4.oidToDer(oids$1["pkcs5PBES2"]).getBytes()),
          asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, [
            asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, [
              asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.OID, false, asn1$4.oidToDer(oids$1["pkcs5PBKDF2"]).getBytes()),
              params
            ]),
            asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, [
              asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.OID, false, asn1$4.oidToDer(encOid).getBytes()),
              asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.OCTETSTRING, false, iv)
            ])
          ])
        ]);
      } else if (options2.algorithm === "3des") {
        dkLen = 24;
        var saltBytes = new forge$7.util.ByteBuffer(salt);
        var dk = pki$3.pbe.generatePkcs12Key(password, saltBytes, 1, count, dkLen);
        var iv = pki$3.pbe.generatePkcs12Key(password, saltBytes, 2, count, dkLen);
        var cipher = forge$7.des.createEncryptionCipher(dk);
        cipher.start(iv);
        cipher.update(asn1$4.toDer(obj));
        cipher.finish();
        encryptedData = cipher.output.getBytes();
        encryptionAlgorithm = asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, [
          asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.OID, false, asn1$4.oidToDer(oids$1["pbeWithSHAAnd3-KeyTripleDES-CBC"]).getBytes()),
          asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, [
            asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.OCTETSTRING, false, salt),
            asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.INTEGER, false, countBytes.getBytes())
          ])
        ]);
      } else {
        var error2 = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
        error2.algorithm = options2.algorithm;
        throw error2;
      }
      var rval = asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, [
        encryptionAlgorithm,
        asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.OCTETSTRING, false, encryptedData)
      ]);
      return rval;
    };
    pki$3.decryptPrivateKeyInfo = function(obj, password) {
      var rval = null;
      var capture = {};
      var errors = [];
      if (!asn1$4.validate(obj, encryptedPrivateKeyValidator, capture, errors)) {
        var error2 = new Error("Cannot read encrypted private key. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
        error2.errors = errors;
        throw error2;
      }
      var oid = asn1$4.derToOid(capture.encryptionOid);
      var cipher = pki$3.pbe.getCipher(oid, capture.encryptionParams, password);
      var encrypted = forge$7.util.createBuffer(capture.encryptedData);
      cipher.update(encrypted);
      if (cipher.finish()) {
        rval = asn1$4.fromDer(cipher.output);
      }
      return rval;
    };
    pki$3.encryptedPrivateKeyToPem = function(epki, maxline) {
      var msg = {
        type: "ENCRYPTED PRIVATE KEY",
        body: asn1$4.toDer(epki).getBytes()
      };
      return forge$7.pem.encode(msg, { maxline });
    };
    pki$3.encryptedPrivateKeyFromPem = function(pem2) {
      var msg = forge$7.pem.decode(pem2)[0];
      if (msg.type !== "ENCRYPTED PRIVATE KEY") {
        var error2 = new Error('Could not convert encrypted private key from PEM; PEM header type is "ENCRYPTED PRIVATE KEY".');
        error2.headerType = msg.type;
        throw error2;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert encrypted private key from PEM; PEM is encrypted.");
      }
      return asn1$4.fromDer(msg.body);
    };
    pki$3.encryptRsaPrivateKey = function(rsaKey, password, options2) {
      options2 = options2 || {};
      if (!options2.legacy) {
        var rval = pki$3.wrapRsaPrivateKey(pki$3.privateKeyToAsn1(rsaKey));
        rval = pki$3.encryptPrivateKeyInfo(rval, password, options2);
        return pki$3.encryptedPrivateKeyToPem(rval);
      }
      var algorithm;
      var iv;
      var dkLen;
      var cipherFn;
      switch (options2.algorithm) {
        case "aes128":
          algorithm = "AES-128-CBC";
          dkLen = 16;
          iv = forge$7.random.getBytesSync(16);
          cipherFn = forge$7.aes.createEncryptionCipher;
          break;
        case "aes192":
          algorithm = "AES-192-CBC";
          dkLen = 24;
          iv = forge$7.random.getBytesSync(16);
          cipherFn = forge$7.aes.createEncryptionCipher;
          break;
        case "aes256":
          algorithm = "AES-256-CBC";
          dkLen = 32;
          iv = forge$7.random.getBytesSync(16);
          cipherFn = forge$7.aes.createEncryptionCipher;
          break;
        case "3des":
          algorithm = "DES-EDE3-CBC";
          dkLen = 24;
          iv = forge$7.random.getBytesSync(8);
          cipherFn = forge$7.des.createEncryptionCipher;
          break;
        case "des":
          algorithm = "DES-CBC";
          dkLen = 8;
          iv = forge$7.random.getBytesSync(8);
          cipherFn = forge$7.des.createEncryptionCipher;
          break;
        default:
          var error2 = new Error('Could not encrypt RSA private key; unsupported encryption algorithm "' + options2.algorithm + '".');
          error2.algorithm = options2.algorithm;
          throw error2;
      }
      var dk = forge$7.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
      var cipher = cipherFn(dk);
      cipher.start(iv);
      cipher.update(asn1$4.toDer(pki$3.privateKeyToAsn1(rsaKey)));
      cipher.finish();
      var msg = {
        type: "RSA PRIVATE KEY",
        procType: {
          version: "4",
          type: "ENCRYPTED"
        },
        dekInfo: {
          algorithm,
          parameters: forge$7.util.bytesToHex(iv).toUpperCase()
        },
        body: cipher.output.getBytes()
      };
      return forge$7.pem.encode(msg);
    };
    pki$3.decryptRsaPrivateKey = function(pem2, password) {
      var rval = null;
      var msg = forge$7.pem.decode(pem2)[0];
      if (msg.type !== "ENCRYPTED PRIVATE KEY" && msg.type !== "PRIVATE KEY" && msg.type !== "RSA PRIVATE KEY") {
        var error2 = new Error('Could not convert private key from PEM; PEM header type is not "ENCRYPTED PRIVATE KEY", "PRIVATE KEY", or "RSA PRIVATE KEY".');
        error2.headerType = error2;
        throw error2;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        var dkLen;
        var cipherFn;
        switch (msg.dekInfo.algorithm) {
          case "DES-CBC":
            dkLen = 8;
            cipherFn = forge$7.des.createDecryptionCipher;
            break;
          case "DES-EDE3-CBC":
            dkLen = 24;
            cipherFn = forge$7.des.createDecryptionCipher;
            break;
          case "AES-128-CBC":
            dkLen = 16;
            cipherFn = forge$7.aes.createDecryptionCipher;
            break;
          case "AES-192-CBC":
            dkLen = 24;
            cipherFn = forge$7.aes.createDecryptionCipher;
            break;
          case "AES-256-CBC":
            dkLen = 32;
            cipherFn = forge$7.aes.createDecryptionCipher;
            break;
          case "RC2-40-CBC":
            dkLen = 5;
            cipherFn = function(key2) {
              return forge$7.rc2.createDecryptionCipher(key2, 40);
            };
            break;
          case "RC2-64-CBC":
            dkLen = 8;
            cipherFn = function(key2) {
              return forge$7.rc2.createDecryptionCipher(key2, 64);
            };
            break;
          case "RC2-128-CBC":
            dkLen = 16;
            cipherFn = function(key2) {
              return forge$7.rc2.createDecryptionCipher(key2, 128);
            };
            break;
          default:
            var error2 = new Error('Could not decrypt private key; unsupported encryption algorithm "' + msg.dekInfo.algorithm + '".');
            error2.algorithm = msg.dekInfo.algorithm;
            throw error2;
        }
        var iv = forge$7.util.hexToBytes(msg.dekInfo.parameters);
        var dk = forge$7.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
        var cipher = cipherFn(dk);
        cipher.start(iv);
        cipher.update(forge$7.util.createBuffer(msg.body));
        if (cipher.finish()) {
          rval = cipher.output.getBytes();
        } else {
          return rval;
        }
      } else {
        rval = msg.body;
      }
      if (msg.type === "ENCRYPTED PRIVATE KEY") {
        rval = pki$3.decryptPrivateKeyInfo(asn1$4.fromDer(rval), password);
      } else {
        rval = asn1$4.fromDer(rval);
      }
      if (rval !== null) {
        rval = pki$3.privateKeyFromAsn1(rval);
      }
      return rval;
    };
    pki$3.pbe.generatePkcs12Key = function(password, salt, id, iter, n3, md) {
      var j2, l2;
      if (typeof md === "undefined" || md === null) {
        if (!("sha1" in forge$7.md)) {
          throw new Error('"sha1" hash algorithm unavailable.');
        }
        md = forge$7.md.sha1.create();
      }
      var u2 = md.digestLength;
      var v2 = md.blockLength;
      var result2 = new forge$7.util.ByteBuffer();
      var passBuf = new forge$7.util.ByteBuffer();
      if (password !== null && password !== void 0) {
        for (l2 = 0; l2 < password.length; l2++) {
          passBuf.putInt16(password.charCodeAt(l2));
        }
        passBuf.putInt16(0);
      }
      var p2 = passBuf.length();
      var s3 = salt.length();
      var D2 = new forge$7.util.ByteBuffer();
      D2.fillWithByte(id, v2);
      var Slen = v2 * Math.ceil(s3 / v2);
      var S2 = new forge$7.util.ByteBuffer();
      for (l2 = 0; l2 < Slen; l2++) {
        S2.putByte(salt.at(l2 % s3));
      }
      var Plen = v2 * Math.ceil(p2 / v2);
      var P2 = new forge$7.util.ByteBuffer();
      for (l2 = 0; l2 < Plen; l2++) {
        P2.putByte(passBuf.at(l2 % p2));
      }
      var I2 = S2;
      I2.putBuffer(P2);
      var c3 = Math.ceil(n3 / u2);
      for (var i2 = 1; i2 <= c3; i2++) {
        var buf = new forge$7.util.ByteBuffer();
        buf.putBytes(D2.bytes());
        buf.putBytes(I2.bytes());
        for (var round = 0; round < iter; round++) {
          md.start();
          md.update(buf.getBytes());
          buf = md.digest();
        }
        var B3 = new forge$7.util.ByteBuffer();
        for (l2 = 0; l2 < v2; l2++) {
          B3.putByte(buf.at(l2 % u2));
        }
        var k2 = Math.ceil(s3 / v2) + Math.ceil(p2 / v2);
        var Inew = new forge$7.util.ByteBuffer();
        for (j2 = 0; j2 < k2; j2++) {
          var chunk = new forge$7.util.ByteBuffer(I2.getBytes(v2));
          var x2 = 511;
          for (l2 = B3.length() - 1; l2 >= 0; l2--) {
            x2 = x2 >> 8;
            x2 += B3.at(l2) + chunk.at(l2);
            chunk.setAt(l2, x2 & 255);
          }
          Inew.putBuffer(chunk);
        }
        I2 = Inew;
        result2.putBuffer(buf);
      }
      result2.truncate(result2.length() - n3);
      return result2;
    };
    pki$3.pbe.getCipher = function(oid, params, password) {
      switch (oid) {
        case pki$3.oids["pkcs5PBES2"]:
          return pki$3.pbe.getCipherForPBES2(oid, params, password);
        case pki$3.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
        case pki$3.oids["pbewithSHAAnd40BitRC2-CBC"]:
          return pki$3.pbe.getCipherForPKCS12PBE(oid, params, password);
        default:
          var error2 = new Error("Cannot read encrypted PBE data block. Unsupported OID.");
          error2.oid = oid;
          error2.supportedOids = [
            "pkcs5PBES2",
            "pbeWithSHAAnd3-KeyTripleDES-CBC",
            "pbewithSHAAnd40BitRC2-CBC"
          ];
          throw error2;
      }
    };
    pki$3.pbe.getCipherForPBES2 = function(oid, params, password) {
      var capture = {};
      var errors = [];
      if (!asn1$4.validate(params, PBES2AlgorithmsValidator, capture, errors)) {
        var error2 = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
        error2.errors = errors;
        throw error2;
      }
      oid = asn1$4.derToOid(capture.kdfOid);
      if (oid !== pki$3.oids["pkcs5PBKDF2"]) {
        var error2 = new Error("Cannot read encrypted private key. Unsupported key derivation function OID.");
        error2.oid = oid;
        error2.supportedOids = ["pkcs5PBKDF2"];
        throw error2;
      }
      oid = asn1$4.derToOid(capture.encOid);
      if (oid !== pki$3.oids["aes128-CBC"] && oid !== pki$3.oids["aes192-CBC"] && oid !== pki$3.oids["aes256-CBC"] && oid !== pki$3.oids["des-EDE3-CBC"] && oid !== pki$3.oids["desCBC"]) {
        var error2 = new Error("Cannot read encrypted private key. Unsupported encryption scheme OID.");
        error2.oid = oid;
        error2.supportedOids = [
          "aes128-CBC",
          "aes192-CBC",
          "aes256-CBC",
          "des-EDE3-CBC",
          "desCBC"
        ];
        throw error2;
      }
      var salt = capture.kdfSalt;
      var count = forge$7.util.createBuffer(capture.kdfIterationCount);
      count = count.getInt(count.length() << 3);
      var dkLen;
      var cipherFn;
      switch (pki$3.oids[oid]) {
        case "aes128-CBC":
          dkLen = 16;
          cipherFn = forge$7.aes.createDecryptionCipher;
          break;
        case "aes192-CBC":
          dkLen = 24;
          cipherFn = forge$7.aes.createDecryptionCipher;
          break;
        case "aes256-CBC":
          dkLen = 32;
          cipherFn = forge$7.aes.createDecryptionCipher;
          break;
        case "des-EDE3-CBC":
          dkLen = 24;
          cipherFn = forge$7.des.createDecryptionCipher;
          break;
        case "desCBC":
          dkLen = 8;
          cipherFn = forge$7.des.createDecryptionCipher;
          break;
      }
      var md = prfOidToMessageDigest(capture.prfOid);
      var dk = forge$7.pkcs5.pbkdf2(password, salt, count, dkLen, md);
      var iv = capture.encIv;
      var cipher = cipherFn(dk);
      cipher.start(iv);
      return cipher;
    };
    pki$3.pbe.getCipherForPKCS12PBE = function(oid, params, password) {
      var capture = {};
      var errors = [];
      if (!asn1$4.validate(params, pkcs12PbeParamsValidator, capture, errors)) {
        var error2 = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
        error2.errors = errors;
        throw error2;
      }
      var salt = forge$7.util.createBuffer(capture.salt);
      var count = forge$7.util.createBuffer(capture.iterations);
      count = count.getInt(count.length() << 3);
      var dkLen, dIvLen, cipherFn;
      switch (oid) {
        case pki$3.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
          dkLen = 24;
          dIvLen = 8;
          cipherFn = forge$7.des.startDecrypting;
          break;
        case pki$3.oids["pbewithSHAAnd40BitRC2-CBC"]:
          dkLen = 5;
          dIvLen = 8;
          cipherFn = function(key3, iv2) {
            var cipher = forge$7.rc2.createDecryptionCipher(key3, 40);
            cipher.start(iv2, null);
            return cipher;
          };
          break;
        default:
          var error2 = new Error("Cannot read PKCS #12 PBE data block. Unsupported OID.");
          error2.oid = oid;
          throw error2;
      }
      var md = prfOidToMessageDigest(capture.prfOid);
      var key2 = pki$3.pbe.generatePkcs12Key(password, salt, 1, count, dkLen, md);
      md.start();
      var iv = pki$3.pbe.generatePkcs12Key(password, salt, 2, count, dIvLen, md);
      return cipherFn(key2, iv);
    };
    pki$3.pbe.opensslDeriveBytes = function(password, salt, dkLen, md) {
      if (typeof md === "undefined" || md === null) {
        if (!("md5" in forge$7.md)) {
          throw new Error('"md5" hash algorithm unavailable.');
        }
        md = forge$7.md.md5.create();
      }
      if (salt === null) {
        salt = "";
      }
      var digests = [hash(md, password + salt)];
      for (var length = 16, i2 = 1; length < dkLen; ++i2, length += 16) {
        digests.push(hash(md, digests[i2 - 1] + password + salt));
      }
      return digests.join("").substr(0, dkLen);
    };
    function hash(md, bytes) {
      return md.start().update(bytes).digest().getBytes();
    }
    function prfOidToMessageDigest(prfOid) {
      var prfAlgorithm;
      if (!prfOid) {
        prfAlgorithm = "hmacWithSHA1";
      } else {
        prfAlgorithm = pki$3.oids[asn1$4.derToOid(prfOid)];
        if (!prfAlgorithm) {
          var error2 = new Error("Unsupported PRF OID.");
          error2.oid = prfOid;
          error2.supported = [
            "hmacWithSHA1",
            "hmacWithSHA224",
            "hmacWithSHA256",
            "hmacWithSHA384",
            "hmacWithSHA512"
          ];
          throw error2;
        }
      }
      return prfAlgorithmToMessageDigest(prfAlgorithm);
    }
    function prfAlgorithmToMessageDigest(prfAlgorithm) {
      var factory = forge$7.md;
      switch (prfAlgorithm) {
        case "hmacWithSHA224":
          factory = forge$7.md.sha512;
        case "hmacWithSHA1":
        case "hmacWithSHA256":
        case "hmacWithSHA384":
        case "hmacWithSHA512":
          prfAlgorithm = prfAlgorithm.substr(8).toLowerCase();
          break;
        default:
          var error2 = new Error("Unsupported PRF algorithm.");
          error2.algorithm = prfAlgorithm;
          error2.supported = [
            "hmacWithSHA1",
            "hmacWithSHA224",
            "hmacWithSHA256",
            "hmacWithSHA384",
            "hmacWithSHA512"
          ];
          throw error2;
      }
      if (!factory || !(prfAlgorithm in factory)) {
        throw new Error("Unknown hash algorithm: " + prfAlgorithm);
      }
      return factory[prfAlgorithm].create();
    }
    function createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm) {
      var params = asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, [
        asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.OCTETSTRING, false, salt),
        asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.INTEGER, false, countBytes.getBytes())
      ]);
      if (prfAlgorithm !== "hmacWithSHA1") {
        params.value.push(asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.INTEGER, false, forge$7.util.hexToBytes(dkLen.toString(16))), asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, [
          asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.OID, false, asn1$4.oidToDer(pki$3.oids[prfAlgorithm]).getBytes()),
          asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.NULL, false, "")
        ]));
      }
      return params;
    }
    var forge$6 = forge$s;
    var asn1$3 = forge$6.asn1;
    var p7v = forge$6.pkcs7asn1 = forge$6.pkcs7asn1 || {};
    forge$6.pkcs7 = forge$6.pkcs7 || {};
    forge$6.pkcs7.asn1 = p7v;
    var contentInfoValidator$1 = {
      name: "ContentInfo",
      tagClass: asn1$3.Class.UNIVERSAL,
      type: asn1$3.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "ContentInfo.ContentType",
        tagClass: asn1$3.Class.UNIVERSAL,
        type: asn1$3.Type.OID,
        constructed: false,
        capture: "contentType"
      }, {
        name: "ContentInfo.content",
        tagClass: asn1$3.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: true,
        optional: true,
        captureAsn1: "content"
      }]
    };
    p7v.contentInfoValidator = contentInfoValidator$1;
    var encryptedContentInfoValidator = {
      name: "EncryptedContentInfo",
      tagClass: asn1$3.Class.UNIVERSAL,
      type: asn1$3.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "EncryptedContentInfo.contentType",
        tagClass: asn1$3.Class.UNIVERSAL,
        type: asn1$3.Type.OID,
        constructed: false,
        capture: "contentType"
      }, {
        name: "EncryptedContentInfo.contentEncryptionAlgorithm",
        tagClass: asn1$3.Class.UNIVERSAL,
        type: asn1$3.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "EncryptedContentInfo.contentEncryptionAlgorithm.algorithm",
          tagClass: asn1$3.Class.UNIVERSAL,
          type: asn1$3.Type.OID,
          constructed: false,
          capture: "encAlgorithm"
        }, {
          name: "EncryptedContentInfo.contentEncryptionAlgorithm.parameter",
          tagClass: asn1$3.Class.UNIVERSAL,
          captureAsn1: "encParameter"
        }]
      }, {
        name: "EncryptedContentInfo.encryptedContent",
        tagClass: asn1$3.Class.CONTEXT_SPECIFIC,
        type: 0,
        capture: "encryptedContent",
        captureAsn1: "encryptedContentAsn1"
      }]
    };
    p7v.envelopedDataValidator = {
      name: "EnvelopedData",
      tagClass: asn1$3.Class.UNIVERSAL,
      type: asn1$3.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "EnvelopedData.Version",
        tagClass: asn1$3.Class.UNIVERSAL,
        type: asn1$3.Type.INTEGER,
        constructed: false,
        capture: "version"
      }, {
        name: "EnvelopedData.RecipientInfos",
        tagClass: asn1$3.Class.UNIVERSAL,
        type: asn1$3.Type.SET,
        constructed: true,
        captureAsn1: "recipientInfos"
      }].concat(encryptedContentInfoValidator)
    };
    p7v.encryptedDataValidator = {
      name: "EncryptedData",
      tagClass: asn1$3.Class.UNIVERSAL,
      type: asn1$3.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "EncryptedData.Version",
        tagClass: asn1$3.Class.UNIVERSAL,
        type: asn1$3.Type.INTEGER,
        constructed: false,
        capture: "version"
      }].concat(encryptedContentInfoValidator)
    };
    var signerValidator = {
      name: "SignerInfo",
      tagClass: asn1$3.Class.UNIVERSAL,
      type: asn1$3.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "SignerInfo.version",
        tagClass: asn1$3.Class.UNIVERSAL,
        type: asn1$3.Type.INTEGER,
        constructed: false
      }, {
        name: "SignerInfo.issuerAndSerialNumber",
        tagClass: asn1$3.Class.UNIVERSAL,
        type: asn1$3.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "SignerInfo.issuerAndSerialNumber.issuer",
          tagClass: asn1$3.Class.UNIVERSAL,
          type: asn1$3.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "issuer"
        }, {
          name: "SignerInfo.issuerAndSerialNumber.serialNumber",
          tagClass: asn1$3.Class.UNIVERSAL,
          type: asn1$3.Type.INTEGER,
          constructed: false,
          capture: "serial"
        }]
      }, {
        name: "SignerInfo.digestAlgorithm",
        tagClass: asn1$3.Class.UNIVERSAL,
        type: asn1$3.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "SignerInfo.digestAlgorithm.algorithm",
          tagClass: asn1$3.Class.UNIVERSAL,
          type: asn1$3.Type.OID,
          constructed: false,
          capture: "digestAlgorithm"
        }, {
          name: "SignerInfo.digestAlgorithm.parameter",
          tagClass: asn1$3.Class.UNIVERSAL,
          constructed: false,
          captureAsn1: "digestParameter",
          optional: true
        }]
      }, {
        name: "SignerInfo.authenticatedAttributes",
        tagClass: asn1$3.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: true,
        optional: true,
        capture: "authenticatedAttributes"
      }, {
        name: "SignerInfo.digestEncryptionAlgorithm",
        tagClass: asn1$3.Class.UNIVERSAL,
        type: asn1$3.Type.SEQUENCE,
        constructed: true,
        capture: "signatureAlgorithm"
      }, {
        name: "SignerInfo.encryptedDigest",
        tagClass: asn1$3.Class.UNIVERSAL,
        type: asn1$3.Type.OCTETSTRING,
        constructed: false,
        capture: "signature"
      }, {
        name: "SignerInfo.unauthenticatedAttributes",
        tagClass: asn1$3.Class.CONTEXT_SPECIFIC,
        type: 1,
        constructed: true,
        optional: true,
        capture: "unauthenticatedAttributes"
      }]
    };
    p7v.signedDataValidator = {
      name: "SignedData",
      tagClass: asn1$3.Class.UNIVERSAL,
      type: asn1$3.Type.SEQUENCE,
      constructed: true,
      value: [
        {
          name: "SignedData.Version",
          tagClass: asn1$3.Class.UNIVERSAL,
          type: asn1$3.Type.INTEGER,
          constructed: false,
          capture: "version"
        },
        {
          name: "SignedData.DigestAlgorithms",
          tagClass: asn1$3.Class.UNIVERSAL,
          type: asn1$3.Type.SET,
          constructed: true,
          captureAsn1: "digestAlgorithms"
        },
        contentInfoValidator$1,
        {
          name: "SignedData.Certificates",
          tagClass: asn1$3.Class.CONTEXT_SPECIFIC,
          type: 0,
          optional: true,
          captureAsn1: "certificates"
        },
        {
          name: "SignedData.CertificateRevocationLists",
          tagClass: asn1$3.Class.CONTEXT_SPECIFIC,
          type: 1,
          optional: true,
          captureAsn1: "crls"
        },
        {
          name: "SignedData.SignerInfos",
          tagClass: asn1$3.Class.UNIVERSAL,
          type: asn1$3.Type.SET,
          capture: "signerInfos",
          optional: true,
          value: [signerValidator]
        }
      ]
    };
    p7v.recipientInfoValidator = {
      name: "RecipientInfo",
      tagClass: asn1$3.Class.UNIVERSAL,
      type: asn1$3.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "RecipientInfo.version",
        tagClass: asn1$3.Class.UNIVERSAL,
        type: asn1$3.Type.INTEGER,
        constructed: false,
        capture: "version"
      }, {
        name: "RecipientInfo.issuerAndSerial",
        tagClass: asn1$3.Class.UNIVERSAL,
        type: asn1$3.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "RecipientInfo.issuerAndSerial.issuer",
          tagClass: asn1$3.Class.UNIVERSAL,
          type: asn1$3.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "issuer"
        }, {
          name: "RecipientInfo.issuerAndSerial.serialNumber",
          tagClass: asn1$3.Class.UNIVERSAL,
          type: asn1$3.Type.INTEGER,
          constructed: false,
          capture: "serial"
        }]
      }, {
        name: "RecipientInfo.keyEncryptionAlgorithm",
        tagClass: asn1$3.Class.UNIVERSAL,
        type: asn1$3.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "RecipientInfo.keyEncryptionAlgorithm.algorithm",
          tagClass: asn1$3.Class.UNIVERSAL,
          type: asn1$3.Type.OID,
          constructed: false,
          capture: "encAlgorithm"
        }, {
          name: "RecipientInfo.keyEncryptionAlgorithm.parameter",
          tagClass: asn1$3.Class.UNIVERSAL,
          constructed: false,
          captureAsn1: "encParameter",
          optional: true
        }]
      }, {
        name: "RecipientInfo.encryptedKey",
        tagClass: asn1$3.Class.UNIVERSAL,
        type: asn1$3.Type.OCTETSTRING,
        constructed: false,
        capture: "encKey"
      }]
    };
    var forge$5 = forge$s;
    forge$5.mgf = forge$5.mgf || {};
    var mgf1 = forge$5.mgf.mgf1 = forge$5.mgf1 = forge$5.mgf1 || {};
    mgf1.create = function(md) {
      var mgf = {
        generate: function(seed, maskLen) {
          var t = new forge$5.util.ByteBuffer();
          var len = Math.ceil(maskLen / md.digestLength);
          for (var i2 = 0; i2 < len; i2++) {
            var c3 = new forge$5.util.ByteBuffer();
            c3.putInt32(i2);
            md.start();
            md.update(seed + c3.getBytes());
            t.putBuffer(md.digest());
          }
          t.truncate(t.length() - maskLen);
          return t.getBytes();
        }
      };
      return mgf;
    };
    var forge$4 = forge$s;
    forge$4.mgf = forge$4.mgf || {};
    forge$4.mgf.mgf1 = forge$4.mgf1;
    var forge$3 = forge$s;
    var pss = forge$3.pss = forge$3.pss || {};
    pss.create = function(options2) {
      if (arguments.length === 3) {
        options2 = {
          md: arguments[0],
          mgf: arguments[1],
          saltLength: arguments[2]
        };
      }
      var hash2 = options2.md;
      var mgf = options2.mgf;
      var hLen = hash2.digestLength;
      var salt_ = options2.salt || null;
      if (typeof salt_ === "string") {
        salt_ = forge$3.util.createBuffer(salt_);
      }
      var sLen;
      if ("saltLength" in options2) {
        sLen = options2.saltLength;
      } else if (salt_ !== null) {
        sLen = salt_.length();
      } else {
        throw new Error("Salt length not specified or specific salt not given.");
      }
      if (salt_ !== null && salt_.length() !== sLen) {
        throw new Error("Given salt length does not match length of given salt.");
      }
      var prng2 = options2.prng || forge$3.random;
      var pssobj = {};
      pssobj.encode = function(md, modBits) {
        var i2;
        var emBits = modBits - 1;
        var emLen = Math.ceil(emBits / 8);
        var mHash = md.digest().getBytes();
        if (emLen < hLen + sLen + 2) {
          throw new Error("Message is too long to encrypt.");
        }
        var salt;
        if (salt_ === null) {
          salt = prng2.getBytesSync(sLen);
        } else {
          salt = salt_.bytes();
        }
        var m_ = new forge$3.util.ByteBuffer();
        m_.fillWithByte(0, 8);
        m_.putBytes(mHash);
        m_.putBytes(salt);
        hash2.start();
        hash2.update(m_.getBytes());
        var h3 = hash2.digest().getBytes();
        var ps2 = new forge$3.util.ByteBuffer();
        ps2.fillWithByte(0, emLen - sLen - hLen - 2);
        ps2.putByte(1);
        ps2.putBytes(salt);
        var db = ps2.getBytes();
        var maskLen = emLen - hLen - 1;
        var dbMask = mgf.generate(h3, maskLen);
        var maskedDB = "";
        for (i2 = 0; i2 < maskLen; i2++) {
          maskedDB += String.fromCharCode(db.charCodeAt(i2) ^ dbMask.charCodeAt(i2));
        }
        var mask = 65280 >> 8 * emLen - emBits & 255;
        maskedDB = String.fromCharCode(maskedDB.charCodeAt(0) & ~mask) + maskedDB.substr(1);
        return maskedDB + h3 + String.fromCharCode(188);
      };
      pssobj.verify = function(mHash, em, modBits) {
        var i2;
        var emBits = modBits - 1;
        var emLen = Math.ceil(emBits / 8);
        em = em.substr(-emLen);
        if (emLen < hLen + sLen + 2) {
          throw new Error("Inconsistent parameters to PSS signature verification.");
        }
        if (em.charCodeAt(emLen - 1) !== 188) {
          throw new Error("Encoded message does not end in 0xBC.");
        }
        var maskLen = emLen - hLen - 1;
        var maskedDB = em.substr(0, maskLen);
        var h3 = em.substr(maskLen, hLen);
        var mask = 65280 >> 8 * emLen - emBits & 255;
        if ((maskedDB.charCodeAt(0) & mask) !== 0) {
          throw new Error("Bits beyond keysize not zero as expected.");
        }
        var dbMask = mgf.generate(h3, maskLen);
        var db = "";
        for (i2 = 0; i2 < maskLen; i2++) {
          db += String.fromCharCode(maskedDB.charCodeAt(i2) ^ dbMask.charCodeAt(i2));
        }
        db = String.fromCharCode(db.charCodeAt(0) & ~mask) + db.substr(1);
        var checkLen = emLen - hLen - sLen - 2;
        for (i2 = 0; i2 < checkLen; i2++) {
          if (db.charCodeAt(i2) !== 0) {
            throw new Error("Leftmost octets not zero as expected");
          }
        }
        if (db.charCodeAt(checkLen) !== 1) {
          throw new Error("Inconsistent PSS signature, 0x01 marker not found");
        }
        var salt = db.substr(-sLen);
        var m_ = new forge$3.util.ByteBuffer();
        m_.fillWithByte(0, 8);
        m_.putBytes(mHash);
        m_.putBytes(salt);
        hash2.start();
        hash2.update(m_.getBytes());
        var h_ = hash2.digest().getBytes();
        return h3 === h_;
      };
      return pssobj;
    };
    var forge$2 = forge$s;
    var asn1$2 = forge$2.asn1;
    var pki$2 = forge$2.pki = forge$2.pki || {};
    var oids = pki$2.oids;
    var _shortNames = {};
    _shortNames["CN"] = oids["commonName"];
    _shortNames["commonName"] = "CN";
    _shortNames["C"] = oids["countryName"];
    _shortNames["countryName"] = "C";
    _shortNames["L"] = oids["localityName"];
    _shortNames["localityName"] = "L";
    _shortNames["ST"] = oids["stateOrProvinceName"];
    _shortNames["stateOrProvinceName"] = "ST";
    _shortNames["O"] = oids["organizationName"];
    _shortNames["organizationName"] = "O";
    _shortNames["OU"] = oids["organizationalUnitName"];
    _shortNames["organizationalUnitName"] = "OU";
    _shortNames["E"] = oids["emailAddress"];
    _shortNames["emailAddress"] = "E";
    var publicKeyValidator = forge$2.pki.rsa.publicKeyValidator;
    var x509CertificateValidator = {
      name: "Certificate",
      tagClass: asn1$2.Class.UNIVERSAL,
      type: asn1$2.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "Certificate.TBSCertificate",
        tagClass: asn1$2.Class.UNIVERSAL,
        type: asn1$2.Type.SEQUENCE,
        constructed: true,
        captureAsn1: "tbsCertificate",
        value: [
          {
            name: "Certificate.TBSCertificate.version",
            tagClass: asn1$2.Class.CONTEXT_SPECIFIC,
            type: 0,
            constructed: true,
            optional: true,
            value: [{
              name: "Certificate.TBSCertificate.version.integer",
              tagClass: asn1$2.Class.UNIVERSAL,
              type: asn1$2.Type.INTEGER,
              constructed: false,
              capture: "certVersion"
            }]
          },
          {
            name: "Certificate.TBSCertificate.serialNumber",
            tagClass: asn1$2.Class.UNIVERSAL,
            type: asn1$2.Type.INTEGER,
            constructed: false,
            capture: "certSerialNumber"
          },
          {
            name: "Certificate.TBSCertificate.signature",
            tagClass: asn1$2.Class.UNIVERSAL,
            type: asn1$2.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "Certificate.TBSCertificate.signature.algorithm",
              tagClass: asn1$2.Class.UNIVERSAL,
              type: asn1$2.Type.OID,
              constructed: false,
              capture: "certinfoSignatureOid"
            }, {
              name: "Certificate.TBSCertificate.signature.parameters",
              tagClass: asn1$2.Class.UNIVERSAL,
              optional: true,
              captureAsn1: "certinfoSignatureParams"
            }]
          },
          {
            name: "Certificate.TBSCertificate.issuer",
            tagClass: asn1$2.Class.UNIVERSAL,
            type: asn1$2.Type.SEQUENCE,
            constructed: true,
            captureAsn1: "certIssuer"
          },
          {
            name: "Certificate.TBSCertificate.validity",
            tagClass: asn1$2.Class.UNIVERSAL,
            type: asn1$2.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "Certificate.TBSCertificate.validity.notBefore (utc)",
              tagClass: asn1$2.Class.UNIVERSAL,
              type: asn1$2.Type.UTCTIME,
              constructed: false,
              optional: true,
              capture: "certValidity1UTCTime"
            }, {
              name: "Certificate.TBSCertificate.validity.notBefore (generalized)",
              tagClass: asn1$2.Class.UNIVERSAL,
              type: asn1$2.Type.GENERALIZEDTIME,
              constructed: false,
              optional: true,
              capture: "certValidity2GeneralizedTime"
            }, {
              name: "Certificate.TBSCertificate.validity.notAfter (utc)",
              tagClass: asn1$2.Class.UNIVERSAL,
              type: asn1$2.Type.UTCTIME,
              constructed: false,
              optional: true,
              capture: "certValidity3UTCTime"
            }, {
              name: "Certificate.TBSCertificate.validity.notAfter (generalized)",
              tagClass: asn1$2.Class.UNIVERSAL,
              type: asn1$2.Type.GENERALIZEDTIME,
              constructed: false,
              optional: true,
              capture: "certValidity4GeneralizedTime"
            }]
          },
          {
            name: "Certificate.TBSCertificate.subject",
            tagClass: asn1$2.Class.UNIVERSAL,
            type: asn1$2.Type.SEQUENCE,
            constructed: true,
            captureAsn1: "certSubject"
          },
          publicKeyValidator,
          {
            name: "Certificate.TBSCertificate.issuerUniqueID",
            tagClass: asn1$2.Class.CONTEXT_SPECIFIC,
            type: 1,
            constructed: true,
            optional: true,
            value: [{
              name: "Certificate.TBSCertificate.issuerUniqueID.id",
              tagClass: asn1$2.Class.UNIVERSAL,
              type: asn1$2.Type.BITSTRING,
              constructed: false,
              captureBitStringValue: "certIssuerUniqueId"
            }]
          },
          {
            name: "Certificate.TBSCertificate.subjectUniqueID",
            tagClass: asn1$2.Class.CONTEXT_SPECIFIC,
            type: 2,
            constructed: true,
            optional: true,
            value: [{
              name: "Certificate.TBSCertificate.subjectUniqueID.id",
              tagClass: asn1$2.Class.UNIVERSAL,
              type: asn1$2.Type.BITSTRING,
              constructed: false,
              captureBitStringValue: "certSubjectUniqueId"
            }]
          },
          {
            name: "Certificate.TBSCertificate.extensions",
            tagClass: asn1$2.Class.CONTEXT_SPECIFIC,
            type: 3,
            constructed: true,
            captureAsn1: "certExtensions",
            optional: true
          }
        ]
      }, {
        name: "Certificate.signatureAlgorithm",
        tagClass: asn1$2.Class.UNIVERSAL,
        type: asn1$2.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "Certificate.signatureAlgorithm.algorithm",
          tagClass: asn1$2.Class.UNIVERSAL,
          type: asn1$2.Type.OID,
          constructed: false,
          capture: "certSignatureOid"
        }, {
          name: "Certificate.TBSCertificate.signature.parameters",
          tagClass: asn1$2.Class.UNIVERSAL,
          optional: true,
          captureAsn1: "certSignatureParams"
        }]
      }, {
        name: "Certificate.signatureValue",
        tagClass: asn1$2.Class.UNIVERSAL,
        type: asn1$2.Type.BITSTRING,
        constructed: false,
        captureBitStringValue: "certSignature"
      }]
    };
    var rsassaPssParameterValidator = {
      name: "rsapss",
      tagClass: asn1$2.Class.UNIVERSAL,
      type: asn1$2.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "rsapss.hashAlgorithm",
        tagClass: asn1$2.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: true,
        value: [{
          name: "rsapss.hashAlgorithm.AlgorithmIdentifier",
          tagClass: asn1$2.Class.UNIVERSAL,
          type: asn1$2.Class.SEQUENCE,
          constructed: true,
          optional: true,
          value: [{
            name: "rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm",
            tagClass: asn1$2.Class.UNIVERSAL,
            type: asn1$2.Type.OID,
            constructed: false,
            capture: "hashOid"
          }]
        }]
      }, {
        name: "rsapss.maskGenAlgorithm",
        tagClass: asn1$2.Class.CONTEXT_SPECIFIC,
        type: 1,
        constructed: true,
        value: [{
          name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier",
          tagClass: asn1$2.Class.UNIVERSAL,
          type: asn1$2.Class.SEQUENCE,
          constructed: true,
          optional: true,
          value: [{
            name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm",
            tagClass: asn1$2.Class.UNIVERSAL,
            type: asn1$2.Type.OID,
            constructed: false,
            capture: "maskGenOid"
          }, {
            name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params",
            tagClass: asn1$2.Class.UNIVERSAL,
            type: asn1$2.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm",
              tagClass: asn1$2.Class.UNIVERSAL,
              type: asn1$2.Type.OID,
              constructed: false,
              capture: "maskGenHashOid"
            }]
          }]
        }]
      }, {
        name: "rsapss.saltLength",
        tagClass: asn1$2.Class.CONTEXT_SPECIFIC,
        type: 2,
        optional: true,
        value: [{
          name: "rsapss.saltLength.saltLength",
          tagClass: asn1$2.Class.UNIVERSAL,
          type: asn1$2.Class.INTEGER,
          constructed: false,
          capture: "saltLength"
        }]
      }, {
        name: "rsapss.trailerField",
        tagClass: asn1$2.Class.CONTEXT_SPECIFIC,
        type: 3,
        optional: true,
        value: [{
          name: "rsapss.trailer.trailer",
          tagClass: asn1$2.Class.UNIVERSAL,
          type: asn1$2.Class.INTEGER,
          constructed: false,
          capture: "trailer"
        }]
      }]
    };
    var certificationRequestInfoValidator = {
      name: "CertificationRequestInfo",
      tagClass: asn1$2.Class.UNIVERSAL,
      type: asn1$2.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "certificationRequestInfo",
      value: [
        {
          name: "CertificationRequestInfo.integer",
          tagClass: asn1$2.Class.UNIVERSAL,
          type: asn1$2.Type.INTEGER,
          constructed: false,
          capture: "certificationRequestInfoVersion"
        },
        {
          name: "CertificationRequestInfo.subject",
          tagClass: asn1$2.Class.UNIVERSAL,
          type: asn1$2.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "certificationRequestInfoSubject"
        },
        publicKeyValidator,
        {
          name: "CertificationRequestInfo.attributes",
          tagClass: asn1$2.Class.CONTEXT_SPECIFIC,
          type: 0,
          constructed: true,
          optional: true,
          capture: "certificationRequestInfoAttributes",
          value: [{
            name: "CertificationRequestInfo.attributes",
            tagClass: asn1$2.Class.UNIVERSAL,
            type: asn1$2.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "CertificationRequestInfo.attributes.type",
              tagClass: asn1$2.Class.UNIVERSAL,
              type: asn1$2.Type.OID,
              constructed: false
            }, {
              name: "CertificationRequestInfo.attributes.value",
              tagClass: asn1$2.Class.UNIVERSAL,
              type: asn1$2.Type.SET,
              constructed: true
            }]
          }]
        }
      ]
    };
    var certificationRequestValidator = {
      name: "CertificationRequest",
      tagClass: asn1$2.Class.UNIVERSAL,
      type: asn1$2.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "csr",
      value: [
        certificationRequestInfoValidator,
        {
          name: "CertificationRequest.signatureAlgorithm",
          tagClass: asn1$2.Class.UNIVERSAL,
          type: asn1$2.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "CertificationRequest.signatureAlgorithm.algorithm",
            tagClass: asn1$2.Class.UNIVERSAL,
            type: asn1$2.Type.OID,
            constructed: false,
            capture: "csrSignatureOid"
          }, {
            name: "CertificationRequest.signatureAlgorithm.parameters",
            tagClass: asn1$2.Class.UNIVERSAL,
            optional: true,
            captureAsn1: "csrSignatureParams"
          }]
        },
        {
          name: "CertificationRequest.signature",
          tagClass: asn1$2.Class.UNIVERSAL,
          type: asn1$2.Type.BITSTRING,
          constructed: false,
          captureBitStringValue: "csrSignature"
        }
      ]
    };
    pki$2.RDNAttributesAsArray = function(rdn, md) {
      var rval = [];
      var set2, attr, obj;
      for (var si2 = 0; si2 < rdn.value.length; ++si2) {
        set2 = rdn.value[si2];
        for (var i2 = 0; i2 < set2.value.length; ++i2) {
          obj = {};
          attr = set2.value[i2];
          obj.type = asn1$2.derToOid(attr.value[0].value);
          obj.value = attr.value[1].value;
          obj.valueTagClass = attr.value[1].type;
          if (obj.type in oids) {
            obj.name = oids[obj.type];
            if (obj.name in _shortNames) {
              obj.shortName = _shortNames[obj.name];
            }
          }
          if (md) {
            md.update(obj.type);
            md.update(obj.value);
          }
          rval.push(obj);
        }
      }
      return rval;
    };
    pki$2.CRIAttributesAsArray = function(attributes) {
      var rval = [];
      for (var si2 = 0; si2 < attributes.length; ++si2) {
        var seq2 = attributes[si2];
        var type = asn1$2.derToOid(seq2.value[0].value);
        var values = seq2.value[1].value;
        for (var vi2 = 0; vi2 < values.length; ++vi2) {
          var obj = {};
          obj.type = type;
          obj.value = values[vi2].value;
          obj.valueTagClass = values[vi2].type;
          if (obj.type in oids) {
            obj.name = oids[obj.type];
            if (obj.name in _shortNames) {
              obj.shortName = _shortNames[obj.name];
            }
          }
          if (obj.type === oids.extensionRequest) {
            obj.extensions = [];
            for (var ei2 = 0; ei2 < obj.value.length; ++ei2) {
              obj.extensions.push(pki$2.certificateExtensionFromAsn1(obj.value[ei2]));
            }
          }
          rval.push(obj);
        }
      }
      return rval;
    };
    function _getAttribute(obj, options2) {
      if (typeof options2 === "string") {
        options2 = { shortName: options2 };
      }
      var rval = null;
      var attr;
      for (var i2 = 0; rval === null && i2 < obj.attributes.length; ++i2) {
        attr = obj.attributes[i2];
        if (options2.type && options2.type === attr.type) {
          rval = attr;
        } else if (options2.name && options2.name === attr.name) {
          rval = attr;
        } else if (options2.shortName && options2.shortName === attr.shortName) {
          rval = attr;
        }
      }
      return rval;
    }
    var _readSignatureParameters = function(oid, obj, fillDefaults) {
      var params = {};
      if (oid !== oids["RSASSA-PSS"]) {
        return params;
      }
      if (fillDefaults) {
        params = {
          hash: {
            algorithmOid: oids["sha1"]
          },
          mgf: {
            algorithmOid: oids["mgf1"],
            hash: {
              algorithmOid: oids["sha1"]
            }
          },
          saltLength: 20
        };
      }
      var capture = {};
      var errors = [];
      if (!asn1$2.validate(obj, rsassaPssParameterValidator, capture, errors)) {
        var error2 = new Error("Cannot read RSASSA-PSS parameter block.");
        error2.errors = errors;
        throw error2;
      }
      if (capture.hashOid !== void 0) {
        params.hash = params.hash || {};
        params.hash.algorithmOid = asn1$2.derToOid(capture.hashOid);
      }
      if (capture.maskGenOid !== void 0) {
        params.mgf = params.mgf || {};
        params.mgf.algorithmOid = asn1$2.derToOid(capture.maskGenOid);
        params.mgf.hash = params.mgf.hash || {};
        params.mgf.hash.algorithmOid = asn1$2.derToOid(capture.maskGenHashOid);
      }
      if (capture.saltLength !== void 0) {
        params.saltLength = capture.saltLength.charCodeAt(0);
      }
      return params;
    };
    var _createSignatureDigest = function(options2) {
      switch (oids[options2.signatureOid]) {
        case "sha1WithRSAEncryption":
        case "sha1WithRSASignature":
          return forge$2.md.sha1.create();
        case "md5WithRSAEncryption":
          return forge$2.md.md5.create();
        case "sha256WithRSAEncryption":
          return forge$2.md.sha256.create();
        case "sha384WithRSAEncryption":
          return forge$2.md.sha384.create();
        case "sha512WithRSAEncryption":
          return forge$2.md.sha512.create();
        case "RSASSA-PSS":
          return forge$2.md.sha256.create();
        default:
          var error2 = new Error("Could not compute " + options2.type + " digest. Unknown signature OID.");
          error2.signatureOid = options2.signatureOid;
          throw error2;
      }
    };
    var _verifySignature = function(options2) {
      var cert = options2.certificate;
      var scheme;
      switch (cert.signatureOid) {
        case oids.sha1WithRSAEncryption:
        case oids.sha1WithRSASignature:
          break;
        case oids["RSASSA-PSS"]:
          var hash2, mgf;
          hash2 = oids[cert.signatureParameters.mgf.hash.algorithmOid];
          if (hash2 === void 0 || forge$2.md[hash2] === void 0) {
            var error2 = new Error("Unsupported MGF hash function.");
            error2.oid = cert.signatureParameters.mgf.hash.algorithmOid;
            error2.name = hash2;
            throw error2;
          }
          mgf = oids[cert.signatureParameters.mgf.algorithmOid];
          if (mgf === void 0 || forge$2.mgf[mgf] === void 0) {
            var error2 = new Error("Unsupported MGF function.");
            error2.oid = cert.signatureParameters.mgf.algorithmOid;
            error2.name = mgf;
            throw error2;
          }
          mgf = forge$2.mgf[mgf].create(forge$2.md[hash2].create());
          hash2 = oids[cert.signatureParameters.hash.algorithmOid];
          if (hash2 === void 0 || forge$2.md[hash2] === void 0) {
            var error2 = new Error("Unsupported RSASSA-PSS hash function.");
            error2.oid = cert.signatureParameters.hash.algorithmOid;
            error2.name = hash2;
            throw error2;
          }
          scheme = forge$2.pss.create(forge$2.md[hash2].create(), mgf, cert.signatureParameters.saltLength);
          break;
      }
      return cert.publicKey.verify(options2.md.digest().getBytes(), options2.signature, scheme);
    };
    pki$2.certificateFromPem = function(pem2, computeHash, strict) {
      var msg = forge$2.pem.decode(pem2)[0];
      if (msg.type !== "CERTIFICATE" && msg.type !== "X509 CERTIFICATE" && msg.type !== "TRUSTED CERTIFICATE") {
        var error2 = new Error('Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".');
        error2.headerType = msg.type;
        throw error2;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert certificate from PEM; PEM is encrypted.");
      }
      var obj = asn1$2.fromDer(msg.body, strict);
      return pki$2.certificateFromAsn1(obj, computeHash);
    };
    pki$2.certificateToPem = function(cert, maxline) {
      var msg = {
        type: "CERTIFICATE",
        body: asn1$2.toDer(pki$2.certificateToAsn1(cert)).getBytes()
      };
      return forge$2.pem.encode(msg, { maxline });
    };
    pki$2.publicKeyFromPem = function(pem2) {
      var msg = forge$2.pem.decode(pem2)[0];
      if (msg.type !== "PUBLIC KEY" && msg.type !== "RSA PUBLIC KEY") {
        var error2 = new Error('Could not convert public key from PEM; PEM header type is not "PUBLIC KEY" or "RSA PUBLIC KEY".');
        error2.headerType = msg.type;
        throw error2;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert public key from PEM; PEM is encrypted.");
      }
      var obj = asn1$2.fromDer(msg.body);
      return pki$2.publicKeyFromAsn1(obj);
    };
    pki$2.publicKeyToPem = function(key2, maxline) {
      var msg = {
        type: "PUBLIC KEY",
        body: asn1$2.toDer(pki$2.publicKeyToAsn1(key2)).getBytes()
      };
      return forge$2.pem.encode(msg, { maxline });
    };
    pki$2.publicKeyToRSAPublicKeyPem = function(key2, maxline) {
      var msg = {
        type: "RSA PUBLIC KEY",
        body: asn1$2.toDer(pki$2.publicKeyToRSAPublicKey(key2)).getBytes()
      };
      return forge$2.pem.encode(msg, { maxline });
    };
    pki$2.getPublicKeyFingerprint = function(key2, options2) {
      options2 = options2 || {};
      var md = options2.md || forge$2.md.sha1.create();
      var type = options2.type || "RSAPublicKey";
      var bytes;
      switch (type) {
        case "RSAPublicKey":
          bytes = asn1$2.toDer(pki$2.publicKeyToRSAPublicKey(key2)).getBytes();
          break;
        case "SubjectPublicKeyInfo":
          bytes = asn1$2.toDer(pki$2.publicKeyToAsn1(key2)).getBytes();
          break;
        default:
          throw new Error('Unknown fingerprint type "' + options2.type + '".');
      }
      md.start();
      md.update(bytes);
      var digest = md.digest();
      if (options2.encoding === "hex") {
        var hex = digest.toHex();
        if (options2.delimiter) {
          return hex.match(/.{2}/g).join(options2.delimiter);
        }
        return hex;
      } else if (options2.encoding === "binary") {
        return digest.getBytes();
      } else if (options2.encoding) {
        throw new Error('Unknown encoding "' + options2.encoding + '".');
      }
      return digest;
    };
    pki$2.certificationRequestFromPem = function(pem2, computeHash, strict) {
      var msg = forge$2.pem.decode(pem2)[0];
      if (msg.type !== "CERTIFICATE REQUEST") {
        var error2 = new Error('Could not convert certification request from PEM; PEM header type is not "CERTIFICATE REQUEST".');
        error2.headerType = msg.type;
        throw error2;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert certification request from PEM; PEM is encrypted.");
      }
      var obj = asn1$2.fromDer(msg.body, strict);
      return pki$2.certificationRequestFromAsn1(obj, computeHash);
    };
    pki$2.certificationRequestToPem = function(csr, maxline) {
      var msg = {
        type: "CERTIFICATE REQUEST",
        body: asn1$2.toDer(pki$2.certificationRequestToAsn1(csr)).getBytes()
      };
      return forge$2.pem.encode(msg, { maxline });
    };
    pki$2.createCertificate = function() {
      var cert = {};
      cert.version = 2;
      cert.serialNumber = "00";
      cert.signatureOid = null;
      cert.signature = null;
      cert.siginfo = {};
      cert.siginfo.algorithmOid = null;
      cert.validity = {};
      cert.validity.notBefore = new Date();
      cert.validity.notAfter = new Date();
      cert.issuer = {};
      cert.issuer.getField = function(sn2) {
        return _getAttribute(cert.issuer, sn2);
      };
      cert.issuer.addField = function(attr) {
        _fillMissingFields([attr]);
        cert.issuer.attributes.push(attr);
      };
      cert.issuer.attributes = [];
      cert.issuer.hash = null;
      cert.subject = {};
      cert.subject.getField = function(sn2) {
        return _getAttribute(cert.subject, sn2);
      };
      cert.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        cert.subject.attributes.push(attr);
      };
      cert.subject.attributes = [];
      cert.subject.hash = null;
      cert.extensions = [];
      cert.publicKey = null;
      cert.md = null;
      cert.setSubject = function(attrs, uniqueId) {
        _fillMissingFields(attrs);
        cert.subject.attributes = attrs;
        delete cert.subject.uniqueId;
        if (uniqueId) {
          cert.subject.uniqueId = uniqueId;
        }
        cert.subject.hash = null;
      };
      cert.setIssuer = function(attrs, uniqueId) {
        _fillMissingFields(attrs);
        cert.issuer.attributes = attrs;
        delete cert.issuer.uniqueId;
        if (uniqueId) {
          cert.issuer.uniqueId = uniqueId;
        }
        cert.issuer.hash = null;
      };
      cert.setExtensions = function(exts) {
        for (var i2 = 0; i2 < exts.length; ++i2) {
          _fillMissingExtensionFields(exts[i2], { cert });
        }
        cert.extensions = exts;
      };
      cert.getExtension = function(options2) {
        if (typeof options2 === "string") {
          options2 = { name: options2 };
        }
        var rval = null;
        var ext2;
        for (var i2 = 0; rval === null && i2 < cert.extensions.length; ++i2) {
          ext2 = cert.extensions[i2];
          if (options2.id && ext2.id === options2.id) {
            rval = ext2;
          } else if (options2.name && ext2.name === options2.name) {
            rval = ext2;
          }
        }
        return rval;
      };
      cert.sign = function(key2, md) {
        cert.md = md || forge$2.md.sha1.create();
        var algorithmOid = oids[cert.md.algorithm + "WithRSAEncryption"];
        if (!algorithmOid) {
          var error2 = new Error("Could not compute certificate digest. Unknown message digest algorithm OID.");
          error2.algorithm = cert.md.algorithm;
          throw error2;
        }
        cert.signatureOid = cert.siginfo.algorithmOid = algorithmOid;
        cert.tbsCertificate = pki$2.getTBSCertificate(cert);
        var bytes = asn1$2.toDer(cert.tbsCertificate);
        cert.md.update(bytes.getBytes());
        cert.signature = key2.sign(cert.md);
      };
      cert.verify = function(child) {
        var rval = false;
        if (!cert.issued(child)) {
          var issuer = child.issuer;
          var subject = cert.subject;
          var error2 = new Error("The parent certificate did not issue the given child certificate; the child certificate's issuer does not match the parent's subject.");
          error2.expectedIssuer = subject.attributes;
          error2.actualIssuer = issuer.attributes;
          throw error2;
        }
        var md = child.md;
        if (md === null) {
          md = _createSignatureDigest({
            signatureOid: child.signatureOid,
            type: "certificate"
          });
          var tbsCertificate = child.tbsCertificate || pki$2.getTBSCertificate(child);
          var bytes = asn1$2.toDer(tbsCertificate);
          md.update(bytes.getBytes());
        }
        if (md !== null) {
          rval = _verifySignature({
            certificate: cert,
            md,
            signature: child.signature
          });
        }
        return rval;
      };
      cert.isIssuer = function(parent) {
        var rval = false;
        var i2 = cert.issuer;
        var s3 = parent.subject;
        if (i2.hash && s3.hash) {
          rval = i2.hash === s3.hash;
        } else if (i2.attributes.length === s3.attributes.length) {
          rval = true;
          var iattr, sattr;
          for (var n3 = 0; rval && n3 < i2.attributes.length; ++n3) {
            iattr = i2.attributes[n3];
            sattr = s3.attributes[n3];
            if (iattr.type !== sattr.type || iattr.value !== sattr.value) {
              rval = false;
            }
          }
        }
        return rval;
      };
      cert.issued = function(child) {
        return child.isIssuer(cert);
      };
      cert.generateSubjectKeyIdentifier = function() {
        return pki$2.getPublicKeyFingerprint(cert.publicKey, { type: "RSAPublicKey" });
      };
      cert.verifySubjectKeyIdentifier = function() {
        var oid = oids["subjectKeyIdentifier"];
        for (var i2 = 0; i2 < cert.extensions.length; ++i2) {
          var ext2 = cert.extensions[i2];
          if (ext2.id === oid) {
            var ski = cert.generateSubjectKeyIdentifier().getBytes();
            return forge$2.util.hexToBytes(ext2.subjectKeyIdentifier) === ski;
          }
        }
        return false;
      };
      return cert;
    };
    pki$2.certificateFromAsn1 = function(obj, computeHash) {
      var capture = {};
      var errors = [];
      if (!asn1$2.validate(obj, x509CertificateValidator, capture, errors)) {
        var error2 = new Error("Cannot read X.509 certificate. ASN.1 object is not an X509v3 Certificate.");
        error2.errors = errors;
        throw error2;
      }
      var oid = asn1$2.derToOid(capture.publicKeyOid);
      if (oid !== pki$2.oids.rsaEncryption) {
        throw new Error("Cannot read public key. OID is not RSA.");
      }
      var cert = pki$2.createCertificate();
      cert.version = capture.certVersion ? capture.certVersion.charCodeAt(0) : 0;
      var serial = forge$2.util.createBuffer(capture.certSerialNumber);
      cert.serialNumber = serial.toHex();
      cert.signatureOid = forge$2.asn1.derToOid(capture.certSignatureOid);
      cert.signatureParameters = _readSignatureParameters(cert.signatureOid, capture.certSignatureParams, true);
      cert.siginfo.algorithmOid = forge$2.asn1.derToOid(capture.certinfoSignatureOid);
      cert.siginfo.parameters = _readSignatureParameters(cert.siginfo.algorithmOid, capture.certinfoSignatureParams, false);
      cert.signature = capture.certSignature;
      var validity = [];
      if (capture.certValidity1UTCTime !== void 0) {
        validity.push(asn1$2.utcTimeToDate(capture.certValidity1UTCTime));
      }
      if (capture.certValidity2GeneralizedTime !== void 0) {
        validity.push(asn1$2.generalizedTimeToDate(capture.certValidity2GeneralizedTime));
      }
      if (capture.certValidity3UTCTime !== void 0) {
        validity.push(asn1$2.utcTimeToDate(capture.certValidity3UTCTime));
      }
      if (capture.certValidity4GeneralizedTime !== void 0) {
        validity.push(asn1$2.generalizedTimeToDate(capture.certValidity4GeneralizedTime));
      }
      if (validity.length > 2) {
        throw new Error("Cannot read notBefore/notAfter validity times; more than two times were provided in the certificate.");
      }
      if (validity.length < 2) {
        throw new Error("Cannot read notBefore/notAfter validity times; they were not provided as either UTCTime or GeneralizedTime.");
      }
      cert.validity.notBefore = validity[0];
      cert.validity.notAfter = validity[1];
      cert.tbsCertificate = capture.tbsCertificate;
      if (computeHash) {
        cert.md = _createSignatureDigest({
          signatureOid: cert.signatureOid,
          type: "certificate"
        });
        var bytes = asn1$2.toDer(cert.tbsCertificate);
        cert.md.update(bytes.getBytes());
      }
      var imd = forge$2.md.sha1.create();
      var ibytes = asn1$2.toDer(capture.certIssuer);
      imd.update(ibytes.getBytes());
      cert.issuer.getField = function(sn2) {
        return _getAttribute(cert.issuer, sn2);
      };
      cert.issuer.addField = function(attr) {
        _fillMissingFields([attr]);
        cert.issuer.attributes.push(attr);
      };
      cert.issuer.attributes = pki$2.RDNAttributesAsArray(capture.certIssuer);
      if (capture.certIssuerUniqueId) {
        cert.issuer.uniqueId = capture.certIssuerUniqueId;
      }
      cert.issuer.hash = imd.digest().toHex();
      var smd = forge$2.md.sha1.create();
      var sbytes = asn1$2.toDer(capture.certSubject);
      smd.update(sbytes.getBytes());
      cert.subject.getField = function(sn2) {
        return _getAttribute(cert.subject, sn2);
      };
      cert.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        cert.subject.attributes.push(attr);
      };
      cert.subject.attributes = pki$2.RDNAttributesAsArray(capture.certSubject);
      if (capture.certSubjectUniqueId) {
        cert.subject.uniqueId = capture.certSubjectUniqueId;
      }
      cert.subject.hash = smd.digest().toHex();
      if (capture.certExtensions) {
        cert.extensions = pki$2.certificateExtensionsFromAsn1(capture.certExtensions);
      } else {
        cert.extensions = [];
      }
      cert.publicKey = pki$2.publicKeyFromAsn1(capture.subjectPublicKeyInfo);
      return cert;
    };
    pki$2.certificateExtensionsFromAsn1 = function(exts) {
      var rval = [];
      for (var i2 = 0; i2 < exts.value.length; ++i2) {
        var extseq = exts.value[i2];
        for (var ei2 = 0; ei2 < extseq.value.length; ++ei2) {
          rval.push(pki$2.certificateExtensionFromAsn1(extseq.value[ei2]));
        }
      }
      return rval;
    };
    pki$2.certificateExtensionFromAsn1 = function(ext2) {
      var e2 = {};
      e2.id = asn1$2.derToOid(ext2.value[0].value);
      e2.critical = false;
      if (ext2.value[1].type === asn1$2.Type.BOOLEAN) {
        e2.critical = ext2.value[1].value.charCodeAt(0) !== 0;
        e2.value = ext2.value[2].value;
      } else {
        e2.value = ext2.value[1].value;
      }
      if (e2.id in oids) {
        e2.name = oids[e2.id];
        if (e2.name === "keyUsage") {
          var ev = asn1$2.fromDer(e2.value);
          var b2 = 0;
          var b3 = 0;
          if (ev.value.length > 1) {
            b2 = ev.value.charCodeAt(1);
            b3 = ev.value.length > 2 ? ev.value.charCodeAt(2) : 0;
          }
          e2.digitalSignature = (b2 & 128) === 128;
          e2.nonRepudiation = (b2 & 64) === 64;
          e2.keyEncipherment = (b2 & 32) === 32;
          e2.dataEncipherment = (b2 & 16) === 16;
          e2.keyAgreement = (b2 & 8) === 8;
          e2.keyCertSign = (b2 & 4) === 4;
          e2.cRLSign = (b2 & 2) === 2;
          e2.encipherOnly = (b2 & 1) === 1;
          e2.decipherOnly = (b3 & 128) === 128;
        } else if (e2.name === "basicConstraints") {
          var ev = asn1$2.fromDer(e2.value);
          if (ev.value.length > 0 && ev.value[0].type === asn1$2.Type.BOOLEAN) {
            e2.cA = ev.value[0].value.charCodeAt(0) !== 0;
          } else {
            e2.cA = false;
          }
          var value = null;
          if (ev.value.length > 0 && ev.value[0].type === asn1$2.Type.INTEGER) {
            value = ev.value[0].value;
          } else if (ev.value.length > 1) {
            value = ev.value[1].value;
          }
          if (value !== null) {
            e2.pathLenConstraint = asn1$2.derToInteger(value);
          }
        } else if (e2.name === "extKeyUsage") {
          var ev = asn1$2.fromDer(e2.value);
          for (var vi2 = 0; vi2 < ev.value.length; ++vi2) {
            var oid = asn1$2.derToOid(ev.value[vi2].value);
            if (oid in oids) {
              e2[oids[oid]] = true;
            } else {
              e2[oid] = true;
            }
          }
        } else if (e2.name === "nsCertType") {
          var ev = asn1$2.fromDer(e2.value);
          var b2 = 0;
          if (ev.value.length > 1) {
            b2 = ev.value.charCodeAt(1);
          }
          e2.client = (b2 & 128) === 128;
          e2.server = (b2 & 64) === 64;
          e2.email = (b2 & 32) === 32;
          e2.objsign = (b2 & 16) === 16;
          e2.reserved = (b2 & 8) === 8;
          e2.sslCA = (b2 & 4) === 4;
          e2.emailCA = (b2 & 2) === 2;
          e2.objCA = (b2 & 1) === 1;
        } else if (e2.name === "subjectAltName" || e2.name === "issuerAltName") {
          e2.altNames = [];
          var gn2;
          var ev = asn1$2.fromDer(e2.value);
          for (var n3 = 0; n3 < ev.value.length; ++n3) {
            gn2 = ev.value[n3];
            var altName = {
              type: gn2.type,
              value: gn2.value
            };
            e2.altNames.push(altName);
            switch (gn2.type) {
              case 1:
              case 2:
              case 6:
                break;
              case 7:
                altName.ip = forge$2.util.bytesToIP(gn2.value);
                break;
              case 8:
                altName.oid = asn1$2.derToOid(gn2.value);
                break;
            }
          }
        } else if (e2.name === "subjectKeyIdentifier") {
          var ev = asn1$2.fromDer(e2.value);
          e2.subjectKeyIdentifier = forge$2.util.bytesToHex(ev.value);
        }
      }
      return e2;
    };
    pki$2.certificationRequestFromAsn1 = function(obj, computeHash) {
      var capture = {};
      var errors = [];
      if (!asn1$2.validate(obj, certificationRequestValidator, capture, errors)) {
        var error2 = new Error("Cannot read PKCS#10 certificate request. ASN.1 object is not a PKCS#10 CertificationRequest.");
        error2.errors = errors;
        throw error2;
      }
      var oid = asn1$2.derToOid(capture.publicKeyOid);
      if (oid !== pki$2.oids.rsaEncryption) {
        throw new Error("Cannot read public key. OID is not RSA.");
      }
      var csr = pki$2.createCertificationRequest();
      csr.version = capture.csrVersion ? capture.csrVersion.charCodeAt(0) : 0;
      csr.signatureOid = forge$2.asn1.derToOid(capture.csrSignatureOid);
      csr.signatureParameters = _readSignatureParameters(csr.signatureOid, capture.csrSignatureParams, true);
      csr.siginfo.algorithmOid = forge$2.asn1.derToOid(capture.csrSignatureOid);
      csr.siginfo.parameters = _readSignatureParameters(csr.siginfo.algorithmOid, capture.csrSignatureParams, false);
      csr.signature = capture.csrSignature;
      csr.certificationRequestInfo = capture.certificationRequestInfo;
      if (computeHash) {
        csr.md = _createSignatureDigest({
          signatureOid: csr.signatureOid,
          type: "certification request"
        });
        var bytes = asn1$2.toDer(csr.certificationRequestInfo);
        csr.md.update(bytes.getBytes());
      }
      var smd = forge$2.md.sha1.create();
      csr.subject.getField = function(sn2) {
        return _getAttribute(csr.subject, sn2);
      };
      csr.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        csr.subject.attributes.push(attr);
      };
      csr.subject.attributes = pki$2.RDNAttributesAsArray(capture.certificationRequestInfoSubject, smd);
      csr.subject.hash = smd.digest().toHex();
      csr.publicKey = pki$2.publicKeyFromAsn1(capture.subjectPublicKeyInfo);
      csr.getAttribute = function(sn2) {
        return _getAttribute(csr, sn2);
      };
      csr.addAttribute = function(attr) {
        _fillMissingFields([attr]);
        csr.attributes.push(attr);
      };
      csr.attributes = pki$2.CRIAttributesAsArray(capture.certificationRequestInfoAttributes || []);
      return csr;
    };
    pki$2.createCertificationRequest = function() {
      var csr = {};
      csr.version = 0;
      csr.signatureOid = null;
      csr.signature = null;
      csr.siginfo = {};
      csr.siginfo.algorithmOid = null;
      csr.subject = {};
      csr.subject.getField = function(sn2) {
        return _getAttribute(csr.subject, sn2);
      };
      csr.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        csr.subject.attributes.push(attr);
      };
      csr.subject.attributes = [];
      csr.subject.hash = null;
      csr.publicKey = null;
      csr.attributes = [];
      csr.getAttribute = function(sn2) {
        return _getAttribute(csr, sn2);
      };
      csr.addAttribute = function(attr) {
        _fillMissingFields([attr]);
        csr.attributes.push(attr);
      };
      csr.md = null;
      csr.setSubject = function(attrs) {
        _fillMissingFields(attrs);
        csr.subject.attributes = attrs;
        csr.subject.hash = null;
      };
      csr.setAttributes = function(attrs) {
        _fillMissingFields(attrs);
        csr.attributes = attrs;
      };
      csr.sign = function(key2, md) {
        csr.md = md || forge$2.md.sha1.create();
        var algorithmOid = oids[csr.md.algorithm + "WithRSAEncryption"];
        if (!algorithmOid) {
          var error2 = new Error("Could not compute certification request digest. Unknown message digest algorithm OID.");
          error2.algorithm = csr.md.algorithm;
          throw error2;
        }
        csr.signatureOid = csr.siginfo.algorithmOid = algorithmOid;
        csr.certificationRequestInfo = pki$2.getCertificationRequestInfo(csr);
        var bytes = asn1$2.toDer(csr.certificationRequestInfo);
        csr.md.update(bytes.getBytes());
        csr.signature = key2.sign(csr.md);
      };
      csr.verify = function() {
        var rval = false;
        var md = csr.md;
        if (md === null) {
          md = _createSignatureDigest({
            signatureOid: csr.signatureOid,
            type: "certification request"
          });
          var cri = csr.certificationRequestInfo || pki$2.getCertificationRequestInfo(csr);
          var bytes = asn1$2.toDer(cri);
          md.update(bytes.getBytes());
        }
        if (md !== null) {
          rval = _verifySignature({
            certificate: csr,
            md,
            signature: csr.signature
          });
        }
        return rval;
      };
      return csr;
    };
    function _dnToAsn1(obj) {
      var rval = asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.SEQUENCE, true, []);
      var attr, set2;
      var attrs = obj.attributes;
      for (var i2 = 0; i2 < attrs.length; ++i2) {
        attr = attrs[i2];
        var value = attr.value;
        var valueTagClass = asn1$2.Type.PRINTABLESTRING;
        if ("valueTagClass" in attr) {
          valueTagClass = attr.valueTagClass;
          if (valueTagClass === asn1$2.Type.UTF8) {
            value = forge$2.util.encodeUtf8(value);
          }
        }
        set2 = asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.SET, true, [
          asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.SEQUENCE, true, [
            asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.OID, false, asn1$2.oidToDer(attr.type).getBytes()),
            asn1$2.create(asn1$2.Class.UNIVERSAL, valueTagClass, false, value)
          ])
        ]);
        rval.value.push(set2);
      }
      return rval;
    }
    function _fillMissingFields(attrs) {
      var attr;
      for (var i2 = 0; i2 < attrs.length; ++i2) {
        attr = attrs[i2];
        if (typeof attr.name === "undefined") {
          if (attr.type && attr.type in pki$2.oids) {
            attr.name = pki$2.oids[attr.type];
          } else if (attr.shortName && attr.shortName in _shortNames) {
            attr.name = pki$2.oids[_shortNames[attr.shortName]];
          }
        }
        if (typeof attr.type === "undefined") {
          if (attr.name && attr.name in pki$2.oids) {
            attr.type = pki$2.oids[attr.name];
          } else {
            var error2 = new Error("Attribute type not specified.");
            error2.attribute = attr;
            throw error2;
          }
        }
        if (typeof attr.shortName === "undefined") {
          if (attr.name && attr.name in _shortNames) {
            attr.shortName = _shortNames[attr.name];
          }
        }
        if (attr.type === oids.extensionRequest) {
          attr.valueConstructed = true;
          attr.valueTagClass = asn1$2.Type.SEQUENCE;
          if (!attr.value && attr.extensions) {
            attr.value = [];
            for (var ei2 = 0; ei2 < attr.extensions.length; ++ei2) {
              attr.value.push(pki$2.certificateExtensionToAsn1(_fillMissingExtensionFields(attr.extensions[ei2])));
            }
          }
        }
        if (typeof attr.value === "undefined") {
          var error2 = new Error("Attribute value not specified.");
          error2.attribute = attr;
          throw error2;
        }
      }
    }
    function _fillMissingExtensionFields(e2, options2) {
      options2 = options2 || {};
      if (typeof e2.name === "undefined") {
        if (e2.id && e2.id in pki$2.oids) {
          e2.name = pki$2.oids[e2.id];
        }
      }
      if (typeof e2.id === "undefined") {
        if (e2.name && e2.name in pki$2.oids) {
          e2.id = pki$2.oids[e2.name];
        } else {
          var error2 = new Error("Extension ID not specified.");
          error2.extension = e2;
          throw error2;
        }
      }
      if (typeof e2.value !== "undefined") {
        return e2;
      }
      if (e2.name === "keyUsage") {
        var unused = 0;
        var b2 = 0;
        var b3 = 0;
        if (e2.digitalSignature) {
          b2 |= 128;
          unused = 7;
        }
        if (e2.nonRepudiation) {
          b2 |= 64;
          unused = 6;
        }
        if (e2.keyEncipherment) {
          b2 |= 32;
          unused = 5;
        }
        if (e2.dataEncipherment) {
          b2 |= 16;
          unused = 4;
        }
        if (e2.keyAgreement) {
          b2 |= 8;
          unused = 3;
        }
        if (e2.keyCertSign) {
          b2 |= 4;
          unused = 2;
        }
        if (e2.cRLSign) {
          b2 |= 2;
          unused = 1;
        }
        if (e2.encipherOnly) {
          b2 |= 1;
          unused = 0;
        }
        if (e2.decipherOnly) {
          b3 |= 128;
          unused = 7;
        }
        var value = String.fromCharCode(unused);
        if (b3 !== 0) {
          value += String.fromCharCode(b2) + String.fromCharCode(b3);
        } else if (b2 !== 0) {
          value += String.fromCharCode(b2);
        }
        e2.value = asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.BITSTRING, false, value);
      } else if (e2.name === "basicConstraints") {
        e2.value = asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.SEQUENCE, true, []);
        if (e2.cA) {
          e2.value.value.push(asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.BOOLEAN, false, String.fromCharCode(255)));
        }
        if ("pathLenConstraint" in e2) {
          e2.value.value.push(asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.INTEGER, false, asn1$2.integerToDer(e2.pathLenConstraint).getBytes()));
        }
      } else if (e2.name === "extKeyUsage") {
        e2.value = asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.SEQUENCE, true, []);
        var seq2 = e2.value.value;
        for (var key2 in e2) {
          if (e2[key2] !== true) {
            continue;
          }
          if (key2 in oids) {
            seq2.push(asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.OID, false, asn1$2.oidToDer(oids[key2]).getBytes()));
          } else if (key2.indexOf(".") !== -1) {
            seq2.push(asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.OID, false, asn1$2.oidToDer(key2).getBytes()));
          }
        }
      } else if (e2.name === "nsCertType") {
        var unused = 0;
        var b2 = 0;
        if (e2.client) {
          b2 |= 128;
          unused = 7;
        }
        if (e2.server) {
          b2 |= 64;
          unused = 6;
        }
        if (e2.email) {
          b2 |= 32;
          unused = 5;
        }
        if (e2.objsign) {
          b2 |= 16;
          unused = 4;
        }
        if (e2.reserved) {
          b2 |= 8;
          unused = 3;
        }
        if (e2.sslCA) {
          b2 |= 4;
          unused = 2;
        }
        if (e2.emailCA) {
          b2 |= 2;
          unused = 1;
        }
        if (e2.objCA) {
          b2 |= 1;
          unused = 0;
        }
        var value = String.fromCharCode(unused);
        if (b2 !== 0) {
          value += String.fromCharCode(b2);
        }
        e2.value = asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.BITSTRING, false, value);
      } else if (e2.name === "subjectAltName" || e2.name === "issuerAltName") {
        e2.value = asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.SEQUENCE, true, []);
        var altName;
        for (var n3 = 0; n3 < e2.altNames.length; ++n3) {
          altName = e2.altNames[n3];
          var value = altName.value;
          if (altName.type === 7 && altName.ip) {
            value = forge$2.util.bytesFromIP(altName.ip);
            if (value === null) {
              var error2 = new Error('Extension "ip" value is not a valid IPv4 or IPv6 address.');
              error2.extension = e2;
              throw error2;
            }
          } else if (altName.type === 8) {
            if (altName.oid) {
              value = asn1$2.oidToDer(asn1$2.oidToDer(altName.oid));
            } else {
              value = asn1$2.oidToDer(value);
            }
          }
          e2.value.value.push(asn1$2.create(asn1$2.Class.CONTEXT_SPECIFIC, altName.type, false, value));
        }
      } else if (e2.name === "nsComment" && options2.cert) {
        if (!/^[\x00-\x7F]*$/.test(e2.comment) || e2.comment.length < 1 || e2.comment.length > 128) {
          throw new Error('Invalid "nsComment" content.');
        }
        e2.value = asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.IA5STRING, false, e2.comment);
      } else if (e2.name === "subjectKeyIdentifier" && options2.cert) {
        var ski = options2.cert.generateSubjectKeyIdentifier();
        e2.subjectKeyIdentifier = ski.toHex();
        e2.value = asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.OCTETSTRING, false, ski.getBytes());
      } else if (e2.name === "authorityKeyIdentifier" && options2.cert) {
        e2.value = asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.SEQUENCE, true, []);
        var seq2 = e2.value.value;
        if (e2.keyIdentifier) {
          var keyIdentifier = e2.keyIdentifier === true ? options2.cert.generateSubjectKeyIdentifier().getBytes() : e2.keyIdentifier;
          seq2.push(asn1$2.create(asn1$2.Class.CONTEXT_SPECIFIC, 0, false, keyIdentifier));
        }
        if (e2.authorityCertIssuer) {
          var authorityCertIssuer = [
            asn1$2.create(asn1$2.Class.CONTEXT_SPECIFIC, 4, true, [
              _dnToAsn1(e2.authorityCertIssuer === true ? options2.cert.issuer : e2.authorityCertIssuer)
            ])
          ];
          seq2.push(asn1$2.create(asn1$2.Class.CONTEXT_SPECIFIC, 1, true, authorityCertIssuer));
        }
        if (e2.serialNumber) {
          var serialNumber = forge$2.util.hexToBytes(e2.serialNumber === true ? options2.cert.serialNumber : e2.serialNumber);
          seq2.push(asn1$2.create(asn1$2.Class.CONTEXT_SPECIFIC, 2, false, serialNumber));
        }
      } else if (e2.name === "cRLDistributionPoints") {
        e2.value = asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.SEQUENCE, true, []);
        var seq2 = e2.value.value;
        var subSeq = asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.SEQUENCE, true, []);
        var fullNameGeneralNames = asn1$2.create(asn1$2.Class.CONTEXT_SPECIFIC, 0, true, []);
        var altName;
        for (var n3 = 0; n3 < e2.altNames.length; ++n3) {
          altName = e2.altNames[n3];
          var value = altName.value;
          if (altName.type === 7 && altName.ip) {
            value = forge$2.util.bytesFromIP(altName.ip);
            if (value === null) {
              var error2 = new Error('Extension "ip" value is not a valid IPv4 or IPv6 address.');
              error2.extension = e2;
              throw error2;
            }
          } else if (altName.type === 8) {
            if (altName.oid) {
              value = asn1$2.oidToDer(asn1$2.oidToDer(altName.oid));
            } else {
              value = asn1$2.oidToDer(value);
            }
          }
          fullNameGeneralNames.value.push(asn1$2.create(asn1$2.Class.CONTEXT_SPECIFIC, altName.type, false, value));
        }
        subSeq.value.push(asn1$2.create(asn1$2.Class.CONTEXT_SPECIFIC, 0, true, [fullNameGeneralNames]));
        seq2.push(subSeq);
      }
      if (typeof e2.value === "undefined") {
        var error2 = new Error("Extension value not specified.");
        error2.extension = e2;
        throw error2;
      }
      return e2;
    }
    function _signatureParametersToAsn1(oid, params) {
      switch (oid) {
        case oids["RSASSA-PSS"]:
          var parts = [];
          if (params.hash.algorithmOid !== void 0) {
            parts.push(asn1$2.create(asn1$2.Class.CONTEXT_SPECIFIC, 0, true, [
              asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.SEQUENCE, true, [
                asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.OID, false, asn1$2.oidToDer(params.hash.algorithmOid).getBytes()),
                asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.NULL, false, "")
              ])
            ]));
          }
          if (params.mgf.algorithmOid !== void 0) {
            parts.push(asn1$2.create(asn1$2.Class.CONTEXT_SPECIFIC, 1, true, [
              asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.SEQUENCE, true, [
                asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.OID, false, asn1$2.oidToDer(params.mgf.algorithmOid).getBytes()),
                asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.SEQUENCE, true, [
                  asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.OID, false, asn1$2.oidToDer(params.mgf.hash.algorithmOid).getBytes()),
                  asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.NULL, false, "")
                ])
              ])
            ]));
          }
          if (params.saltLength !== void 0) {
            parts.push(asn1$2.create(asn1$2.Class.CONTEXT_SPECIFIC, 2, true, [
              asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.INTEGER, false, asn1$2.integerToDer(params.saltLength).getBytes())
            ]));
          }
          return asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.SEQUENCE, true, parts);
        default:
          return asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.NULL, false, "");
      }
    }
    function _CRIAttributesToAsn1(csr) {
      var rval = asn1$2.create(asn1$2.Class.CONTEXT_SPECIFIC, 0, true, []);
      if (csr.attributes.length === 0) {
        return rval;
      }
      var attrs = csr.attributes;
      for (var i2 = 0; i2 < attrs.length; ++i2) {
        var attr = attrs[i2];
        var value = attr.value;
        var valueTagClass = asn1$2.Type.UTF8;
        if ("valueTagClass" in attr) {
          valueTagClass = attr.valueTagClass;
        }
        if (valueTagClass === asn1$2.Type.UTF8) {
          value = forge$2.util.encodeUtf8(value);
        }
        var valueConstructed = false;
        if ("valueConstructed" in attr) {
          valueConstructed = attr.valueConstructed;
        }
        var seq2 = asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.SEQUENCE, true, [
          asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.OID, false, asn1$2.oidToDer(attr.type).getBytes()),
          asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.SET, true, [
            asn1$2.create(asn1$2.Class.UNIVERSAL, valueTagClass, valueConstructed, value)
          ])
        ]);
        rval.value.push(seq2);
      }
      return rval;
    }
    var jan_1_1950 = new Date("1950-01-01T00:00:00Z");
    var jan_1_2050 = new Date("2050-01-01T00:00:00Z");
    function _dateToAsn1(date) {
      if (date >= jan_1_1950 && date < jan_1_2050) {
        return asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.UTCTIME, false, asn1$2.dateToUtcTime(date));
      } else {
        return asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.GENERALIZEDTIME, false, asn1$2.dateToGeneralizedTime(date));
      }
    }
    pki$2.getTBSCertificate = function(cert) {
      var notBefore = _dateToAsn1(cert.validity.notBefore);
      var notAfter = _dateToAsn1(cert.validity.notAfter);
      var tbs = asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.SEQUENCE, true, [
        asn1$2.create(asn1$2.Class.CONTEXT_SPECIFIC, 0, true, [
          asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.INTEGER, false, asn1$2.integerToDer(cert.version).getBytes())
        ]),
        asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.INTEGER, false, forge$2.util.hexToBytes(cert.serialNumber)),
        asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.SEQUENCE, true, [
          asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.OID, false, asn1$2.oidToDer(cert.siginfo.algorithmOid).getBytes()),
          _signatureParametersToAsn1(cert.siginfo.algorithmOid, cert.siginfo.parameters)
        ]),
        _dnToAsn1(cert.issuer),
        asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.SEQUENCE, true, [
          notBefore,
          notAfter
        ]),
        _dnToAsn1(cert.subject),
        pki$2.publicKeyToAsn1(cert.publicKey)
      ]);
      if (cert.issuer.uniqueId) {
        tbs.value.push(asn1$2.create(asn1$2.Class.CONTEXT_SPECIFIC, 1, true, [
          asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.BITSTRING, false, String.fromCharCode(0) + cert.issuer.uniqueId)
        ]));
      }
      if (cert.subject.uniqueId) {
        tbs.value.push(asn1$2.create(asn1$2.Class.CONTEXT_SPECIFIC, 2, true, [
          asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.BITSTRING, false, String.fromCharCode(0) + cert.subject.uniqueId)
        ]));
      }
      if (cert.extensions.length > 0) {
        tbs.value.push(pki$2.certificateExtensionsToAsn1(cert.extensions));
      }
      return tbs;
    };
    pki$2.getCertificationRequestInfo = function(csr) {
      var cri = asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.SEQUENCE, true, [
        asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.INTEGER, false, asn1$2.integerToDer(csr.version).getBytes()),
        _dnToAsn1(csr.subject),
        pki$2.publicKeyToAsn1(csr.publicKey),
        _CRIAttributesToAsn1(csr)
      ]);
      return cri;
    };
    pki$2.distinguishedNameToAsn1 = function(dn2) {
      return _dnToAsn1(dn2);
    };
    pki$2.certificateToAsn1 = function(cert) {
      var tbsCertificate = cert.tbsCertificate || pki$2.getTBSCertificate(cert);
      return asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.SEQUENCE, true, [
        tbsCertificate,
        asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.SEQUENCE, true, [
          asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.OID, false, asn1$2.oidToDer(cert.signatureOid).getBytes()),
          _signatureParametersToAsn1(cert.signatureOid, cert.signatureParameters)
        ]),
        asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.BITSTRING, false, String.fromCharCode(0) + cert.signature)
      ]);
    };
    pki$2.certificateExtensionsToAsn1 = function(exts) {
      var rval = asn1$2.create(asn1$2.Class.CONTEXT_SPECIFIC, 3, true, []);
      var seq2 = asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.SEQUENCE, true, []);
      rval.value.push(seq2);
      for (var i2 = 0; i2 < exts.length; ++i2) {
        seq2.value.push(pki$2.certificateExtensionToAsn1(exts[i2]));
      }
      return rval;
    };
    pki$2.certificateExtensionToAsn1 = function(ext2) {
      var extseq = asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.SEQUENCE, true, []);
      extseq.value.push(asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.OID, false, asn1$2.oidToDer(ext2.id).getBytes()));
      if (ext2.critical) {
        extseq.value.push(asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.BOOLEAN, false, String.fromCharCode(255)));
      }
      var value = ext2.value;
      if (typeof ext2.value !== "string") {
        value = asn1$2.toDer(value).getBytes();
      }
      extseq.value.push(asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.OCTETSTRING, false, value));
      return extseq;
    };
    pki$2.certificationRequestToAsn1 = function(csr) {
      var cri = csr.certificationRequestInfo || pki$2.getCertificationRequestInfo(csr);
      return asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.SEQUENCE, true, [
        cri,
        asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.SEQUENCE, true, [
          asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.OID, false, asn1$2.oidToDer(csr.signatureOid).getBytes()),
          _signatureParametersToAsn1(csr.signatureOid, csr.signatureParameters)
        ]),
        asn1$2.create(asn1$2.Class.UNIVERSAL, asn1$2.Type.BITSTRING, false, String.fromCharCode(0) + csr.signature)
      ]);
    };
    pki$2.createCaStore = function(certs) {
      var caStore = {
        certs: {}
      };
      caStore.getIssuer = function(cert2) {
        var rval = getBySubject(cert2.issuer);
        return rval;
      };
      caStore.addCertificate = function(cert2) {
        if (typeof cert2 === "string") {
          cert2 = forge$2.pki.certificateFromPem(cert2);
        }
        ensureSubjectHasHash(cert2.subject);
        if (!caStore.hasCertificate(cert2)) {
          if (cert2.subject.hash in caStore.certs) {
            var tmp = caStore.certs[cert2.subject.hash];
            if (!forge$2.util.isArray(tmp)) {
              tmp = [tmp];
            }
            tmp.push(cert2);
            caStore.certs[cert2.subject.hash] = tmp;
          } else {
            caStore.certs[cert2.subject.hash] = cert2;
          }
        }
      };
      caStore.hasCertificate = function(cert2) {
        if (typeof cert2 === "string") {
          cert2 = forge$2.pki.certificateFromPem(cert2);
        }
        var match2 = getBySubject(cert2.subject);
        if (!match2) {
          return false;
        }
        if (!forge$2.util.isArray(match2)) {
          match2 = [match2];
        }
        var der1 = asn1$2.toDer(pki$2.certificateToAsn1(cert2)).getBytes();
        for (var i3 = 0; i3 < match2.length; ++i3) {
          var der2 = asn1$2.toDer(pki$2.certificateToAsn1(match2[i3])).getBytes();
          if (der1 === der2) {
            return true;
          }
        }
        return false;
      };
      caStore.listAllCertificates = function() {
        var certList = [];
        for (var hash2 in caStore.certs) {
          if (caStore.certs.hasOwnProperty(hash2)) {
            var value = caStore.certs[hash2];
            if (!forge$2.util.isArray(value)) {
              certList.push(value);
            } else {
              for (var i3 = 0; i3 < value.length; ++i3) {
                certList.push(value[i3]);
              }
            }
          }
        }
        return certList;
      };
      caStore.removeCertificate = function(cert2) {
        var result2;
        if (typeof cert2 === "string") {
          cert2 = forge$2.pki.certificateFromPem(cert2);
        }
        ensureSubjectHasHash(cert2.subject);
        if (!caStore.hasCertificate(cert2)) {
          return null;
        }
        var match2 = getBySubject(cert2.subject);
        if (!forge$2.util.isArray(match2)) {
          result2 = caStore.certs[cert2.subject.hash];
          delete caStore.certs[cert2.subject.hash];
          return result2;
        }
        var der1 = asn1$2.toDer(pki$2.certificateToAsn1(cert2)).getBytes();
        for (var i3 = 0; i3 < match2.length; ++i3) {
          var der2 = asn1$2.toDer(pki$2.certificateToAsn1(match2[i3])).getBytes();
          if (der1 === der2) {
            result2 = match2[i3];
            match2.splice(i3, 1);
          }
        }
        if (match2.length === 0) {
          delete caStore.certs[cert2.subject.hash];
        }
        return result2;
      };
      function getBySubject(subject) {
        ensureSubjectHasHash(subject);
        return caStore.certs[subject.hash] || null;
      }
      function ensureSubjectHasHash(subject) {
        if (!subject.hash) {
          var md = forge$2.md.sha1.create();
          subject.attributes = pki$2.RDNAttributesAsArray(_dnToAsn1(subject), md);
          subject.hash = md.digest().toHex();
        }
      }
      if (certs) {
        for (var i2 = 0; i2 < certs.length; ++i2) {
          var cert = certs[i2];
          caStore.addCertificate(cert);
        }
      }
      return caStore;
    };
    pki$2.certificateError = {
      bad_certificate: "forge.pki.BadCertificate",
      unsupported_certificate: "forge.pki.UnsupportedCertificate",
      certificate_revoked: "forge.pki.CertificateRevoked",
      certificate_expired: "forge.pki.CertificateExpired",
      certificate_unknown: "forge.pki.CertificateUnknown",
      unknown_ca: "forge.pki.UnknownCertificateAuthority"
    };
    pki$2.verifyCertificateChain = function(caStore, chain, options2) {
      if (typeof options2 === "function") {
        options2 = { verify: options2 };
      }
      options2 = options2 || {};
      chain = chain.slice(0);
      var certs = chain.slice(0);
      var validityCheckDate = options2.validityCheckDate;
      if (typeof validityCheckDate === "undefined") {
        validityCheckDate = new Date();
      }
      var first2 = true;
      var error2 = null;
      var depth2 = 0;
      do {
        var cert = chain.shift();
        var parent = null;
        var selfSigned = false;
        if (validityCheckDate) {
          if (validityCheckDate < cert.validity.notBefore || validityCheckDate > cert.validity.notAfter) {
            error2 = {
              message: "Certificate is not valid yet or has expired.",
              error: pki$2.certificateError.certificate_expired,
              notBefore: cert.validity.notBefore,
              notAfter: cert.validity.notAfter,
              now: validityCheckDate
            };
          }
        }
        if (error2 === null) {
          parent = chain[0] || caStore.getIssuer(cert);
          if (parent === null) {
            if (cert.isIssuer(cert)) {
              selfSigned = true;
              parent = cert;
            }
          }
          if (parent) {
            var parents = parent;
            if (!forge$2.util.isArray(parents)) {
              parents = [parents];
            }
            var verified = false;
            while (!verified && parents.length > 0) {
              parent = parents.shift();
              try {
                verified = parent.verify(cert);
              } catch (ex) {
              }
            }
            if (!verified) {
              error2 = {
                message: "Certificate signature is invalid.",
                error: pki$2.certificateError.bad_certificate
              };
            }
          }
          if (error2 === null && (!parent || selfSigned) && !caStore.hasCertificate(cert)) {
            error2 = {
              message: "Certificate is not trusted.",
              error: pki$2.certificateError.unknown_ca
            };
          }
        }
        if (error2 === null && parent && !cert.isIssuer(parent)) {
          error2 = {
            message: "Certificate issuer is invalid.",
            error: pki$2.certificateError.bad_certificate
          };
        }
        if (error2 === null) {
          var se2 = {
            keyUsage: true,
            basicConstraints: true
          };
          for (var i2 = 0; error2 === null && i2 < cert.extensions.length; ++i2) {
            var ext2 = cert.extensions[i2];
            if (ext2.critical && !(ext2.name in se2)) {
              error2 = {
                message: "Certificate has an unsupported critical extension.",
                error: pki$2.certificateError.unsupported_certificate
              };
            }
          }
        }
        if (error2 === null && (!first2 || chain.length === 0 && (!parent || selfSigned))) {
          var bcExt = cert.getExtension("basicConstraints");
          var keyUsageExt = cert.getExtension("keyUsage");
          if (keyUsageExt !== null) {
            if (!keyUsageExt.keyCertSign || bcExt === null) {
              error2 = {
                message: "Certificate keyUsage or basicConstraints conflict or indicate that the certificate is not a CA. If the certificate is the only one in the chain or isn't the first then the certificate must be a valid CA.",
                error: pki$2.certificateError.bad_certificate
              };
            }
          }
          if (error2 === null && bcExt !== null && !bcExt.cA) {
            error2 = {
              message: "Certificate basicConstraints indicates the certificate is not a CA.",
              error: pki$2.certificateError.bad_certificate
            };
          }
          if (error2 === null && keyUsageExt !== null && "pathLenConstraint" in bcExt) {
            var pathLen = depth2 - 1;
            if (pathLen > bcExt.pathLenConstraint) {
              error2 = {
                message: "Certificate basicConstraints pathLenConstraint violated.",
                error: pki$2.certificateError.bad_certificate
              };
            }
          }
        }
        var vfd = error2 === null ? true : error2.error;
        var ret = options2.verify ? options2.verify(vfd, depth2, certs) : vfd;
        if (ret === true) {
          error2 = null;
        } else {
          if (vfd === true) {
            error2 = {
              message: "The application rejected the certificate.",
              error: pki$2.certificateError.bad_certificate
            };
          }
          if (ret || ret === 0) {
            if (typeof ret === "object" && !forge$2.util.isArray(ret)) {
              if (ret.message) {
                error2.message = ret.message;
              }
              if (ret.error) {
                error2.error = ret.error;
              }
            } else if (typeof ret === "string") {
              error2.error = ret;
            }
          }
          throw error2;
        }
        first2 = false;
        ++depth2;
      } while (chain.length > 0);
      return true;
    };
    var forge$1 = forge$s;
    var asn1$1 = forge$1.asn1;
    var pki$1 = forge$1.pki;
    var p12 = forge$1.pkcs12 = forge$1.pkcs12 || {};
    var contentInfoValidator = {
      name: "ContentInfo",
      tagClass: asn1$1.Class.UNIVERSAL,
      type: asn1$1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "ContentInfo.contentType",
        tagClass: asn1$1.Class.UNIVERSAL,
        type: asn1$1.Type.OID,
        constructed: false,
        capture: "contentType"
      }, {
        name: "ContentInfo.content",
        tagClass: asn1$1.Class.CONTEXT_SPECIFIC,
        constructed: true,
        captureAsn1: "content"
      }]
    };
    var pfxValidator = {
      name: "PFX",
      tagClass: asn1$1.Class.UNIVERSAL,
      type: asn1$1.Type.SEQUENCE,
      constructed: true,
      value: [
        {
          name: "PFX.version",
          tagClass: asn1$1.Class.UNIVERSAL,
          type: asn1$1.Type.INTEGER,
          constructed: false,
          capture: "version"
        },
        contentInfoValidator,
        {
          name: "PFX.macData",
          tagClass: asn1$1.Class.UNIVERSAL,
          type: asn1$1.Type.SEQUENCE,
          constructed: true,
          optional: true,
          captureAsn1: "mac",
          value: [{
            name: "PFX.macData.mac",
            tagClass: asn1$1.Class.UNIVERSAL,
            type: asn1$1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "PFX.macData.mac.digestAlgorithm",
              tagClass: asn1$1.Class.UNIVERSAL,
              type: asn1$1.Type.SEQUENCE,
              constructed: true,
              value: [{
                name: "PFX.macData.mac.digestAlgorithm.algorithm",
                tagClass: asn1$1.Class.UNIVERSAL,
                type: asn1$1.Type.OID,
                constructed: false,
                capture: "macAlgorithm"
              }, {
                name: "PFX.macData.mac.digestAlgorithm.parameters",
                tagClass: asn1$1.Class.UNIVERSAL,
                captureAsn1: "macAlgorithmParameters"
              }]
            }, {
              name: "PFX.macData.mac.digest",
              tagClass: asn1$1.Class.UNIVERSAL,
              type: asn1$1.Type.OCTETSTRING,
              constructed: false,
              capture: "macDigest"
            }]
          }, {
            name: "PFX.macData.macSalt",
            tagClass: asn1$1.Class.UNIVERSAL,
            type: asn1$1.Type.OCTETSTRING,
            constructed: false,
            capture: "macSalt"
          }, {
            name: "PFX.macData.iterations",
            tagClass: asn1$1.Class.UNIVERSAL,
            type: asn1$1.Type.INTEGER,
            constructed: false,
            optional: true,
            capture: "macIterations"
          }]
        }
      ]
    };
    var safeBagValidator = {
      name: "SafeBag",
      tagClass: asn1$1.Class.UNIVERSAL,
      type: asn1$1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "SafeBag.bagId",
        tagClass: asn1$1.Class.UNIVERSAL,
        type: asn1$1.Type.OID,
        constructed: false,
        capture: "bagId"
      }, {
        name: "SafeBag.bagValue",
        tagClass: asn1$1.Class.CONTEXT_SPECIFIC,
        constructed: true,
        captureAsn1: "bagValue"
      }, {
        name: "SafeBag.bagAttributes",
        tagClass: asn1$1.Class.UNIVERSAL,
        type: asn1$1.Type.SET,
        constructed: true,
        optional: true,
        capture: "bagAttributes"
      }]
    };
    var attributeValidator = {
      name: "Attribute",
      tagClass: asn1$1.Class.UNIVERSAL,
      type: asn1$1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "Attribute.attrId",
        tagClass: asn1$1.Class.UNIVERSAL,
        type: asn1$1.Type.OID,
        constructed: false,
        capture: "oid"
      }, {
        name: "Attribute.attrValues",
        tagClass: asn1$1.Class.UNIVERSAL,
        type: asn1$1.Type.SET,
        constructed: true,
        capture: "values"
      }]
    };
    var certBagValidator = {
      name: "CertBag",
      tagClass: asn1$1.Class.UNIVERSAL,
      type: asn1$1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "CertBag.certId",
        tagClass: asn1$1.Class.UNIVERSAL,
        type: asn1$1.Type.OID,
        constructed: false,
        capture: "certId"
      }, {
        name: "CertBag.certValue",
        tagClass: asn1$1.Class.CONTEXT_SPECIFIC,
        constructed: true,
        value: [{
          name: "CertBag.certValue[0]",
          tagClass: asn1$1.Class.UNIVERSAL,
          type: asn1$1.Class.OCTETSTRING,
          constructed: false,
          capture: "cert"
        }]
      }]
    };
    function _getBagsByAttribute(safeContents, attrName, attrValue, bagType) {
      var result2 = [];
      for (var i2 = 0; i2 < safeContents.length; i2++) {
        for (var j2 = 0; j2 < safeContents[i2].safeBags.length; j2++) {
          var bag = safeContents[i2].safeBags[j2];
          if (bagType !== void 0 && bag.type !== bagType) {
            continue;
          }
          if (attrName === null) {
            result2.push(bag);
            continue;
          }
          if (bag.attributes[attrName] !== void 0 && bag.attributes[attrName].indexOf(attrValue) >= 0) {
            result2.push(bag);
          }
        }
      }
      return result2;
    }
    p12.pkcs12FromAsn1 = function(obj, strict, password) {
      if (typeof strict === "string") {
        password = strict;
        strict = true;
      } else if (strict === void 0) {
        strict = true;
      }
      var capture = {};
      var errors = [];
      if (!asn1$1.validate(obj, pfxValidator, capture, errors)) {
        var error2 = new Error("Cannot read PKCS#12 PFX. ASN.1 object is not an PKCS#12 PFX.");
        error2.errors = error2;
        throw error2;
      }
      var pfx = {
        version: capture.version.charCodeAt(0),
        safeContents: [],
        getBags: function(filter2) {
          var rval = {};
          var localKeyId;
          if ("localKeyId" in filter2) {
            localKeyId = filter2.localKeyId;
          } else if ("localKeyIdHex" in filter2) {
            localKeyId = forge$1.util.hexToBytes(filter2.localKeyIdHex);
          }
          if (localKeyId === void 0 && !("friendlyName" in filter2) && "bagType" in filter2) {
            rval[filter2.bagType] = _getBagsByAttribute(pfx.safeContents, null, null, filter2.bagType);
          }
          if (localKeyId !== void 0) {
            rval.localKeyId = _getBagsByAttribute(pfx.safeContents, "localKeyId", localKeyId, filter2.bagType);
          }
          if ("friendlyName" in filter2) {
            rval.friendlyName = _getBagsByAttribute(pfx.safeContents, "friendlyName", filter2.friendlyName, filter2.bagType);
          }
          return rval;
        },
        getBagsByFriendlyName: function(friendlyName, bagType) {
          return _getBagsByAttribute(pfx.safeContents, "friendlyName", friendlyName, bagType);
        },
        getBagsByLocalKeyId: function(localKeyId, bagType) {
          return _getBagsByAttribute(pfx.safeContents, "localKeyId", localKeyId, bagType);
        }
      };
      if (capture.version.charCodeAt(0) !== 3) {
        var error2 = new Error("PKCS#12 PFX of version other than 3 not supported.");
        error2.version = capture.version.charCodeAt(0);
        throw error2;
      }
      if (asn1$1.derToOid(capture.contentType) !== pki$1.oids.data) {
        var error2 = new Error("Only PKCS#12 PFX in password integrity mode supported.");
        error2.oid = asn1$1.derToOid(capture.contentType);
        throw error2;
      }
      var data2 = capture.content.value[0];
      if (data2.tagClass !== asn1$1.Class.UNIVERSAL || data2.type !== asn1$1.Type.OCTETSTRING) {
        throw new Error("PKCS#12 authSafe content data is not an OCTET STRING.");
      }
      data2 = _decodePkcs7Data(data2);
      if (capture.mac) {
        var md = null;
        var macKeyBytes = 0;
        var macAlgorithm = asn1$1.derToOid(capture.macAlgorithm);
        switch (macAlgorithm) {
          case pki$1.oids.sha1:
            md = forge$1.md.sha1.create();
            macKeyBytes = 20;
            break;
          case pki$1.oids.sha256:
            md = forge$1.md.sha256.create();
            macKeyBytes = 32;
            break;
          case pki$1.oids.sha384:
            md = forge$1.md.sha384.create();
            macKeyBytes = 48;
            break;
          case pki$1.oids.sha512:
            md = forge$1.md.sha512.create();
            macKeyBytes = 64;
            break;
          case pki$1.oids.md5:
            md = forge$1.md.md5.create();
            macKeyBytes = 16;
            break;
        }
        if (md === null) {
          throw new Error("PKCS#12 uses unsupported MAC algorithm: " + macAlgorithm);
        }
        var macSalt = new forge$1.util.ByteBuffer(capture.macSalt);
        var macIterations = "macIterations" in capture ? parseInt(forge$1.util.bytesToHex(capture.macIterations), 16) : 1;
        var macKey = p12.generateKey(password, macSalt, 3, macIterations, macKeyBytes, md);
        var mac = forge$1.hmac.create();
        mac.start(md, macKey);
        mac.update(data2.value);
        var macValue = mac.getMac();
        if (macValue.getBytes() !== capture.macDigest) {
          throw new Error("PKCS#12 MAC could not be verified. Invalid password?");
        }
      }
      _decodeAuthenticatedSafe(pfx, data2.value, strict, password);
      return pfx;
    };
    function _decodePkcs7Data(data2) {
      if (data2.composed || data2.constructed) {
        var value = forge$1.util.createBuffer();
        for (var i2 = 0; i2 < data2.value.length; ++i2) {
          value.putBytes(data2.value[i2].value);
        }
        data2.composed = data2.constructed = false;
        data2.value = value.getBytes();
      }
      return data2;
    }
    function _decodeAuthenticatedSafe(pfx, authSafe, strict, password) {
      authSafe = asn1$1.fromDer(authSafe, strict);
      if (authSafe.tagClass !== asn1$1.Class.UNIVERSAL || authSafe.type !== asn1$1.Type.SEQUENCE || authSafe.constructed !== true) {
        throw new Error("PKCS#12 AuthenticatedSafe expected to be a SEQUENCE OF ContentInfo");
      }
      for (var i2 = 0; i2 < authSafe.value.length; i2++) {
        var contentInfo = authSafe.value[i2];
        var capture = {};
        var errors = [];
        if (!asn1$1.validate(contentInfo, contentInfoValidator, capture, errors)) {
          var error2 = new Error("Cannot read ContentInfo.");
          error2.errors = errors;
          throw error2;
        }
        var obj = {
          encrypted: false
        };
        var safeContents = null;
        var data2 = capture.content.value[0];
        switch (asn1$1.derToOid(capture.contentType)) {
          case pki$1.oids.data:
            if (data2.tagClass !== asn1$1.Class.UNIVERSAL || data2.type !== asn1$1.Type.OCTETSTRING) {
              throw new Error("PKCS#12 SafeContents Data is not an OCTET STRING.");
            }
            safeContents = _decodePkcs7Data(data2).value;
            break;
          case pki$1.oids.encryptedData:
            safeContents = _decryptSafeContents(data2, password);
            obj.encrypted = true;
            break;
          default:
            var error2 = new Error("Unsupported PKCS#12 contentType.");
            error2.contentType = asn1$1.derToOid(capture.contentType);
            throw error2;
        }
        obj.safeBags = _decodeSafeContents(safeContents, strict, password);
        pfx.safeContents.push(obj);
      }
    }
    function _decryptSafeContents(data2, password) {
      var capture = {};
      var errors = [];
      if (!asn1$1.validate(data2, forge$1.pkcs7.asn1.encryptedDataValidator, capture, errors)) {
        var error2 = new Error("Cannot read EncryptedContentInfo.");
        error2.errors = errors;
        throw error2;
      }
      var oid = asn1$1.derToOid(capture.contentType);
      if (oid !== pki$1.oids.data) {
        var error2 = new Error("PKCS#12 EncryptedContentInfo ContentType is not Data.");
        error2.oid = oid;
        throw error2;
      }
      oid = asn1$1.derToOid(capture.encAlgorithm);
      var cipher = pki$1.pbe.getCipher(oid, capture.encParameter, password);
      var encryptedContentAsn1 = _decodePkcs7Data(capture.encryptedContentAsn1);
      var encrypted = forge$1.util.createBuffer(encryptedContentAsn1.value);
      cipher.update(encrypted);
      if (!cipher.finish()) {
        throw new Error("Failed to decrypt PKCS#12 SafeContents.");
      }
      return cipher.output.getBytes();
    }
    function _decodeSafeContents(safeContents, strict, password) {
      if (!strict && safeContents.length === 0) {
        return [];
      }
      safeContents = asn1$1.fromDer(safeContents, strict);
      if (safeContents.tagClass !== asn1$1.Class.UNIVERSAL || safeContents.type !== asn1$1.Type.SEQUENCE || safeContents.constructed !== true) {
        throw new Error("PKCS#12 SafeContents expected to be a SEQUENCE OF SafeBag.");
      }
      var res = [];
      for (var i2 = 0; i2 < safeContents.value.length; i2++) {
        var safeBag = safeContents.value[i2];
        var capture = {};
        var errors = [];
        if (!asn1$1.validate(safeBag, safeBagValidator, capture, errors)) {
          var error2 = new Error("Cannot read SafeBag.");
          error2.errors = errors;
          throw error2;
        }
        var bag = {
          type: asn1$1.derToOid(capture.bagId),
          attributes: _decodeBagAttributes(capture.bagAttributes)
        };
        res.push(bag);
        var validator, decoder;
        var bagAsn1 = capture.bagValue.value[0];
        switch (bag.type) {
          case pki$1.oids.pkcs8ShroudedKeyBag:
            bagAsn1 = pki$1.decryptPrivateKeyInfo(bagAsn1, password);
            if (bagAsn1 === null) {
              throw new Error("Unable to decrypt PKCS#8 ShroudedKeyBag, wrong password?");
            }
          case pki$1.oids.keyBag:
            try {
              bag.key = pki$1.privateKeyFromAsn1(bagAsn1);
            } catch (e2) {
              bag.key = null;
              bag.asn1 = bagAsn1;
            }
            continue;
          case pki$1.oids.certBag:
            validator = certBagValidator;
            decoder = function() {
              if (asn1$1.derToOid(capture.certId) !== pki$1.oids.x509Certificate) {
                var error3 = new Error("Unsupported certificate type, only X.509 supported.");
                error3.oid = asn1$1.derToOid(capture.certId);
                throw error3;
              }
              var certAsn1 = asn1$1.fromDer(capture.cert, strict);
              try {
                bag.cert = pki$1.certificateFromAsn1(certAsn1, true);
              } catch (e2) {
                bag.cert = null;
                bag.asn1 = certAsn1;
              }
            };
            break;
          default:
            var error2 = new Error("Unsupported PKCS#12 SafeBag type.");
            error2.oid = bag.type;
            throw error2;
        }
        if (validator !== void 0 && !asn1$1.validate(bagAsn1, validator, capture, errors)) {
          var error2 = new Error("Cannot read PKCS#12 " + validator.name);
          error2.errors = errors;
          throw error2;
        }
        decoder();
      }
      return res;
    }
    function _decodeBagAttributes(attributes) {
      var decodedAttrs = {};
      if (attributes !== void 0) {
        for (var i2 = 0; i2 < attributes.length; ++i2) {
          var capture = {};
          var errors = [];
          if (!asn1$1.validate(attributes[i2], attributeValidator, capture, errors)) {
            var error2 = new Error("Cannot read PKCS#12 BagAttribute.");
            error2.errors = errors;
            throw error2;
          }
          var oid = asn1$1.derToOid(capture.oid);
          if (pki$1.oids[oid] === void 0) {
            continue;
          }
          decodedAttrs[pki$1.oids[oid]] = [];
          for (var j2 = 0; j2 < capture.values.length; ++j2) {
            decodedAttrs[pki$1.oids[oid]].push(capture.values[j2].value);
          }
        }
      }
      return decodedAttrs;
    }
    p12.toPkcs12Asn1 = function(key2, cert, password, options2) {
      options2 = options2 || {};
      options2.saltSize = options2.saltSize || 8;
      options2.count = options2.count || 2048;
      options2.algorithm = options2.algorithm || options2.encAlgorithm || "aes128";
      if (!("useMac" in options2)) {
        options2.useMac = true;
      }
      if (!("localKeyId" in options2)) {
        options2.localKeyId = null;
      }
      if (!("generateLocalKeyId" in options2)) {
        options2.generateLocalKeyId = true;
      }
      var localKeyId = options2.localKeyId;
      var bagAttrs;
      if (localKeyId !== null) {
        localKeyId = forge$1.util.hexToBytes(localKeyId);
      } else if (options2.generateLocalKeyId) {
        if (cert) {
          var pairedCert = forge$1.util.isArray(cert) ? cert[0] : cert;
          if (typeof pairedCert === "string") {
            pairedCert = pki$1.certificateFromPem(pairedCert);
          }
          var sha12 = forge$1.md.sha1.create();
          sha12.update(asn1$1.toDer(pki$1.certificateToAsn1(pairedCert)).getBytes());
          localKeyId = sha12.digest().getBytes();
        } else {
          localKeyId = forge$1.random.getBytes(20);
        }
      }
      var attrs = [];
      if (localKeyId !== null) {
        attrs.push(asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.SEQUENCE, true, [
          asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.OID, false, asn1$1.oidToDer(pki$1.oids.localKeyId).getBytes()),
          asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.SET, true, [
            asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.OCTETSTRING, false, localKeyId)
          ])
        ]));
      }
      if ("friendlyName" in options2) {
        attrs.push(asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.SEQUENCE, true, [
          asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.OID, false, asn1$1.oidToDer(pki$1.oids.friendlyName).getBytes()),
          asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.SET, true, [
            asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.BMPSTRING, false, options2.friendlyName)
          ])
        ]));
      }
      if (attrs.length > 0) {
        bagAttrs = asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.SET, true, attrs);
      }
      var contents = [];
      var chain = [];
      if (cert !== null) {
        if (forge$1.util.isArray(cert)) {
          chain = cert;
        } else {
          chain = [cert];
        }
      }
      var certSafeBags = [];
      for (var i2 = 0; i2 < chain.length; ++i2) {
        cert = chain[i2];
        if (typeof cert === "string") {
          cert = pki$1.certificateFromPem(cert);
        }
        var certBagAttrs = i2 === 0 ? bagAttrs : void 0;
        var certAsn1 = pki$1.certificateToAsn1(cert);
        var certSafeBag = asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.SEQUENCE, true, [
          asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.OID, false, asn1$1.oidToDer(pki$1.oids.certBag).getBytes()),
          asn1$1.create(asn1$1.Class.CONTEXT_SPECIFIC, 0, true, [
            asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.SEQUENCE, true, [
              asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.OID, false, asn1$1.oidToDer(pki$1.oids.x509Certificate).getBytes()),
              asn1$1.create(asn1$1.Class.CONTEXT_SPECIFIC, 0, true, [
                asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.OCTETSTRING, false, asn1$1.toDer(certAsn1).getBytes())
              ])
            ])
          ]),
          certBagAttrs
        ]);
        certSafeBags.push(certSafeBag);
      }
      if (certSafeBags.length > 0) {
        var certSafeContents = asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.SEQUENCE, true, certSafeBags);
        var certCI = asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.SEQUENCE, true, [
          asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.OID, false, asn1$1.oidToDer(pki$1.oids.data).getBytes()),
          asn1$1.create(asn1$1.Class.CONTEXT_SPECIFIC, 0, true, [
            asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.OCTETSTRING, false, asn1$1.toDer(certSafeContents).getBytes())
          ])
        ]);
        contents.push(certCI);
      }
      var keyBag = null;
      if (key2 !== null) {
        var pkAsn1 = pki$1.wrapRsaPrivateKey(pki$1.privateKeyToAsn1(key2));
        if (password === null) {
          keyBag = asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.SEQUENCE, true, [
            asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.OID, false, asn1$1.oidToDer(pki$1.oids.keyBag).getBytes()),
            asn1$1.create(asn1$1.Class.CONTEXT_SPECIFIC, 0, true, [
              pkAsn1
            ]),
            bagAttrs
          ]);
        } else {
          keyBag = asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.SEQUENCE, true, [
            asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.OID, false, asn1$1.oidToDer(pki$1.oids.pkcs8ShroudedKeyBag).getBytes()),
            asn1$1.create(asn1$1.Class.CONTEXT_SPECIFIC, 0, true, [
              pki$1.encryptPrivateKeyInfo(pkAsn1, password, options2)
            ]),
            bagAttrs
          ]);
        }
        var keySafeContents = asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.SEQUENCE, true, [keyBag]);
        var keyCI = asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.SEQUENCE, true, [
          asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.OID, false, asn1$1.oidToDer(pki$1.oids.data).getBytes()),
          asn1$1.create(asn1$1.Class.CONTEXT_SPECIFIC, 0, true, [
            asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.OCTETSTRING, false, asn1$1.toDer(keySafeContents).getBytes())
          ])
        ]);
        contents.push(keyCI);
      }
      var safe = asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.SEQUENCE, true, contents);
      var macData;
      if (options2.useMac) {
        var sha12 = forge$1.md.sha1.create();
        var macSalt = new forge$1.util.ByteBuffer(forge$1.random.getBytes(options2.saltSize));
        var count = options2.count;
        var key2 = p12.generateKey(password, macSalt, 3, count, 20);
        var mac = forge$1.hmac.create();
        mac.start(sha12, key2);
        mac.update(asn1$1.toDer(safe).getBytes());
        var macValue = mac.getMac();
        macData = asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.SEQUENCE, true, [
          asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.SEQUENCE, true, [
            asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.SEQUENCE, true, [
              asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.OID, false, asn1$1.oidToDer(pki$1.oids.sha1).getBytes()),
              asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.NULL, false, "")
            ]),
            asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.OCTETSTRING, false, macValue.getBytes())
          ]),
          asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.OCTETSTRING, false, macSalt.getBytes()),
          asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.INTEGER, false, asn1$1.integerToDer(count).getBytes())
        ]);
      }
      return asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.SEQUENCE, true, [
        asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.INTEGER, false, asn1$1.integerToDer(3).getBytes()),
        asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.SEQUENCE, true, [
          asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.OID, false, asn1$1.oidToDer(pki$1.oids.data).getBytes()),
          asn1$1.create(asn1$1.Class.CONTEXT_SPECIFIC, 0, true, [
            asn1$1.create(asn1$1.Class.UNIVERSAL, asn1$1.Type.OCTETSTRING, false, asn1$1.toDer(safe).getBytes())
          ])
        ]),
        macData
      ]);
    };
    p12.generateKey = forge$1.pbe.generatePkcs12Key;
    var forge = forge$s;
    var asn1 = forge.asn1;
    var pki = forge.pki = forge.pki || {};
    pki.pemToDer = function(pem2) {
      var msg = forge.pem.decode(pem2)[0];
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert PEM to DER; PEM is encrypted.");
      }
      return forge.util.createBuffer(msg.body);
    };
    pki.privateKeyFromPem = function(pem2) {
      var msg = forge.pem.decode(pem2)[0];
      if (msg.type !== "PRIVATE KEY" && msg.type !== "RSA PRIVATE KEY") {
        var error2 = new Error('Could not convert private key from PEM; PEM header type is not "PRIVATE KEY" or "RSA PRIVATE KEY".');
        error2.headerType = msg.type;
        throw error2;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert private key from PEM; PEM is encrypted.");
      }
      var obj = asn1.fromDer(msg.body);
      return pki.privateKeyFromAsn1(obj);
    };
    pki.privateKeyToPem = function(key2, maxline) {
      var msg = {
        type: "RSA PRIVATE KEY",
        body: asn1.toDer(pki.privateKeyToAsn1(key2)).getBytes()
      };
      return forge.pem.encode(msg, { maxline });
    };
    pki.privateKeyInfoToPem = function(pki2, maxline) {
      var msg = {
        type: "PRIVATE KEY",
        body: asn1.toDer(pki2).getBytes()
      };
      return forge.pem.encode(msg, { maxline });
    };
    function toPositiveHex(hexString) {
      let mostSignificativeHexAsInt = parseInt(hexString[0], 16);
      if (mostSignificativeHexAsInt < 8) {
        return hexString;
      }
      mostSignificativeHexAsInt -= 8;
      return mostSignificativeHexAsInt.toString() + hexString.substring(1);
    }
    function createCertificate() {
      const days = 30;
      const keySize = 2048;
      const extensions2 = [
        {
          name: "keyUsage",
          keyCertSign: true,
          digitalSignature: true,
          nonRepudiation: true,
          keyEncipherment: true,
          dataEncipherment: true
        },
        {
          name: "extKeyUsage",
          serverAuth: true,
          clientAuth: true,
          codeSigning: true,
          timeStamping: true
        },
        {
          name: "subjectAltName",
          altNames: [
            {
              type: 2,
              value: "localhost"
            },
            {
              type: 2,
              value: "localhost.localdomain"
            },
            {
              type: 2,
              value: "lvh.me"
            },
            {
              type: 2,
              value: "*.lvh.me"
            },
            {
              type: 2,
              value: "[::1]"
            },
            {
              type: 7,
              ip: "127.0.0.1"
            },
            {
              type: 7,
              ip: "fe80::1"
            }
          ]
        }
      ];
      const attrs = [
        {
          name: "commonName",
          value: "example.org"
        },
        {
          name: "countryName",
          value: "US"
        },
        {
          shortName: "ST",
          value: "Virginia"
        },
        {
          name: "localityName",
          value: "Blacksburg"
        },
        {
          name: "organizationName",
          value: "Test"
        },
        {
          shortName: "OU",
          value: "Test"
        }
      ];
      const keyPair = forge$s.pki.rsa.generateKeyPair(keySize);
      const cert = forge$s.pki.createCertificate();
      cert.serialNumber = toPositiveHex(forge$s.util.bytesToHex(forge$s.random.getBytesSync(9)));
      cert.validity.notBefore = new Date();
      cert.validity.notAfter = new Date();
      cert.validity.notAfter.setDate(cert.validity.notBefore.getDate() + days);
      cert.setSubject(attrs);
      cert.setIssuer(attrs);
      cert.publicKey = keyPair.publicKey;
      cert.setExtensions(extensions2);
      const algorithm = forge$s.md.sha256.create();
      cert.sign(keyPair.privateKey, algorithm);
      const privateKeyPem = forge$s.pki.privateKeyToPem(keyPair.privateKey);
      const certPem = forge$s.pki.certificateToPem(cert);
      return privateKeyPem + certPem;
    }
    exports2.createCertificate = createCertificate;
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports2, module2) {
    var s2 = 1e3;
    var m3 = s2 * 60;
    var h3 = m3 * 60;
    var d3 = h3 * 24;
    var w3 = d3 * 7;
    var y3 = d3 * 365.25;
    module2.exports = function(val, options2) {
      options2 = options2 || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse2(val);
      } else if (type === "number" && isFinite(val)) {
        return options2.long ? fmtLong2(val) : fmtShort2(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse2(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match2 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
      if (!match2) {
        return;
      }
      var n3 = parseFloat(match2[1]);
      var type = (match2[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n3 * y3;
        case "weeks":
        case "week":
        case "w":
          return n3 * w3;
        case "days":
        case "day":
        case "d":
          return n3 * d3;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n3 * h3;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n3 * m3;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n3 * s2;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n3;
        default:
          return void 0;
      }
    }
    function fmtShort2(ms3) {
      var msAbs = Math.abs(ms3);
      if (msAbs >= d3) {
        return Math.round(ms3 / d3) + "d";
      }
      if (msAbs >= h3) {
        return Math.round(ms3 / h3) + "h";
      }
      if (msAbs >= m3) {
        return Math.round(ms3 / m3) + "m";
      }
      if (msAbs >= s2) {
        return Math.round(ms3 / s2) + "s";
      }
      return ms3 + "ms";
    }
    function fmtLong2(ms3) {
      var msAbs = Math.abs(ms3);
      if (msAbs >= d3) {
        return plural2(ms3, msAbs, d3, "day");
      }
      if (msAbs >= h3) {
        return plural2(ms3, msAbs, h3, "hour");
      }
      if (msAbs >= m3) {
        return plural2(ms3, msAbs, m3, "minute");
      }
      if (msAbs >= s2) {
        return plural2(ms3, msAbs, s2, "second");
      }
      return ms3 + " ms";
    }
    function plural2(ms3, msAbs, n3, name) {
      var isPlural = msAbs >= n3 * 1.5;
      return Math.round(ms3 / n3) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports2, module2) {
    function setup2(env2) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env2).forEach((key2) => {
        createDebug[key2] = env2[key2];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i2 = 0; i2 < namespace.length; i2++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i2);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug2(...args) {
          if (!debug2.enabled) {
            return;
          }
          const self2 = debug2;
          const curr = Number(new Date());
          const ms3 = curr - (prevTime || curr);
          self2.diff = ms3;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index2 = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match2, format2) => {
            if (match2 === "%%") {
              return "%";
            }
            index2++;
            const formatter2 = createDebug.formatters[format2];
            if (typeof formatter2 === "function") {
              const val = args[index2];
              match2 = formatter2.call(self2, val);
              args.splice(index2, 1);
              index2--;
            }
            return match2;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug2.namespace = namespace;
        debug2.useColors = createDebug.useColors();
        debug2.color = createDebug.selectColor(namespace);
        debug2.extend = extend2;
        debug2.destroy = createDebug.destroy;
        Object.defineProperty(debug2, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v2) => {
            enableOverride = v2;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug2);
        }
        return debug2;
      }
      function extend2(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i2;
        const split2 = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split2.length;
        for (i2 = 0; i2 < len; i2++) {
          if (!split2[i2]) {
            continue;
          }
          namespaces = split2[i2].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i2;
        let len;
        for (i2 = 0, len = createDebug.skips.length; i2 < len; i2++) {
          if (createDebug.skips[i2].test(name)) {
            return false;
          }
        }
        for (i2 = 0, len = createDebug.names.length; i2 < len; i2++) {
          if (createDebug.names[i2].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup2;
  }
});

// node_modules/debug/src/browser.js
var require_browser2 = __commonJS({
  "node_modules/debug/src/browser.js"(exports2, module2) {
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load2;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = (() => {
      let warned2 = false;
      return () => {
        if (!warned2) {
          warned2 = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c3 = "color: " + this.color;
      args.splice(1, 0, c3, "color: inherit");
      let index2 = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match2) => {
        if (match2 === "%%") {
          return;
        }
        index2++;
        if (match2 === "%c") {
          lastC = index2;
        }
      });
      args.splice(lastC, 0, c3);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error2) {
      }
    }
    function load2() {
      let r2;
      try {
        r2 = exports2.storage.getItem("debug");
      } catch (error2) {
      }
      if (!r2 && typeof process !== "undefined" && "env" in process) {
        r2 = process.env.DEBUG;
      }
      return r2;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error2) {
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v2) {
      try {
        return JSON.stringify(v2);
      } catch (error2) {
        return "[UnexpectedJSONParseError]: " + error2.message;
      }
    };
  }
});

// node_modules/vite/dist/node/chunks/dep-611778e0.js
var require_dep_611778e0 = __commonJS({
  "node_modules/vite/dist/node/chunks/dep-611778e0.js"(exports, module) {
    "use strict";
    var fs$n = (init_fs(), __toCommonJS(fs_exports));
    var path$r = (init_path(), __toCommonJS(path_exports));
    var require$$0$2 = (init_tty(), __toCommonJS(tty_exports));
    var require$$0$3 = (init_util(), __toCommonJS(util_exports));
    var require$$3 = (init_net(), __toCommonJS(net_exports));
    var require$$0$6 = (init_events(), __toCommonJS(events_exports));
    var require$$0$4 = (init_url(), __toCommonJS(url_exports));
    var require$$1$3 = (init_http(), __toCommonJS(http_exports));
    var require$$0$7 = (init_stream(), __toCommonJS(stream_exports));
    var require$$1 = (init_os(), __toCommonJS(os_exports));
    var resolve$4 = require_resolve();
    var require$$0$5 = (init_module(), __toCommonJS(module_exports));
    var perf_hooks = (init_perf_hooks(), __toCommonJS(perf_hooks_exports));
    var require$$1$4 = (init_https(), __toCommonJS(https_exports));
    var zlib$1 = (init_zlib(), __toCommonJS(zlib_exports));
    var require$$1$2 = (init_crypto(), __toCommonJS(crypto_exports));
    var require$$4 = (init_tls(), __toCommonJS(tls_exports));
    var require$$5 = (init_assert(), __toCommonJS(assert_exports));
    var esbuild = require_main();
    var require$$0$8 = (init_buffer(), __toCommonJS(buffer_exports));
    var qs = (init_querystring(), __toCommonJS(querystring_exports));
    var require$$1$5 = (init_child_process(), __toCommonJS(child_process_exports));
    var require$$1$1 = (init_worker_threads(), __toCommonJS(worker_threads_exports));
    var readline = (init_readline(), __toCommonJS(readline_exports));
    function _interopDefaultLegacy(e2) {
      return e2 && typeof e2 === "object" && "default" in e2 ? e2["default"] : e2;
    }
    function _interopNamespace(e2) {
      if (e2 && e2.__esModule)
        return e2;
      var n3 = /* @__PURE__ */ Object.create(null);
      if (e2) {
        for (var k2 in e2) {
          n3[k2] = e2[k2];
        }
      }
      n3["default"] = e2;
      return n3;
    }
    var fs__default = _interopDefaultLegacy(fs$n);
    var fs__namespace = _interopNamespace(fs$n);
    var path__default = _interopDefaultLegacy(path$r);
    var require$$0__default = _interopDefaultLegacy(require$$0$2);
    var require$$0__default$1 = _interopDefaultLegacy(require$$0$3);
    var require$$3__default = _interopDefaultLegacy(require$$3);
    var require$$0__default$2 = _interopDefaultLegacy(require$$0$6);
    var require$$0__default$5 = _interopDefaultLegacy(require$$0$4);
    var require$$1__default$2 = _interopDefaultLegacy(require$$1$3);
    var require$$0__default$3 = _interopDefaultLegacy(require$$0$7);
    var require$$1__default = _interopDefaultLegacy(require$$1);
    var resolve__default = _interopDefaultLegacy(resolve$4);
    var require$$0__default$4 = _interopDefaultLegacy(require$$0$5);
    var require$$1__default$4 = _interopDefaultLegacy(require$$1$4);
    var zlib__default = _interopDefaultLegacy(zlib$1);
    var require$$1__default$3 = _interopDefaultLegacy(require$$1$2);
    var require$$4__default = _interopDefaultLegacy(require$$4);
    var require$$5__default = _interopDefaultLegacy(require$$5);
    var require$$0__default$6 = _interopDefaultLegacy(require$$0$8);
    var qs__namespace = _interopNamespace(qs);
    var require$$1__default$5 = _interopDefaultLegacy(require$$1$5);
    var require$$1__default$1 = _interopDefaultLegacy(require$$1$1);
    var readline__default = _interopDefaultLegacy(readline);
    var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    function getDefaultExportFromCjs(x2) {
      return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
    }
    function getAugmentedNamespace(n3) {
      if (n3.__esModule)
        return n3;
      var a2 = Object.defineProperty({}, "__esModule", { value: true });
      Object.keys(n3).forEach(function(k2) {
        var d3 = Object.getOwnPropertyDescriptor(n3, k2);
        Object.defineProperty(a2, k2, d3.get ? d3 : {
          enumerable: true,
          get: function() {
            return n3[k2];
          }
        });
      });
      return a2;
    }
    function commonjsRequire(path2) {
      throw new Error('Could not dynamically require "' + path2 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
    }
    var picocolors = { exports: {} };
    var tty = require$$0__default;
    var isColorSupported = !("NO_COLOR" in process.env || process.argv.includes("--no-color")) && ("FORCE_COLOR" in process.env || process.argv.includes("--color") || process.platform === "win32" || tty.isatty(1) && process.env.TERM !== "dumb" || "CI" in process.env);
    var formatter = (open2, close2, replace2 = open2) => (input) => {
      let string2 = "" + input;
      let index2 = string2.indexOf(close2, open2.length);
      return ~index2 ? open2 + replaceClose(string2, close2, replace2, index2) + close2 : open2 + string2 + close2;
    };
    var replaceClose = (string2, close2, replace2, index2) => {
      let start = string2.substring(0, index2) + replace2;
      let end = string2.substring(index2 + close2.length);
      let nextIndex = end.indexOf(close2);
      return ~nextIndex ? start + replaceClose(end, close2, replace2, nextIndex) : start + end;
    };
    var createColors = (enabled = isColorSupported) => ({
      isColorSupported: enabled,
      reset: enabled ? (s2) => `\x1B[0m${s2}\x1B[0m` : String,
      bold: enabled ? formatter("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m") : String,
      dim: enabled ? formatter("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m") : String,
      italic: enabled ? formatter("\x1B[3m", "\x1B[23m") : String,
      underline: enabled ? formatter("\x1B[4m", "\x1B[24m") : String,
      inverse: enabled ? formatter("\x1B[7m", "\x1B[27m") : String,
      hidden: enabled ? formatter("\x1B[8m", "\x1B[28m") : String,
      strikethrough: enabled ? formatter("\x1B[9m", "\x1B[29m") : String,
      black: enabled ? formatter("\x1B[30m", "\x1B[39m") : String,
      red: enabled ? formatter("\x1B[31m", "\x1B[39m") : String,
      green: enabled ? formatter("\x1B[32m", "\x1B[39m") : String,
      yellow: enabled ? formatter("\x1B[33m", "\x1B[39m") : String,
      blue: enabled ? formatter("\x1B[34m", "\x1B[39m") : String,
      magenta: enabled ? formatter("\x1B[35m", "\x1B[39m") : String,
      cyan: enabled ? formatter("\x1B[36m", "\x1B[39m") : String,
      white: enabled ? formatter("\x1B[37m", "\x1B[39m") : String,
      gray: enabled ? formatter("\x1B[90m", "\x1B[39m") : String,
      bgBlack: enabled ? formatter("\x1B[40m", "\x1B[49m") : String,
      bgRed: enabled ? formatter("\x1B[41m", "\x1B[49m") : String,
      bgGreen: enabled ? formatter("\x1B[42m", "\x1B[49m") : String,
      bgYellow: enabled ? formatter("\x1B[43m", "\x1B[49m") : String,
      bgBlue: enabled ? formatter("\x1B[44m", "\x1B[49m") : String,
      bgMagenta: enabled ? formatter("\x1B[45m", "\x1B[49m") : String,
      bgCyan: enabled ? formatter("\x1B[46m", "\x1B[49m") : String,
      bgWhite: enabled ? formatter("\x1B[47m", "\x1B[49m") : String
    });
    picocolors.exports = createColors();
    picocolors.exports.createColors = createColors;
    var colors$1 = picocolors.exports;
    var src$2 = { exports: {} };
    var browser$1 = { exports: {} };
    var s$1 = 1e3;
    var m$1 = s$1 * 60;
    var h$1 = m$1 * 60;
    var d$1 = h$1 * 24;
    var w = d$1 * 7;
    var y$1 = d$1 * 365.25;
    var ms$1 = function(val, options2) {
      options2 = options2 || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse$o(val);
      } else if (type === "number" && isFinite(val)) {
        return options2.long ? fmtLong$1(val) : fmtShort$1(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse$o(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match2 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
      if (!match2) {
        return;
      }
      var n3 = parseFloat(match2[1]);
      var type = (match2[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n3 * y$1;
        case "weeks":
        case "week":
        case "w":
          return n3 * w;
        case "days":
        case "day":
        case "d":
          return n3 * d$1;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n3 * h$1;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n3 * m$1;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n3 * s$1;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n3;
        default:
          return void 0;
      }
    }
    function fmtShort$1(ms3) {
      var msAbs = Math.abs(ms3);
      if (msAbs >= d$1) {
        return Math.round(ms3 / d$1) + "d";
      }
      if (msAbs >= h$1) {
        return Math.round(ms3 / h$1) + "h";
      }
      if (msAbs >= m$1) {
        return Math.round(ms3 / m$1) + "m";
      }
      if (msAbs >= s$1) {
        return Math.round(ms3 / s$1) + "s";
      }
      return ms3 + "ms";
    }
    function fmtLong$1(ms3) {
      var msAbs = Math.abs(ms3);
      if (msAbs >= d$1) {
        return plural$1(ms3, msAbs, d$1, "day");
      }
      if (msAbs >= h$1) {
        return plural$1(ms3, msAbs, h$1, "hour");
      }
      if (msAbs >= m$1) {
        return plural$1(ms3, msAbs, m$1, "minute");
      }
      if (msAbs >= s$1) {
        return plural$1(ms3, msAbs, s$1, "second");
      }
      return ms3 + " ms";
    }
    function plural$1(ms3, msAbs, n3, name) {
      var isPlural = msAbs >= n3 * 1.5;
      return Math.round(ms3 / n3) + " " + name + (isPlural ? "s" : "");
    }
    function setup(env2) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = ms$1;
      createDebug.destroy = destroy;
      Object.keys(env2).forEach((key2) => {
        createDebug[key2] = env2[key2];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i2 = 0; i2 < namespace.length; i2++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i2);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug2(...args) {
          if (!debug2.enabled) {
            return;
          }
          const self2 = debug2;
          const curr = Number(new Date());
          const ms3 = curr - (prevTime || curr);
          self2.diff = ms3;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index2 = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match2, format2) => {
            if (match2 === "%%") {
              return "%";
            }
            index2++;
            const formatter2 = createDebug.formatters[format2];
            if (typeof formatter2 === "function") {
              const val = args[index2];
              match2 = formatter2.call(self2, val);
              args.splice(index2, 1);
              index2--;
            }
            return match2;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug2.namespace = namespace;
        debug2.useColors = createDebug.useColors();
        debug2.color = createDebug.selectColor(namespace);
        debug2.extend = extend2;
        debug2.destroy = createDebug.destroy;
        Object.defineProperty(debug2, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v2) => {
            enableOverride = v2;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug2);
        }
        return debug2;
      }
      function extend2(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i2;
        const split2 = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split2.length;
        for (i2 = 0; i2 < len; i2++) {
          if (!split2[i2]) {
            continue;
          }
          namespaces = split2[i2].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i2;
        let len;
        for (i2 = 0, len = createDebug.skips.length; i2 < len; i2++) {
          if (createDebug.skips[i2].test(name)) {
            return false;
          }
        }
        for (i2 = 0, len = createDebug.names.length; i2 < len; i2++) {
          if (createDebug.names[i2].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    var common$e = setup;
    (function(module2, exports2) {
      exports2.formatArgs = formatArgs;
      exports2.save = save;
      exports2.load = load2;
      exports2.useColors = useColors;
      exports2.storage = localstorage();
      exports2.destroy = (() => {
        let warned2 = false;
        return () => {
          if (!warned2) {
            warned2 = true;
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
          }
        };
      })();
      exports2.colors = [
        "#0000CC",
        "#0000FF",
        "#0033CC",
        "#0033FF",
        "#0066CC",
        "#0066FF",
        "#0099CC",
        "#0099FF",
        "#00CC00",
        "#00CC33",
        "#00CC66",
        "#00CC99",
        "#00CCCC",
        "#00CCFF",
        "#3300CC",
        "#3300FF",
        "#3333CC",
        "#3333FF",
        "#3366CC",
        "#3366FF",
        "#3399CC",
        "#3399FF",
        "#33CC00",
        "#33CC33",
        "#33CC66",
        "#33CC99",
        "#33CCCC",
        "#33CCFF",
        "#6600CC",
        "#6600FF",
        "#6633CC",
        "#6633FF",
        "#66CC00",
        "#66CC33",
        "#9900CC",
        "#9900FF",
        "#9933CC",
        "#9933FF",
        "#99CC00",
        "#99CC33",
        "#CC0000",
        "#CC0033",
        "#CC0066",
        "#CC0099",
        "#CC00CC",
        "#CC00FF",
        "#CC3300",
        "#CC3333",
        "#CC3366",
        "#CC3399",
        "#CC33CC",
        "#CC33FF",
        "#CC6600",
        "#CC6633",
        "#CC9900",
        "#CC9933",
        "#CCCC00",
        "#CCCC33",
        "#FF0000",
        "#FF0033",
        "#FF0066",
        "#FF0099",
        "#FF00CC",
        "#FF00FF",
        "#FF3300",
        "#FF3333",
        "#FF3366",
        "#FF3399",
        "#FF33CC",
        "#FF33FF",
        "#FF6600",
        "#FF6633",
        "#FF9900",
        "#FF9933",
        "#FFCC00",
        "#FFCC33"
      ];
      function useColors() {
        if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
          return true;
        }
        if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
          return false;
        }
        return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
      }
      function formatArgs(args) {
        args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
        if (!this.useColors) {
          return;
        }
        const c3 = "color: " + this.color;
        args.splice(1, 0, c3, "color: inherit");
        let index2 = 0;
        let lastC = 0;
        args[0].replace(/%[a-zA-Z%]/g, (match2) => {
          if (match2 === "%%") {
            return;
          }
          index2++;
          if (match2 === "%c") {
            lastC = index2;
          }
        });
        args.splice(lastC, 0, c3);
      }
      exports2.log = console.debug || console.log || (() => {
      });
      function save(namespaces) {
        try {
          if (namespaces) {
            exports2.storage.setItem("debug", namespaces);
          } else {
            exports2.storage.removeItem("debug");
          }
        } catch (error2) {
        }
      }
      function load2() {
        let r2;
        try {
          r2 = exports2.storage.getItem("debug");
        } catch (error2) {
        }
        if (!r2 && typeof process !== "undefined" && "env" in process) {
          r2 = process.env.DEBUG;
        }
        return r2;
      }
      function localstorage() {
        try {
          return localStorage;
        } catch (error2) {
        }
      }
      module2.exports = common$e(exports2);
      const { formatters } = module2.exports;
      formatters.j = function(v2) {
        try {
          return JSON.stringify(v2);
        } catch (error2) {
          return "[UnexpectedJSONParseError]: " + error2.message;
        }
      };
    })(browser$1, browser$1.exports);
    var node$1 = { exports: {} };
    (function(module2, exports2) {
      const tty2 = require$$0__default;
      const util2 = require$$0__default$1;
      exports2.init = init2;
      exports2.log = log2;
      exports2.formatArgs = formatArgs;
      exports2.save = save;
      exports2.load = load2;
      exports2.useColors = useColors;
      exports2.destroy = util2.deprecate(() => {
      }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      exports2.colors = [6, 2, 3, 4, 5, 1];
      try {
        const supportsColor = require_browser();
        if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
          exports2.colors = [
            20,
            21,
            26,
            27,
            32,
            33,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            56,
            57,
            62,
            63,
            68,
            69,
            74,
            75,
            76,
            77,
            78,
            79,
            80,
            81,
            92,
            93,
            98,
            99,
            112,
            113,
            128,
            129,
            134,
            135,
            148,
            149,
            160,
            161,
            162,
            163,
            164,
            165,
            166,
            167,
            168,
            169,
            170,
            171,
            172,
            173,
            178,
            179,
            184,
            185,
            196,
            197,
            198,
            199,
            200,
            201,
            202,
            203,
            204,
            205,
            206,
            207,
            208,
            209,
            214,
            215,
            220,
            221
          ];
        }
      } catch (error2) {
      }
      exports2.inspectOpts = Object.keys(process.env).filter((key2) => {
        return /^debug_/i.test(key2);
      }).reduce((obj, key2) => {
        const prop = key2.substring(6).toLowerCase().replace(/_([a-z])/g, (_2, k2) => {
          return k2.toUpperCase();
        });
        let val = process.env[key2];
        if (/^(yes|on|true|enabled)$/i.test(val)) {
          val = true;
        } else if (/^(no|off|false|disabled)$/i.test(val)) {
          val = false;
        } else if (val === "null") {
          val = null;
        } else {
          val = Number(val);
        }
        obj[prop] = val;
        return obj;
      }, {});
      function useColors() {
        return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty2.isatty(process.stderr.fd);
      }
      function formatArgs(args) {
        const { namespace: name, useColors: useColors2 } = this;
        if (useColors2) {
          const c3 = this.color;
          const colorCode = "\x1B[3" + (c3 < 8 ? c3 : "8;5;" + c3);
          const prefix = `  ${colorCode};1m${name} \x1B[0m`;
          args[0] = prefix + args[0].split("\n").join("\n" + prefix);
          args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
        } else {
          args[0] = getDate() + name + " " + args[0];
        }
      }
      function getDate() {
        if (exports2.inspectOpts.hideDate) {
          return "";
        }
        return new Date().toISOString() + " ";
      }
      function log2(...args) {
        return process.stderr.write(util2.format(...args) + "\n");
      }
      function save(namespaces) {
        if (namespaces) {
          process.env.DEBUG = namespaces;
        } else {
          delete process.env.DEBUG;
        }
      }
      function load2() {
        return process.env.DEBUG;
      }
      function init2(debug2) {
        debug2.inspectOpts = {};
        const keys = Object.keys(exports2.inspectOpts);
        for (let i2 = 0; i2 < keys.length; i2++) {
          debug2.inspectOpts[keys[i2]] = exports2.inspectOpts[keys[i2]];
        }
      }
      module2.exports = common$e(exports2);
      const { formatters } = module2.exports;
      formatters.o = function(v2) {
        this.inspectOpts.colors = this.useColors;
        return util2.inspect(v2, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
      };
      formatters.O = function(v2) {
        this.inspectOpts.colors = this.useColors;
        return util2.inspect(v2, this.inspectOpts);
      };
    })(node$1, node$1.exports);
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      src$2.exports = browser$1.exports;
    } else {
      src$2.exports = node$1.exports;
    }
    var _debug = src$2.exports;
    var DEFAULT_MAIN_FIELDS = [
      "module",
      "jsnext:main",
      "jsnext"
    ];
    var DEFAULT_EXTENSIONS$1 = [
      ".mjs",
      ".js",
      ".ts",
      ".jsx",
      ".tsx",
      ".json"
    ];
    var JS_TYPES_RE = /\.(?:j|t)sx?$|\.mjs$/;
    var OPTIMIZABLE_ENTRY_RE = /\.(?:m?js|ts)$/;
    var SPECIAL_QUERY_RE = /[\?&](?:worker|sharedworker|raw|url)\b/;
    var FS_PREFIX = `/@fs/`;
    var VALID_ID_PREFIX = `/@id/`;
    var NULL_BYTE_PLACEHOLDER = `__x00__`;
    var CLIENT_PUBLIC_PATH = `/@vite/client`;
    var ENV_PUBLIC_PATH = `/@vite/env`;
    var CLIENT_ENTRY = __require.resolve("vite/dist/client/client.mjs");
    var ENV_ENTRY = __require.resolve("vite/dist/client/env.mjs");
    var CLIENT_DIR = path__default.dirname(CLIENT_ENTRY);
    var KNOWN_ASSET_TYPES = [
      "png",
      "jpe?g",
      "gif",
      "svg",
      "ico",
      "webp",
      "avif",
      "mp4",
      "webm",
      "ogg",
      "mp3",
      "wav",
      "flac",
      "aac",
      "woff2?",
      "eot",
      "ttf",
      "otf",
      "wasm",
      "webmanifest",
      "pdf",
      "txt"
    ];
    var DEFAULT_ASSETS_RE = new RegExp(`\\.(` + KNOWN_ASSET_TYPES.join("|") + `)(\\?.*)?$`);
    var DEP_VERSION_RE = /[\?&](v=[\w\.-]+)\b/;
    var comma = 44;
    var semicolon = 59;
    var chars$2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    var intToChar = new Uint8Array(65);
    var charToInteger$1 = new Uint8Array(123);
    for (let i2 = 0; i2 < chars$2.length; i2++) {
      const c3 = chars$2.charCodeAt(i2);
      charToInteger$1[c3] = i2;
      intToChar[i2] = c3;
    }
    var td = typeof TextDecoder !== "undefined" ? new TextDecoder() : typeof Buffer !== "undefined" ? {
      decode(buf) {
        const out2 = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
        return out2.toString();
      }
    } : {
      decode(buf) {
        let out2 = "";
        for (let i2 = 0; i2 < buf.length; i2++) {
          out2 += String.fromCharCode(buf[i2]);
        }
        return out2;
      }
    };
    function decode(mappings) {
      const state = new Int32Array(5);
      const decoded = [];
      let line2 = [];
      let sorted = true;
      let lastCol = 0;
      for (let i2 = 0; i2 < mappings.length; ) {
        const c3 = mappings.charCodeAt(i2);
        if (c3 === comma) {
          i2++;
        } else if (c3 === semicolon) {
          state[0] = lastCol = 0;
          if (!sorted)
            sort(line2);
          sorted = true;
          decoded.push(line2);
          line2 = [];
          i2++;
        } else {
          i2 = decodeInteger(mappings, i2, state, 0);
          const col = state[0];
          if (col < lastCol)
            sorted = false;
          lastCol = col;
          if (!hasMoreSegments(mappings, i2)) {
            line2.push([col]);
            continue;
          }
          i2 = decodeInteger(mappings, i2, state, 1);
          i2 = decodeInteger(mappings, i2, state, 2);
          i2 = decodeInteger(mappings, i2, state, 3);
          if (!hasMoreSegments(mappings, i2)) {
            line2.push([col, state[1], state[2], state[3]]);
            continue;
          }
          i2 = decodeInteger(mappings, i2, state, 4);
          line2.push([col, state[1], state[2], state[3], state[4]]);
        }
      }
      if (!sorted)
        sort(line2);
      decoded.push(line2);
      return decoded;
    }
    function decodeInteger(mappings, pos2, state, j2) {
      let value = 0;
      let shift = 0;
      let integer = 0;
      do {
        const c3 = mappings.charCodeAt(pos2++);
        integer = charToInteger$1[c3];
        value |= (integer & 31) << shift;
        shift += 5;
      } while (integer & 32);
      const shouldNegate = value & 1;
      value >>>= 1;
      if (shouldNegate) {
        value = value === 0 ? -2147483648 : -value;
      }
      state[j2] += value;
      return pos2;
    }
    function hasMoreSegments(mappings, i2) {
      if (i2 >= mappings.length)
        return false;
      const c3 = mappings.charCodeAt(i2);
      if (c3 === comma || c3 === semicolon)
        return false;
      return true;
    }
    function sort(line2) {
      line2.sort(sortComparator$1);
    }
    function sortComparator$1(a2, b2) {
      return a2[0] - b2[0];
    }
    function encode$1(decoded) {
      const state = new Int32Array(5);
      let buf = new Uint8Array(1e3);
      let pos2 = 0;
      for (let i2 = 0; i2 < decoded.length; i2++) {
        const line2 = decoded[i2];
        if (i2 > 0) {
          buf = reserve(buf, pos2, 1);
          buf[pos2++] = semicolon;
        }
        if (line2.length === 0)
          continue;
        state[0] = 0;
        for (let j2 = 0; j2 < line2.length; j2++) {
          const segment = line2[j2];
          buf = reserve(buf, pos2, 36);
          if (j2 > 0)
            buf[pos2++] = comma;
          pos2 = encodeInteger$1(buf, pos2, state, segment, 0);
          if (segment.length === 1)
            continue;
          pos2 = encodeInteger$1(buf, pos2, state, segment, 1);
          pos2 = encodeInteger$1(buf, pos2, state, segment, 2);
          pos2 = encodeInteger$1(buf, pos2, state, segment, 3);
          if (segment.length === 4)
            continue;
          pos2 = encodeInteger$1(buf, pos2, state, segment, 4);
        }
      }
      return td.decode(buf.subarray(0, pos2));
    }
    function reserve(buf, pos2, count) {
      if (buf.length > pos2 + count)
        return buf;
      const swap = new Uint8Array(buf.length * 2);
      swap.set(buf);
      return swap;
    }
    function encodeInteger$1(buf, pos2, state, segment, j2) {
      const next = segment[j2];
      let num = next - state[j2];
      state[j2] = next;
      num = num < 0 ? -num << 1 | 1 : num << 1;
      do {
        let clamped = num & 31;
        num >>>= 5;
        if (num > 0)
          clamped |= 32;
        buf[pos2++] = intToChar[clamped];
      } while (num > 0);
      return pos2;
    }
    var schemeRegex = /^[\w+.-]+:\/\//;
    var urlRegex = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?/;
    function isAbsoluteUrl(input) {
      return schemeRegex.test(input);
    }
    function isSchemeRelativeUrl(input) {
      return input.startsWith("//");
    }
    function isAbsolutePath(input) {
      return input.startsWith("/");
    }
    function parseAbsoluteUrl(input) {
      const match2 = urlRegex.exec(input);
      return {
        scheme: match2[1],
        user: match2[2] || "",
        host: match2[3],
        port: match2[4] || "",
        path: match2[5] || "/",
        relativePath: false
      };
    }
    function parseUrl$2(input) {
      if (isSchemeRelativeUrl(input)) {
        const url2 = parseAbsoluteUrl("http:" + input);
        url2.scheme = "";
        return url2;
      }
      if (isAbsolutePath(input)) {
        const url2 = parseAbsoluteUrl("http://foo.com" + input);
        url2.scheme = "";
        url2.host = "";
        return url2;
      }
      if (!isAbsoluteUrl(input)) {
        const url2 = parseAbsoluteUrl("http://foo.com/" + input);
        url2.scheme = "";
        url2.host = "";
        url2.relativePath = true;
        return url2;
      }
      return parseAbsoluteUrl(input);
    }
    function stripPathFilename(path2) {
      if (path2.endsWith("/.."))
        return path2;
      const index2 = path2.lastIndexOf("/");
      return path2.slice(0, index2 + 1);
    }
    function mergePaths(url2, base2) {
      if (!url2.relativePath)
        return;
      normalizePath$5(base2);
      if (url2.path === "/") {
        url2.path = base2.path;
      } else {
        url2.path = stripPathFilename(base2.path) + url2.path;
      }
      url2.relativePath = base2.relativePath;
    }
    function normalizePath$5(url2) {
      const { relativePath } = url2;
      const pieces = url2.path.split("/");
      let pointer = 1;
      let positive = 0;
      let addTrailingSlash = false;
      for (let i2 = 1; i2 < pieces.length; i2++) {
        const piece = pieces[i2];
        if (!piece) {
          addTrailingSlash = true;
          continue;
        }
        addTrailingSlash = false;
        if (piece === ".")
          continue;
        if (piece === "..") {
          if (positive) {
            addTrailingSlash = true;
            positive--;
            pointer--;
          } else if (relativePath) {
            pieces[pointer++] = piece;
          }
          continue;
        }
        pieces[pointer++] = piece;
        positive++;
      }
      let path2 = "";
      for (let i2 = 1; i2 < pointer; i2++) {
        path2 += "/" + pieces[i2];
      }
      if (!path2 || addTrailingSlash && !path2.endsWith("/..")) {
        path2 += "/";
      }
      url2.path = path2;
    }
    function resolve$3(input, base2) {
      if (!input && !base2)
        return "";
      const url2 = parseUrl$2(input);
      if (base2 && !url2.scheme) {
        const baseUrl = parseUrl$2(base2);
        url2.scheme = baseUrl.scheme;
        if (!url2.host || baseUrl.scheme === "file:") {
          url2.user = baseUrl.user;
          url2.host = baseUrl.host;
          url2.port = baseUrl.port;
        }
        mergePaths(url2, baseUrl);
      }
      normalizePath$5(url2);
      if (url2.relativePath) {
        const path2 = url2.path.slice(1);
        if (!path2)
          return ".";
        const keepRelative = (base2 || input).startsWith(".");
        return !keepRelative || path2.startsWith(".") ? path2 : "./" + path2;
      }
      if (!url2.scheme && !url2.host)
        return url2.path;
      return `${url2.scheme}//${url2.user}${url2.host}${url2.port}${url2.path}`;
    }
    function resolve$2(input, base2) {
      if (base2 && !base2.endsWith("/"))
        base2 += "/";
      return resolve$3(input, base2);
    }
    function stripFilename(path2) {
      if (!path2)
        return "";
      const index2 = path2.lastIndexOf("/");
      return path2.slice(0, index2 + 1);
    }
    function maybeSort(mappings, owned) {
      const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);
      if (unsortedIndex === mappings.length)
        return mappings;
      if (!owned)
        mappings = mappings.slice();
      for (let i2 = unsortedIndex; i2 < mappings.length; i2 = nextUnsortedSegmentLine(mappings, i2 + 1)) {
        mappings[i2] = sortSegments(mappings[i2], owned);
      }
      return mappings;
    }
    function nextUnsortedSegmentLine(mappings, start) {
      for (let i2 = start; i2 < mappings.length; i2++) {
        if (!isSorted(mappings[i2]))
          return i2;
      }
      return mappings.length;
    }
    function isSorted(line2) {
      for (let j2 = 1; j2 < line2.length; j2++) {
        if (line2[j2][0] < line2[j2 - 1][0]) {
          return false;
        }
      }
      return true;
    }
    function sortSegments(line2, owned) {
      if (!owned)
        line2 = line2.slice();
      return line2.sort(sortComparator);
    }
    function sortComparator(a2, b2) {
      return a2[0] - b2[0];
    }
    function binarySearch(haystack, needle, low, high) {
      while (low <= high) {
        const mid = low + (high - low >> 1);
        const cmp = haystack[mid][0] - needle;
        if (cmp === 0) {
          return mid;
        }
        if (cmp < 0) {
          low = mid + 1;
        } else {
          high = mid - 1;
        }
      }
      return low - 1;
    }
    function memoizedState() {
      return {
        lastKey: -1,
        lastNeedle: -1,
        lastIndex: -1
      };
    }
    function memoizedBinarySearch(haystack, needle, state, key2) {
      const { lastKey, lastNeedle, lastIndex } = state;
      let low = 0;
      let high = haystack.length - 1;
      if (key2 === lastKey) {
        if (needle === lastNeedle) {
          return lastIndex;
        }
        if (needle >= lastNeedle) {
          low = Math.max(lastIndex, 0);
        } else {
          high = lastIndex;
        }
      }
      state.lastKey = key2;
      state.lastNeedle = needle;
      return state.lastIndex = binarySearch(haystack, needle, low, high);
    }
    var INVALID_MAPPING$1 = Object.freeze({
      source: null,
      line: null,
      column: null,
      name: null
    });
    var encodedMappings;
    var decodedMappings;
    var traceSegment;
    var originalPositionFor;
    var presortedDecodedMap;
    var TraceMap = class {
      constructor(map2, mapUrl) {
        this._binarySearchMemo = memoizedState();
        const isString2 = typeof map2 === "string";
        const parsed = isString2 ? JSON.parse(map2) : map2;
        const { version: version2, file, names, sourceRoot, sources, sourcesContent } = parsed;
        this.version = version2;
        this.file = file;
        this.names = names;
        this.sourceRoot = sourceRoot;
        this.sources = sources;
        this.sourcesContent = sourcesContent;
        if (sourceRoot || mapUrl) {
          const from = resolve$2(sourceRoot || "", stripFilename(mapUrl));
          this.resolvedSources = sources.map((s2) => resolve$2(s2 || "", from));
        } else {
          this.resolvedSources = sources.map((s2) => s2 || "");
        }
        const { mappings } = parsed;
        if (typeof mappings === "string") {
          this._encoded = mappings;
          this._decoded = decode(mappings);
        } else {
          this._encoded = void 0;
          this._decoded = maybeSort(mappings, isString2);
        }
      }
    };
    (() => {
      encodedMappings = (map2) => {
        var _a2;
        return (_a2 = map2._encoded) !== null && _a2 !== void 0 ? _a2 : map2._encoded = encode$1(map2._decoded);
      };
      decodedMappings = (map2) => {
        return map2._decoded;
      };
      traceSegment = (map2, line2, column2) => {
        const decoded = map2._decoded;
        if (line2 >= decoded.length)
          return null;
        const segments = decoded[line2];
        const index2 = memoizedBinarySearch(segments, column2, map2._binarySearchMemo, line2);
        if (index2 < 0)
          return null;
        return segments[index2];
      };
      originalPositionFor = (map2, { line: line2, column: column2 }) => {
        if (line2 < 1)
          throw new Error("`line` must be greater than 0 (lines start at line 1)");
        if (column2 < 0) {
          throw new Error("`column` must be greater than or equal to 0 (columns start at column 0)");
        }
        const segment = traceSegment(map2, line2 - 1, column2);
        if (segment == null)
          return INVALID_MAPPING$1;
        if (segment.length == 1)
          return INVALID_MAPPING$1;
        const { names, resolvedSources } = map2;
        return {
          source: resolvedSources[segment[1]],
          line: segment[2] + 1,
          column: segment[3],
          name: segment.length === 5 ? names[segment[4]] : null
        };
      };
      presortedDecodedMap = (map2, mapUrl) => {
        const clone = Object.assign({}, map2);
        clone.mappings = [];
        const tracer = new TraceMap(clone, mapUrl);
        tracer._decoded = map2.mappings;
        return tracer;
      };
    })();
    var OriginalSource = class {
      constructor(source2, content2) {
        this.source = source2;
        this.content = content2;
      }
      originalPositionFor(line2, column2, name) {
        return { column: column2, line: line2, name, source: this.source, content: this.content };
      }
    };
    var put;
    var FastStringArray = class {
      constructor() {
        this.indexes = /* @__PURE__ */ Object.create(null);
        this.array = [];
      }
    };
    (() => {
      put = (strarr, key2) => {
        const { array: array2, indexes } = strarr;
        let index2 = indexes[key2];
        if (index2 === void 0) {
          index2 = indexes[key2] = array2.length;
          array2.push(key2);
        }
        return index2;
      };
    })();
    var INVALID_MAPPING = void 0;
    var SOURCELESS_MAPPING = null;
    var traceMappings;
    var SourceMapTree = class {
      constructor(map2, sources) {
        this.map = map2;
        this.sources = sources;
      }
      originalPositionFor(line2, column2, name) {
        const segment = traceSegment(this.map, line2, column2);
        if (segment == null)
          return INVALID_MAPPING;
        if (segment.length === 1)
          return SOURCELESS_MAPPING;
        const source2 = this.sources[segment[1]];
        return source2.originalPositionFor(segment[2], segment[3], segment.length === 5 ? this.map.names[segment[4]] : name);
      }
    };
    (() => {
      traceMappings = (tree) => {
        const mappings = [];
        const names = new FastStringArray();
        const sources = new FastStringArray();
        const sourcesContent = [];
        const { sources: rootSources, map: map2 } = tree;
        const rootNames = map2.names;
        const rootMappings = decodedMappings(map2);
        let lastLineWithSegment = -1;
        for (let i2 = 0; i2 < rootMappings.length; i2++) {
          const segments = rootMappings[i2];
          const tracedSegments = [];
          let lastSourcesIndex = -1;
          let lastSourceLine = -1;
          let lastSourceColumn = -1;
          for (let j2 = 0; j2 < segments.length; j2++) {
            const segment = segments[j2];
            let traced = SOURCELESS_MAPPING;
            if (segment.length !== 1) {
              const source3 = rootSources[segment[1]];
              traced = source3.originalPositionFor(segment[2], segment[3], segment.length === 5 ? rootNames[segment[4]] : "");
              if (traced === INVALID_MAPPING)
                continue;
            }
            const genCol = segment[0];
            if (traced === SOURCELESS_MAPPING) {
              if (lastSourcesIndex === -1) {
                continue;
              }
              lastSourcesIndex = lastSourceLine = lastSourceColumn = -1;
              tracedSegments.push([genCol]);
              continue;
            }
            const { column: column2, line: line2, name, content: content2, source: source2 } = traced;
            const sourcesIndex = put(sources, source2);
            sourcesContent[sourcesIndex] = content2;
            if (lastSourcesIndex === sourcesIndex && lastSourceLine === line2 && lastSourceColumn === column2) {
              continue;
            }
            lastLineWithSegment = i2;
            lastSourcesIndex = sourcesIndex;
            lastSourceLine = line2;
            lastSourceColumn = column2;
            tracedSegments.push(name ? [genCol, sourcesIndex, line2, column2, put(names, name)] : [genCol, sourcesIndex, line2, column2]);
          }
          mappings.push(tracedSegments);
        }
        if (mappings.length > lastLineWithSegment + 1) {
          mappings.length = lastLineWithSegment + 1;
        }
        return presortedDecodedMap(Object.assign({}, tree.map, {
          mappings,
          sourceRoot: void 0,
          names: names.array,
          sources: sources.array,
          sourcesContent
        }));
      };
    })();
    function asArray(value) {
      if (Array.isArray(value))
        return value;
      return [value];
    }
    function buildSourceMapTree(input, loader) {
      const maps = asArray(input).map((m3) => new TraceMap(m3, ""));
      const map2 = maps.pop();
      for (let i2 = 0; i2 < maps.length; i2++) {
        if (maps[i2].sources.length > 1) {
          throw new Error(`Transformation map ${i2} must have exactly one source file.
Did you specify these with the most recent transformation maps first?`);
        }
      }
      let tree = build$2(map2, loader, "", 0);
      for (let i2 = maps.length - 1; i2 >= 0; i2--) {
        tree = new SourceMapTree(maps[i2], [tree]);
      }
      return tree;
    }
    function build$2(map2, loader, importer, importerDepth) {
      const { resolvedSources, sourcesContent } = map2;
      const depth2 = importerDepth + 1;
      const children = resolvedSources.map((sourceFile, i2) => {
        const ctx = {
          importer,
          depth: depth2,
          source: sourceFile || "",
          content: void 0
        };
        const sourceMap = loader(ctx.source, ctx);
        const { source: source2, content: content2 } = ctx;
        if (!sourceMap) {
          const sourceContent = content2 !== void 0 ? content2 : sourcesContent ? sourcesContent[i2] : null;
          return new OriginalSource(source2, sourceContent);
        }
        return build$2(new TraceMap(sourceMap, source2), loader, source2, depth2);
      });
      return new SourceMapTree(map2, children);
    }
    var SourceMap$2 = class {
      constructor(map2, options2) {
        this.version = 3;
        this.file = map2.file;
        this.mappings = options2.decodedMappings ? decodedMappings(map2) : encodedMappings(map2);
        this.names = map2.names;
        this.sourceRoot = map2.sourceRoot;
        this.sources = map2.sources;
        if (!options2.excludeContent && "sourcesContent" in map2) {
          this.sourcesContent = map2.sourcesContent;
        }
      }
      toString() {
        return JSON.stringify(this);
      }
    };
    function remapping(input, loader, options2) {
      const opts = typeof options2 === "object" ? options2 : { excludeContent: !!options2, decodedMappings: false };
      const tree = buildSourceMapTree(input, loader);
      return new SourceMap$2(traceMappings(tree), opts);
    }
    function slash$1(p2) {
      return p2.replace(/\\/g, "/");
    }
    function unwrapId$1(id) {
      return id.startsWith(VALID_ID_PREFIX) ? id.slice(VALID_ID_PREFIX.length) : id;
    }
    var flattenId = (id) => id.replace(/(\s*>\s*)/g, "__").replace(/[\/\.:]/g, "_");
    var normalizeId = (id) => id.replace(/(\s*>\s*)/g, " > ");
    var builtins$2 = /* @__PURE__ */ new Set([
      ...require$$0$5.builtinModules,
      "assert/strict",
      "diagnostics_channel",
      "dns/promises",
      "fs/promises",
      "path/posix",
      "path/win32",
      "readline/promises",
      "stream/consumers",
      "stream/promises",
      "stream/web",
      "timers/promises",
      "util/types",
      "wasi"
    ]);
    function isBuiltin(id) {
      return builtins$2.has(id.replace(/^node:/, ""));
    }
    function moduleListContains(moduleList, id) {
      return moduleList === null || moduleList === void 0 ? void 0 : moduleList.some((m3) => m3 === id || id.startsWith(m3 + "/"));
    }
    var bareImportRE = /^[\w@](?!.*:\/\/)/;
    var isRunningWithYarnPnp;
    try {
      isRunningWithYarnPnp = Boolean(__require("pnpapi"));
    } catch {
    }
    var ssrExtensions = [".js", ".cjs", ".json", ".node"];
    function resolveFrom(id, basedir, preserveSymlinks = false, ssr = false) {
      return resolve__default.sync(id, {
        basedir,
        extensions: ssr ? ssrExtensions : DEFAULT_EXTENSIONS$1,
        preserveSymlinks: preserveSymlinks || isRunningWithYarnPnp || false
      });
    }
    function nestedResolveFrom(id, basedir, preserveSymlinks = false) {
      const pkgs = id.split(">").map((pkg) => pkg.trim());
      try {
        for (const pkg of pkgs) {
          basedir = resolveFrom(pkg, basedir, preserveSymlinks);
        }
      } catch {
      }
      return basedir;
    }
    var filter$1 = process.env.VITE_DEBUG_FILTER;
    var DEBUG$1 = process.env.DEBUG;
    function createDebugger(namespace, options2 = {}) {
      const log2 = _debug(namespace);
      const { onlyWhenFocused } = options2;
      const focus = typeof onlyWhenFocused === "string" ? onlyWhenFocused : namespace;
      return (msg, ...args) => {
        if (filter$1 && !msg.includes(filter$1)) {
          return;
        }
        if (onlyWhenFocused && !(DEBUG$1 === null || DEBUG$1 === void 0 ? void 0 : DEBUG$1.includes(focus))) {
          return;
        }
        log2(msg, ...args);
      };
    }
    function testCaseInsensitiveFS() {
      if (!CLIENT_ENTRY.endsWith("client.mjs")) {
        throw new Error(`cannot test case insensitive FS, CLIENT_ENTRY const doesn't contain client.mjs`);
      }
      if (!fs__default.existsSync(CLIENT_ENTRY)) {
        throw new Error("cannot test case insensitive FS, CLIENT_ENTRY does not point to an existing file: " + CLIENT_ENTRY);
      }
      return fs__default.existsSync(CLIENT_ENTRY.replace("client.mjs", "cLiEnT.mjs"));
    }
    var isCaseInsensitiveFS = testCaseInsensitiveFS();
    var isWindows$4 = require$$1__default.platform() === "win32";
    var VOLUME_RE = /^[A-Z]:/i;
    function normalizePath$4(id) {
      return path__default.posix.normalize(isWindows$4 ? slash$1(id) : id);
    }
    function fsPathFromId(id) {
      const fsPath = normalizePath$4(id.startsWith(FS_PREFIX) ? id.slice(FS_PREFIX.length) : id);
      return fsPath.startsWith("/") || fsPath.match(VOLUME_RE) ? fsPath : `/${fsPath}`;
    }
    function fsPathFromUrl(url2) {
      return fsPathFromId(cleanUrl(url2));
    }
    function isParentDirectory(dir, file) {
      if (!dir.endsWith("/")) {
        dir = `${dir}/`;
      }
      return file.startsWith(dir) || isCaseInsensitiveFS && file.toLowerCase().startsWith(dir.toLowerCase());
    }
    function ensureVolumeInPath(file) {
      return isWindows$4 ? path__default.resolve(file) : file;
    }
    var queryRE = /\?.*$/s;
    var hashRE = /#.*$/s;
    var cleanUrl = (url2) => url2.replace(hashRE, "").replace(queryRE, "");
    var externalRE = /^(https?:)?\/\//;
    var isExternalUrl = (url2) => externalRE.test(url2);
    var dataUrlRE = /^\s*data:/i;
    var isDataUrl = (url2) => dataUrlRE.test(url2);
    var virtualModuleRE = /^virtual-module:.*/;
    var virtualModulePrefix = "virtual-module:";
    var knownJsSrcRE = /\.((j|t)sx?|mjs|vue|marko|svelte|astro)($|\?)/;
    var isJSRequest = (url2) => {
      url2 = cleanUrl(url2);
      if (knownJsSrcRE.test(url2)) {
        return true;
      }
      if (!path__default.extname(url2) && !url2.endsWith("/")) {
        return true;
      }
      return false;
    };
    var knownTsRE = /\.(ts|mts|cts|tsx)$/;
    var knownTsOutputRE = /\.(js|mjs|cjs|jsx)$/;
    var isTsRequest = (url2) => knownTsRE.test(cleanUrl(url2));
    var isPossibleTsOutput = (url2) => knownTsOutputRE.test(cleanUrl(url2));
    function getPotentialTsSrcPaths(filePath) {
      const [name, type, query = ""] = filePath.split(/(\.(?:[cm]?js|jsx))(\?.*)?$/);
      const paths = [name + type.replace("js", "ts") + query];
      if (!type.endsWith("x")) {
        paths.push(name + type.replace("js", "tsx") + query);
      }
      return paths;
    }
    var importQueryRE = /(\?|&)import=?(?:&|$)/;
    var internalPrefixes = [
      FS_PREFIX,
      VALID_ID_PREFIX,
      CLIENT_PUBLIC_PATH,
      ENV_PUBLIC_PATH
    ];
    var InternalPrefixRE = new RegExp(`^(?:${internalPrefixes.join("|")})`);
    var trailingSeparatorRE = /[\?&]$/;
    var isImportRequest = (url2) => importQueryRE.test(url2);
    var isInternalRequest = (url2) => InternalPrefixRE.test(url2);
    function removeImportQuery(url2) {
      return url2.replace(importQueryRE, "$1").replace(trailingSeparatorRE, "");
    }
    function injectQuery(url2, queryToInject) {
      let resolvedUrl = new require$$0$4.URL(url2.replace(/%/g, "%25"), "relative:///");
      if (resolvedUrl.protocol !== "relative:") {
        resolvedUrl = require$$0$4.pathToFileURL(url2);
      }
      let { protocol, pathname, search, hash } = resolvedUrl;
      if (protocol === "file:") {
        pathname = pathname.slice(1);
      }
      pathname = decodeURIComponent(pathname);
      return `${pathname}?${queryToInject}${search ? `&` + search.slice(1) : ""}${hash !== null && hash !== void 0 ? hash : ""}`;
    }
    var timestampRE = /\bt=\d{13}&?\b/;
    function removeTimestampQuery(url2) {
      return url2.replace(timestampRE, "").replace(trailingSeparatorRE, "");
    }
    async function asyncReplace(input, re2, replacer) {
      let match2;
      let remaining = input;
      let rewritten = "";
      while (match2 = re2.exec(remaining)) {
        rewritten += remaining.slice(0, match2.index);
        rewritten += await replacer(match2);
        remaining = remaining.slice(match2.index + match2[0].length);
      }
      rewritten += remaining;
      return rewritten;
    }
    function timeFrom(start, subtract = 0) {
      const time = perf_hooks.performance.now() - start - subtract;
      const timeString = (time.toFixed(2) + `ms`).padEnd(5, " ");
      if (time < 10) {
        return colors$1.green(timeString);
      } else if (time < 50) {
        return colors$1.yellow(timeString);
      } else {
        return colors$1.red(timeString);
      }
    }
    function prettifyUrl(url2, root2) {
      url2 = removeTimestampQuery(url2);
      const isAbsoluteFile = url2.startsWith(root2);
      if (isAbsoluteFile || url2.startsWith(FS_PREFIX)) {
        let file = path__default.relative(root2, isAbsoluteFile ? url2 : fsPathFromId(url2));
        const seg = file.split("/");
        const npmIndex = seg.indexOf(`node_modules`);
        const isSourceMap = file.endsWith(".map");
        if (npmIndex > 0) {
          file = seg[npmIndex + 1];
          if (file.startsWith("@")) {
            file = `${file}/${seg[npmIndex + 2]}`;
          }
          file = `npm: ${colors$1.dim(file)}${isSourceMap ? ` (source map)` : ``}`;
        }
        return colors$1.dim(file);
      } else {
        return colors$1.dim(url2);
      }
    }
    function isObject$5(value) {
      return Object.prototype.toString.call(value) === "[object Object]";
    }
    function isDefined(value) {
      return value != null;
    }
    function lookupFile(dir, formats, options2) {
      for (const format2 of formats) {
        const fullPath = path__default.join(dir, format2);
        if (fs__default.existsSync(fullPath) && fs__default.statSync(fullPath).isFile()) {
          return (options2 === null || options2 === void 0 ? void 0 : options2.pathOnly) ? fullPath : fs__default.readFileSync(fullPath, "utf-8");
        }
      }
      const parentDir = path__default.dirname(dir);
      if (parentDir !== dir && (!(options2 === null || options2 === void 0 ? void 0 : options2.rootDir) || parentDir.startsWith(options2 === null || options2 === void 0 ? void 0 : options2.rootDir))) {
        return lookupFile(parentDir, formats, options2);
      }
    }
    var splitRE = /\r?\n/;
    var range$1 = 2;
    function pad$1(source2, n3 = 2) {
      const lines = source2.split(splitRE);
      return lines.map((l2) => ` `.repeat(n3) + l2).join(`
`);
    }
    function posToNumber(source2, pos2) {
      if (typeof pos2 === "number")
        return pos2;
      const lines = source2.split(splitRE);
      const { line: line2, column: column2 } = pos2;
      let start = 0;
      for (let i2 = 0; i2 < line2 - 1; i2++) {
        if (lines[i2]) {
          start += lines[i2].length + 1;
        }
      }
      return start + column2;
    }
    function numberToPos(source2, offset2) {
      if (typeof offset2 !== "number")
        return offset2;
      if (offset2 > source2.length) {
        throw new Error(`offset is longer than source length! offset ${offset2} > length ${source2.length}`);
      }
      const lines = source2.split(splitRE);
      let counted = 0;
      let line2 = 0;
      let column2 = 0;
      for (; line2 < lines.length; line2++) {
        const lineLength = lines[line2].length + 1;
        if (counted + lineLength >= offset2) {
          column2 = offset2 - counted + 1;
          break;
        }
        counted += lineLength;
      }
      return { line: line2 + 1, column: column2 };
    }
    function generateCodeFrame(source2, start = 0, end) {
      start = posToNumber(source2, start);
      end = end || start;
      const lines = source2.split(splitRE);
      let count = 0;
      const res = [];
      for (let i2 = 0; i2 < lines.length; i2++) {
        count += lines[i2].length + 1;
        if (count >= start) {
          for (let j2 = i2 - range$1; j2 <= i2 + range$1 || end > count; j2++) {
            if (j2 < 0 || j2 >= lines.length)
              continue;
            const line2 = j2 + 1;
            res.push(`${line2}${" ".repeat(Math.max(3 - String(line2).length, 0))}|  ${lines[j2]}`);
            const lineLength = lines[j2].length;
            if (j2 === i2) {
              const pad2 = start - (count - lineLength) + 1;
              const length = Math.max(1, end > count ? lineLength - pad2 : end - start);
              res.push(`   |  ` + " ".repeat(pad2) + "^".repeat(length));
            } else if (j2 > i2) {
              if (end > count) {
                const length = Math.max(Math.min(end - count, lineLength), 1);
                res.push(`   |  ` + "^".repeat(length));
              }
              count += lineLength + 1;
            }
          }
          break;
        }
      }
      return res.join("\n");
    }
    function writeFile(filename2, content2) {
      const dir = path__default.dirname(filename2);
      if (!fs__default.existsSync(dir)) {
        fs__default.mkdirSync(dir, { recursive: true });
      }
      fs__default.writeFileSync(filename2, content2);
    }
    function isFileReadable(filename2) {
      try {
        const stat2 = fs__default.statSync(filename2, { throwIfNoEntry: false });
        return !!stat2;
      } catch {
        return false;
      }
    }
    function emptyDir(dir, skip) {
      for (const file of fs__default.readdirSync(dir)) {
        if (skip === null || skip === void 0 ? void 0 : skip.includes(file)) {
          continue;
        }
        const abs = path__default.resolve(dir, file);
        if (fs__default.lstatSync(abs).isDirectory()) {
          emptyDir(abs);
          fs__default.rmdirSync(abs);
        } else {
          fs__default.unlinkSync(abs);
        }
      }
    }
    function copyDir(srcDir, destDir) {
      fs__default.mkdirSync(destDir, { recursive: true });
      for (const file of fs__default.readdirSync(srcDir)) {
        const srcFile = path__default.resolve(srcDir, file);
        if (srcFile === destDir) {
          continue;
        }
        const destFile = path__default.resolve(destDir, file);
        const stat2 = fs__default.statSync(srcFile);
        if (stat2.isDirectory()) {
          copyDir(srcFile, destFile);
        } else {
          fs__default.copyFileSync(srcFile, destFile);
        }
      }
    }
    function ensureWatchedFile(watcher, file, root2) {
      if (file && !file.startsWith(root2 + "/") && !file.includes("\0") && fs__default.existsSync(file)) {
        watcher.add(path__default.resolve(file));
      }
    }
    var escapedSpaceCharacters = /( |\\t|\\n|\\f|\\r)+/g;
    async function processSrcSet(srcs, replacer) {
      const imageCandidates = srcs.split(",").map((s2) => {
        const [url2, descriptor] = s2.replace(escapedSpaceCharacters, " ").trim().split(" ", 2);
        return { url: url2, descriptor };
      }).filter(({ url: url2 }) => !!url2);
      const ret = await Promise.all(imageCandidates.map(async ({ url: url2, descriptor }) => {
        return {
          url: await replacer({ url: url2, descriptor }),
          descriptor
        };
      }));
      return ret.reduce((prev, { url: url2, descriptor }, index2) => {
        descriptor !== null && descriptor !== void 0 ? descriptor : descriptor = "";
        return prev += url2 + ` ${descriptor}${index2 === ret.length - 1 ? "" : ", "}`;
      }, "");
    }
    function escapeToLinuxLikePath(path2) {
      if (/^[A-Z]:/.test(path2)) {
        return path2.replace(/^([A-Z]):\//, "/windows/$1/");
      }
      if (/^\/[^/]/.test(path2)) {
        return `/linux${path2}`;
      }
      return path2;
    }
    function unescapeToLinuxLikePath(path2) {
      if (path2.startsWith("/linux/")) {
        return path2.slice("/linux".length);
      }
      if (path2.startsWith("/windows/")) {
        return path2.replace(/^\/windows\/([A-Z])\//, "$1:/");
      }
      return path2;
    }
    var nullSourceMap = {
      names: [],
      sources: [],
      mappings: "",
      version: 3
    };
    function combineSourcemaps(filename2, sourcemapList) {
      if (sourcemapList.length === 0 || sourcemapList.every((m3) => m3.sources.length === 0)) {
        return __spreadValues2({}, nullSourceMap);
      }
      sourcemapList = sourcemapList.map((sourcemap) => {
        const newSourcemaps = __spreadValues2({}, sourcemap);
        newSourcemaps.sources = sourcemap.sources.map((source2) => source2 ? escapeToLinuxLikePath(source2) : null);
        if (sourcemap.sourceRoot) {
          newSourcemaps.sourceRoot = escapeToLinuxLikePath(sourcemap.sourceRoot);
        }
        return newSourcemaps;
      });
      const escapedFilename = escapeToLinuxLikePath(filename2);
      let map2;
      let mapIndex = 1;
      const useArrayInterface = sourcemapList.slice(0, -1).find((m3) => m3.sources.length !== 1) === void 0;
      if (useArrayInterface) {
        map2 = remapping(sourcemapList, () => null, true);
      } else {
        map2 = remapping(sourcemapList[0], function loader(sourcefile) {
          if (sourcefile === escapedFilename && sourcemapList[mapIndex]) {
            return sourcemapList[mapIndex++];
          } else {
            return null;
          }
        }, true);
      }
      if (!map2.file) {
        delete map2.file;
      }
      map2.sources = map2.sources.map((source2) => source2 ? unescapeToLinuxLikePath(source2) : source2);
      map2.file = filename2;
      return map2;
    }
    function resolveHostname(optionsHost) {
      let host;
      if (optionsHost === void 0 || optionsHost === false) {
        host = "127.0.0.1";
      } else if (optionsHost === true) {
        host = void 0;
      } else {
        host = optionsHost;
      }
      const name = optionsHost !== "127.0.0.1" && host === "127.0.0.1" || host === "0.0.0.0" || host === "::" || host === void 0 ? "localhost" : host;
      return { host, name };
    }
    function arraify(target) {
      return Array.isArray(target) ? target : [target];
    }
    function toUpperCaseDriveLetter(pathName) {
      return pathName.replace(/^\w:/, (letter) => letter.toUpperCase());
    }
    var multilineCommentsRE = /\/\*(.|[\r\n])*?\*\//gm;
    var singlelineCommentsRE = /\/\/.*/g;
    var usingDynamicImport = typeof jest === "undefined";
    var dynamicImport = usingDynamicImport ? new Function("file", "return import(file)") : __require;
    function parseRequest(id) {
      const { search } = require$$0$4.parse(id);
      if (!search) {
        return null;
      }
      return Object.fromEntries(new require$$0$4.URLSearchParams(search.slice(1)));
    }
    var blankReplacer = (match2) => " ".repeat(match2.length);
    var stringsRE = /"[^"]*"|'[^']*'|`[^`]*`/g;
    var LogLevels = {
      silent: 0,
      error: 1,
      warn: 2,
      info: 3
    };
    var lastType;
    var lastMsg;
    var sameCount = 0;
    function clearScreen() {
      const repeatCount = process.stdout.rows - 2;
      const blank = repeatCount > 0 ? "\n".repeat(repeatCount) : "";
      console.log(blank);
      readline__default.cursorTo(process.stdout, 0, 0);
      readline__default.clearScreenDown(process.stdout);
    }
    function createLogger(level2 = "info", options2 = {}) {
      if (options2.customLogger) {
        return options2.customLogger;
      }
      const loggedErrors = /* @__PURE__ */ new WeakSet();
      const { prefix = "[vite]", allowClearScreen = true } = options2;
      const thresh = LogLevels[level2];
      const canClearScreen = allowClearScreen && process.stdout.isTTY && !process.env.CI;
      const clear = canClearScreen ? clearScreen : () => {
      };
      function output(type, msg, options3 = {}) {
        if (thresh >= LogLevels[type]) {
          const method = type === "info" ? "log" : type;
          const format2 = () => {
            if (options3.timestamp) {
              const tag = type === "info" ? colors$1.cyan(colors$1.bold(prefix)) : type === "warn" ? colors$1.yellow(colors$1.bold(prefix)) : colors$1.red(colors$1.bold(prefix));
              return `${colors$1.dim(new Date().toLocaleTimeString())} ${tag} ${msg}`;
            } else {
              return msg;
            }
          };
          if (options3.error) {
            loggedErrors.add(options3.error);
          }
          if (canClearScreen) {
            if (type === lastType && msg === lastMsg) {
              sameCount++;
              clear();
              console[method](format2(), colors$1.yellow(`(x${sameCount + 1})`));
            } else {
              sameCount = 0;
              lastMsg = msg;
              lastType = type;
              if (options3.clear) {
                clear();
              }
              console[method](format2());
            }
          } else {
            console[method](format2());
          }
        }
      }
      const warnedMessages = /* @__PURE__ */ new Set();
      const logger = {
        hasWarned: false,
        info(msg, opts) {
          output("info", msg, opts);
        },
        warn(msg, opts) {
          logger.hasWarned = true;
          output("warn", msg, opts);
        },
        warnOnce(msg, opts) {
          if (warnedMessages.has(msg))
            return;
          logger.hasWarned = true;
          output("warn", msg, opts);
          warnedMessages.add(msg);
        },
        error(msg, opts) {
          logger.hasWarned = true;
          output("error", msg, opts);
        },
        clearScreen(type) {
          if (thresh >= LogLevels[type]) {
            clear();
          }
        },
        hasErrorLogged(error2) {
          return loggedErrors.has(error2);
        }
      };
      return logger;
    }
    function printHttpServerUrls(server2, config2) {
      printCommonServerUrls(server2, config2.server, config2);
    }
    function printCommonServerUrls(server2, options2, config2) {
      const address = server2.address();
      const isAddressInfo = (x2) => x2 === null || x2 === void 0 ? void 0 : x2.address;
      if (isAddressInfo(address)) {
        const hostname = resolveHostname(options2.host);
        const protocol = options2.https ? "https" : "http";
        printServerUrls(hostname, protocol, address.port, config2.base, config2.logger.info);
      }
    }
    function printServerUrls(hostname, protocol, port, base2, info) {
      if (hostname.host === "127.0.0.1") {
        const url2 = `${protocol}://${hostname.name}:${colors$1.bold(port)}${base2}`;
        info(`  > Local: ${colors$1.cyan(url2)}`);
        if (hostname.name !== "127.0.0.1") {
          info(`  > Network: ${colors$1.dim("use `--host` to expose")}`);
        }
      } else {
        Object.values(require$$1__default.networkInterfaces()).flatMap((nInterface) => nInterface !== null && nInterface !== void 0 ? nInterface : []).filter((detail) => detail && detail.address && detail.family === "IPv4").map((detail) => {
          const type = detail.address.includes("127.0.0.1") ? "Local:   " : "Network: ";
          const host = detail.address.replace("127.0.0.1", hostname.name);
          const url2 = `${protocol}://${host}:${colors$1.bold(port)}${base2}`;
          return `  > ${type} ${colors$1.cyan(url2)}`;
        }).forEach((msg) => info(msg));
      }
    }
    var writeColors = {
      [0]: colors$1.cyan,
      [1]: colors$1.magenta,
      [2]: colors$1.green,
      [3]: colors$1.blue,
      [4]: colors$1.gray
    };
    function buildReporterPlugin(config2) {
      const compress = require$$0$3.promisify(zlib$1.gzip);
      const chunkLimit = config2.build.chunkSizeWarningLimit;
      function isLarge(code) {
        return code.length / 1024 > chunkLimit;
      }
      async function getCompressedSize(code) {
        if (config2.build.ssr || !config2.build.reportCompressedSize || config2.build.brotliSize === false) {
          return "";
        }
        return ` / gzip: ${((await compress(typeof code === "string" ? code : Buffer.from(code))).length / 1024).toFixed(2)} KiB`;
      }
      function printFileInfo(filePath, content2, type, maxLength, compressedSize = "") {
        const outDir = normalizePath$4(path__default.relative(config2.root, path__default.resolve(config2.root, config2.build.outDir))) + "/";
        const kibs = content2.length / 1024;
        const sizeColor = kibs > chunkLimit ? colors$1.yellow : colors$1.dim;
        config2.logger.info(`${colors$1.gray(colors$1.white(colors$1.dim(outDir)))}${writeColors[type](filePath.padEnd(maxLength + 2))} ${sizeColor(`${kibs.toFixed(2)} KiB${compressedSize}`)}`);
      }
      const tty2 = process.stdout.isTTY && !process.env.CI;
      const shouldLogInfo = LogLevels[config2.logLevel || "info"] >= LogLevels.info;
      let hasTransformed = false;
      let hasRenderedChunk = false;
      let transformedCount = 0;
      let chunkCount = 0;
      const logTransform = throttle((id) => {
        writeLine(`transforming (${transformedCount}) ${colors$1.dim(path__default.relative(config2.root, id))}`);
      });
      return {
        name: "vite:reporter",
        transform(_2, id) {
          transformedCount++;
          if (shouldLogInfo) {
            if (!tty2) {
              if (!hasTransformed) {
                config2.logger.info(`transforming...`);
              }
            } else {
              if (id.includes(`?`))
                return;
              logTransform(id);
            }
            hasTransformed = true;
          }
          return null;
        },
        buildEnd() {
          if (shouldLogInfo) {
            if (tty2) {
              process.stdout.clearLine(0);
              process.stdout.cursorTo(0);
            }
            config2.logger.info(`${colors$1.green(`\u2713`)} ${transformedCount} modules transformed.`);
          }
        },
        renderStart() {
          chunkCount = 0;
        },
        renderChunk() {
          chunkCount++;
          if (shouldLogInfo) {
            if (!tty2) {
              if (!hasRenderedChunk) {
                config2.logger.info("rendering chunks...");
              }
            } else {
              writeLine(`rendering chunks (${chunkCount})...`);
            }
            hasRenderedChunk = true;
          }
          return null;
        },
        generateBundle() {
          if (shouldLogInfo && tty2) {
            process.stdout.clearLine(0);
            process.stdout.cursorTo(0);
          }
        },
        async writeBundle(_2, output) {
          let hasLargeChunks = false;
          if (shouldLogInfo) {
            let longest = 0;
            for (const file in output) {
              const l2 = output[file].fileName.length;
              if (l2 > longest)
                longest = l2;
            }
            const deferredLogs = [];
            await Promise.all(Object.keys(output).map(async (file) => {
              const chunk = output[file];
              if (chunk.type === "chunk") {
                const log2 = async () => {
                  printFileInfo(chunk.fileName, chunk.code, 0, longest, await getCompressedSize(chunk.code));
                  if (chunk.map) {
                    printFileInfo(chunk.fileName + ".map", chunk.map.toString(), 4, longest);
                  }
                };
                if (isLarge(chunk.code)) {
                  hasLargeChunks = true;
                  deferredLogs.push(log2);
                } else {
                  await log2();
                }
              } else if (chunk.source) {
                const isCSS = chunk.fileName.endsWith(".css");
                printFileInfo(chunk.fileName, chunk.source, isCSS ? 1 : 2, longest, isCSS ? await getCompressedSize(chunk.source) : void 0);
              }
            }));
            await Promise.all(deferredLogs.map((l2) => l2()));
          } else {
            hasLargeChunks = Object.keys(output).some((file) => {
              const chunk = output[file];
              return chunk.type === "chunk" && chunk.code.length / 1024 > chunkLimit;
            });
          }
          if (hasLargeChunks && config2.build.minify && !config2.build.lib && !config2.build.ssr) {
            config2.logger.warn(colors$1.yellow(`
(!) Some chunks are larger than ${chunkLimit} KiB after minification. Consider:
- Using dynamic import() to code-split the application
- Use build.rollupOptions.output.manualChunks to improve chunking: https://rollupjs.org/guide/en/#outputmanualchunks
- Adjust chunk size limit for this warning via build.chunkSizeWarningLimit.`));
          }
        }
      };
    }
    function writeLine(output) {
      process.stdout.clearLine(0);
      process.stdout.cursorTo(0);
      if (output.length < process.stdout.columns) {
        process.stdout.write(output);
      } else {
        process.stdout.write(output.substring(0, process.stdout.columns - 1));
      }
    }
    function throttle(fn2) {
      let timerHandle = null;
      return (...args) => {
        if (timerHandle)
          return;
        fn2(...args);
        timerHandle = setTimeout(() => {
          timerHandle = null;
        }, 100);
      };
    }
    var utils$p = {};
    var path$q = path__default;
    var WIN_SLASH$1 = "\\\\/";
    var WIN_NO_SLASH$1 = `[^${WIN_SLASH$1}]`;
    var DOT_LITERAL$1 = "\\.";
    var PLUS_LITERAL$1 = "\\+";
    var QMARK_LITERAL$1 = "\\?";
    var SLASH_LITERAL$1 = "\\/";
    var ONE_CHAR$1 = "(?=.)";
    var QMARK$1 = "[^/]";
    var END_ANCHOR$1 = `(?:${SLASH_LITERAL$1}|$)`;
    var START_ANCHOR$1 = `(?:^|${SLASH_LITERAL$1})`;
    var DOTS_SLASH$1 = `${DOT_LITERAL$1}{1,2}${END_ANCHOR$1}`;
    var NO_DOT$1 = `(?!${DOT_LITERAL$1})`;
    var NO_DOTS$1 = `(?!${START_ANCHOR$1}${DOTS_SLASH$1})`;
    var NO_DOT_SLASH$1 = `(?!${DOT_LITERAL$1}{0,1}${END_ANCHOR$1})`;
    var NO_DOTS_SLASH$1 = `(?!${DOTS_SLASH$1})`;
    var QMARK_NO_DOT$1 = `[^.${SLASH_LITERAL$1}]`;
    var STAR$2 = `${QMARK$1}*?`;
    var POSIX_CHARS$1 = {
      DOT_LITERAL: DOT_LITERAL$1,
      PLUS_LITERAL: PLUS_LITERAL$1,
      QMARK_LITERAL: QMARK_LITERAL$1,
      SLASH_LITERAL: SLASH_LITERAL$1,
      ONE_CHAR: ONE_CHAR$1,
      QMARK: QMARK$1,
      END_ANCHOR: END_ANCHOR$1,
      DOTS_SLASH: DOTS_SLASH$1,
      NO_DOT: NO_DOT$1,
      NO_DOTS: NO_DOTS$1,
      NO_DOT_SLASH: NO_DOT_SLASH$1,
      NO_DOTS_SLASH: NO_DOTS_SLASH$1,
      QMARK_NO_DOT: QMARK_NO_DOT$1,
      STAR: STAR$2,
      START_ANCHOR: START_ANCHOR$1
    };
    var WINDOWS_CHARS$1 = __spreadProps2(__spreadValues2({}, POSIX_CHARS$1), {
      SLASH_LITERAL: `[${WIN_SLASH$1}]`,
      QMARK: WIN_NO_SLASH$1,
      STAR: `${WIN_NO_SLASH$1}*?`,
      DOTS_SLASH: `${DOT_LITERAL$1}{1,2}(?:[${WIN_SLASH$1}]|$)`,
      NO_DOT: `(?!${DOT_LITERAL$1})`,
      NO_DOTS: `(?!(?:^|[${WIN_SLASH$1}])${DOT_LITERAL$1}{1,2}(?:[${WIN_SLASH$1}]|$))`,
      NO_DOT_SLASH: `(?!${DOT_LITERAL$1}{0,1}(?:[${WIN_SLASH$1}]|$))`,
      NO_DOTS_SLASH: `(?!${DOT_LITERAL$1}{1,2}(?:[${WIN_SLASH$1}]|$))`,
      QMARK_NO_DOT: `[^.${WIN_SLASH$1}]`,
      START_ANCHOR: `(?:^|[${WIN_SLASH$1}])`,
      END_ANCHOR: `(?:[${WIN_SLASH$1}]|$)`
    });
    var POSIX_REGEX_SOURCE$3 = {
      alnum: "a-zA-Z0-9",
      alpha: "a-zA-Z",
      ascii: "\\x00-\\x7F",
      blank: " \\t",
      cntrl: "\\x00-\\x1F\\x7F",
      digit: "0-9",
      graph: "\\x21-\\x7E",
      lower: "a-z",
      print: "\\x20-\\x7E ",
      punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
      space: " \\t\\r\\n\\v\\f",
      upper: "A-Z",
      word: "A-Za-z0-9_",
      xdigit: "A-Fa-f0-9"
    };
    var constants$9 = {
      MAX_LENGTH: 1024 * 64,
      POSIX_REGEX_SOURCE: POSIX_REGEX_SOURCE$3,
      REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
      REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
      REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
      REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
      REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
      REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
      REPLACEMENTS: {
        "***": "*",
        "**/**": "**",
        "**/**/**": "**"
      },
      CHAR_0: 48,
      CHAR_9: 57,
      CHAR_UPPERCASE_A: 65,
      CHAR_LOWERCASE_A: 97,
      CHAR_UPPERCASE_Z: 90,
      CHAR_LOWERCASE_Z: 122,
      CHAR_LEFT_PARENTHESES: 40,
      CHAR_RIGHT_PARENTHESES: 41,
      CHAR_ASTERISK: 42,
      CHAR_AMPERSAND: 38,
      CHAR_AT: 64,
      CHAR_BACKWARD_SLASH: 92,
      CHAR_CARRIAGE_RETURN: 13,
      CHAR_CIRCUMFLEX_ACCENT: 94,
      CHAR_COLON: 58,
      CHAR_COMMA: 44,
      CHAR_DOT: 46,
      CHAR_DOUBLE_QUOTE: 34,
      CHAR_EQUAL: 61,
      CHAR_EXCLAMATION_MARK: 33,
      CHAR_FORM_FEED: 12,
      CHAR_FORWARD_SLASH: 47,
      CHAR_GRAVE_ACCENT: 96,
      CHAR_HASH: 35,
      CHAR_HYPHEN_MINUS: 45,
      CHAR_LEFT_ANGLE_BRACKET: 60,
      CHAR_LEFT_CURLY_BRACE: 123,
      CHAR_LEFT_SQUARE_BRACKET: 91,
      CHAR_LINE_FEED: 10,
      CHAR_NO_BREAK_SPACE: 160,
      CHAR_PERCENT: 37,
      CHAR_PLUS: 43,
      CHAR_QUESTION_MARK: 63,
      CHAR_RIGHT_ANGLE_BRACKET: 62,
      CHAR_RIGHT_CURLY_BRACE: 125,
      CHAR_RIGHT_SQUARE_BRACKET: 93,
      CHAR_SEMICOLON: 59,
      CHAR_SINGLE_QUOTE: 39,
      CHAR_SPACE: 32,
      CHAR_TAB: 9,
      CHAR_UNDERSCORE: 95,
      CHAR_VERTICAL_LINE: 124,
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
      SEP: path$q.sep,
      extglobChars(chars2) {
        return {
          "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars2.STAR})` },
          "?": { type: "qmark", open: "(?:", close: ")?" },
          "+": { type: "plus", open: "(?:", close: ")+" },
          "*": { type: "star", open: "(?:", close: ")*" },
          "@": { type: "at", open: "(?:", close: ")" }
        };
      },
      globChars(win322) {
        return win322 === true ? WINDOWS_CHARS$1 : POSIX_CHARS$1;
      }
    };
    (function(exports2) {
      const path2 = path__default;
      const win322 = process.platform === "win32";
      const {
        REGEX_BACKSLASH,
        REGEX_REMOVE_BACKSLASH,
        REGEX_SPECIAL_CHARS,
        REGEX_SPECIAL_CHARS_GLOBAL
      } = constants$9;
      exports2.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
      exports2.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
      exports2.isRegexChar = (str) => str.length === 1 && exports2.hasRegexChars(str);
      exports2.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
      exports2.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
      exports2.removeBackslashes = (str) => {
        return str.replace(REGEX_REMOVE_BACKSLASH, (match2) => {
          return match2 === "\\" ? "" : match2;
        });
      };
      exports2.supportsLookbehinds = () => {
        const segs = process.version.slice(1).split(".").map(Number);
        if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
          return true;
        }
        return false;
      };
      exports2.isWindows = (options2) => {
        if (options2 && typeof options2.windows === "boolean") {
          return options2.windows;
        }
        return win322 === true || path2.sep === "\\";
      };
      exports2.escapeLast = (input, char, lastIdx) => {
        const idx = input.lastIndexOf(char, lastIdx);
        if (idx === -1)
          return input;
        if (input[idx - 1] === "\\")
          return exports2.escapeLast(input, char, idx - 1);
        return `${input.slice(0, idx)}\\${input.slice(idx)}`;
      };
      exports2.removePrefix = (input, state = {}) => {
        let output = input;
        if (output.startsWith("./")) {
          output = output.slice(2);
          state.prefix = "./";
        }
        return output;
      };
      exports2.wrapOutput = (input, state = {}, options2 = {}) => {
        const prepend = options2.contains ? "" : "^";
        const append2 = options2.contains ? "" : "$";
        let output = `${prepend}(?:${input})${append2}`;
        if (state.negated === true) {
          output = `(?:^(?!${output}).*$)`;
        }
        return output;
      };
    })(utils$p);
    var utils$o = utils$p;
    var {
      CHAR_ASTERISK: CHAR_ASTERISK$1,
      CHAR_AT: CHAR_AT$1,
      CHAR_BACKWARD_SLASH: CHAR_BACKWARD_SLASH$1,
      CHAR_COMMA: CHAR_COMMA$2,
      CHAR_DOT: CHAR_DOT$2,
      CHAR_EXCLAMATION_MARK: CHAR_EXCLAMATION_MARK$1,
      CHAR_FORWARD_SLASH: CHAR_FORWARD_SLASH$1,
      CHAR_LEFT_CURLY_BRACE: CHAR_LEFT_CURLY_BRACE$2,
      CHAR_LEFT_PARENTHESES: CHAR_LEFT_PARENTHESES$2,
      CHAR_LEFT_SQUARE_BRACKET: CHAR_LEFT_SQUARE_BRACKET$2,
      CHAR_PLUS: CHAR_PLUS$1,
      CHAR_QUESTION_MARK: CHAR_QUESTION_MARK$1,
      CHAR_RIGHT_CURLY_BRACE: CHAR_RIGHT_CURLY_BRACE$2,
      CHAR_RIGHT_PARENTHESES: CHAR_RIGHT_PARENTHESES$2,
      CHAR_RIGHT_SQUARE_BRACKET: CHAR_RIGHT_SQUARE_BRACKET$2
    } = constants$9;
    var isPathSeparator$1 = (code) => {
      return code === CHAR_FORWARD_SLASH$1 || code === CHAR_BACKWARD_SLASH$1;
    };
    var depth$1 = (token2) => {
      if (token2.isPrefix !== true) {
        token2.depth = token2.isGlobstar ? Infinity : 1;
      }
    };
    var scan$3 = (input, options2) => {
      const opts = options2 || {};
      const length = input.length - 1;
      const scanToEnd = opts.parts === true || opts.scanToEnd === true;
      const slashes = [];
      const tokens = [];
      const parts = [];
      let str = input;
      let index2 = -1;
      let start = 0;
      let lastIndex = 0;
      let isBrace = false;
      let isBracket = false;
      let isGlob2 = false;
      let isExtglob2 = false;
      let isGlobstar = false;
      let braceEscaped = false;
      let backslashes = false;
      let negated = false;
      let negatedExtglob = false;
      let finished = false;
      let braces2 = 0;
      let prev;
      let code;
      let token2 = { value: "", depth: 0, isGlob: false };
      const eos = () => index2 >= length;
      const peek2 = () => str.charCodeAt(index2 + 1);
      const advance = () => {
        prev = code;
        return str.charCodeAt(++index2);
      };
      while (index2 < length) {
        code = advance();
        let next;
        if (code === CHAR_BACKWARD_SLASH$1) {
          backslashes = token2.backslashes = true;
          code = advance();
          if (code === CHAR_LEFT_CURLY_BRACE$2) {
            braceEscaped = true;
          }
          continue;
        }
        if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE$2) {
          braces2++;
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_BACKWARD_SLASH$1) {
              backslashes = token2.backslashes = true;
              advance();
              continue;
            }
            if (code === CHAR_LEFT_CURLY_BRACE$2) {
              braces2++;
              continue;
            }
            if (braceEscaped !== true && code === CHAR_DOT$2 && (code = advance()) === CHAR_DOT$2) {
              isBrace = token2.isBrace = true;
              isGlob2 = token2.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (braceEscaped !== true && code === CHAR_COMMA$2) {
              isBrace = token2.isBrace = true;
              isGlob2 = token2.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (code === CHAR_RIGHT_CURLY_BRACE$2) {
              braces2--;
              if (braces2 === 0) {
                braceEscaped = false;
                isBrace = token2.isBrace = true;
                finished = true;
                break;
              }
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_FORWARD_SLASH$1) {
          slashes.push(index2);
          tokens.push(token2);
          token2 = { value: "", depth: 0, isGlob: false };
          if (finished === true)
            continue;
          if (prev === CHAR_DOT$2 && index2 === start + 1) {
            start += 2;
            continue;
          }
          lastIndex = index2 + 1;
          continue;
        }
        if (opts.noext !== true) {
          const isExtglobChar = code === CHAR_PLUS$1 || code === CHAR_AT$1 || code === CHAR_ASTERISK$1 || code === CHAR_QUESTION_MARK$1 || code === CHAR_EXCLAMATION_MARK$1;
          if (isExtglobChar === true && peek2() === CHAR_LEFT_PARENTHESES$2) {
            isGlob2 = token2.isGlob = true;
            isExtglob2 = token2.isExtglob = true;
            finished = true;
            if (code === CHAR_EXCLAMATION_MARK$1 && index2 === start) {
              negatedExtglob = true;
            }
            if (scanToEnd === true) {
              while (eos() !== true && (code = advance())) {
                if (code === CHAR_BACKWARD_SLASH$1) {
                  backslashes = token2.backslashes = true;
                  code = advance();
                  continue;
                }
                if (code === CHAR_RIGHT_PARENTHESES$2) {
                  isGlob2 = token2.isGlob = true;
                  finished = true;
                  break;
                }
              }
              continue;
            }
            break;
          }
        }
        if (code === CHAR_ASTERISK$1) {
          if (prev === CHAR_ASTERISK$1)
            isGlobstar = token2.isGlobstar = true;
          isGlob2 = token2.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_QUESTION_MARK$1) {
          isGlob2 = token2.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_LEFT_SQUARE_BRACKET$2) {
          while (eos() !== true && (next = advance())) {
            if (next === CHAR_BACKWARD_SLASH$1) {
              backslashes = token2.backslashes = true;
              advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET$2) {
              isBracket = token2.isBracket = true;
              isGlob2 = token2.isGlob = true;
              finished = true;
              break;
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK$1 && index2 === start) {
          negated = token2.negated = true;
          start++;
          continue;
        }
        if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES$2) {
          isGlob2 = token2.isGlob = true;
          if (scanToEnd === true) {
            while (eos() !== true && (code = advance())) {
              if (code === CHAR_LEFT_PARENTHESES$2) {
                backslashes = token2.backslashes = true;
                code = advance();
                continue;
              }
              if (code === CHAR_RIGHT_PARENTHESES$2) {
                finished = true;
                break;
              }
            }
            continue;
          }
          break;
        }
        if (isGlob2 === true) {
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
      }
      if (opts.noext === true) {
        isExtglob2 = false;
        isGlob2 = false;
      }
      let base2 = str;
      let prefix = "";
      let glob2 = "";
      if (start > 0) {
        prefix = str.slice(0, start);
        str = str.slice(start);
        lastIndex -= start;
      }
      if (base2 && isGlob2 === true && lastIndex > 0) {
        base2 = str.slice(0, lastIndex);
        glob2 = str.slice(lastIndex);
      } else if (isGlob2 === true) {
        base2 = "";
        glob2 = str;
      } else {
        base2 = str;
      }
      if (base2 && base2 !== "" && base2 !== "/" && base2 !== str) {
        if (isPathSeparator$1(base2.charCodeAt(base2.length - 1))) {
          base2 = base2.slice(0, -1);
        }
      }
      if (opts.unescape === true) {
        if (glob2)
          glob2 = utils$o.removeBackslashes(glob2);
        if (base2 && backslashes === true) {
          base2 = utils$o.removeBackslashes(base2);
        }
      }
      const state = {
        prefix,
        input,
        start,
        base: base2,
        glob: glob2,
        isBrace,
        isBracket,
        isGlob: isGlob2,
        isExtglob: isExtglob2,
        isGlobstar,
        negated,
        negatedExtglob
      };
      if (opts.tokens === true) {
        state.maxDepth = 0;
        if (!isPathSeparator$1(code)) {
          tokens.push(token2);
        }
        state.tokens = tokens;
      }
      if (opts.parts === true || opts.tokens === true) {
        let prevIndex;
        for (let idx = 0; idx < slashes.length; idx++) {
          const n3 = prevIndex ? prevIndex + 1 : start;
          const i2 = slashes[idx];
          const value = input.slice(n3, i2);
          if (opts.tokens) {
            if (idx === 0 && start !== 0) {
              tokens[idx].isPrefix = true;
              tokens[idx].value = prefix;
            } else {
              tokens[idx].value = value;
            }
            depth$1(tokens[idx]);
            state.maxDepth += tokens[idx].depth;
          }
          if (idx !== 0 || value !== "") {
            parts.push(value);
          }
          prevIndex = i2;
        }
        if (prevIndex && prevIndex + 1 < input.length) {
          const value = input.slice(prevIndex + 1);
          parts.push(value);
          if (opts.tokens) {
            tokens[tokens.length - 1].value = value;
            depth$1(tokens[tokens.length - 1]);
            state.maxDepth += tokens[tokens.length - 1].depth;
          }
        }
        state.slashes = slashes;
        state.parts = parts;
      }
      return state;
    };
    var scan_1$1 = scan$3;
    var constants$8 = constants$9;
    var utils$n = utils$p;
    var {
      MAX_LENGTH: MAX_LENGTH$2,
      POSIX_REGEX_SOURCE: POSIX_REGEX_SOURCE$2,
      REGEX_NON_SPECIAL_CHARS: REGEX_NON_SPECIAL_CHARS$1,
      REGEX_SPECIAL_CHARS_BACKREF: REGEX_SPECIAL_CHARS_BACKREF$1,
      REPLACEMENTS: REPLACEMENTS$1
    } = constants$8;
    var expandRange$1 = (args, options2) => {
      if (typeof options2.expandRange === "function") {
        return options2.expandRange(...args, options2);
      }
      args.sort();
      const value = `[${args.join("-")}]`;
      return value;
    };
    var syntaxError$2 = (type, char) => {
      return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
    };
    var parse$n = (input, options2) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      input = REPLACEMENTS$1[input] || input;
      const opts = __spreadValues2({}, options2);
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH$2, opts.maxLength) : MAX_LENGTH$2;
      let len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      const bos = { type: "bos", value: "", output: opts.prepend || "" };
      const tokens = [bos];
      const capture = opts.capture ? "" : "?:";
      const win322 = utils$n.isWindows(options2);
      const PLATFORM_CHARS = constants$8.globChars(win322);
      const EXTGLOB_CHARS = constants$8.extglobChars(PLATFORM_CHARS);
      const {
        DOT_LITERAL: DOT_LITERAL2,
        PLUS_LITERAL: PLUS_LITERAL2,
        SLASH_LITERAL: SLASH_LITERAL2,
        ONE_CHAR: ONE_CHAR2,
        DOTS_SLASH: DOTS_SLASH2,
        NO_DOT: NO_DOT2,
        NO_DOT_SLASH: NO_DOT_SLASH2,
        NO_DOTS_SLASH: NO_DOTS_SLASH2,
        QMARK: QMARK2,
        QMARK_NO_DOT: QMARK_NO_DOT2,
        STAR: STAR2,
        START_ANCHOR: START_ANCHOR2
      } = PLATFORM_CHARS;
      const globstar = (opts2) => {
        return `(${capture}(?:(?!${START_ANCHOR2}${opts2.dot ? DOTS_SLASH2 : DOT_LITERAL2}).)*?)`;
      };
      const nodot = opts.dot ? "" : NO_DOT2;
      const qmarkNoDot = opts.dot ? QMARK2 : QMARK_NO_DOT2;
      let star2 = opts.bash === true ? globstar(opts) : STAR2;
      if (opts.capture) {
        star2 = `(${star2})`;
      }
      if (typeof opts.noext === "boolean") {
        opts.noextglob = opts.noext;
      }
      const state = {
        input,
        index: -1,
        start: 0,
        dot: opts.dot === true,
        consumed: "",
        output: "",
        prefix: "",
        backtrack: false,
        negated: false,
        brackets: 0,
        braces: 0,
        parens: 0,
        quotes: 0,
        globstar: false,
        tokens
      };
      input = utils$n.removePrefix(input, state);
      len = input.length;
      const extglobs = [];
      const braces2 = [];
      const stack2 = [];
      let prev = bos;
      let value;
      const eos = () => state.index === len - 1;
      const peek2 = state.peek = (n3 = 1) => input[state.index + n3];
      const advance = state.advance = () => input[++state.index] || "";
      const remaining = () => input.slice(state.index + 1);
      const consume = (value2 = "", num = 0) => {
        state.consumed += value2;
        state.index += num;
      };
      const append2 = (token2) => {
        state.output += token2.output != null ? token2.output : token2.value;
        consume(token2.value);
      };
      const negate = () => {
        let count = 1;
        while (peek2() === "!" && (peek2(2) !== "(" || peek2(3) === "?")) {
          advance();
          state.start++;
          count++;
        }
        if (count % 2 === 0) {
          return false;
        }
        state.negated = true;
        state.start++;
        return true;
      };
      const increment = (type) => {
        state[type]++;
        stack2.push(type);
      };
      const decrement = (type) => {
        state[type]--;
        stack2.pop();
      };
      const push2 = (tok) => {
        if (prev.type === "globstar") {
          const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
          const isExtglob2 = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
          if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob2) {
            state.output = state.output.slice(0, -prev.output.length);
            prev.type = "star";
            prev.value = "*";
            prev.output = star2;
            state.output += prev.output;
          }
        }
        if (extglobs.length && tok.type !== "paren") {
          extglobs[extglobs.length - 1].inner += tok.value;
        }
        if (tok.value || tok.output)
          append2(tok);
        if (prev && prev.type === "text" && tok.type === "text") {
          prev.value += tok.value;
          prev.output = (prev.output || "") + tok.value;
          return;
        }
        tok.prev = prev;
        tokens.push(tok);
        prev = tok;
      };
      const extglobOpen = (type, value2) => {
        const token2 = __spreadProps2(__spreadValues2({}, EXTGLOB_CHARS[value2]), { conditions: 1, inner: "" });
        token2.prev = prev;
        token2.parens = state.parens;
        token2.output = state.output;
        const output = (opts.capture ? "(" : "") + token2.open;
        increment("parens");
        push2({ type, value: value2, output: state.output ? "" : ONE_CHAR2 });
        push2({ type: "paren", extglob: true, value: advance(), output });
        extglobs.push(token2);
      };
      const extglobClose = (token2) => {
        let output = token2.close + (opts.capture ? ")" : "");
        let rest;
        if (token2.type === "negate") {
          let extglobStar = star2;
          if (token2.inner && token2.inner.length > 1 && token2.inner.includes("/")) {
            extglobStar = globstar(opts);
          }
          if (extglobStar !== star2 || eos() || /^\)+$/.test(remaining())) {
            output = token2.close = `)$))${extglobStar}`;
          }
          if (token2.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
            output = token2.close = `)${rest})${extglobStar})`;
          }
          if (token2.prev.type === "bos") {
            state.negatedExtglob = true;
          }
        }
        push2({ type: "paren", extglob: true, value, output });
        decrement("parens");
      };
      if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
        let backslashes = false;
        let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF$1, (m3, esc, chars2, first2, rest, index2) => {
          if (first2 === "\\") {
            backslashes = true;
            return m3;
          }
          if (first2 === "?") {
            if (esc) {
              return esc + first2 + (rest ? QMARK2.repeat(rest.length) : "");
            }
            if (index2 === 0) {
              return qmarkNoDot + (rest ? QMARK2.repeat(rest.length) : "");
            }
            return QMARK2.repeat(chars2.length);
          }
          if (first2 === ".") {
            return DOT_LITERAL2.repeat(chars2.length);
          }
          if (first2 === "*") {
            if (esc) {
              return esc + first2 + (rest ? star2 : "");
            }
            return star2;
          }
          return esc ? m3 : `\\${m3}`;
        });
        if (backslashes === true) {
          if (opts.unescape === true) {
            output = output.replace(/\\/g, "");
          } else {
            output = output.replace(/\\+/g, (m3) => {
              return m3.length % 2 === 0 ? "\\\\" : m3 ? "\\" : "";
            });
          }
        }
        if (output === input && opts.contains === true) {
          state.output = input;
          return state;
        }
        state.output = utils$n.wrapOutput(output, state, options2);
        return state;
      }
      while (!eos()) {
        value = advance();
        if (value === "\0") {
          continue;
        }
        if (value === "\\") {
          const next = peek2();
          if (next === "/" && opts.bash !== true) {
            continue;
          }
          if (next === "." || next === ";") {
            continue;
          }
          if (!next) {
            value += "\\";
            push2({ type: "text", value });
            continue;
          }
          const match2 = /^\\+/.exec(remaining());
          let slashes = 0;
          if (match2 && match2[0].length > 2) {
            slashes = match2[0].length;
            state.index += slashes;
            if (slashes % 2 !== 0) {
              value += "\\";
            }
          }
          if (opts.unescape === true) {
            value = advance();
          } else {
            value += advance();
          }
          if (state.brackets === 0) {
            push2({ type: "text", value });
            continue;
          }
        }
        if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
          if (opts.posix !== false && value === ":") {
            const inner = prev.value.slice(1);
            if (inner.includes("[")) {
              prev.posix = true;
              if (inner.includes(":")) {
                const idx = prev.value.lastIndexOf("[");
                const pre = prev.value.slice(0, idx);
                const rest2 = prev.value.slice(idx + 2);
                const posix2 = POSIX_REGEX_SOURCE$2[rest2];
                if (posix2) {
                  prev.value = pre + posix2;
                  state.backtrack = true;
                  advance();
                  if (!bos.output && tokens.indexOf(prev) === 1) {
                    bos.output = ONE_CHAR2;
                  }
                  continue;
                }
              }
            }
          }
          if (value === "[" && peek2() !== ":" || value === "-" && peek2() === "]") {
            value = `\\${value}`;
          }
          if (value === "]" && (prev.value === "[" || prev.value === "[^")) {
            value = `\\${value}`;
          }
          if (opts.posix === true && value === "!" && prev.value === "[") {
            value = "^";
          }
          prev.value += value;
          append2({ value });
          continue;
        }
        if (state.quotes === 1 && value !== '"') {
          value = utils$n.escapeRegex(value);
          prev.value += value;
          append2({ value });
          continue;
        }
        if (value === '"') {
          state.quotes = state.quotes === 1 ? 0 : 1;
          if (opts.keepQuotes === true) {
            push2({ type: "text", value });
          }
          continue;
        }
        if (value === "(") {
          increment("parens");
          push2({ type: "paren", value });
          continue;
        }
        if (value === ")") {
          if (state.parens === 0 && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError$2("opening", "("));
          }
          const extglob = extglobs[extglobs.length - 1];
          if (extglob && state.parens === extglob.parens + 1) {
            extglobClose(extglobs.pop());
            continue;
          }
          push2({ type: "paren", value, output: state.parens ? ")" : "\\)" });
          decrement("parens");
          continue;
        }
        if (value === "[") {
          if (opts.nobracket === true || !remaining().includes("]")) {
            if (opts.nobracket !== true && opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError$2("closing", "]"));
            }
            value = `\\${value}`;
          } else {
            increment("brackets");
          }
          push2({ type: "bracket", value });
          continue;
        }
        if (value === "]") {
          if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
            push2({ type: "text", value, output: `\\${value}` });
            continue;
          }
          if (state.brackets === 0) {
            if (opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError$2("opening", "["));
            }
            push2({ type: "text", value, output: `\\${value}` });
            continue;
          }
          decrement("brackets");
          const prevValue = prev.value.slice(1);
          if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
            value = `/${value}`;
          }
          prev.value += value;
          append2({ value });
          if (opts.literalBrackets === false || utils$n.hasRegexChars(prevValue)) {
            continue;
          }
          const escaped2 = utils$n.escapeRegex(prev.value);
          state.output = state.output.slice(0, -prev.value.length);
          if (opts.literalBrackets === true) {
            state.output += escaped2;
            prev.value = escaped2;
            continue;
          }
          prev.value = `(${capture}${escaped2}|${prev.value})`;
          state.output += prev.value;
          continue;
        }
        if (value === "{" && opts.nobrace !== true) {
          increment("braces");
          const open2 = {
            type: "brace",
            value,
            output: "(",
            outputIndex: state.output.length,
            tokensIndex: state.tokens.length
          };
          braces2.push(open2);
          push2(open2);
          continue;
        }
        if (value === "}") {
          const brace = braces2[braces2.length - 1];
          if (opts.nobrace === true || !brace) {
            push2({ type: "text", value, output: value });
            continue;
          }
          let output = ")";
          if (brace.dots === true) {
            const arr = tokens.slice();
            const range2 = [];
            for (let i2 = arr.length - 1; i2 >= 0; i2--) {
              tokens.pop();
              if (arr[i2].type === "brace") {
                break;
              }
              if (arr[i2].type !== "dots") {
                range2.unshift(arr[i2].value);
              }
            }
            output = expandRange$1(range2, opts);
            state.backtrack = true;
          }
          if (brace.comma !== true && brace.dots !== true) {
            const out2 = state.output.slice(0, brace.outputIndex);
            const toks = state.tokens.slice(brace.tokensIndex);
            brace.value = brace.output = "\\{";
            value = output = "\\}";
            state.output = out2;
            for (const t of toks) {
              state.output += t.output || t.value;
            }
          }
          push2({ type: "brace", value, output });
          decrement("braces");
          braces2.pop();
          continue;
        }
        if (value === "|") {
          if (extglobs.length > 0) {
            extglobs[extglobs.length - 1].conditions++;
          }
          push2({ type: "text", value });
          continue;
        }
        if (value === ",") {
          let output = value;
          const brace = braces2[braces2.length - 1];
          if (brace && stack2[stack2.length - 1] === "braces") {
            brace.comma = true;
            output = "|";
          }
          push2({ type: "comma", value, output });
          continue;
        }
        if (value === "/") {
          if (prev.type === "dot" && state.index === state.start + 1) {
            state.start = state.index + 1;
            state.consumed = "";
            state.output = "";
            tokens.pop();
            prev = bos;
            continue;
          }
          push2({ type: "slash", value, output: SLASH_LITERAL2 });
          continue;
        }
        if (value === ".") {
          if (state.braces > 0 && prev.type === "dot") {
            if (prev.value === ".")
              prev.output = DOT_LITERAL2;
            const brace = braces2[braces2.length - 1];
            prev.type = "dots";
            prev.output += value;
            prev.value += value;
            brace.dots = true;
            continue;
          }
          if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
            push2({ type: "text", value, output: DOT_LITERAL2 });
            continue;
          }
          push2({ type: "dot", value, output: DOT_LITERAL2 });
          continue;
        }
        if (value === "?") {
          const isGroup = prev && prev.value === "(";
          if (!isGroup && opts.noextglob !== true && peek2() === "(" && peek2(2) !== "?") {
            extglobOpen("qmark", value);
            continue;
          }
          if (prev && prev.type === "paren") {
            const next = peek2();
            let output = value;
            if (next === "<" && !utils$n.supportsLookbehinds()) {
              throw new Error("Node.js v10 or higher is required for regex lookbehinds");
            }
            if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
              output = `\\${value}`;
            }
            push2({ type: "text", value, output });
            continue;
          }
          if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
            push2({ type: "qmark", value, output: QMARK_NO_DOT2 });
            continue;
          }
          push2({ type: "qmark", value, output: QMARK2 });
          continue;
        }
        if (value === "!") {
          if (opts.noextglob !== true && peek2() === "(") {
            if (peek2(2) !== "?" || !/[!=<:]/.test(peek2(3))) {
              extglobOpen("negate", value);
              continue;
            }
          }
          if (opts.nonegate !== true && state.index === 0) {
            negate();
            continue;
          }
        }
        if (value === "+") {
          if (opts.noextglob !== true && peek2() === "(" && peek2(2) !== "?") {
            extglobOpen("plus", value);
            continue;
          }
          if (prev && prev.value === "(" || opts.regex === false) {
            push2({ type: "plus", value, output: PLUS_LITERAL2 });
            continue;
          }
          if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
            push2({ type: "plus", value });
            continue;
          }
          push2({ type: "plus", value: PLUS_LITERAL2 });
          continue;
        }
        if (value === "@") {
          if (opts.noextglob !== true && peek2() === "(" && peek2(2) !== "?") {
            push2({ type: "at", extglob: true, value, output: "" });
            continue;
          }
          push2({ type: "text", value });
          continue;
        }
        if (value !== "*") {
          if (value === "$" || value === "^") {
            value = `\\${value}`;
          }
          const match2 = REGEX_NON_SPECIAL_CHARS$1.exec(remaining());
          if (match2) {
            value += match2[0];
            state.index += match2[0].length;
          }
          push2({ type: "text", value });
          continue;
        }
        if (prev && (prev.type === "globstar" || prev.star === true)) {
          prev.type = "star";
          prev.star = true;
          prev.value += value;
          prev.output = star2;
          state.backtrack = true;
          state.globstar = true;
          consume(value);
          continue;
        }
        let rest = remaining();
        if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
          extglobOpen("star", value);
          continue;
        }
        if (prev.type === "star") {
          if (opts.noglobstar === true) {
            consume(value);
            continue;
          }
          const prior = prev.prev;
          const before = prior.prev;
          const isStart = prior.type === "slash" || prior.type === "bos";
          const afterStar = before && (before.type === "star" || before.type === "globstar");
          if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
            push2({ type: "star", value, output: "" });
            continue;
          }
          const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
          const isExtglob2 = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
          if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob2) {
            push2({ type: "star", value, output: "" });
            continue;
          }
          while (rest.slice(0, 3) === "/**") {
            const after = input[state.index + 4];
            if (after && after !== "/") {
              break;
            }
            rest = rest.slice(3);
            consume("/**", 3);
          }
          if (prior.type === "bos" && eos()) {
            prev.type = "globstar";
            prev.value += value;
            prev.output = globstar(opts);
            state.output = prev.output;
            state.globstar = true;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
            prev.value += value;
            state.globstar = true;
            state.output += prior.output + prev.output;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
            const end = rest[1] !== void 0 ? "|$" : "";
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = `${globstar(opts)}${SLASH_LITERAL2}|${SLASH_LITERAL2}${end})`;
            prev.value += value;
            state.output += prior.output + prev.output;
            state.globstar = true;
            consume(value + advance());
            push2({ type: "slash", value: "/", output: "" });
            continue;
          }
          if (prior.type === "bos" && rest[0] === "/") {
            prev.type = "globstar";
            prev.value += value;
            prev.output = `(?:^|${SLASH_LITERAL2}|${globstar(opts)}${SLASH_LITERAL2})`;
            state.output = prev.output;
            state.globstar = true;
            consume(value + advance());
            push2({ type: "slash", value: "/", output: "" });
            continue;
          }
          state.output = state.output.slice(0, -prev.output.length);
          prev.type = "globstar";
          prev.output = globstar(opts);
          prev.value += value;
          state.output += prev.output;
          state.globstar = true;
          consume(value);
          continue;
        }
        const token2 = { type: "star", value, output: star2 };
        if (opts.bash === true) {
          token2.output = ".*?";
          if (prev.type === "bos" || prev.type === "slash") {
            token2.output = nodot + token2.output;
          }
          push2(token2);
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
          token2.output = value;
          push2(token2);
          continue;
        }
        if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
          if (prev.type === "dot") {
            state.output += NO_DOT_SLASH2;
            prev.output += NO_DOT_SLASH2;
          } else if (opts.dot === true) {
            state.output += NO_DOTS_SLASH2;
            prev.output += NO_DOTS_SLASH2;
          } else {
            state.output += nodot;
            prev.output += nodot;
          }
          if (peek2() !== "*") {
            state.output += ONE_CHAR2;
            prev.output += ONE_CHAR2;
          }
        }
        push2(token2);
      }
      while (state.brackets > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError$2("closing", "]"));
        state.output = utils$n.escapeLast(state.output, "[");
        decrement("brackets");
      }
      while (state.parens > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError$2("closing", ")"));
        state.output = utils$n.escapeLast(state.output, "(");
        decrement("parens");
      }
      while (state.braces > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError$2("closing", "}"));
        state.output = utils$n.escapeLast(state.output, "{");
        decrement("braces");
      }
      if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
        push2({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL2}?` });
      }
      if (state.backtrack === true) {
        state.output = "";
        for (const token2 of state.tokens) {
          state.output += token2.output != null ? token2.output : token2.value;
          if (token2.suffix) {
            state.output += token2.suffix;
          }
        }
      }
      return state;
    };
    parse$n.fastpaths = (input, options2) => {
      const opts = __spreadValues2({}, options2);
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH$2, opts.maxLength) : MAX_LENGTH$2;
      const len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      input = REPLACEMENTS$1[input] || input;
      const win322 = utils$n.isWindows(options2);
      const {
        DOT_LITERAL: DOT_LITERAL2,
        SLASH_LITERAL: SLASH_LITERAL2,
        ONE_CHAR: ONE_CHAR2,
        DOTS_SLASH: DOTS_SLASH2,
        NO_DOT: NO_DOT2,
        NO_DOTS: NO_DOTS2,
        NO_DOTS_SLASH: NO_DOTS_SLASH2,
        STAR: STAR2,
        START_ANCHOR: START_ANCHOR2
      } = constants$8.globChars(win322);
      const nodot = opts.dot ? NO_DOTS2 : NO_DOT2;
      const slashDot = opts.dot ? NO_DOTS_SLASH2 : NO_DOT2;
      const capture = opts.capture ? "" : "?:";
      const state = { negated: false, prefix: "" };
      let star2 = opts.bash === true ? ".*?" : STAR2;
      if (opts.capture) {
        star2 = `(${star2})`;
      }
      const globstar = (opts2) => {
        if (opts2.noglobstar === true)
          return star2;
        return `(${capture}(?:(?!${START_ANCHOR2}${opts2.dot ? DOTS_SLASH2 : DOT_LITERAL2}).)*?)`;
      };
      const create = (str) => {
        switch (str) {
          case "*":
            return `${nodot}${ONE_CHAR2}${star2}`;
          case ".*":
            return `${DOT_LITERAL2}${ONE_CHAR2}${star2}`;
          case "*.*":
            return `${nodot}${star2}${DOT_LITERAL2}${ONE_CHAR2}${star2}`;
          case "*/*":
            return `${nodot}${star2}${SLASH_LITERAL2}${ONE_CHAR2}${slashDot}${star2}`;
          case "**":
            return nodot + globstar(opts);
          case "**/*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL2})?${slashDot}${ONE_CHAR2}${star2}`;
          case "**/*.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL2})?${slashDot}${star2}${DOT_LITERAL2}${ONE_CHAR2}${star2}`;
          case "**/.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL2})?${DOT_LITERAL2}${ONE_CHAR2}${star2}`;
          default: {
            const match2 = /^(.*?)\.(\w+)$/.exec(str);
            if (!match2)
              return;
            const source3 = create(match2[1]);
            if (!source3)
              return;
            return source3 + DOT_LITERAL2 + match2[2];
          }
        }
      };
      const output = utils$n.removePrefix(input, state);
      let source2 = create(output);
      if (source2 && opts.strictSlashes !== true) {
        source2 += `${SLASH_LITERAL2}?`;
      }
      return source2;
    };
    var parse_1$3 = parse$n;
    var path$p = path__default;
    var scan$2 = scan_1$1;
    var parse$m = parse_1$3;
    var utils$m = utils$p;
    var constants$7 = constants$9;
    var isObject$4 = (val) => val && typeof val === "object" && !Array.isArray(val);
    var picomatch$7 = (glob2, options2, returnState = false) => {
      if (Array.isArray(glob2)) {
        const fns = glob2.map((input) => picomatch$7(input, options2, returnState));
        const arrayMatcher = (str) => {
          for (const isMatch2 of fns) {
            const state2 = isMatch2(str);
            if (state2)
              return state2;
          }
          return false;
        };
        return arrayMatcher;
      }
      const isState = isObject$4(glob2) && glob2.tokens && glob2.input;
      if (glob2 === "" || typeof glob2 !== "string" && !isState) {
        throw new TypeError("Expected pattern to be a non-empty string");
      }
      const opts = options2 || {};
      const posix2 = utils$m.isWindows(options2);
      const regex = isState ? picomatch$7.compileRe(glob2, options2) : picomatch$7.makeRe(glob2, options2, false, true);
      const state = regex.state;
      delete regex.state;
      let isIgnored2 = () => false;
      if (opts.ignore) {
        const ignoreOpts = __spreadProps2(__spreadValues2({}, options2), { ignore: null, onMatch: null, onResult: null });
        isIgnored2 = picomatch$7(opts.ignore, ignoreOpts, returnState);
      }
      const matcher2 = (input, returnObject = false) => {
        const { isMatch: isMatch2, match: match2, output } = picomatch$7.test(input, regex, options2, { glob: glob2, posix: posix2 });
        const result2 = { glob: glob2, state, regex, posix: posix2, input, output, match: match2, isMatch: isMatch2 };
        if (typeof opts.onResult === "function") {
          opts.onResult(result2);
        }
        if (isMatch2 === false) {
          result2.isMatch = false;
          return returnObject ? result2 : false;
        }
        if (isIgnored2(input)) {
          if (typeof opts.onIgnore === "function") {
            opts.onIgnore(result2);
          }
          result2.isMatch = false;
          return returnObject ? result2 : false;
        }
        if (typeof opts.onMatch === "function") {
          opts.onMatch(result2);
        }
        return returnObject ? result2 : true;
      };
      if (returnState) {
        matcher2.state = state;
      }
      return matcher2;
    };
    picomatch$7.test = (input, regex, options2, { glob: glob2, posix: posix2 } = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected input to be a string");
      }
      if (input === "") {
        return { isMatch: false, output: "" };
      }
      const opts = options2 || {};
      const format2 = opts.format || (posix2 ? utils$m.toPosixSlashes : null);
      let match2 = input === glob2;
      let output = match2 && format2 ? format2(input) : input;
      if (match2 === false) {
        output = format2 ? format2(input) : input;
        match2 = output === glob2;
      }
      if (match2 === false || opts.capture === true) {
        if (opts.matchBase === true || opts.basename === true) {
          match2 = picomatch$7.matchBase(input, regex, options2, posix2);
        } else {
          match2 = regex.exec(output);
        }
      }
      return { isMatch: Boolean(match2), match: match2, output };
    };
    picomatch$7.matchBase = (input, glob2, options2, posix2 = utils$m.isWindows(options2)) => {
      const regex = glob2 instanceof RegExp ? glob2 : picomatch$7.makeRe(glob2, options2);
      return regex.test(path$p.basename(input));
    };
    picomatch$7.isMatch = (str, patterns2, options2) => picomatch$7(patterns2, options2)(str);
    picomatch$7.parse = (pattern2, options2) => {
      if (Array.isArray(pattern2))
        return pattern2.map((p2) => picomatch$7.parse(p2, options2));
      return parse$m(pattern2, __spreadProps2(__spreadValues2({}, options2), { fastpaths: false }));
    };
    picomatch$7.scan = (input, options2) => scan$2(input, options2);
    picomatch$7.compileRe = (state, options2, returnOutput = false, returnState = false) => {
      if (returnOutput === true) {
        return state.output;
      }
      const opts = options2 || {};
      const prepend = opts.contains ? "" : "^";
      const append2 = opts.contains ? "" : "$";
      let source2 = `${prepend}(?:${state.output})${append2}`;
      if (state && state.negated === true) {
        source2 = `^(?!${source2}).*$`;
      }
      const regex = picomatch$7.toRegex(source2, options2);
      if (returnState === true) {
        regex.state = state;
      }
      return regex;
    };
    picomatch$7.makeRe = (input, options2 = {}, returnOutput = false, returnState = false) => {
      if (!input || typeof input !== "string") {
        throw new TypeError("Expected a non-empty string");
      }
      let parsed = { negated: false, fastpaths: true };
      if (options2.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
        parsed.output = parse$m.fastpaths(input, options2);
      }
      if (!parsed.output) {
        parsed = parse$m(input, options2);
      }
      return picomatch$7.compileRe(parsed, options2, returnOutput, returnState);
    };
    picomatch$7.toRegex = (source2, options2) => {
      try {
        const opts = options2 || {};
        return new RegExp(source2, opts.flags || (opts.nocase ? "i" : ""));
      } catch (err) {
        if (options2 && options2.debug === true)
          throw err;
        return /$^/;
      }
    };
    picomatch$7.constants = constants$7;
    var picomatch_1$1 = picomatch$7;
    var picomatch$6 = picomatch_1$1;
    function isArray$3(arg) {
      return Array.isArray(arg);
    }
    function ensureArray$1(thing) {
      if (isArray$3(thing))
        return thing;
      if (thing == null)
        return [];
      return [thing];
    }
    var normalizePath$3 = function normalizePath2(filename2) {
      return filename2.split(path$r.win32.sep).join(path$r.posix.sep);
    };
    function getMatcherString$1(id, resolutionBase) {
      if (resolutionBase === false || path$r.isAbsolute(id) || id.startsWith("*")) {
        return id;
      }
      const basePath = normalizePath$3(path$r.resolve(resolutionBase || "")).replace(/[-^$*+?.()|[\]{}]/g, "\\$&");
      return path$r.posix.join(basePath, id);
    }
    var createFilter$1 = function createFilter2(include, exclude, options2) {
      const resolutionBase = options2 && options2.resolve;
      const getMatcher = (id) => id instanceof RegExp ? id : {
        test: (what) => {
          const pattern2 = getMatcherString$1(id, resolutionBase);
          const fn2 = picomatch$6(pattern2, { dot: true });
          const result2 = fn2(what);
          return result2;
        }
      };
      const includeMatchers = ensureArray$1(include).map(getMatcher);
      const excludeMatchers = ensureArray$1(exclude).map(getMatcher);
      return function result2(id) {
        if (typeof id !== "string")
          return false;
        if (/\0/.test(id))
          return false;
        const pathId = normalizePath$3(id);
        for (let i2 = 0; i2 < excludeMatchers.length; ++i2) {
          const matcher2 = excludeMatchers[i2];
          if (matcher2.test(pathId))
            return false;
        }
        for (let i2 = 0; i2 < includeMatchers.length; ++i2) {
          const matcher2 = includeMatchers[i2];
          if (matcher2.test(pathId))
            return true;
        }
        return !includeMatchers.length;
      };
    };
    var reservedWords$2 = "break case class catch const continue debugger default delete do else export extends finally for function if import in instanceof let new return super switch this throw try typeof var void while with yield enum await implements package protected static interface private public";
    var builtins$1 = "arguments Infinity NaN undefined null true false eval uneval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Symbol Error EvalError InternalError RangeError ReferenceError SyntaxError TypeError URIError Number Math Date String RegExp Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array Map Set WeakMap WeakSet SIMD ArrayBuffer DataView JSON Promise Generator GeneratorFunction Reflect Proxy Intl";
    var forbiddenIdentifiers$1 = new Set(`${reservedWords$2} ${builtins$1}`.split(" "));
    forbiddenIdentifiers$1.add("");
    var makeLegalIdentifier$1 = function makeLegalIdentifier2(str) {
      let identifier = str.replace(/-(\w)/g, (_2, letter) => letter.toUpperCase()).replace(/[^$_a-zA-Z0-9]/g, "_");
      if (/\d/.test(identifier[0]) || forbiddenIdentifiers$1.has(identifier)) {
        identifier = `_${identifier}`;
      }
      return identifier || "_";
    };
    function stringify$8(obj) {
      return (JSON.stringify(obj) || "undefined").replace(/[\u2028\u2029]/g, (char) => `\\u${`000${char.charCodeAt(0).toString(16)}`.slice(-4)}`);
    }
    function serializeArray(arr, indent, baseIndent) {
      let output = "[";
      const separator = indent ? `
${baseIndent}${indent}` : "";
      for (let i2 = 0; i2 < arr.length; i2++) {
        const key2 = arr[i2];
        output += `${i2 > 0 ? "," : ""}${separator}${serialize(key2, indent, baseIndent + indent)}`;
      }
      return `${output}${indent ? `
${baseIndent}` : ""}]`;
    }
    function serializeObject(obj, indent, baseIndent) {
      let output = "{";
      const separator = indent ? `
${baseIndent}${indent}` : "";
      const entries = Object.entries(obj);
      for (let i2 = 0; i2 < entries.length; i2++) {
        const [key2, value] = entries[i2];
        const stringKey = makeLegalIdentifier$1(key2) === key2 ? key2 : stringify$8(key2);
        output += `${i2 > 0 ? "," : ""}${separator}${stringKey}:${indent ? " " : ""}${serialize(value, indent, baseIndent + indent)}`;
      }
      return `${output}${indent ? `
${baseIndent}` : ""}}`;
    }
    function serialize(obj, indent, baseIndent) {
      if (typeof obj === "object" && obj !== null) {
        if (Array.isArray(obj))
          return serializeArray(obj, indent, baseIndent);
        if (obj instanceof Date)
          return `new Date(${obj.getTime()})`;
        if (obj instanceof RegExp)
          return obj.toString();
        return serializeObject(obj, indent, baseIndent);
      }
      if (typeof obj === "number") {
        if (obj === Infinity)
          return "Infinity";
        if (obj === -Infinity)
          return "-Infinity";
        if (obj === 0)
          return 1 / obj === Infinity ? "0" : "-0";
        if (obj !== obj)
          return "NaN";
      }
      if (typeof obj === "symbol") {
        const key2 = Symbol.keyFor(obj);
        if (key2 !== void 0)
          return `Symbol.for(${stringify$8(key2)})`;
      }
      if (typeof obj === "bigint")
        return `${obj}n`;
      return stringify$8(obj);
    }
    var dataToEsm = function dataToEsm2(data2, options2 = {}) {
      const t = options2.compact ? "" : "indent" in options2 ? options2.indent : "	";
      const _2 = options2.compact ? "" : " ";
      const n3 = options2.compact ? "" : "\n";
      const declarationType = options2.preferConst ? "const" : "var";
      if (options2.namedExports === false || typeof data2 !== "object" || Array.isArray(data2) || data2 instanceof Date || data2 instanceof RegExp || data2 === null) {
        const code = serialize(data2, options2.compact ? null : t, "");
        const magic = _2 || (/^[{[\-\/]/.test(code) ? "" : " ");
        return `export default${magic}${code};`;
      }
      let namedExportCode = "";
      const defaultExportRows = [];
      for (const [key2, value] of Object.entries(data2)) {
        if (key2 === makeLegalIdentifier$1(key2)) {
          if (options2.objectShorthand)
            defaultExportRows.push(key2);
          else
            defaultExportRows.push(`${key2}:${_2}${key2}`);
          namedExportCode += `export ${declarationType} ${key2}${_2}=${_2}${serialize(value, options2.compact ? null : t, "")};${n3}`;
        } else {
          defaultExportRows.push(`${stringify$8(key2)}:${_2}${serialize(value, options2.compact ? null : t, "")}`);
        }
      }
      return `${namedExportCode}export default${_2}{${n3}${t}${defaultExportRows.join(`,${n3}${t}`)}${n3}};${n3}`;
    };
    var __defProp = Object.defineProperty;
    var __defProps = Object.defineProperties;
    var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
    var __getOwnPropSymbols = Object.getOwnPropertySymbols;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __propIsEnum = Object.prototype.propertyIsEnumerable;
    var __defNormalProp = (obj, key2, value) => key2 in obj ? __defProp(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
    var __spreadValues = (a2, b2) => {
      for (var prop in b2 || (b2 = {}))
        if (__hasOwnProp.call(b2, prop))
          __defNormalProp(a2, prop, b2[prop]);
      if (__getOwnPropSymbols)
        for (var prop of __getOwnPropSymbols(b2)) {
          if (__propIsEnum.call(b2, prop))
            __defNormalProp(a2, prop, b2[prop]);
        }
      return a2;
    };
    var __spreadProps = (a2, b2) => __defProps(a2, __getOwnPropDescs(b2));
    async function find(filename2, options2) {
      let dir = path__default.dirname(path__default.resolve(filename2));
      const root2 = (options2 == null ? void 0 : options2.root) ? path__default.resolve(options2.root) : null;
      while (dir) {
        const tsconfig = await tsconfigInDir(dir, options2);
        if (tsconfig) {
          return tsconfig;
        } else {
          if (root2 === dir) {
            break;
          }
          const parent = path__default.dirname(dir);
          if (parent === dir) {
            break;
          } else {
            dir = parent;
          }
        }
      }
      throw new Error(`no tsconfig file found for ${filename2}`);
    }
    async function tsconfigInDir(dir, options2) {
      const tsconfig = path__default.join(dir, "tsconfig.json");
      if (options2 == null ? void 0 : options2.tsConfigPaths) {
        return options2.tsConfigPaths.has(tsconfig) ? tsconfig : void 0;
      }
      try {
        const stat2 = await fs$n.promises.stat(tsconfig);
        if (stat2.isFile() || stat2.isFIFO()) {
          return tsconfig;
        }
      } catch (e2) {
        if (e2.code !== "ENOENT") {
          throw e2;
        }
      }
    }
    async function findAll(dir, options2) {
      const files = [];
      for await (const tsconfigFile of findTSConfig(path__default.resolve(dir), options2)) {
        files.push(tsconfigFile);
      }
      return files;
    }
    async function* findTSConfig(dir, options2, visited = /* @__PURE__ */ new Set()) {
      if (!visited.has(dir)) {
        const dirents = await fs$n.promises.readdir(dir, { withFileTypes: true });
        for (const dirent of dirents) {
          if (dirent.isDirectory() && (!(options2 == null ? void 0 : options2.skip) || !options2.skip(dirent.name))) {
            yield* findTSConfig(path__default.resolve(dir, dirent.name), options2, visited);
          } else if (dirent.isFile() && dirent.name === "tsconfig.json") {
            yield path__default.resolve(dir, dirent.name);
          }
        }
      }
    }
    function toJson(tsconfigJson) {
      const stripped = stripDanglingComma(stripJsonComments(stripBom(tsconfigJson)));
      if (stripped.trim() === "") {
        return "{}";
      } else {
        return stripped;
      }
    }
    function stripDanglingComma(pseudoJson) {
      let insideString = false;
      let offset2 = 0;
      let result2 = "";
      let danglingCommaPos = null;
      for (let i2 = 0; i2 < pseudoJson.length; i2++) {
        const currentCharacter = pseudoJson[i2];
        if (currentCharacter === '"') {
          const escaped2 = isEscaped(pseudoJson, i2);
          if (!escaped2) {
            insideString = !insideString;
          }
        }
        if (insideString) {
          danglingCommaPos = null;
          continue;
        }
        if (currentCharacter === ",") {
          danglingCommaPos = i2;
          continue;
        }
        if (danglingCommaPos) {
          if (currentCharacter === "}" || currentCharacter === "]") {
            result2 += pseudoJson.slice(offset2, danglingCommaPos) + " ";
            offset2 = danglingCommaPos + 1;
            danglingCommaPos = null;
          } else if (!currentCharacter.match(/\s/)) {
            danglingCommaPos = null;
          }
        }
      }
      return result2 + pseudoJson.substring(offset2);
    }
    function isEscaped(jsonString, quotePosition) {
      let index2 = quotePosition - 1;
      let backslashCount = 0;
      while (jsonString[index2] === "\\") {
        index2 -= 1;
        backslashCount += 1;
      }
      return Boolean(backslashCount % 2);
    }
    function strip(string2, start, end) {
      return string2.slice(start, end).replace(/\S/g, " ");
    }
    var singleComment = Symbol("singleComment");
    var multiComment = Symbol("multiComment");
    function stripJsonComments(jsonString) {
      let isInsideString = false;
      let isInsideComment = false;
      let offset2 = 0;
      let result2 = "";
      for (let index2 = 0; index2 < jsonString.length; index2++) {
        const currentCharacter = jsonString[index2];
        const nextCharacter = jsonString[index2 + 1];
        if (!isInsideComment && currentCharacter === '"') {
          const escaped2 = isEscaped(jsonString, index2);
          if (!escaped2) {
            isInsideString = !isInsideString;
          }
        }
        if (isInsideString) {
          continue;
        }
        if (!isInsideComment && currentCharacter + nextCharacter === "//") {
          result2 += jsonString.slice(offset2, index2);
          offset2 = index2;
          isInsideComment = singleComment;
          index2++;
        } else if (isInsideComment === singleComment && currentCharacter + nextCharacter === "\r\n") {
          index2++;
          isInsideComment = false;
          result2 += strip(jsonString, offset2, index2);
          offset2 = index2;
        } else if (isInsideComment === singleComment && currentCharacter === "\n") {
          isInsideComment = false;
          result2 += strip(jsonString, offset2, index2);
          offset2 = index2;
        } else if (!isInsideComment && currentCharacter + nextCharacter === "/*") {
          result2 += jsonString.slice(offset2, index2);
          offset2 = index2;
          isInsideComment = multiComment;
          index2++;
        } else if (isInsideComment === multiComment && currentCharacter + nextCharacter === "*/") {
          index2++;
          isInsideComment = false;
          result2 += strip(jsonString, offset2, index2 + 1);
          offset2 = index2 + 1;
        }
      }
      return result2 + (isInsideComment ? strip(jsonString.slice(offset2)) : jsonString.slice(offset2));
    }
    function stripBom(string2) {
      if (string2.charCodeAt(0) === 65279) {
        return string2.slice(1);
      }
      return string2;
    }
    var POSIX_SEP_RE = new RegExp("\\" + path__default.posix.sep, "g");
    var NATIVE_SEP_RE = new RegExp("\\" + path__default.sep, "g");
    var PATTERN_REGEX_CACHE = /* @__PURE__ */ new Map();
    var GLOB_ALL_PATTERN = `**/*`;
    var DEFAULT_EXTENSIONS = [".ts", ".tsx", ".mts", ".cts"];
    var DEFAULT_EXTENSIONS_RE_GROUP = `\\.(?:${DEFAULT_EXTENSIONS.map((ext2) => ext2.substring(1)).join("|")})`;
    new Function("path", "return import(path).then(m => m.default)");
    async function resolveTSConfig(filename2) {
      if (path__default.extname(filename2) !== ".json") {
        return;
      }
      const tsconfig = path__default.resolve(filename2);
      try {
        const stat2 = await fs$n.promises.stat(tsconfig);
        if (stat2.isFile() || stat2.isFIFO()) {
          return tsconfig;
        }
      } catch (e2) {
        if (e2.code !== "ENOENT") {
          throw e2;
        }
      }
      throw new Error(`no tsconfig file found for ${filename2}`);
    }
    function posix2native(filename2) {
      return path__default.posix.sep !== path__default.sep && filename2.includes(path__default.posix.sep) ? filename2.replace(POSIX_SEP_RE, path__default.sep) : filename2;
    }
    function native2posix(filename2) {
      return path__default.posix.sep !== path__default.sep && filename2.includes(path__default.sep) ? filename2.replace(NATIVE_SEP_RE, path__default.posix.sep) : filename2;
    }
    function resolve2posix(dir, filename2) {
      if (path__default.sep === path__default.posix.sep) {
        return dir ? path__default.resolve(dir, filename2) : path__default.resolve(filename2);
      }
      return native2posix(dir ? path__default.resolve(posix2native(dir), posix2native(filename2)) : path__default.resolve(posix2native(filename2)));
    }
    function resolveReferencedTSConfigFiles(result2) {
      const dir = path__default.dirname(result2.tsconfigFile);
      return result2.tsconfig.references.map((ref2) => {
        const refPath = ref2.path.endsWith(".json") ? ref2.path : path__default.join(ref2.path, "tsconfig.json");
        return resolve2posix(dir, refPath);
      });
    }
    function resolveSolutionTSConfig(filename2, result2) {
      if (result2.referenced && DEFAULT_EXTENSIONS.some((ext2) => filename2.endsWith(ext2)) && !isIncluded(filename2, result2)) {
        const solutionTSConfig = result2.referenced.find((referenced) => isIncluded(filename2, referenced));
        if (solutionTSConfig) {
          return __spreadProps(__spreadValues({}, solutionTSConfig), {
            solution: result2
          });
        }
      }
      return result2;
    }
    function isIncluded(filename2, result2) {
      const dir = native2posix(path__default.dirname(result2.tsconfigFile));
      const files = (result2.tsconfig.files || []).map((file) => resolve2posix(dir, file));
      const absoluteFilename = resolve2posix(null, filename2);
      if (files.includes(filename2)) {
        return true;
      }
      const isIncluded2 = isGlobMatch(absoluteFilename, dir, result2.tsconfig.include || (result2.tsconfig.files ? [] : [GLOB_ALL_PATTERN]));
      if (isIncluded2) {
        const isExcluded = isGlobMatch(absoluteFilename, dir, result2.tsconfig.exclude || []);
        return !isExcluded;
      }
      return false;
    }
    function isGlobMatch(filename2, dir, patterns2) {
      return patterns2.some((pattern2) => {
        let lastWildcardIndex = pattern2.length;
        let hasWildcard = false;
        for (let i2 = pattern2.length - 1; i2 > -1; i2--) {
          if (pattern2[i2] === "*" || pattern2[i2] === "?") {
            lastWildcardIndex = i2;
            hasWildcard = true;
            break;
          }
        }
        if (lastWildcardIndex < pattern2.length - 1 && !filename2.endsWith(pattern2.slice(lastWildcardIndex + 1))) {
          return false;
        }
        if (pattern2.endsWith("*") && !DEFAULT_EXTENSIONS.some((ext2) => filename2.endsWith(ext2))) {
          return false;
        }
        if (pattern2 === GLOB_ALL_PATTERN) {
          return filename2.startsWith(`${dir}/`);
        }
        const resolvedPattern = resolve2posix(dir, pattern2);
        let firstWildcardIndex = -1;
        for (let i2 = 0; i2 < resolvedPattern.length; i2++) {
          if (resolvedPattern[i2] === "*" || resolvedPattern[i2] === "?") {
            firstWildcardIndex = i2;
            hasWildcard = true;
            break;
          }
        }
        if (firstWildcardIndex > 1 && !filename2.startsWith(resolvedPattern.slice(0, firstWildcardIndex - 1))) {
          return false;
        }
        if (!hasWildcard) {
          return filename2 === resolvedPattern;
        }
        if (PATTERN_REGEX_CACHE.has(resolvedPattern)) {
          return PATTERN_REGEX_CACHE.get(resolvedPattern).test(filename2);
        }
        const regex = pattern2regex(resolvedPattern);
        PATTERN_REGEX_CACHE.set(resolvedPattern, regex);
        return regex.test(filename2);
      });
    }
    function pattern2regex(resolvedPattern) {
      let regexStr = "^";
      for (let i2 = 0; i2 < resolvedPattern.length; i2++) {
        const char = resolvedPattern[i2];
        if (char === "?") {
          regexStr += "[^\\/]";
          continue;
        }
        if (char === "*") {
          if (resolvedPattern[i2 + 1] === "*" && resolvedPattern[i2 + 2] === "/") {
            i2 += 2;
            regexStr += "(?:[^\\/]*\\/)*";
            continue;
          }
          regexStr += "[^\\/]*";
          continue;
        }
        if ("/.+^${}()|[]\\".includes(char)) {
          regexStr += `\\`;
        }
        regexStr += char;
      }
      if (resolvedPattern.endsWith("*")) {
        regexStr += DEFAULT_EXTENSIONS_RE_GROUP;
      }
      regexStr += "$";
      return new RegExp(regexStr);
    }
    async function parse$l(filename2, options2) {
      const cache2 = options2 == null ? void 0 : options2.cache;
      if (cache2 == null ? void 0 : cache2.has(filename2)) {
        return cache2.get(filename2);
      }
      let tsconfigFile;
      if (options2 == null ? void 0 : options2.resolveWithEmptyIfConfigNotFound) {
        try {
          tsconfigFile = await resolveTSConfig(filename2) || await find(filename2, options2);
        } catch (e2) {
          const notFoundResult = {
            tsconfigFile: "no_tsconfig_file_found",
            tsconfig: {}
          };
          cache2 == null ? void 0 : cache2.set(filename2, notFoundResult);
          return notFoundResult;
        }
      } else {
        tsconfigFile = await resolveTSConfig(filename2) || await find(filename2, options2);
      }
      let result2;
      if (cache2 == null ? void 0 : cache2.has(tsconfigFile)) {
        result2 = cache2.get(tsconfigFile);
      } else {
        result2 = await parseFile$1(tsconfigFile, cache2);
        await Promise.all([parseExtends(result2, cache2), parseReferences(result2, cache2)]);
        cache2 == null ? void 0 : cache2.set(tsconfigFile, result2);
      }
      result2 = resolveSolutionTSConfig(filename2, result2);
      cache2 == null ? void 0 : cache2.set(filename2, result2);
      return result2;
    }
    async function parseFile$1(tsconfigFile, cache2) {
      if (cache2 == null ? void 0 : cache2.has(tsconfigFile)) {
        return cache2.get(tsconfigFile);
      }
      try {
        const tsconfigJson = await fs$n.promises.readFile(tsconfigFile, "utf-8");
        const json2 = toJson(tsconfigJson);
        const result2 = {
          tsconfigFile,
          tsconfig: normalizeTSConfig(JSON.parse(json2), path__default.dirname(tsconfigFile))
        };
        cache2 == null ? void 0 : cache2.set(tsconfigFile, result2);
        return result2;
      } catch (e2) {
        throw new TSConfckParseError(`parsing ${tsconfigFile} failed: ${e2}`, "PARSE_FILE", tsconfigFile, e2);
      }
    }
    function normalizeTSConfig(tsconfig, dir) {
      var _a2;
      if (((_a2 = tsconfig.compilerOptions) == null ? void 0 : _a2.baseUrl) && !path__default.isAbsolute(tsconfig.compilerOptions.baseUrl)) {
        tsconfig.compilerOptions.baseUrl = resolve2posix(dir, tsconfig.compilerOptions.baseUrl);
      }
      return tsconfig;
    }
    async function parseReferences(result2, cache2) {
      if (!result2.tsconfig.references) {
        return;
      }
      const referencedFiles = resolveReferencedTSConfigFiles(result2);
      const referenced = await Promise.all(referencedFiles.map((file) => parseFile$1(file, cache2)));
      await Promise.all(referenced.map((ref2) => parseExtends(ref2, cache2)));
      result2.referenced = referenced;
    }
    async function parseExtends(result2, cache2) {
      if (!result2.tsconfig.extends) {
        return;
      }
      const extended = [
        { tsconfigFile: result2.tsconfigFile, tsconfig: JSON.parse(JSON.stringify(result2.tsconfig)) }
      ];
      while (extended[extended.length - 1].tsconfig.extends) {
        const extending = extended[extended.length - 1];
        const extendedTSConfigFile = resolveExtends(extending.tsconfig.extends, extending.tsconfigFile);
        if (extended.some((x2) => x2.tsconfigFile === extendedTSConfigFile)) {
          const circle = extended.concat({ tsconfigFile: extendedTSConfigFile, tsconfig: null }).map((e2) => e2.tsconfigFile).join(" -> ");
          throw new TSConfckParseError(`Circular dependency in "extends": ${circle}`, "EXTENDS_CIRCULAR", result2.tsconfigFile);
        }
        extended.push(await parseFile$1(extendedTSConfigFile, cache2));
      }
      result2.extended = extended;
      for (const ext2 of result2.extended.slice(1)) {
        extendTSConfig(result2, ext2);
      }
    }
    function resolveExtends(extended, from) {
      let error2;
      try {
        return require$$0$5.createRequire(from).resolve(extended);
      } catch (e2) {
        error2 = e2;
      }
      if (!path__default.isAbsolute(extended) && !extended.startsWith("./") && !extended.startsWith("../")) {
        try {
          const fallbackExtended = path__default.join(extended, "tsconfig.json");
          return require$$0$5.createRequire(from).resolve(fallbackExtended);
        } catch (e2) {
          error2 = e2;
        }
      }
      throw new TSConfckParseError(`failed to resolve "extends":"${extended}" in ${from}`, "EXTENDS_RESOLVE", from, error2);
    }
    var EXTENDABLE_KEYS = [
      "compilerOptions",
      "files",
      "include",
      "exclude",
      "watchOptions",
      "compileOnSave",
      "typeAcquisition",
      "buildOptions"
    ];
    function extendTSConfig(extending, extended) {
      const extendingConfig = extending.tsconfig;
      const extendedConfig = extended.tsconfig;
      const relativePath = native2posix(path__default.relative(path__default.dirname(extending.tsconfigFile), path__default.dirname(extended.tsconfigFile)));
      for (const key2 of Object.keys(extendedConfig).filter((key22) => EXTENDABLE_KEYS.includes(key22))) {
        if (key2 === "compilerOptions") {
          if (!extendingConfig.compilerOptions) {
            extendingConfig.compilerOptions = {};
          }
          for (const option of Object.keys(extendedConfig.compilerOptions)) {
            if (Object.prototype.hasOwnProperty.call(extendingConfig.compilerOptions, option)) {
              continue;
            }
            extendingConfig.compilerOptions[option] = rebaseRelative(option, extendedConfig.compilerOptions[option], relativePath);
          }
        } else if (extendingConfig[key2] === void 0) {
          if (key2 === "watchOptions") {
            extendingConfig.watchOptions = {};
            for (const option of Object.keys(extendedConfig.watchOptions)) {
              extendingConfig.watchOptions[option] = rebaseRelative(option, extendedConfig.watchOptions[option], relativePath);
            }
          } else {
            extendingConfig[key2] = rebaseRelative(key2, extendedConfig[key2], relativePath);
          }
        }
      }
    }
    var REBASE_KEYS = [
      "files",
      "include",
      "exclude",
      "baseUrl",
      "rootDir",
      "rootDirs",
      "typeRoots",
      "outDir",
      "outFile",
      "declarationDir",
      "excludeDirectories",
      "excludeFiles"
    ];
    function rebaseRelative(key2, value, prependPath) {
      if (!REBASE_KEYS.includes(key2)) {
        return value;
      }
      if (Array.isArray(value)) {
        return value.map((x2) => rebasePath(x2, prependPath));
      } else {
        return rebasePath(value, prependPath);
      }
    }
    function rebasePath(value, prependPath) {
      if (path__default.isAbsolute(value)) {
        return value;
      } else {
        return path__default.posix.normalize(path__default.posix.join(prependPath, value));
      }
    }
    var TSConfckParseError = class extends Error {
      constructor(message, code, tsconfigFile, cause) {
        super(message);
        Object.setPrototypeOf(this, TSConfckParseError.prototype);
        this.name = TSConfckParseError.name;
        this.code = code;
        this.cause = cause;
        this.tsconfigFile = tsconfigFile;
      }
    };
    var debug$f = createDebugger("vite:esbuild");
    var server;
    async function transformWithEsbuild(code, filename2, options2, inMap) {
      var _a2, _b, _c;
      let loader = options2 === null || options2 === void 0 ? void 0 : options2.loader;
      if (!loader) {
        const ext2 = path__default.extname(/\.\w+$/.test(filename2) ? filename2 : cleanUrl(filename2)).slice(1);
        if (ext2 === "cjs" || ext2 === "mjs") {
          loader = "js";
        } else {
          loader = ext2;
        }
      }
      let tsconfigRaw = options2 === null || options2 === void 0 ? void 0 : options2.tsconfigRaw;
      if (typeof tsconfigRaw !== "string") {
        const meaningfulFields = [
          "jsxFactory",
          "jsxFragmentFactory",
          "useDefineForClassFields",
          "importsNotUsedAsValues",
          "preserveValueImports"
        ];
        const compilerOptionsForFile = {};
        if (loader === "ts" || loader === "tsx") {
          const loadedTsconfig = await loadTsconfigJsonForFile(filename2);
          const loadedCompilerOptions = (_a2 = loadedTsconfig.compilerOptions) !== null && _a2 !== void 0 ? _a2 : {};
          for (const field of meaningfulFields) {
            if (field in loadedCompilerOptions) {
              compilerOptionsForFile[field] = loadedCompilerOptions[field];
            }
          }
          if (((_b = loadedCompilerOptions.target) === null || _b === void 0 ? void 0 : _b.toLowerCase()) === "esnext") {
            compilerOptionsForFile.useDefineForClassFields = (_c = loadedCompilerOptions.useDefineForClassFields) !== null && _c !== void 0 ? _c : true;
          }
        }
        tsconfigRaw = __spreadProps2(__spreadValues2({}, tsconfigRaw), {
          compilerOptions: __spreadValues2(__spreadValues2({}, compilerOptionsForFile), tsconfigRaw === null || tsconfigRaw === void 0 ? void 0 : tsconfigRaw.compilerOptions)
        });
      }
      const resolvedOptions = __spreadProps2(__spreadValues2({
        sourcemap: true,
        sourcefile: filename2
      }, options2), {
        loader,
        tsconfigRaw
      });
      delete resolvedOptions.include;
      delete resolvedOptions.exclude;
      delete resolvedOptions.jsxInject;
      try {
        const result2 = await esbuild.transform(code, resolvedOptions);
        let map2;
        if (inMap && resolvedOptions.sourcemap) {
          const nextMap = JSON.parse(result2.map);
          nextMap.sourcesContent = [];
          map2 = combineSourcemaps(filename2, [
            nextMap,
            inMap
          ]);
        } else {
          map2 = resolvedOptions.sourcemap ? JSON.parse(result2.map) : { mappings: "" };
        }
        if (Array.isArray(map2.sources)) {
          map2.sources = map2.sources.map((it2) => toUpperCaseDriveLetter(it2));
        }
        return __spreadProps2(__spreadValues2({}, result2), {
          map: map2
        });
      } catch (e2) {
        debug$f(`esbuild error with options used: `, resolvedOptions);
        if (e2.errors) {
          e2.frame = "";
          e2.errors.forEach((m3) => {
            e2.frame += `
` + prettifyMessage(m3, code);
          });
          e2.loc = e2.errors[0].location;
        }
        throw e2;
      }
    }
    function esbuildPlugin(options2 = {}) {
      const filter2 = createFilter$1(options2.include || /\.(tsx?|jsx)$/, options2.exclude || /\.js$/);
      return {
        name: "vite:esbuild",
        configureServer(_server) {
          server = _server;
          server.watcher.on("add", reloadOnTsconfigChange).on("change", reloadOnTsconfigChange).on("unlink", reloadOnTsconfigChange);
        },
        async configResolved(config2) {
          await initTSConfck(config2);
        },
        buildEnd() {
          server = null;
        },
        async transform(code, id) {
          if (filter2(id) || filter2(cleanUrl(id))) {
            const result2 = await transformWithEsbuild(code, id, options2);
            if (result2.warnings.length) {
              result2.warnings.forEach((m3) => {
                this.warn(prettifyMessage(m3, code));
              });
            }
            if (options2.jsxInject && /\.(?:j|t)sx\b/.test(id)) {
              result2.code = options2.jsxInject + ";" + result2.code;
            }
            return {
              code: result2.code,
              map: result2.map
            };
          }
        }
      };
    }
    var rollupToEsbuildFormatMap = {
      es: "esm",
      cjs: "cjs",
      iife: void 0
    };
    var buildEsbuildPlugin = (config2) => {
      return {
        name: "vite:esbuild-transpile",
        async configResolved(config3) {
          await initTSConfck(config3);
        },
        async renderChunk(code, chunk, opts) {
          if (opts.__vite_skip_esbuild__) {
            return null;
          }
          const target = config2.build.target;
          const minify = config2.build.minify === "esbuild" && !(config2.build.lib && opts.format === "es");
          if ((!target || target === "esnext") && !minify) {
            return null;
          }
          const res = await transformWithEsbuild(code, chunk.fileName, __spreadValues2(__spreadProps2(__spreadValues2({}, config2.esbuild), {
            target: target || void 0
          }), minify ? {
            minify,
            treeShaking: true,
            format: rollupToEsbuildFormatMap[opts.format]
          } : void 0));
          return res;
        }
      };
    };
    function prettifyMessage(m3, code) {
      let res = colors$1.yellow(m3.text);
      if (m3.location) {
        const lines = code.split(/\r?\n/g);
        const line2 = Number(m3.location.line);
        const column2 = Number(m3.location.column);
        const offset2 = lines.slice(0, line2 - 1).map((l2) => l2.length).reduce((total, l2) => total + l2 + 1, 0) + column2;
        res += `
` + generateCodeFrame(code, offset2, offset2 + 1);
      }
      return res + `
`;
    }
    var tsconfckParseOptions = {
      cache: /* @__PURE__ */ new Map(),
      tsConfigPaths: void 0,
      root: void 0,
      resolveWithEmptyIfConfigNotFound: true
    };
    async function initTSConfck(config2) {
      tsconfckParseOptions.cache.clear();
      const workspaceRoot = searchForWorkspaceRoot(config2.root);
      tsconfckParseOptions.root = workspaceRoot;
      tsconfckParseOptions.tsConfigPaths = /* @__PURE__ */ new Set([
        ...await findAll(workspaceRoot, {
          skip: (dir) => dir === "node_modules" || dir === ".git"
        })
      ]);
    }
    async function loadTsconfigJsonForFile(filename2) {
      try {
        const result2 = await parse$l(filename2, tsconfckParseOptions);
        if (server && result2.tsconfigFile !== "no_tsconfig_file_found") {
          ensureWatchedFile(server.watcher, result2.tsconfigFile, server.config.root);
        }
        return result2.tsconfig;
      } catch (e2) {
        if (e2 instanceof TSConfckParseError) {
          if (server && e2.tsconfigFile) {
            ensureWatchedFile(server.watcher, e2.tsconfigFile, server.config.root);
          }
        }
        throw e2;
      }
    }
    function reloadOnTsconfigChange(changedFile) {
      var _a2;
      if (path__default.basename(changedFile) === "tsconfig.json" || changedFile.endsWith(".json") && ((_a2 = tsconfckParseOptions === null || tsconfckParseOptions === void 0 ? void 0 : tsconfckParseOptions.cache) === null || _a2 === void 0 ? void 0 : _a2.has(changedFile))) {
        server.config.logger.info(`changed tsconfig file detected: ${changedFile} - Clearing cache and forcing full-reload to ensure typescript is compiled with updated config values.`, { clear: server.config.clearScreen, timestamp: true });
        server.moduleGraph.invalidateAll();
        initTSConfck(server.config).finally(() => {
          server.ws.send({
            type: "full-reload",
            path: "*"
          });
        });
      }
    }
    var dist$2 = {};
    var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(dist$2, "__esModule", { value: true });
    var Worker_1 = dist$2.Worker = void 0;
    var os_1 = __importDefault(require$$1__default);
    var worker_threads_1 = require$$1__default$1;
    var Worker = class {
      constructor(fn2, options2 = {}) {
        this.code = genWorkerCode(fn2);
        this.max = options2.max || Math.max(1, os_1.default.cpus().length - 1);
        this.pool = [];
        this.idlePool = [];
        this.queue = [];
      }
      async run(...args) {
        const worker = await this._getAvailableWorker();
        return new Promise((resolve2, reject) => {
          worker.currentResolve = resolve2;
          worker.currentReject = reject;
          worker.postMessage(args);
        });
      }
      stop() {
        this.pool.forEach((w3) => w3.unref());
        this.queue.forEach(([_2, reject]) => reject(new Error("Main worker pool stopped before a worker was available.")));
        this.pool = [];
        this.idlePool = [];
        this.queue = [];
      }
      async _getAvailableWorker() {
        if (this.idlePool.length) {
          return this.idlePool.shift();
        }
        if (this.pool.length < this.max) {
          const worker = new worker_threads_1.Worker(this.code, { eval: true });
          worker.on("message", (res) => {
            worker.currentResolve && worker.currentResolve(res);
            worker.currentResolve = null;
            this._assignDoneWorker(worker);
          });
          worker.on("error", (err) => {
            worker.currentReject && worker.currentReject(err);
            worker.currentReject = null;
          });
          worker.on("exit", (code) => {
            const i2 = this.pool.indexOf(worker);
            if (i2 > -1)
              this.pool.splice(i2, 1);
            if (code !== 0 && worker.currentReject) {
              worker.currentReject(new Error(`Wroker stopped with non-0 exit code ${code}`));
              worker.currentReject = null;
            }
          });
          this.pool.push(worker);
          return worker;
        }
        let resolve2;
        let reject;
        const onWorkerAvailablePromise = new Promise((r2, rj) => {
          resolve2 = r2;
          reject = rj;
        });
        this.queue.push([resolve2, reject]);
        return onWorkerAvailablePromise;
      }
      _assignDoneWorker(worker) {
        if (this.queue.length) {
          const [resolve2] = this.queue.shift();
          resolve2(worker);
          return;
        }
        this.idlePool.push(worker);
      }
    };
    Worker_1 = dist$2.Worker = Worker;
    function genWorkerCode(fn2) {
      return `
const doWork = ${fn2.toString()}

const { parentPort } = require('worker_threads')

parentPort.on('message', async (args) => {
  const res = await doWork(...args)
  parentPort.postMessage(res)
})
  `;
    }
    function terserPlugin(config2) {
      const makeWorker = () => new Worker_1((basedir, code, options2) => {
        const terserPath = __require.resolve("vite/dist/node/terser", {
          paths: [basedir]
        });
        return __require(terserPath).minify(code, options2);
      });
      let worker;
      return {
        name: "vite:terser",
        async renderChunk(code, _chunk, outputOptions) {
          if (config2.build.minify !== "terser" && !outputOptions.__vite_force_terser__) {
            return null;
          }
          if (config2.build.lib && outputOptions.format === "es") {
            return null;
          }
          worker || (worker = makeWorker());
          const res = await worker.run(__dirname, code, __spreadProps2(__spreadValues2({
            safari10: true
          }, config2.build.terserOptions), {
            sourceMap: !!outputOptions.sourcemap,
            module: outputOptions.format.startsWith("es"),
            toplevel: outputOptions.format === "cjs"
          }));
          return {
            code: res.code,
            map: res.map
          };
        },
        closeBundle() {
          worker === null || worker === void 0 ? void 0 : worker.stop();
        }
      };
    }
    function manifestPlugin(config2) {
      const manifest = {};
      let outputCount;
      return {
        name: "vite:manifest",
        buildStart() {
          outputCount = 0;
        },
        generateBundle({ format: format2 }, bundle) {
          var _a2;
          function getChunkName(chunk) {
            if (chunk.facadeModuleId) {
              let name = normalizePath$4(path__default.relative(config2.root, chunk.facadeModuleId));
              if (format2 === "system" && !chunk.name.includes("-legacy")) {
                const ext2 = path__default.extname(name);
                name = name.slice(0, -ext2.length) + `-legacy` + ext2;
              }
              return name.replace(/\0/g, "");
            } else {
              return `_` + path__default.basename(chunk.fileName);
            }
          }
          function getInternalImports(imports) {
            const filteredImports = [];
            for (const file of imports) {
              if (bundle[file] === void 0) {
                continue;
              }
              filteredImports.push(getChunkName(bundle[file]));
            }
            return filteredImports;
          }
          function createChunk(chunk) {
            const manifestChunk = {
              file: chunk.fileName
            };
            if (chunk.facadeModuleId) {
              manifestChunk.src = getChunkName(chunk);
            }
            if (chunk.isEntry) {
              manifestChunk.isEntry = true;
            }
            if (chunk.isDynamicEntry) {
              manifestChunk.isDynamicEntry = true;
            }
            if (chunk.imports.length) {
              const internalImports = getInternalImports(chunk.imports);
              if (internalImports.length > 0) {
                manifestChunk.imports = internalImports;
              }
            }
            if (chunk.dynamicImports.length) {
              const internalImports = getInternalImports(chunk.dynamicImports);
              if (internalImports.length > 0) {
                manifestChunk.dynamicImports = internalImports;
              }
            }
            if (chunk.viteMetadata.importedCss.size) {
              manifestChunk.css = [...chunk.viteMetadata.importedCss];
            }
            if (chunk.viteMetadata.importedAssets.size) {
              manifestChunk.assets = [...chunk.viteMetadata.importedAssets];
            }
            return manifestChunk;
          }
          for (const file in bundle) {
            const chunk = bundle[file];
            if (chunk.type === "chunk") {
              manifest[getChunkName(chunk)] = createChunk(chunk);
            }
          }
          outputCount++;
          const output = (_a2 = config2.build.rollupOptions) === null || _a2 === void 0 ? void 0 : _a2.output;
          const outputLength = Array.isArray(output) ? output.length : 1;
          if (outputCount >= outputLength) {
            this.emitFile({
              fileName: typeof config2.build.manifest === "string" ? config2.build.manifest : "manifest.json",
              type: "asset",
              source: JSON.stringify(manifest, null, 2)
            });
          }
        }
      };
    }
    function walk$3(ast, { enter, leave }) {
      return visit$1(ast, null, enter, leave);
    }
    var should_skip = false;
    var should_remove = false;
    var replacement = null;
    var context = {
      skip: () => should_skip = true,
      remove: () => should_remove = true,
      replace: (node2) => replacement = node2
    };
    function replace(parent, prop, index2, node2) {
      if (parent) {
        if (index2 !== null) {
          parent[prop][index2] = node2;
        } else {
          parent[prop] = node2;
        }
      }
    }
    function remove(parent, prop, index2) {
      if (parent) {
        if (index2 !== null) {
          parent[prop].splice(index2, 1);
        } else {
          delete parent[prop];
        }
      }
    }
    function visit$1(node2, parent, enter, leave, prop, index2) {
      if (node2) {
        if (enter) {
          const _should_skip = should_skip;
          const _should_remove = should_remove;
          const _replacement = replacement;
          should_skip = false;
          should_remove = false;
          replacement = null;
          enter.call(context, node2, parent, prop, index2);
          if (replacement) {
            node2 = replacement;
            replace(parent, prop, index2, node2);
          }
          if (should_remove) {
            remove(parent, prop, index2);
          }
          const skipped = should_skip;
          const removed = should_remove;
          should_skip = _should_skip;
          should_remove = _should_remove;
          replacement = _replacement;
          if (skipped)
            return node2;
          if (removed)
            return null;
        }
        for (const key2 in node2) {
          const value = node2[key2];
          if (typeof value !== "object") {
            continue;
          } else if (Array.isArray(value)) {
            for (let j2 = 0, k2 = 0; j2 < value.length; j2 += 1, k2 += 1) {
              if (value[j2] !== null && typeof value[j2].type === "string") {
                if (!visit$1(value[j2], node2, enter, leave, key2, k2)) {
                  j2--;
                }
              }
            }
          } else if (value !== null && typeof value.type === "string") {
            visit$1(value, node2, enter, leave, key2, null);
          }
        }
        if (leave) {
          const _replacement = replacement;
          const _should_remove = should_remove;
          replacement = null;
          should_remove = false;
          leave.call(context, node2, parent, prop, index2);
          if (replacement) {
            node2 = replacement;
            replace(parent, prop, index2, node2);
          }
          if (should_remove) {
            remove(parent, prop, index2);
          }
          const removed = should_remove;
          replacement = _replacement;
          should_remove = _should_remove;
          if (removed)
            return null;
        }
      }
      return node2;
    }
    var extractors = {
      ArrayPattern(names, param) {
        for (const element of param.elements) {
          if (element)
            extractors[element.type](names, element);
        }
      },
      AssignmentPattern(names, param) {
        extractors[param.left.type](names, param.left);
      },
      Identifier(names, param) {
        names.push(param.name);
      },
      MemberExpression() {
      },
      ObjectPattern(names, param) {
        for (const prop of param.properties) {
          if (prop.type === "RestElement") {
            extractors.RestElement(names, prop);
          } else {
            extractors[prop.value.type](names, prop.value);
          }
        }
      },
      RestElement(names, param) {
        extractors[param.argument.type](names, param.argument);
      }
    };
    var extractAssignedNames = function extractAssignedNames2(param) {
      const names = [];
      extractors[param.type](names, param);
      return names;
    };
    var blockDeclarations = {
      const: true,
      let: true
    };
    var Scope$1 = class {
      constructor(options2 = {}) {
        this.parent = options2.parent;
        this.isBlockScope = !!options2.block;
        this.declarations = /* @__PURE__ */ Object.create(null);
        if (options2.params) {
          options2.params.forEach((param) => {
            extractAssignedNames(param).forEach((name) => {
              this.declarations[name] = true;
            });
          });
        }
      }
      addDeclaration(node2, isBlockDeclaration, isVar) {
        if (!isBlockDeclaration && this.isBlockScope) {
          this.parent.addDeclaration(node2, isBlockDeclaration, isVar);
        } else if (node2.id) {
          extractAssignedNames(node2.id).forEach((name) => {
            this.declarations[name] = true;
          });
        }
      }
      contains(name) {
        return this.declarations[name] || (this.parent ? this.parent.contains(name) : false);
      }
    };
    var attachScopes = function attachScopes2(ast, propertyName = "scope") {
      let scope = new Scope$1();
      walk$3(ast, {
        enter(n3, parent) {
          const node2 = n3;
          if (/(Function|Class)Declaration/.test(node2.type)) {
            scope.addDeclaration(node2, false, false);
          }
          if (node2.type === "VariableDeclaration") {
            const { kind } = node2;
            const isBlockDeclaration = blockDeclarations[kind];
            const parentType = parent ? parent.type : "";
            if (!(isBlockDeclaration && /ForOfStatement/.test(parentType))) {
              node2.declarations.forEach((declaration) => {
                scope.addDeclaration(declaration, isBlockDeclaration, true);
              });
            }
          }
          let newScope;
          if (/Function/.test(node2.type)) {
            const func = node2;
            newScope = new Scope$1({
              parent: scope,
              block: false,
              params: func.params
            });
            if (func.type === "FunctionExpression" && func.id) {
              newScope.addDeclaration(func, false, false);
            }
          }
          if (node2.type === "BlockStatement" && !/Function/.test(parent.type)) {
            newScope = new Scope$1({
              parent: scope,
              block: true
            });
          }
          if (node2.type === "CatchClause") {
            newScope = new Scope$1({
              parent: scope,
              params: node2.param ? [node2.param] : [],
              block: true
            });
          }
          if (newScope) {
            Object.defineProperty(node2, propertyName, {
              value: newScope,
              configurable: true
            });
            scope = newScope;
          }
        },
        leave(n3) {
          const node2 = n3;
          if (node2[propertyName])
            scope = scope.parent;
        }
      });
      return scope;
    };
    function isArray$2(arg) {
      return Array.isArray(arg);
    }
    function ensureArray(thing) {
      if (isArray$2(thing))
        return thing;
      if (thing == null)
        return [];
      return [thing];
    }
    function getMatcherString(id, resolutionBase) {
      if (resolutionBase === false) {
        return id;
      }
      const basePath = path$r.resolve(resolutionBase || "").split(path$r.sep).join("/").replace(/[-^$*+?.()|[\]{}]/g, "\\$&");
      return path$r.posix.join(basePath, id);
    }
    var createFilter = function createFilter2(include, exclude, options2) {
      const resolutionBase = options2 && options2.resolve;
      const getMatcher = (id) => id instanceof RegExp ? id : {
        test: (what) => {
          const pattern2 = getMatcherString(id, resolutionBase);
          const fn2 = picomatch$6(pattern2, { dot: true });
          const result2 = fn2(what);
          return result2;
        }
      };
      const includeMatchers = ensureArray(include).map(getMatcher);
      const excludeMatchers = ensureArray(exclude).map(getMatcher);
      return function result2(id) {
        if (typeof id !== "string")
          return false;
        if (/\0/.test(id))
          return false;
        const pathId = id.split(path$r.sep).join("/");
        for (let i2 = 0; i2 < excludeMatchers.length; ++i2) {
          const matcher2 = excludeMatchers[i2];
          if (matcher2.test(pathId))
            return false;
        }
        for (let i2 = 0; i2 < includeMatchers.length; ++i2) {
          const matcher2 = includeMatchers[i2];
          if (matcher2.test(pathId))
            return true;
        }
        return !includeMatchers.length;
      };
    };
    var reservedWords$1 = "break case class catch const continue debugger default delete do else export extends finally for function if import in instanceof let new return super switch this throw try typeof var void while with yield enum await implements package protected static interface private public";
    var builtins = "arguments Infinity NaN undefined null true false eval uneval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Symbol Error EvalError InternalError RangeError ReferenceError SyntaxError TypeError URIError Number Math Date String RegExp Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array Map Set WeakMap WeakSet SIMD ArrayBuffer DataView JSON Promise Generator GeneratorFunction Reflect Proxy Intl";
    var forbiddenIdentifiers = new Set(`${reservedWords$1} ${builtins}`.split(" "));
    forbiddenIdentifiers.add("");
    var makeLegalIdentifier = function makeLegalIdentifier2(str) {
      let identifier = str.replace(/-(\w)/g, (_2, letter) => letter.toUpperCase()).replace(/[^$_a-zA-Z0-9]/g, "_");
      if (/\d/.test(identifier[0]) || forbiddenIdentifiers.has(identifier)) {
        identifier = `_${identifier}`;
      }
      return identifier || "_";
    };
    var path$o = path__default;
    var commondir = function(basedir, relfiles) {
      if (relfiles) {
        var files = relfiles.map(function(r2) {
          return path$o.resolve(basedir, r2);
        });
      } else {
        var files = basedir;
      }
      var res = files.slice(1).reduce(function(ps2, file) {
        if (!file.match(/^([A-Za-z]:)?\/|\\/)) {
          throw new Error("relative path without a basedir");
        }
        var xs2 = file.split(/\/+|\\+/);
        for (var i2 = 0; ps2[i2] === xs2[i2] && i2 < Math.min(ps2.length, xs2.length); i2++)
          ;
        return ps2.slice(0, i2);
      }, files[0].split(/\/+|\\+/));
      return res.length > 1 ? res.join("/") : "/";
    };
    var old$1 = {};
    var pathModule = path__default;
    var isWindows$3 = process.platform === "win32";
    var fs$m = fs__default;
    var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);
    function rethrow() {
      var callback;
      if (DEBUG) {
        var backtrace = new Error();
        callback = debugCallback;
      } else
        callback = missingCallback;
      return callback;
      function debugCallback(err) {
        if (err) {
          backtrace.message = err.message;
          err = backtrace;
          missingCallback(err);
        }
      }
      function missingCallback(err) {
        if (err) {
          if (process.throwDeprecation)
            throw err;
          else if (!process.noDeprecation) {
            var msg = "fs: missing callback " + (err.stack || err.message);
            if (process.traceDeprecation)
              console.trace(msg);
            else
              console.error(msg);
          }
        }
      }
    }
    function maybeCallback(cb) {
      return typeof cb === "function" ? cb : rethrow();
    }
    if (isWindows$3) {
      nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
    } else {
      nextPartRe = /(.*?)(?:[\/]+|$)/g;
    }
    var nextPartRe;
    if (isWindows$3) {
      splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
    } else {
      splitRootRe = /^[\/]*/;
    }
    var splitRootRe;
    old$1.realpathSync = function realpathSync2(p2, cache2) {
      p2 = pathModule.resolve(p2);
      if (cache2 && Object.prototype.hasOwnProperty.call(cache2, p2)) {
        return cache2[p2];
      }
      var original = p2, seenLinks = {}, knownHard = {};
      var pos2;
      var current;
      var base2;
      var previous;
      start();
      function start() {
        var m3 = splitRootRe.exec(p2);
        pos2 = m3[0].length;
        current = m3[0];
        base2 = m3[0];
        previous = "";
        if (isWindows$3 && !knownHard[base2]) {
          fs$m.lstatSync(base2);
          knownHard[base2] = true;
        }
      }
      while (pos2 < p2.length) {
        nextPartRe.lastIndex = pos2;
        var result2 = nextPartRe.exec(p2);
        previous = current;
        current += result2[0];
        base2 = previous + result2[1];
        pos2 = nextPartRe.lastIndex;
        if (knownHard[base2] || cache2 && cache2[base2] === base2) {
          continue;
        }
        var resolvedLink;
        if (cache2 && Object.prototype.hasOwnProperty.call(cache2, base2)) {
          resolvedLink = cache2[base2];
        } else {
          var stat2 = fs$m.lstatSync(base2);
          if (!stat2.isSymbolicLink()) {
            knownHard[base2] = true;
            if (cache2)
              cache2[base2] = base2;
            continue;
          }
          var linkTarget = null;
          if (!isWindows$3) {
            var id = stat2.dev.toString(32) + ":" + stat2.ino.toString(32);
            if (seenLinks.hasOwnProperty(id)) {
              linkTarget = seenLinks[id];
            }
          }
          if (linkTarget === null) {
            fs$m.statSync(base2);
            linkTarget = fs$m.readlinkSync(base2);
          }
          resolvedLink = pathModule.resolve(previous, linkTarget);
          if (cache2)
            cache2[base2] = resolvedLink;
          if (!isWindows$3)
            seenLinks[id] = linkTarget;
        }
        p2 = pathModule.resolve(resolvedLink, p2.slice(pos2));
        start();
      }
      if (cache2)
        cache2[original] = p2;
      return p2;
    };
    old$1.realpath = function realpath2(p2, cache2, cb) {
      if (typeof cb !== "function") {
        cb = maybeCallback(cache2);
        cache2 = null;
      }
      p2 = pathModule.resolve(p2);
      if (cache2 && Object.prototype.hasOwnProperty.call(cache2, p2)) {
        return process.nextTick(cb.bind(null, null, cache2[p2]));
      }
      var original = p2, seenLinks = {}, knownHard = {};
      var pos2;
      var current;
      var base2;
      var previous;
      start();
      function start() {
        var m3 = splitRootRe.exec(p2);
        pos2 = m3[0].length;
        current = m3[0];
        base2 = m3[0];
        previous = "";
        if (isWindows$3 && !knownHard[base2]) {
          fs$m.lstat(base2, function(err) {
            if (err)
              return cb(err);
            knownHard[base2] = true;
            LOOP();
          });
        } else {
          process.nextTick(LOOP);
        }
      }
      function LOOP() {
        if (pos2 >= p2.length) {
          if (cache2)
            cache2[original] = p2;
          return cb(null, p2);
        }
        nextPartRe.lastIndex = pos2;
        var result2 = nextPartRe.exec(p2);
        previous = current;
        current += result2[0];
        base2 = previous + result2[1];
        pos2 = nextPartRe.lastIndex;
        if (knownHard[base2] || cache2 && cache2[base2] === base2) {
          return process.nextTick(LOOP);
        }
        if (cache2 && Object.prototype.hasOwnProperty.call(cache2, base2)) {
          return gotResolvedLink(cache2[base2]);
        }
        return fs$m.lstat(base2, gotStat);
      }
      function gotStat(err, stat2) {
        if (err)
          return cb(err);
        if (!stat2.isSymbolicLink()) {
          knownHard[base2] = true;
          if (cache2)
            cache2[base2] = base2;
          return process.nextTick(LOOP);
        }
        if (!isWindows$3) {
          var id = stat2.dev.toString(32) + ":" + stat2.ino.toString(32);
          if (seenLinks.hasOwnProperty(id)) {
            return gotTarget(null, seenLinks[id], base2);
          }
        }
        fs$m.stat(base2, function(err2) {
          if (err2)
            return cb(err2);
          fs$m.readlink(base2, function(err3, target) {
            if (!isWindows$3)
              seenLinks[id] = target;
            gotTarget(err3, target);
          });
        });
      }
      function gotTarget(err, target, base3) {
        if (err)
          return cb(err);
        var resolvedLink = pathModule.resolve(previous, target);
        if (cache2)
          cache2[base3] = resolvedLink;
        gotResolvedLink(resolvedLink);
      }
      function gotResolvedLink(resolvedLink) {
        p2 = pathModule.resolve(resolvedLink, p2.slice(pos2));
        start();
      }
    };
    var fs_realpath = realpath$2;
    realpath$2.realpath = realpath$2;
    realpath$2.sync = realpathSync;
    realpath$2.realpathSync = realpathSync;
    realpath$2.monkeypatch = monkeypatch;
    realpath$2.unmonkeypatch = unmonkeypatch;
    var fs$l = fs__default;
    var origRealpath = fs$l.realpath;
    var origRealpathSync = fs$l.realpathSync;
    var version$1 = process.version;
    var ok = /^v[0-5]\./.test(version$1);
    var old = old$1;
    function newError(er2) {
      return er2 && er2.syscall === "realpath" && (er2.code === "ELOOP" || er2.code === "ENOMEM" || er2.code === "ENAMETOOLONG");
    }
    function realpath$2(p2, cache2, cb) {
      if (ok) {
        return origRealpath(p2, cache2, cb);
      }
      if (typeof cache2 === "function") {
        cb = cache2;
        cache2 = null;
      }
      origRealpath(p2, cache2, function(er2, result2) {
        if (newError(er2)) {
          old.realpath(p2, cache2, cb);
        } else {
          cb(er2, result2);
        }
      });
    }
    function realpathSync(p2, cache2) {
      if (ok) {
        return origRealpathSync(p2, cache2);
      }
      try {
        return origRealpathSync(p2, cache2);
      } catch (er2) {
        if (newError(er2)) {
          return old.realpathSync(p2, cache2);
        } else {
          throw er2;
        }
      }
    }
    function monkeypatch() {
      fs$l.realpath = realpath$2;
      fs$l.realpathSync = realpathSync;
    }
    function unmonkeypatch() {
      fs$l.realpath = origRealpath;
      fs$l.realpathSync = origRealpathSync;
    }
    var concatMap$1 = function(xs2, fn2) {
      var res = [];
      for (var i2 = 0; i2 < xs2.length; i2++) {
        var x2 = fn2(xs2[i2], i2);
        if (isArray$1(x2))
          res.push.apply(res, x2);
        else
          res.push(x2);
      }
      return res;
    };
    var isArray$1 = Array.isArray || function(xs2) {
      return Object.prototype.toString.call(xs2) === "[object Array]";
    };
    var balancedMatch = balanced$1;
    function balanced$1(a2, b2, str) {
      if (a2 instanceof RegExp)
        a2 = maybeMatch(a2, str);
      if (b2 instanceof RegExp)
        b2 = maybeMatch(b2, str);
      var r2 = range(a2, b2, str);
      return r2 && {
        start: r2[0],
        end: r2[1],
        pre: str.slice(0, r2[0]),
        body: str.slice(r2[0] + a2.length, r2[1]),
        post: str.slice(r2[1] + b2.length)
      };
    }
    function maybeMatch(reg, str) {
      var m3 = str.match(reg);
      return m3 ? m3[0] : null;
    }
    balanced$1.range = range;
    function range(a2, b2, str) {
      var begs, beg, left, right, result2;
      var ai2 = str.indexOf(a2);
      var bi2 = str.indexOf(b2, ai2 + 1);
      var i2 = ai2;
      if (ai2 >= 0 && bi2 > 0) {
        if (a2 === b2) {
          return [ai2, bi2];
        }
        begs = [];
        left = str.length;
        while (i2 >= 0 && !result2) {
          if (i2 == ai2) {
            begs.push(i2);
            ai2 = str.indexOf(a2, i2 + 1);
          } else if (begs.length == 1) {
            result2 = [begs.pop(), bi2];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi2;
            }
            bi2 = str.indexOf(b2, i2 + 1);
          }
          i2 = ai2 < bi2 && ai2 >= 0 ? ai2 : bi2;
        }
        if (begs.length) {
          result2 = [left, right];
        }
      }
      return result2;
    }
    var concatMap = concatMap$1;
    var balanced = balancedMatch;
    var braceExpansion = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m3 = balanced("{", "}", str);
      if (!m3)
        return str.split(",");
      var pre = m3.pre;
      var body = m3.body;
      var post = m3.post;
      var p2 = pre.split(",");
      p2[p2.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p2[p2.length - 1] += postParts.shift();
        p2.push.apply(p2, postParts);
      }
      parts.push.apply(parts, p2);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand$3(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el2) {
      return /^-?0\d/.test(el2);
    }
    function lte(i2, y3) {
      return i2 <= y3;
    }
    function gte(i2, y3) {
      return i2 >= y3;
    }
    function expand$3(str, isTop) {
      var expansions = [];
      var m3 = balanced("{", "}", str);
      if (!m3 || /\$$/.test(m3.pre))
        return [str];
      var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m3.body);
      var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m3.body);
      var isSequence = isNumericSequence || isAlphaSequence;
      var isOptions = m3.body.indexOf(",") >= 0;
      if (!isSequence && !isOptions) {
        if (m3.post.match(/,.*\}/)) {
          str = m3.pre + "{" + m3.body + escClose + m3.post;
          return expand$3(str);
        }
        return [str];
      }
      var n3;
      if (isSequence) {
        n3 = m3.body.split(/\.\./);
      } else {
        n3 = parseCommaParts(m3.body);
        if (n3.length === 1) {
          n3 = expand$3(n3[0], false).map(embrace);
          if (n3.length === 1) {
            var post = m3.post.length ? expand$3(m3.post, false) : [""];
            return post.map(function(p2) {
              return m3.pre + n3[0] + p2;
            });
          }
        }
      }
      var pre = m3.pre;
      var post = m3.post.length ? expand$3(m3.post, false) : [""];
      var N2;
      if (isSequence) {
        var x2 = numeric(n3[0]);
        var y3 = numeric(n3[1]);
        var width = Math.max(n3[0].length, n3[1].length);
        var incr = n3.length == 3 ? Math.abs(numeric(n3[2])) : 1;
        var test = lte;
        var reverse = y3 < x2;
        if (reverse) {
          incr *= -1;
          test = gte;
        }
        var pad2 = n3.some(isPadded);
        N2 = [];
        for (var i2 = x2; test(i2, y3); i2 += incr) {
          var c3;
          if (isAlphaSequence) {
            c3 = String.fromCharCode(i2);
            if (c3 === "\\")
              c3 = "";
          } else {
            c3 = String(i2);
            if (pad2) {
              var need = width - c3.length;
              if (need > 0) {
                var z2 = new Array(need + 1).join("0");
                if (i2 < 0)
                  c3 = "-" + z2 + c3.slice(1);
                else
                  c3 = z2 + c3;
              }
            }
          }
          N2.push(c3);
        }
      } else {
        N2 = concatMap(n3, function(el2) {
          return expand$3(el2, false);
        });
      }
      for (var j2 = 0; j2 < N2.length; j2++) {
        for (var k2 = 0; k2 < post.length; k2++) {
          var expansion = pre + N2[j2] + post[k2];
          if (!isTop || isSequence || expansion)
            expansions.push(expansion);
        }
      }
      return expansions;
    }
    var minimatch_1 = minimatch$3;
    minimatch$3.Minimatch = Minimatch$1;
    var path$n = { sep: "/" };
    try {
      path$n = (init_path(), __toCommonJS(path_exports));
    } catch (er2) {
    }
    var GLOBSTAR$2 = minimatch$3.GLOBSTAR = Minimatch$1.GLOBSTAR = {};
    var expand$2 = braceExpansion;
    var plTypes = {
      "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
      "?": { open: "(?:", close: ")?" },
      "+": { open: "(?:", close: ")+" },
      "*": { open: "(?:", close: ")*" },
      "@": { open: "(?:", close: ")" }
    };
    var qmark = "[^/]";
    var star = qmark + "*?";
    var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    var reSpecials = charSet("().*{}+?[]^$\\!");
    function charSet(s2) {
      return s2.split("").reduce(function(set2, c3) {
        set2[c3] = true;
        return set2;
      }, {});
    }
    var slashSplit = /\/+/;
    minimatch$3.filter = filter;
    function filter(pattern2, options2) {
      options2 = options2 || {};
      return function(p2, i2, list2) {
        return minimatch$3(p2, pattern2, options2);
      };
    }
    function ext(a2, b2) {
      a2 = a2 || {};
      b2 = b2 || {};
      var t = {};
      Object.keys(b2).forEach(function(k2) {
        t[k2] = b2[k2];
      });
      Object.keys(a2).forEach(function(k2) {
        t[k2] = a2[k2];
      });
      return t;
    }
    minimatch$3.defaults = function(def) {
      if (!def || !Object.keys(def).length)
        return minimatch$3;
      var orig = minimatch$3;
      var m3 = function minimatch2(p2, pattern2, options2) {
        return orig.minimatch(p2, pattern2, ext(def, options2));
      };
      m3.Minimatch = function Minimatch2(pattern2, options2) {
        return new orig.Minimatch(pattern2, ext(def, options2));
      };
      return m3;
    };
    Minimatch$1.defaults = function(def) {
      if (!def || !Object.keys(def).length)
        return Minimatch$1;
      return minimatch$3.defaults(def).Minimatch;
    };
    function minimatch$3(p2, pattern2, options2) {
      if (typeof pattern2 !== "string") {
        throw new TypeError("glob pattern string required");
      }
      if (!options2)
        options2 = {};
      if (!options2.nocomment && pattern2.charAt(0) === "#") {
        return false;
      }
      if (pattern2.trim() === "")
        return p2 === "";
      return new Minimatch$1(pattern2, options2).match(p2);
    }
    function Minimatch$1(pattern2, options2) {
      if (!(this instanceof Minimatch$1)) {
        return new Minimatch$1(pattern2, options2);
      }
      if (typeof pattern2 !== "string") {
        throw new TypeError("glob pattern string required");
      }
      if (!options2)
        options2 = {};
      pattern2 = pattern2.trim();
      if (path$n.sep !== "/") {
        pattern2 = pattern2.split(path$n.sep).join("/");
      }
      this.options = options2;
      this.set = [];
      this.pattern = pattern2;
      this.regexp = null;
      this.negate = false;
      this.comment = false;
      this.empty = false;
      this.make();
    }
    Minimatch$1.prototype.debug = function() {
    };
    Minimatch$1.prototype.make = make;
    function make() {
      if (this._made)
        return;
      var pattern2 = this.pattern;
      var options2 = this.options;
      if (!options2.nocomment && pattern2.charAt(0) === "#") {
        this.comment = true;
        return;
      }
      if (!pattern2) {
        this.empty = true;
        return;
      }
      this.parseNegate();
      var set2 = this.globSet = this.braceExpand();
      if (options2.debug)
        this.debug = console.error;
      this.debug(this.pattern, set2);
      set2 = this.globParts = set2.map(function(s2) {
        return s2.split(slashSplit);
      });
      this.debug(this.pattern, set2);
      set2 = set2.map(function(s2, si2, set3) {
        return s2.map(this.parse, this);
      }, this);
      this.debug(this.pattern, set2);
      set2 = set2.filter(function(s2) {
        return s2.indexOf(false) === -1;
      });
      this.debug(this.pattern, set2);
      this.set = set2;
    }
    Minimatch$1.prototype.parseNegate = parseNegate;
    function parseNegate() {
      var pattern2 = this.pattern;
      var negate = false;
      var options2 = this.options;
      var negateOffset = 0;
      if (options2.nonegate)
        return;
      for (var i2 = 0, l2 = pattern2.length; i2 < l2 && pattern2.charAt(i2) === "!"; i2++) {
        negate = !negate;
        negateOffset++;
      }
      if (negateOffset)
        this.pattern = pattern2.substr(negateOffset);
      this.negate = negate;
    }
    minimatch$3.braceExpand = function(pattern2, options2) {
      return braceExpand(pattern2, options2);
    };
    Minimatch$1.prototype.braceExpand = braceExpand;
    function braceExpand(pattern2, options2) {
      if (!options2) {
        if (this instanceof Minimatch$1) {
          options2 = this.options;
        } else {
          options2 = {};
        }
      }
      pattern2 = typeof pattern2 === "undefined" ? this.pattern : pattern2;
      if (typeof pattern2 === "undefined") {
        throw new TypeError("undefined pattern");
      }
      if (options2.nobrace || !pattern2.match(/\{.*\}/)) {
        return [pattern2];
      }
      return expand$2(pattern2);
    }
    Minimatch$1.prototype.parse = parse$k;
    var SUBPARSE = {};
    function parse$k(pattern2, isSub) {
      if (pattern2.length > 1024 * 64) {
        throw new TypeError("pattern is too long");
      }
      var options2 = this.options;
      if (!options2.noglobstar && pattern2 === "**")
        return GLOBSTAR$2;
      if (pattern2 === "")
        return "";
      var re2 = "";
      var hasMagic = !!options2.nocase;
      var escaping = false;
      var patternListStack = [];
      var negativeLists = [];
      var stateChar;
      var inClass = false;
      var reClassStart = -1;
      var classStart = -1;
      var patternStart = pattern2.charAt(0) === "." ? "" : options2.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
      var self2 = this;
      function clearStateChar() {
        if (stateChar) {
          switch (stateChar) {
            case "*":
              re2 += star;
              hasMagic = true;
              break;
            case "?":
              re2 += qmark;
              hasMagic = true;
              break;
            default:
              re2 += "\\" + stateChar;
              break;
          }
          self2.debug("clearStateChar %j %j", stateChar, re2);
          stateChar = false;
        }
      }
      for (var i2 = 0, len = pattern2.length, c3; i2 < len && (c3 = pattern2.charAt(i2)); i2++) {
        this.debug("%s	%s %s %j", pattern2, i2, re2, c3);
        if (escaping && reSpecials[c3]) {
          re2 += "\\" + c3;
          escaping = false;
          continue;
        }
        switch (c3) {
          case "/":
            return false;
          case "\\":
            clearStateChar();
            escaping = true;
            continue;
          case "?":
          case "*":
          case "+":
          case "@":
          case "!":
            this.debug("%s	%s %s %j <-- stateChar", pattern2, i2, re2, c3);
            if (inClass) {
              this.debug("  in class");
              if (c3 === "!" && i2 === classStart + 1)
                c3 = "^";
              re2 += c3;
              continue;
            }
            self2.debug("call clearStateChar %j", stateChar);
            clearStateChar();
            stateChar = c3;
            if (options2.noext)
              clearStateChar();
            continue;
          case "(":
            if (inClass) {
              re2 += "(";
              continue;
            }
            if (!stateChar) {
              re2 += "\\(";
              continue;
            }
            patternListStack.push({
              type: stateChar,
              start: i2 - 1,
              reStart: re2.length,
              open: plTypes[stateChar].open,
              close: plTypes[stateChar].close
            });
            re2 += stateChar === "!" ? "(?:(?!(?:" : "(?:";
            this.debug("plType %j %j", stateChar, re2);
            stateChar = false;
            continue;
          case ")":
            if (inClass || !patternListStack.length) {
              re2 += "\\)";
              continue;
            }
            clearStateChar();
            hasMagic = true;
            var pl = patternListStack.pop();
            re2 += pl.close;
            if (pl.type === "!") {
              negativeLists.push(pl);
            }
            pl.reEnd = re2.length;
            continue;
          case "|":
            if (inClass || !patternListStack.length || escaping) {
              re2 += "\\|";
              escaping = false;
              continue;
            }
            clearStateChar();
            re2 += "|";
            continue;
          case "[":
            clearStateChar();
            if (inClass) {
              re2 += "\\" + c3;
              continue;
            }
            inClass = true;
            classStart = i2;
            reClassStart = re2.length;
            re2 += c3;
            continue;
          case "]":
            if (i2 === classStart + 1 || !inClass) {
              re2 += "\\" + c3;
              escaping = false;
              continue;
            }
            if (inClass) {
              var cs2 = pattern2.substring(classStart + 1, i2);
              try {
              } catch (er2) {
                var sp = this.parse(cs2, SUBPARSE);
                re2 = re2.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
                hasMagic = hasMagic || sp[1];
                inClass = false;
                continue;
              }
            }
            hasMagic = true;
            inClass = false;
            re2 += c3;
            continue;
          default:
            clearStateChar();
            if (escaping) {
              escaping = false;
            } else if (reSpecials[c3] && !(c3 === "^" && inClass)) {
              re2 += "\\";
            }
            re2 += c3;
        }
      }
      if (inClass) {
        cs2 = pattern2.substr(classStart + 1);
        sp = this.parse(cs2, SUBPARSE);
        re2 = re2.substr(0, reClassStart) + "\\[" + sp[0];
        hasMagic = hasMagic || sp[1];
      }
      for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
        var tail = re2.slice(pl.reStart + pl.open.length);
        this.debug("setting tail", re2, pl);
        tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_2, $1, $2) {
          if (!$2) {
            $2 = "\\";
          }
          return $1 + $1 + $2 + "|";
        });
        this.debug("tail=%j\n   %s", tail, tail, pl, re2);
        var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
        hasMagic = true;
        re2 = re2.slice(0, pl.reStart) + t + "\\(" + tail;
      }
      clearStateChar();
      if (escaping) {
        re2 += "\\\\";
      }
      var addPatternStart = false;
      switch (re2.charAt(0)) {
        case ".":
        case "[":
        case "(":
          addPatternStart = true;
      }
      for (var n3 = negativeLists.length - 1; n3 > -1; n3--) {
        var nl = negativeLists[n3];
        var nlBefore = re2.slice(0, nl.reStart);
        var nlFirst = re2.slice(nl.reStart, nl.reEnd - 8);
        var nlLast = re2.slice(nl.reEnd - 8, nl.reEnd);
        var nlAfter = re2.slice(nl.reEnd);
        nlLast += nlAfter;
        var openParensBefore = nlBefore.split("(").length - 1;
        var cleanAfter = nlAfter;
        for (i2 = 0; i2 < openParensBefore; i2++) {
          cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
        }
        nlAfter = cleanAfter;
        var dollar = "";
        if (nlAfter === "" && isSub !== SUBPARSE) {
          dollar = "$";
        }
        var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
        re2 = newRe;
      }
      if (re2 !== "" && hasMagic) {
        re2 = "(?=.)" + re2;
      }
      if (addPatternStart) {
        re2 = patternStart + re2;
      }
      if (isSub === SUBPARSE) {
        return [re2, hasMagic];
      }
      if (!hasMagic) {
        return globUnescape(pattern2);
      }
      var flags = options2.nocase ? "i" : "";
      try {
        var regExp = new RegExp("^" + re2 + "$", flags);
      } catch (er2) {
        return new RegExp("$.");
      }
      regExp._glob = pattern2;
      regExp._src = re2;
      return regExp;
    }
    minimatch$3.makeRe = function(pattern2, options2) {
      return new Minimatch$1(pattern2, options2 || {}).makeRe();
    };
    Minimatch$1.prototype.makeRe = makeRe$1;
    function makeRe$1() {
      if (this.regexp || this.regexp === false)
        return this.regexp;
      var set2 = this.set;
      if (!set2.length) {
        this.regexp = false;
        return this.regexp;
      }
      var options2 = this.options;
      var twoStar = options2.noglobstar ? star : options2.dot ? twoStarDot : twoStarNoDot;
      var flags = options2.nocase ? "i" : "";
      var re2 = set2.map(function(pattern2) {
        return pattern2.map(function(p2) {
          return p2 === GLOBSTAR$2 ? twoStar : typeof p2 === "string" ? regExpEscape(p2) : p2._src;
        }).join("\\/");
      }).join("|");
      re2 = "^(?:" + re2 + ")$";
      if (this.negate)
        re2 = "^(?!" + re2 + ").*$";
      try {
        this.regexp = new RegExp(re2, flags);
      } catch (ex) {
        this.regexp = false;
      }
      return this.regexp;
    }
    minimatch$3.match = function(list2, pattern2, options2) {
      options2 = options2 || {};
      var mm = new Minimatch$1(pattern2, options2);
      list2 = list2.filter(function(f2) {
        return mm.match(f2);
      });
      if (mm.options.nonull && !list2.length) {
        list2.push(pattern2);
      }
      return list2;
    };
    Minimatch$1.prototype.match = match;
    function match(f2, partial2) {
      this.debug("match", f2, this.pattern);
      if (this.comment)
        return false;
      if (this.empty)
        return f2 === "";
      if (f2 === "/" && partial2)
        return true;
      var options2 = this.options;
      if (path$n.sep !== "/") {
        f2 = f2.split(path$n.sep).join("/");
      }
      f2 = f2.split(slashSplit);
      this.debug(this.pattern, "split", f2);
      var set2 = this.set;
      this.debug(this.pattern, "set", set2);
      var filename2;
      var i2;
      for (i2 = f2.length - 1; i2 >= 0; i2--) {
        filename2 = f2[i2];
        if (filename2)
          break;
      }
      for (i2 = 0; i2 < set2.length; i2++) {
        var pattern2 = set2[i2];
        var file = f2;
        if (options2.matchBase && pattern2.length === 1) {
          file = [filename2];
        }
        var hit = this.matchOne(file, pattern2, partial2);
        if (hit) {
          if (options2.flipNegate)
            return true;
          return !this.negate;
        }
      }
      if (options2.flipNegate)
        return false;
      return this.negate;
    }
    Minimatch$1.prototype.matchOne = function(file, pattern2, partial2) {
      var options2 = this.options;
      this.debug("matchOne", { "this": this, file, pattern: pattern2 });
      this.debug("matchOne", file.length, pattern2.length);
      for (var fi2 = 0, pi2 = 0, fl = file.length, pl = pattern2.length; fi2 < fl && pi2 < pl; fi2++, pi2++) {
        this.debug("matchOne loop");
        var p2 = pattern2[pi2];
        var f2 = file[fi2];
        this.debug(pattern2, p2, f2);
        if (p2 === false)
          return false;
        if (p2 === GLOBSTAR$2) {
          this.debug("GLOBSTAR", [pattern2, p2, f2]);
          var fr2 = fi2;
          var pr2 = pi2 + 1;
          if (pr2 === pl) {
            this.debug("** at the end");
            for (; fi2 < fl; fi2++) {
              if (file[fi2] === "." || file[fi2] === ".." || !options2.dot && file[fi2].charAt(0) === ".")
                return false;
            }
            return true;
          }
          while (fr2 < fl) {
            var swallowee = file[fr2];
            this.debug("\nglobstar while", file, fr2, pattern2, pr2, swallowee);
            if (this.matchOne(file.slice(fr2), pattern2.slice(pr2), partial2)) {
              this.debug("globstar found match!", fr2, fl, swallowee);
              return true;
            } else {
              if (swallowee === "." || swallowee === ".." || !options2.dot && swallowee.charAt(0) === ".") {
                this.debug("dot detected!", file, fr2, pattern2, pr2);
                break;
              }
              this.debug("globstar swallow a segment, and continue");
              fr2++;
            }
          }
          if (partial2) {
            this.debug("\n>>> no match, partial?", file, fr2, pattern2, pr2);
            if (fr2 === fl)
              return true;
          }
          return false;
        }
        var hit;
        if (typeof p2 === "string") {
          if (options2.nocase) {
            hit = f2.toLowerCase() === p2.toLowerCase();
          } else {
            hit = f2 === p2;
          }
          this.debug("string match", p2, f2, hit);
        } else {
          hit = f2.match(p2);
          this.debug("pattern match", p2, f2, hit);
        }
        if (!hit)
          return false;
      }
      if (fi2 === fl && pi2 === pl) {
        return true;
      } else if (fi2 === fl) {
        return partial2;
      } else if (pi2 === pl) {
        var emptyFileEnd = fi2 === fl - 1 && file[fi2] === "";
        return emptyFileEnd;
      }
      throw new Error("wtf?");
    };
    function globUnescape(s2) {
      return s2.replace(/\\(.)/g, "$1");
    }
    function regExpEscape(s2) {
      return s2.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    }
    var inherits$1 = { exports: {} };
    var inherits_browser = { exports: {} };
    if (typeof Object.create === "function") {
      inherits_browser.exports = function inherits2(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      inherits_browser.exports = function inherits2(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
    try {
      util$4 = (init_util(), __toCommonJS(util_exports));
      if (typeof util$4.inherits !== "function")
        throw "";
      inherits$1.exports = util$4.inherits;
    } catch (e2) {
      inherits$1.exports = inherits_browser.exports;
    }
    var util$4;
    var pathIsAbsolute = { exports: {} };
    function posix(path2) {
      return path2.charAt(0) === "/";
    }
    function win32(path2) {
      var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
      var result2 = splitDeviceRe.exec(path2);
      var device = result2[1] || "";
      var isUnc = Boolean(device && device.charAt(1) !== ":");
      return Boolean(result2[2] || isUnc);
    }
    pathIsAbsolute.exports = process.platform === "win32" ? win32 : posix;
    pathIsAbsolute.exports.posix = posix;
    pathIsAbsolute.exports.win32 = win32;
    var common$d = {};
    common$d.setopts = setopts$2;
    common$d.ownProp = ownProp$2;
    common$d.makeAbs = makeAbs;
    common$d.finish = finish;
    common$d.mark = mark;
    common$d.isIgnored = isIgnored$2;
    common$d.childrenIgnored = childrenIgnored$2;
    function ownProp$2(obj, field) {
      return Object.prototype.hasOwnProperty.call(obj, field);
    }
    var fs$k = fs__default;
    var path$m = path__default;
    var minimatch$2 = minimatch_1;
    var isAbsolute$2 = pathIsAbsolute.exports;
    var Minimatch = minimatch$2.Minimatch;
    function alphasort(a2, b2) {
      return a2.localeCompare(b2, "en");
    }
    function setupIgnores(self2, options2) {
      self2.ignore = options2.ignore || [];
      if (!Array.isArray(self2.ignore))
        self2.ignore = [self2.ignore];
      if (self2.ignore.length) {
        self2.ignore = self2.ignore.map(ignoreMap);
      }
    }
    function ignoreMap(pattern2) {
      var gmatcher = null;
      if (pattern2.slice(-3) === "/**") {
        var gpattern = pattern2.replace(/(\/\*\*)+$/, "");
        gmatcher = new Minimatch(gpattern, { dot: true });
      }
      return {
        matcher: new Minimatch(pattern2, { dot: true }),
        gmatcher
      };
    }
    function setopts$2(self2, pattern2, options2) {
      if (!options2)
        options2 = {};
      if (options2.matchBase && pattern2.indexOf("/") === -1) {
        if (options2.noglobstar) {
          throw new Error("base matching requires globstar");
        }
        pattern2 = "**/" + pattern2;
      }
      self2.silent = !!options2.silent;
      self2.pattern = pattern2;
      self2.strict = options2.strict !== false;
      self2.realpath = !!options2.realpath;
      self2.realpathCache = options2.realpathCache || /* @__PURE__ */ Object.create(null);
      self2.follow = !!options2.follow;
      self2.dot = !!options2.dot;
      self2.mark = !!options2.mark;
      self2.nodir = !!options2.nodir;
      if (self2.nodir)
        self2.mark = true;
      self2.sync = !!options2.sync;
      self2.nounique = !!options2.nounique;
      self2.nonull = !!options2.nonull;
      self2.nosort = !!options2.nosort;
      self2.nocase = !!options2.nocase;
      self2.stat = !!options2.stat;
      self2.noprocess = !!options2.noprocess;
      self2.absolute = !!options2.absolute;
      self2.fs = options2.fs || fs$k;
      self2.maxLength = options2.maxLength || Infinity;
      self2.cache = options2.cache || /* @__PURE__ */ Object.create(null);
      self2.statCache = options2.statCache || /* @__PURE__ */ Object.create(null);
      self2.symlinks = options2.symlinks || /* @__PURE__ */ Object.create(null);
      setupIgnores(self2, options2);
      self2.changedCwd = false;
      var cwd = process.cwd();
      if (!ownProp$2(options2, "cwd"))
        self2.cwd = cwd;
      else {
        self2.cwd = path$m.resolve(options2.cwd);
        self2.changedCwd = self2.cwd !== cwd;
      }
      self2.root = options2.root || path$m.resolve(self2.cwd, "/");
      self2.root = path$m.resolve(self2.root);
      if (process.platform === "win32")
        self2.root = self2.root.replace(/\\/g, "/");
      self2.cwdAbs = isAbsolute$2(self2.cwd) ? self2.cwd : makeAbs(self2, self2.cwd);
      if (process.platform === "win32")
        self2.cwdAbs = self2.cwdAbs.replace(/\\/g, "/");
      self2.nomount = !!options2.nomount;
      options2.nonegate = true;
      options2.nocomment = true;
      self2.minimatch = new Minimatch(pattern2, options2);
      self2.options = self2.minimatch.options;
    }
    function finish(self2) {
      var nou = self2.nounique;
      var all = nou ? [] : /* @__PURE__ */ Object.create(null);
      for (var i2 = 0, l2 = self2.matches.length; i2 < l2; i2++) {
        var matches2 = self2.matches[i2];
        if (!matches2 || Object.keys(matches2).length === 0) {
          if (self2.nonull) {
            var literal2 = self2.minimatch.globSet[i2];
            if (nou)
              all.push(literal2);
            else
              all[literal2] = true;
          }
        } else {
          var m3 = Object.keys(matches2);
          if (nou)
            all.push.apply(all, m3);
          else
            m3.forEach(function(m4) {
              all[m4] = true;
            });
        }
      }
      if (!nou)
        all = Object.keys(all);
      if (!self2.nosort)
        all = all.sort(alphasort);
      if (self2.mark) {
        for (var i2 = 0; i2 < all.length; i2++) {
          all[i2] = self2._mark(all[i2]);
        }
        if (self2.nodir) {
          all = all.filter(function(e2) {
            var notDir = !/\/$/.test(e2);
            var c3 = self2.cache[e2] || self2.cache[makeAbs(self2, e2)];
            if (notDir && c3)
              notDir = c3 !== "DIR" && !Array.isArray(c3);
            return notDir;
          });
        }
      }
      if (self2.ignore.length)
        all = all.filter(function(m4) {
          return !isIgnored$2(self2, m4);
        });
      self2.found = all;
    }
    function mark(self2, p2) {
      var abs = makeAbs(self2, p2);
      var c3 = self2.cache[abs];
      var m3 = p2;
      if (c3) {
        var isDir = c3 === "DIR" || Array.isArray(c3);
        var slash2 = p2.slice(-1) === "/";
        if (isDir && !slash2)
          m3 += "/";
        else if (!isDir && slash2)
          m3 = m3.slice(0, -1);
        if (m3 !== p2) {
          var mabs = makeAbs(self2, m3);
          self2.statCache[mabs] = self2.statCache[abs];
          self2.cache[mabs] = self2.cache[abs];
        }
      }
      return m3;
    }
    function makeAbs(self2, f2) {
      var abs = f2;
      if (f2.charAt(0) === "/") {
        abs = path$m.join(self2.root, f2);
      } else if (isAbsolute$2(f2) || f2 === "") {
        abs = f2;
      } else if (self2.changedCwd) {
        abs = path$m.resolve(self2.cwd, f2);
      } else {
        abs = path$m.resolve(f2);
      }
      if (process.platform === "win32")
        abs = abs.replace(/\\/g, "/");
      return abs;
    }
    function isIgnored$2(self2, path2) {
      if (!self2.ignore.length)
        return false;
      return self2.ignore.some(function(item) {
        return item.matcher.match(path2) || !!(item.gmatcher && item.gmatcher.match(path2));
      });
    }
    function childrenIgnored$2(self2, path2) {
      if (!self2.ignore.length)
        return false;
      return self2.ignore.some(function(item) {
        return !!(item.gmatcher && item.gmatcher.match(path2));
      });
    }
    var sync$b = globSync$1;
    globSync$1.GlobSync = GlobSync$1;
    var rp$1 = fs_realpath;
    var minimatch$1 = minimatch_1;
    var path$l = path__default;
    var assert$2 = require$$5__default;
    var isAbsolute$1 = pathIsAbsolute.exports;
    var common$c = common$d;
    var setopts$1 = common$c.setopts;
    var ownProp$1 = common$c.ownProp;
    var childrenIgnored$1 = common$c.childrenIgnored;
    var isIgnored$1 = common$c.isIgnored;
    function globSync$1(pattern2, options2) {
      if (typeof options2 === "function" || arguments.length === 3)
        throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
      return new GlobSync$1(pattern2, options2).found;
    }
    function GlobSync$1(pattern2, options2) {
      if (!pattern2)
        throw new Error("must provide pattern");
      if (typeof options2 === "function" || arguments.length === 3)
        throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
      if (!(this instanceof GlobSync$1))
        return new GlobSync$1(pattern2, options2);
      setopts$1(this, pattern2, options2);
      if (this.noprocess)
        return this;
      var n3 = this.minimatch.set.length;
      this.matches = new Array(n3);
      for (var i2 = 0; i2 < n3; i2++) {
        this._process(this.minimatch.set[i2], i2, false);
      }
      this._finish();
    }
    GlobSync$1.prototype._finish = function() {
      assert$2(this instanceof GlobSync$1);
      if (this.realpath) {
        var self2 = this;
        this.matches.forEach(function(matchset, index2) {
          var set2 = self2.matches[index2] = /* @__PURE__ */ Object.create(null);
          for (var p2 in matchset) {
            try {
              p2 = self2._makeAbs(p2);
              var real = rp$1.realpathSync(p2, self2.realpathCache);
              set2[real] = true;
            } catch (er2) {
              if (er2.syscall === "stat")
                set2[self2._makeAbs(p2)] = true;
              else
                throw er2;
            }
          }
        });
      }
      common$c.finish(this);
    };
    GlobSync$1.prototype._process = function(pattern2, index2, inGlobStar) {
      assert$2(this instanceof GlobSync$1);
      var n3 = 0;
      while (typeof pattern2[n3] === "string") {
        n3++;
      }
      var prefix;
      switch (n3) {
        case pattern2.length:
          this._processSimple(pattern2.join("/"), index2);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern2.slice(0, n3).join("/");
          break;
      }
      var remain = pattern2.slice(n3);
      var read2;
      if (prefix === null)
        read2 = ".";
      else if (isAbsolute$1(prefix) || isAbsolute$1(pattern2.join("/"))) {
        if (!prefix || !isAbsolute$1(prefix))
          prefix = "/" + prefix;
        read2 = prefix;
      } else
        read2 = prefix;
      var abs = this._makeAbs(read2);
      if (childrenIgnored$1(this, read2))
        return;
      var isGlobStar = remain[0] === minimatch$1.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read2, abs, remain, index2, inGlobStar);
      else
        this._processReaddir(prefix, read2, abs, remain, index2, inGlobStar);
    };
    GlobSync$1.prototype._processReaddir = function(prefix, read2, abs, remain, index2, inGlobStar) {
      var entries = this._readdir(abs, inGlobStar);
      if (!entries)
        return;
      var pn2 = remain[0];
      var negate = !!this.minimatch.negate;
      var rawGlob = pn2._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === ".";
      var matchedEntries = [];
      for (var i2 = 0; i2 < entries.length; i2++) {
        var e2 = entries[i2];
        if (e2.charAt(0) !== "." || dotOk) {
          var m3;
          if (negate && !prefix) {
            m3 = !e2.match(pn2);
          } else {
            m3 = e2.match(pn2);
          }
          if (m3)
            matchedEntries.push(e2);
        }
      }
      var len = matchedEntries.length;
      if (len === 0)
        return;
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index2])
          this.matches[index2] = /* @__PURE__ */ Object.create(null);
        for (var i2 = 0; i2 < len; i2++) {
          var e2 = matchedEntries[i2];
          if (prefix) {
            if (prefix.slice(-1) !== "/")
              e2 = prefix + "/" + e2;
            else
              e2 = prefix + e2;
          }
          if (e2.charAt(0) === "/" && !this.nomount) {
            e2 = path$l.join(this.root, e2);
          }
          this._emitMatch(index2, e2);
        }
        return;
      }
      remain.shift();
      for (var i2 = 0; i2 < len; i2++) {
        var e2 = matchedEntries[i2];
        var newPattern;
        if (prefix)
          newPattern = [prefix, e2];
        else
          newPattern = [e2];
        this._process(newPattern.concat(remain), index2, inGlobStar);
      }
    };
    GlobSync$1.prototype._emitMatch = function(index2, e2) {
      if (isIgnored$1(this, e2))
        return;
      var abs = this._makeAbs(e2);
      if (this.mark)
        e2 = this._mark(e2);
      if (this.absolute) {
        e2 = abs;
      }
      if (this.matches[index2][e2])
        return;
      if (this.nodir) {
        var c3 = this.cache[abs];
        if (c3 === "DIR" || Array.isArray(c3))
          return;
      }
      this.matches[index2][e2] = true;
      if (this.stat)
        this._stat(e2);
    };
    GlobSync$1.prototype._readdirInGlobStar = function(abs) {
      if (this.follow)
        return this._readdir(abs, false);
      var entries;
      var lstat2;
      try {
        lstat2 = this.fs.lstatSync(abs);
      } catch (er2) {
        if (er2.code === "ENOENT") {
          return null;
        }
      }
      var isSym = lstat2 && lstat2.isSymbolicLink();
      this.symlinks[abs] = isSym;
      if (!isSym && lstat2 && !lstat2.isDirectory())
        this.cache[abs] = "FILE";
      else
        entries = this._readdir(abs, false);
      return entries;
    };
    GlobSync$1.prototype._readdir = function(abs, inGlobStar) {
      if (inGlobStar && !ownProp$1(this.symlinks, abs))
        return this._readdirInGlobStar(abs);
      if (ownProp$1(this.cache, abs)) {
        var c3 = this.cache[abs];
        if (!c3 || c3 === "FILE")
          return null;
        if (Array.isArray(c3))
          return c3;
      }
      try {
        return this._readdirEntries(abs, this.fs.readdirSync(abs));
      } catch (er2) {
        this._readdirError(abs, er2);
        return null;
      }
    };
    GlobSync$1.prototype._readdirEntries = function(abs, entries) {
      if (!this.mark && !this.stat) {
        for (var i2 = 0; i2 < entries.length; i2++) {
          var e2 = entries[i2];
          if (abs === "/")
            e2 = abs + e2;
          else
            e2 = abs + "/" + e2;
          this.cache[e2] = true;
        }
      }
      this.cache[abs] = entries;
      return entries;
    };
    GlobSync$1.prototype._readdirError = function(f2, er2) {
      switch (er2.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          var abs = this._makeAbs(f2);
          this.cache[abs] = "FILE";
          if (abs === this.cwdAbs) {
            var error2 = new Error(er2.code + " invalid cwd " + this.cwd);
            error2.path = this.cwd;
            error2.code = er2.code;
            throw error2;
          }
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f2)] = false;
          break;
        default:
          this.cache[this._makeAbs(f2)] = false;
          if (this.strict)
            throw er2;
          if (!this.silent)
            console.error("glob error", er2);
          break;
      }
    };
    GlobSync$1.prototype._processGlobStar = function(prefix, read2, abs, remain, index2, inGlobStar) {
      var entries = this._readdir(abs, inGlobStar);
      if (!entries)
        return;
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [prefix] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index2, false);
      var len = entries.length;
      var isSym = this.symlinks[abs];
      if (isSym && inGlobStar)
        return;
      for (var i2 = 0; i2 < len; i2++) {
        var e2 = entries[i2];
        if (e2.charAt(0) === "." && !this.dot)
          continue;
        var instead = gspref.concat(entries[i2], remainWithoutGlobStar);
        this._process(instead, index2, true);
        var below = gspref.concat(entries[i2], remain);
        this._process(below, index2, true);
      }
    };
    GlobSync$1.prototype._processSimple = function(prefix, index2) {
      var exists = this._stat(prefix);
      if (!this.matches[index2])
        this.matches[index2] = /* @__PURE__ */ Object.create(null);
      if (!exists)
        return;
      if (prefix && isAbsolute$1(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
          prefix = path$l.join(this.root, prefix);
        } else {
          prefix = path$l.resolve(this.root, prefix);
          if (trail)
            prefix += "/";
        }
      }
      if (process.platform === "win32")
        prefix = prefix.replace(/\\/g, "/");
      this._emitMatch(index2, prefix);
    };
    GlobSync$1.prototype._stat = function(f2) {
      var abs = this._makeAbs(f2);
      var needDir = f2.slice(-1) === "/";
      if (f2.length > this.maxLength)
        return false;
      if (!this.stat && ownProp$1(this.cache, abs)) {
        var c3 = this.cache[abs];
        if (Array.isArray(c3))
          c3 = "DIR";
        if (!needDir || c3 === "DIR")
          return c3;
        if (needDir && c3 === "FILE")
          return false;
      }
      var stat2 = this.statCache[abs];
      if (!stat2) {
        var lstat2;
        try {
          lstat2 = this.fs.lstatSync(abs);
        } catch (er2) {
          if (er2 && (er2.code === "ENOENT" || er2.code === "ENOTDIR")) {
            this.statCache[abs] = false;
            return false;
          }
        }
        if (lstat2 && lstat2.isSymbolicLink()) {
          try {
            stat2 = this.fs.statSync(abs);
          } catch (er2) {
            stat2 = lstat2;
          }
        } else {
          stat2 = lstat2;
        }
      }
      this.statCache[abs] = stat2;
      var c3 = true;
      if (stat2)
        c3 = stat2.isDirectory() ? "DIR" : "FILE";
      this.cache[abs] = this.cache[abs] || c3;
      if (needDir && c3 === "FILE")
        return false;
      return c3;
    };
    GlobSync$1.prototype._mark = function(p2) {
      return common$c.mark(this, p2);
    };
    GlobSync$1.prototype._makeAbs = function(f2) {
      return common$c.makeAbs(this, f2);
    };
    var wrappy_1 = wrappy$2;
    function wrappy$2(fn2, cb) {
      if (fn2 && cb)
        return wrappy$2(fn2)(cb);
      if (typeof fn2 !== "function")
        throw new TypeError("need wrapper function");
      Object.keys(fn2).forEach(function(k2) {
        wrapper[k2] = fn2[k2];
      });
      return wrapper;
      function wrapper() {
        var args = new Array(arguments.length);
        for (var i2 = 0; i2 < args.length; i2++) {
          args[i2] = arguments[i2];
        }
        var ret = fn2.apply(this, args);
        var cb2 = args[args.length - 1];
        if (typeof ret === "function" && ret !== cb2) {
          Object.keys(cb2).forEach(function(k2) {
            ret[k2] = cb2[k2];
          });
        }
        return ret;
      }
    }
    var once$3 = { exports: {} };
    var wrappy$1 = wrappy_1;
    once$3.exports = wrappy$1(once$2);
    once$3.exports.strict = wrappy$1(onceStrict);
    once$2.proto = once$2(function() {
      Object.defineProperty(Function.prototype, "once", {
        value: function() {
          return once$2(this);
        },
        configurable: true
      });
      Object.defineProperty(Function.prototype, "onceStrict", {
        value: function() {
          return onceStrict(this);
        },
        configurable: true
      });
    });
    function once$2(fn2) {
      var f2 = function() {
        if (f2.called)
          return f2.value;
        f2.called = true;
        return f2.value = fn2.apply(this, arguments);
      };
      f2.called = false;
      return f2;
    }
    function onceStrict(fn2) {
      var f2 = function() {
        if (f2.called)
          throw new Error(f2.onceError);
        f2.called = true;
        return f2.value = fn2.apply(this, arguments);
      };
      var name = fn2.name || "Function wrapped with `once`";
      f2.onceError = name + " shouldn't be called more than once";
      f2.called = false;
      return f2;
    }
    var wrappy = wrappy_1;
    var reqs = /* @__PURE__ */ Object.create(null);
    var once$1 = once$3.exports;
    var inflight_1 = wrappy(inflight$1);
    function inflight$1(key2, cb) {
      if (reqs[key2]) {
        reqs[key2].push(cb);
        return null;
      } else {
        reqs[key2] = [cb];
        return makeres(key2);
      }
    }
    function makeres(key2) {
      return once$1(function RES() {
        var cbs = reqs[key2];
        var len = cbs.length;
        var args = slice$1(arguments);
        try {
          for (var i2 = 0; i2 < len; i2++) {
            cbs[i2].apply(null, args);
          }
        } finally {
          if (cbs.length > len) {
            cbs.splice(0, len);
            process.nextTick(function() {
              RES.apply(null, args);
            });
          } else {
            delete reqs[key2];
          }
        }
      });
    }
    function slice$1(args) {
      var length = args.length;
      var array2 = [];
      for (var i2 = 0; i2 < length; i2++)
        array2[i2] = args[i2];
      return array2;
    }
    var glob_1 = glob;
    var rp = fs_realpath;
    var minimatch = minimatch_1;
    var inherits = inherits$1.exports;
    var EE = require$$0__default$2.EventEmitter;
    var path$k = path__default;
    var assert$1 = require$$5__default;
    var isAbsolute = pathIsAbsolute.exports;
    var globSync = sync$b;
    var common$b = common$d;
    var setopts = common$b.setopts;
    var ownProp = common$b.ownProp;
    var inflight = inflight_1;
    var childrenIgnored = common$b.childrenIgnored;
    var isIgnored = common$b.isIgnored;
    var once = once$3.exports;
    function glob(pattern2, options2, cb) {
      if (typeof options2 === "function")
        cb = options2, options2 = {};
      if (!options2)
        options2 = {};
      if (options2.sync) {
        if (cb)
          throw new TypeError("callback provided to sync glob");
        return globSync(pattern2, options2);
      }
      return new Glob(pattern2, options2, cb);
    }
    glob.sync = globSync;
    var GlobSync = glob.GlobSync = globSync.GlobSync;
    glob.glob = glob;
    function extend(origin, add) {
      if (add === null || typeof add !== "object") {
        return origin;
      }
      var keys = Object.keys(add);
      var i2 = keys.length;
      while (i2--) {
        origin[keys[i2]] = add[keys[i2]];
      }
      return origin;
    }
    glob.hasMagic = function(pattern2, options_) {
      var options2 = extend({}, options_);
      options2.noprocess = true;
      var g2 = new Glob(pattern2, options2);
      var set2 = g2.minimatch.set;
      if (!pattern2)
        return false;
      if (set2.length > 1)
        return true;
      for (var j2 = 0; j2 < set2[0].length; j2++) {
        if (typeof set2[0][j2] !== "string")
          return true;
      }
      return false;
    };
    glob.Glob = Glob;
    inherits(Glob, EE);
    function Glob(pattern2, options2, cb) {
      if (typeof options2 === "function") {
        cb = options2;
        options2 = null;
      }
      if (options2 && options2.sync) {
        if (cb)
          throw new TypeError("callback provided to sync glob");
        return new GlobSync(pattern2, options2);
      }
      if (!(this instanceof Glob))
        return new Glob(pattern2, options2, cb);
      setopts(this, pattern2, options2);
      this._didRealPath = false;
      var n3 = this.minimatch.set.length;
      this.matches = new Array(n3);
      if (typeof cb === "function") {
        cb = once(cb);
        this.on("error", cb);
        this.on("end", function(matches2) {
          cb(null, matches2);
        });
      }
      var self2 = this;
      this._processing = 0;
      this._emitQueue = [];
      this._processQueue = [];
      this.paused = false;
      if (this.noprocess)
        return this;
      if (n3 === 0)
        return done();
      var sync2 = true;
      for (var i2 = 0; i2 < n3; i2++) {
        this._process(this.minimatch.set[i2], i2, false, done);
      }
      sync2 = false;
      function done() {
        --self2._processing;
        if (self2._processing <= 0) {
          if (sync2) {
            process.nextTick(function() {
              self2._finish();
            });
          } else {
            self2._finish();
          }
        }
      }
    }
    Glob.prototype._finish = function() {
      assert$1(this instanceof Glob);
      if (this.aborted)
        return;
      if (this.realpath && !this._didRealpath)
        return this._realpath();
      common$b.finish(this);
      this.emit("end", this.found);
    };
    Glob.prototype._realpath = function() {
      if (this._didRealpath)
        return;
      this._didRealpath = true;
      var n3 = this.matches.length;
      if (n3 === 0)
        return this._finish();
      var self2 = this;
      for (var i2 = 0; i2 < this.matches.length; i2++)
        this._realpathSet(i2, next);
      function next() {
        if (--n3 === 0)
          self2._finish();
      }
    };
    Glob.prototype._realpathSet = function(index2, cb) {
      var matchset = this.matches[index2];
      if (!matchset)
        return cb();
      var found = Object.keys(matchset);
      var self2 = this;
      var n3 = found.length;
      if (n3 === 0)
        return cb();
      var set2 = this.matches[index2] = /* @__PURE__ */ Object.create(null);
      found.forEach(function(p2, i2) {
        p2 = self2._makeAbs(p2);
        rp.realpath(p2, self2.realpathCache, function(er2, real) {
          if (!er2)
            set2[real] = true;
          else if (er2.syscall === "stat")
            set2[p2] = true;
          else
            self2.emit("error", er2);
          if (--n3 === 0) {
            self2.matches[index2] = set2;
            cb();
          }
        });
      });
    };
    Glob.prototype._mark = function(p2) {
      return common$b.mark(this, p2);
    };
    Glob.prototype._makeAbs = function(f2) {
      return common$b.makeAbs(this, f2);
    };
    Glob.prototype.abort = function() {
      this.aborted = true;
      this.emit("abort");
    };
    Glob.prototype.pause = function() {
      if (!this.paused) {
        this.paused = true;
        this.emit("pause");
      }
    };
    Glob.prototype.resume = function() {
      if (this.paused) {
        this.emit("resume");
        this.paused = false;
        if (this._emitQueue.length) {
          var eq = this._emitQueue.slice(0);
          this._emitQueue.length = 0;
          for (var i2 = 0; i2 < eq.length; i2++) {
            var e2 = eq[i2];
            this._emitMatch(e2[0], e2[1]);
          }
        }
        if (this._processQueue.length) {
          var pq = this._processQueue.slice(0);
          this._processQueue.length = 0;
          for (var i2 = 0; i2 < pq.length; i2++) {
            var p2 = pq[i2];
            this._processing--;
            this._process(p2[0], p2[1], p2[2], p2[3]);
          }
        }
      }
    };
    Glob.prototype._process = function(pattern2, index2, inGlobStar, cb) {
      assert$1(this instanceof Glob);
      assert$1(typeof cb === "function");
      if (this.aborted)
        return;
      this._processing++;
      if (this.paused) {
        this._processQueue.push([pattern2, index2, inGlobStar, cb]);
        return;
      }
      var n3 = 0;
      while (typeof pattern2[n3] === "string") {
        n3++;
      }
      var prefix;
      switch (n3) {
        case pattern2.length:
          this._processSimple(pattern2.join("/"), index2, cb);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern2.slice(0, n3).join("/");
          break;
      }
      var remain = pattern2.slice(n3);
      var read2;
      if (prefix === null)
        read2 = ".";
      else if (isAbsolute(prefix) || isAbsolute(pattern2.join("/"))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = "/" + prefix;
        read2 = prefix;
      } else
        read2 = prefix;
      var abs = this._makeAbs(read2);
      if (childrenIgnored(this, read2))
        return cb();
      var isGlobStar = remain[0] === minimatch.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read2, abs, remain, index2, inGlobStar, cb);
      else
        this._processReaddir(prefix, read2, abs, remain, index2, inGlobStar, cb);
    };
    Glob.prototype._processReaddir = function(prefix, read2, abs, remain, index2, inGlobStar, cb) {
      var self2 = this;
      this._readdir(abs, inGlobStar, function(er2, entries) {
        return self2._processReaddir2(prefix, read2, abs, remain, index2, inGlobStar, entries, cb);
      });
    };
    Glob.prototype._processReaddir2 = function(prefix, read2, abs, remain, index2, inGlobStar, entries, cb) {
      if (!entries)
        return cb();
      var pn2 = remain[0];
      var negate = !!this.minimatch.negate;
      var rawGlob = pn2._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === ".";
      var matchedEntries = [];
      for (var i2 = 0; i2 < entries.length; i2++) {
        var e2 = entries[i2];
        if (e2.charAt(0) !== "." || dotOk) {
          var m3;
          if (negate && !prefix) {
            m3 = !e2.match(pn2);
          } else {
            m3 = e2.match(pn2);
          }
          if (m3)
            matchedEntries.push(e2);
        }
      }
      var len = matchedEntries.length;
      if (len === 0)
        return cb();
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index2])
          this.matches[index2] = /* @__PURE__ */ Object.create(null);
        for (var i2 = 0; i2 < len; i2++) {
          var e2 = matchedEntries[i2];
          if (prefix) {
            if (prefix !== "/")
              e2 = prefix + "/" + e2;
            else
              e2 = prefix + e2;
          }
          if (e2.charAt(0) === "/" && !this.nomount) {
            e2 = path$k.join(this.root, e2);
          }
          this._emitMatch(index2, e2);
        }
        return cb();
      }
      remain.shift();
      for (var i2 = 0; i2 < len; i2++) {
        var e2 = matchedEntries[i2];
        if (prefix) {
          if (prefix !== "/")
            e2 = prefix + "/" + e2;
          else
            e2 = prefix + e2;
        }
        this._process([e2].concat(remain), index2, inGlobStar, cb);
      }
      cb();
    };
    Glob.prototype._emitMatch = function(index2, e2) {
      if (this.aborted)
        return;
      if (isIgnored(this, e2))
        return;
      if (this.paused) {
        this._emitQueue.push([index2, e2]);
        return;
      }
      var abs = isAbsolute(e2) ? e2 : this._makeAbs(e2);
      if (this.mark)
        e2 = this._mark(e2);
      if (this.absolute)
        e2 = abs;
      if (this.matches[index2][e2])
        return;
      if (this.nodir) {
        var c3 = this.cache[abs];
        if (c3 === "DIR" || Array.isArray(c3))
          return;
      }
      this.matches[index2][e2] = true;
      var st2 = this.statCache[abs];
      if (st2)
        this.emit("stat", e2, st2);
      this.emit("match", e2);
    };
    Glob.prototype._readdirInGlobStar = function(abs, cb) {
      if (this.aborted)
        return;
      if (this.follow)
        return this._readdir(abs, false, cb);
      var lstatkey = "lstat\0" + abs;
      var self2 = this;
      var lstatcb = inflight(lstatkey, lstatcb_);
      if (lstatcb)
        self2.fs.lstat(abs, lstatcb);
      function lstatcb_(er2, lstat2) {
        if (er2 && er2.code === "ENOENT")
          return cb();
        var isSym = lstat2 && lstat2.isSymbolicLink();
        self2.symlinks[abs] = isSym;
        if (!isSym && lstat2 && !lstat2.isDirectory()) {
          self2.cache[abs] = "FILE";
          cb();
        } else
          self2._readdir(abs, false, cb);
      }
    };
    Glob.prototype._readdir = function(abs, inGlobStar, cb) {
      if (this.aborted)
        return;
      cb = inflight("readdir\0" + abs + "\0" + inGlobStar, cb);
      if (!cb)
        return;
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs, cb);
      if (ownProp(this.cache, abs)) {
        var c3 = this.cache[abs];
        if (!c3 || c3 === "FILE")
          return cb();
        if (Array.isArray(c3))
          return cb(null, c3);
      }
      var self2 = this;
      self2.fs.readdir(abs, readdirCb(this, abs, cb));
    };
    function readdirCb(self2, abs, cb) {
      return function(er2, entries) {
        if (er2)
          self2._readdirError(abs, er2, cb);
        else
          self2._readdirEntries(abs, entries, cb);
      };
    }
    Glob.prototype._readdirEntries = function(abs, entries, cb) {
      if (this.aborted)
        return;
      if (!this.mark && !this.stat) {
        for (var i2 = 0; i2 < entries.length; i2++) {
          var e2 = entries[i2];
          if (abs === "/")
            e2 = abs + e2;
          else
            e2 = abs + "/" + e2;
          this.cache[e2] = true;
        }
      }
      this.cache[abs] = entries;
      return cb(null, entries);
    };
    Glob.prototype._readdirError = function(f2, er2, cb) {
      if (this.aborted)
        return;
      switch (er2.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          var abs = this._makeAbs(f2);
          this.cache[abs] = "FILE";
          if (abs === this.cwdAbs) {
            var error2 = new Error(er2.code + " invalid cwd " + this.cwd);
            error2.path = this.cwd;
            error2.code = er2.code;
            this.emit("error", error2);
            this.abort();
          }
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f2)] = false;
          break;
        default:
          this.cache[this._makeAbs(f2)] = false;
          if (this.strict) {
            this.emit("error", er2);
            this.abort();
          }
          if (!this.silent)
            console.error("glob error", er2);
          break;
      }
      return cb();
    };
    Glob.prototype._processGlobStar = function(prefix, read2, abs, remain, index2, inGlobStar, cb) {
      var self2 = this;
      this._readdir(abs, inGlobStar, function(er2, entries) {
        self2._processGlobStar2(prefix, read2, abs, remain, index2, inGlobStar, entries, cb);
      });
    };
    Glob.prototype._processGlobStar2 = function(prefix, read2, abs, remain, index2, inGlobStar, entries, cb) {
      if (!entries)
        return cb();
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [prefix] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index2, false, cb);
      var isSym = this.symlinks[abs];
      var len = entries.length;
      if (isSym && inGlobStar)
        return cb();
      for (var i2 = 0; i2 < len; i2++) {
        var e2 = entries[i2];
        if (e2.charAt(0) === "." && !this.dot)
          continue;
        var instead = gspref.concat(entries[i2], remainWithoutGlobStar);
        this._process(instead, index2, true, cb);
        var below = gspref.concat(entries[i2], remain);
        this._process(below, index2, true, cb);
      }
      cb();
    };
    Glob.prototype._processSimple = function(prefix, index2, cb) {
      var self2 = this;
      this._stat(prefix, function(er2, exists) {
        self2._processSimple2(prefix, index2, er2, exists, cb);
      });
    };
    Glob.prototype._processSimple2 = function(prefix, index2, er2, exists, cb) {
      if (!this.matches[index2])
        this.matches[index2] = /* @__PURE__ */ Object.create(null);
      if (!exists)
        return cb();
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
          prefix = path$k.join(this.root, prefix);
        } else {
          prefix = path$k.resolve(this.root, prefix);
          if (trail)
            prefix += "/";
        }
      }
      if (process.platform === "win32")
        prefix = prefix.replace(/\\/g, "/");
      this._emitMatch(index2, prefix);
      cb();
    };
    Glob.prototype._stat = function(f2, cb) {
      var abs = this._makeAbs(f2);
      var needDir = f2.slice(-1) === "/";
      if (f2.length > this.maxLength)
        return cb();
      if (!this.stat && ownProp(this.cache, abs)) {
        var c3 = this.cache[abs];
        if (Array.isArray(c3))
          c3 = "DIR";
        if (!needDir || c3 === "DIR")
          return cb(null, c3);
        if (needDir && c3 === "FILE")
          return cb();
      }
      var stat2 = this.statCache[abs];
      if (stat2 !== void 0) {
        if (stat2 === false)
          return cb(null, stat2);
        else {
          var type = stat2.isDirectory() ? "DIR" : "FILE";
          if (needDir && type === "FILE")
            return cb();
          else
            return cb(null, type, stat2);
        }
      }
      var self2 = this;
      var statcb = inflight("stat\0" + abs, lstatcb_);
      if (statcb)
        self2.fs.lstat(abs, statcb);
      function lstatcb_(er2, lstat2) {
        if (lstat2 && lstat2.isSymbolicLink()) {
          return self2.fs.stat(abs, function(er3, stat3) {
            if (er3)
              self2._stat2(f2, abs, null, lstat2, cb);
            else
              self2._stat2(f2, abs, er3, stat3, cb);
          });
        } else {
          self2._stat2(f2, abs, er2, lstat2, cb);
        }
      }
    };
    Glob.prototype._stat2 = function(f2, abs, er2, stat2, cb) {
      if (er2 && (er2.code === "ENOENT" || er2.code === "ENOTDIR")) {
        this.statCache[abs] = false;
        return cb();
      }
      var needDir = f2.slice(-1) === "/";
      this.statCache[abs] = stat2;
      if (abs.slice(-1) === "/" && stat2 && !stat2.isDirectory())
        return cb(null, false, stat2);
      var c3 = true;
      if (stat2)
        c3 = stat2.isDirectory() ? "DIR" : "FILE";
      this.cache[abs] = this.cache[abs] || c3;
      if (needDir && c3 === "FILE")
        return cb();
      return cb(null, c3, stat2);
    };
    var WalkerBase = class {
      constructor() {
        this.should_skip = false;
        this.should_remove = false;
        this.replacement = null;
        this.context = {
          skip: () => this.should_skip = true,
          remove: () => this.should_remove = true,
          replace: (node2) => this.replacement = node2
        };
      }
      replace(parent, prop, index2, node2) {
        if (parent) {
          if (index2 !== null) {
            parent[prop][index2] = node2;
          } else {
            parent[prop] = node2;
          }
        }
      }
      remove(parent, prop, index2) {
        if (parent) {
          if (index2 !== null) {
            parent[prop].splice(index2, 1);
          } else {
            delete parent[prop];
          }
        }
      }
    };
    var SyncWalker = class extends WalkerBase {
      constructor(enter, leave) {
        super();
        this.enter = enter;
        this.leave = leave;
      }
      visit(node2, parent, prop, index2) {
        if (node2) {
          if (this.enter) {
            const _should_skip = this.should_skip;
            const _should_remove = this.should_remove;
            const _replacement = this.replacement;
            this.should_skip = false;
            this.should_remove = false;
            this.replacement = null;
            this.enter.call(this.context, node2, parent, prop, index2);
            if (this.replacement) {
              node2 = this.replacement;
              this.replace(parent, prop, index2, node2);
            }
            if (this.should_remove) {
              this.remove(parent, prop, index2);
            }
            const skipped = this.should_skip;
            const removed = this.should_remove;
            this.should_skip = _should_skip;
            this.should_remove = _should_remove;
            this.replacement = _replacement;
            if (skipped)
              return node2;
            if (removed)
              return null;
          }
          for (const key2 in node2) {
            const value = node2[key2];
            if (typeof value !== "object") {
              continue;
            } else if (Array.isArray(value)) {
              for (let i2 = 0; i2 < value.length; i2 += 1) {
                if (value[i2] !== null && typeof value[i2].type === "string") {
                  if (!this.visit(value[i2], node2, key2, i2)) {
                    i2--;
                  }
                }
              }
            } else if (value !== null && typeof value.type === "string") {
              this.visit(value, node2, key2, null);
            }
          }
          if (this.leave) {
            const _replacement = this.replacement;
            const _should_remove = this.should_remove;
            this.replacement = null;
            this.should_remove = false;
            this.leave.call(this.context, node2, parent, prop, index2);
            if (this.replacement) {
              node2 = this.replacement;
              this.replace(parent, prop, index2, node2);
            }
            if (this.should_remove) {
              this.remove(parent, prop, index2);
            }
            const removed = this.should_remove;
            this.replacement = _replacement;
            this.should_remove = _should_remove;
            if (removed)
              return null;
          }
        }
        return node2;
      }
    };
    function walk$2(ast, { enter, leave }) {
      const instance = new SyncWalker(enter, leave);
      return instance.visit(ast, null);
    }
    var charToInteger = {};
    var chars$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    for (i$2 = 0; i$2 < chars$1.length; i$2++) {
      charToInteger[chars$1.charCodeAt(i$2)] = i$2;
    }
    var i$2;
    function encode(decoded) {
      var sourceFileIndex = 0;
      var sourceCodeLine = 0;
      var sourceCodeColumn = 0;
      var nameIndex = 0;
      var mappings = "";
      for (var i2 = 0; i2 < decoded.length; i2++) {
        var line2 = decoded[i2];
        if (i2 > 0)
          mappings += ";";
        if (line2.length === 0)
          continue;
        var generatedCodeColumn = 0;
        var lineMappings = [];
        for (var _i2 = 0, line_1 = line2; _i2 < line_1.length; _i2++) {
          var segment = line_1[_i2];
          var segmentMappings = encodeInteger(segment[0] - generatedCodeColumn);
          generatedCodeColumn = segment[0];
          if (segment.length > 1) {
            segmentMappings += encodeInteger(segment[1] - sourceFileIndex) + encodeInteger(segment[2] - sourceCodeLine) + encodeInteger(segment[3] - sourceCodeColumn);
            sourceFileIndex = segment[1];
            sourceCodeLine = segment[2];
            sourceCodeColumn = segment[3];
          }
          if (segment.length === 5) {
            segmentMappings += encodeInteger(segment[4] - nameIndex);
            nameIndex = segment[4];
          }
          lineMappings.push(segmentMappings);
        }
        mappings += lineMappings.join(",");
      }
      return mappings;
    }
    function encodeInteger(num) {
      var result2 = "";
      num = num < 0 ? -num << 1 | 1 : num << 1;
      do {
        var clamped = num & 31;
        num >>>= 5;
        if (num > 0) {
          clamped |= 32;
        }
        result2 += chars$1[clamped];
      } while (num > 0);
      return result2;
    }
    var BitSet$1 = function BitSet2(arg) {
      this.bits = arg instanceof BitSet2 ? arg.bits.slice() : [];
    };
    BitSet$1.prototype.add = function add(n3) {
      this.bits[n3 >> 5] |= 1 << (n3 & 31);
    };
    BitSet$1.prototype.has = function has(n3) {
      return !!(this.bits[n3 >> 5] & 1 << (n3 & 31));
    };
    var Chunk$1 = function Chunk2(start, end, content2) {
      this.start = start;
      this.end = end;
      this.original = content2;
      this.intro = "";
      this.outro = "";
      this.content = content2;
      this.storeName = false;
      this.edited = false;
      Object.defineProperties(this, {
        previous: { writable: true, value: null },
        next: { writable: true, value: null }
      });
    };
    Chunk$1.prototype.appendLeft = function appendLeft(content2) {
      this.outro += content2;
    };
    Chunk$1.prototype.appendRight = function appendRight(content2) {
      this.intro = this.intro + content2;
    };
    Chunk$1.prototype.clone = function clone() {
      var chunk = new Chunk$1(this.start, this.end, this.original);
      chunk.intro = this.intro;
      chunk.outro = this.outro;
      chunk.content = this.content;
      chunk.storeName = this.storeName;
      chunk.edited = this.edited;
      return chunk;
    };
    Chunk$1.prototype.contains = function contains2(index2) {
      return this.start < index2 && index2 < this.end;
    };
    Chunk$1.prototype.eachNext = function eachNext(fn2) {
      var chunk = this;
      while (chunk) {
        fn2(chunk);
        chunk = chunk.next;
      }
    };
    Chunk$1.prototype.eachPrevious = function eachPrevious(fn2) {
      var chunk = this;
      while (chunk) {
        fn2(chunk);
        chunk = chunk.previous;
      }
    };
    Chunk$1.prototype.edit = function edit(content2, storeName, contentOnly) {
      this.content = content2;
      if (!contentOnly) {
        this.intro = "";
        this.outro = "";
      }
      this.storeName = storeName;
      this.edited = true;
      return this;
    };
    Chunk$1.prototype.prependLeft = function prependLeft(content2) {
      this.outro = content2 + this.outro;
    };
    Chunk$1.prototype.prependRight = function prependRight(content2) {
      this.intro = content2 + this.intro;
    };
    Chunk$1.prototype.split = function split2(index2) {
      var sliceIndex = index2 - this.start;
      var originalBefore = this.original.slice(0, sliceIndex);
      var originalAfter = this.original.slice(sliceIndex);
      this.original = originalBefore;
      var newChunk = new Chunk$1(index2, this.end, originalAfter);
      newChunk.outro = this.outro;
      this.outro = "";
      this.end = index2;
      if (this.edited) {
        newChunk.edit("", false);
        this.content = "";
      } else {
        this.content = originalBefore;
      }
      newChunk.next = this.next;
      if (newChunk.next) {
        newChunk.next.previous = newChunk;
      }
      newChunk.previous = this;
      this.next = newChunk;
      return newChunk;
    };
    Chunk$1.prototype.toString = function toString2() {
      return this.intro + this.content + this.outro;
    };
    Chunk$1.prototype.trimEnd = function trimEnd(rx) {
      this.outro = this.outro.replace(rx, "");
      if (this.outro.length) {
        return true;
      }
      var trimmed = this.content.replace(rx, "");
      if (trimmed.length) {
        if (trimmed !== this.content) {
          this.split(this.start + trimmed.length).edit("", void 0, true);
        }
        return true;
      } else {
        this.edit("", void 0, true);
        this.intro = this.intro.replace(rx, "");
        if (this.intro.length) {
          return true;
        }
      }
    };
    Chunk$1.prototype.trimStart = function trimStart(rx) {
      this.intro = this.intro.replace(rx, "");
      if (this.intro.length) {
        return true;
      }
      var trimmed = this.content.replace(rx, "");
      if (trimmed.length) {
        if (trimmed !== this.content) {
          this.split(this.end - trimmed.length);
          this.edit("", void 0, true);
        }
        return true;
      } else {
        this.edit("", void 0, true);
        this.outro = this.outro.replace(rx, "");
        if (this.outro.length) {
          return true;
        }
      }
    };
    var btoa$2 = function() {
      throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.");
    };
    if (typeof window !== "undefined" && typeof window.btoa === "function") {
      btoa$2 = function(str) {
        return window.btoa(unescape(encodeURIComponent(str)));
      };
    } else if (typeof Buffer === "function") {
      btoa$2 = function(str) {
        return Buffer.from(str, "utf-8").toString("base64");
      };
    }
    var SourceMap$1 = function SourceMap2(properties) {
      this.version = 3;
      this.file = properties.file;
      this.sources = properties.sources;
      this.sourcesContent = properties.sourcesContent;
      this.names = properties.names;
      this.mappings = encode(properties.mappings);
    };
    SourceMap$1.prototype.toString = function toString2() {
      return JSON.stringify(this);
    };
    SourceMap$1.prototype.toUrl = function toUrl() {
      return "data:application/json;charset=utf-8;base64," + btoa$2(this.toString());
    };
    function guessIndent$1(code) {
      var lines = code.split("\n");
      var tabbed = lines.filter(function(line2) {
        return /^\t+/.test(line2);
      });
      var spaced = lines.filter(function(line2) {
        return /^ {2,}/.test(line2);
      });
      if (tabbed.length === 0 && spaced.length === 0) {
        return null;
      }
      if (tabbed.length >= spaced.length) {
        return "	";
      }
      var min2 = spaced.reduce(function(previous, current) {
        var numSpaces = /^ +/.exec(current)[0].length;
        return Math.min(numSpaces, previous);
      }, Infinity);
      return new Array(min2 + 1).join(" ");
    }
    function getRelativePath$1(from, to2) {
      var fromParts = from.split(/[/\\]/);
      var toParts = to2.split(/[/\\]/);
      fromParts.pop();
      while (fromParts[0] === toParts[0]) {
        fromParts.shift();
        toParts.shift();
      }
      if (fromParts.length) {
        var i2 = fromParts.length;
        while (i2--) {
          fromParts[i2] = "..";
        }
      }
      return fromParts.concat(toParts).join("/");
    }
    var toString$3 = Object.prototype.toString;
    function isObject$3(thing) {
      return toString$3.call(thing) === "[object Object]";
    }
    function getLocator$1(source2) {
      var originalLines = source2.split("\n");
      var lineOffsets = [];
      for (var i2 = 0, pos2 = 0; i2 < originalLines.length; i2++) {
        lineOffsets.push(pos2);
        pos2 += originalLines[i2].length + 1;
      }
      return function locate(index2) {
        var i3 = 0;
        var j2 = lineOffsets.length;
        while (i3 < j2) {
          var m3 = i3 + j2 >> 1;
          if (index2 < lineOffsets[m3]) {
            j2 = m3;
          } else {
            i3 = m3 + 1;
          }
        }
        var line2 = i3 - 1;
        var column2 = index2 - lineOffsets[line2];
        return { line: line2, column: column2 };
      };
    }
    var Mappings$1 = function Mappings2(hires) {
      this.hires = hires;
      this.generatedCodeLine = 0;
      this.generatedCodeColumn = 0;
      this.raw = [];
      this.rawSegments = this.raw[this.generatedCodeLine] = [];
      this.pending = null;
    };
    Mappings$1.prototype.addEdit = function addEdit(sourceIndex, content2, loc, nameIndex) {
      if (content2.length) {
        var segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
        if (nameIndex >= 0) {
          segment.push(nameIndex);
        }
        this.rawSegments.push(segment);
      } else if (this.pending) {
        this.rawSegments.push(this.pending);
      }
      this.advance(content2);
      this.pending = null;
    };
    Mappings$1.prototype.addUneditedChunk = function addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {
      var originalCharIndex = chunk.start;
      var first2 = true;
      while (originalCharIndex < chunk.end) {
        if (this.hires || first2 || sourcemapLocations.has(originalCharIndex)) {
          this.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);
        }
        if (original[originalCharIndex] === "\n") {
          loc.line += 1;
          loc.column = 0;
          this.generatedCodeLine += 1;
          this.raw[this.generatedCodeLine] = this.rawSegments = [];
          this.generatedCodeColumn = 0;
          first2 = true;
        } else {
          loc.column += 1;
          this.generatedCodeColumn += 1;
          first2 = false;
        }
        originalCharIndex += 1;
      }
      this.pending = null;
    };
    Mappings$1.prototype.advance = function advance(str) {
      if (!str) {
        return;
      }
      var lines = str.split("\n");
      if (lines.length > 1) {
        for (var i2 = 0; i2 < lines.length - 1; i2++) {
          this.generatedCodeLine++;
          this.raw[this.generatedCodeLine] = this.rawSegments = [];
        }
        this.generatedCodeColumn = 0;
      }
      this.generatedCodeColumn += lines[lines.length - 1].length;
    };
    var n$1 = "\n";
    var warned$2 = {
      insertLeft: false,
      insertRight: false,
      storeName: false
    };
    var MagicString$1 = function MagicString2(string2, options2) {
      if (options2 === void 0)
        options2 = {};
      var chunk = new Chunk$1(0, string2.length, string2);
      Object.defineProperties(this, {
        original: { writable: true, value: string2 },
        outro: { writable: true, value: "" },
        intro: { writable: true, value: "" },
        firstChunk: { writable: true, value: chunk },
        lastChunk: { writable: true, value: chunk },
        lastSearchedChunk: { writable: true, value: chunk },
        byStart: { writable: true, value: {} },
        byEnd: { writable: true, value: {} },
        filename: { writable: true, value: options2.filename },
        indentExclusionRanges: { writable: true, value: options2.indentExclusionRanges },
        sourcemapLocations: { writable: true, value: new BitSet$1() },
        storedNames: { writable: true, value: {} },
        indentStr: { writable: true, value: guessIndent$1(string2) }
      });
      this.byStart[0] = chunk;
      this.byEnd[string2.length] = chunk;
    };
    MagicString$1.prototype.addSourcemapLocation = function addSourcemapLocation(char) {
      this.sourcemapLocations.add(char);
    };
    MagicString$1.prototype.append = function append2(content2) {
      if (typeof content2 !== "string") {
        throw new TypeError("outro content must be a string");
      }
      this.outro += content2;
      return this;
    };
    MagicString$1.prototype.appendLeft = function appendLeft(index2, content2) {
      if (typeof content2 !== "string") {
        throw new TypeError("inserted content must be a string");
      }
      this._split(index2);
      var chunk = this.byEnd[index2];
      if (chunk) {
        chunk.appendLeft(content2);
      } else {
        this.intro += content2;
      }
      return this;
    };
    MagicString$1.prototype.appendRight = function appendRight(index2, content2) {
      if (typeof content2 !== "string") {
        throw new TypeError("inserted content must be a string");
      }
      this._split(index2);
      var chunk = this.byStart[index2];
      if (chunk) {
        chunk.appendRight(content2);
      } else {
        this.outro += content2;
      }
      return this;
    };
    MagicString$1.prototype.clone = function clone() {
      var cloned = new MagicString$1(this.original, { filename: this.filename });
      var originalChunk = this.firstChunk;
      var clonedChunk = cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone();
      while (originalChunk) {
        cloned.byStart[clonedChunk.start] = clonedChunk;
        cloned.byEnd[clonedChunk.end] = clonedChunk;
        var nextOriginalChunk = originalChunk.next;
        var nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();
        if (nextClonedChunk) {
          clonedChunk.next = nextClonedChunk;
          nextClonedChunk.previous = clonedChunk;
          clonedChunk = nextClonedChunk;
        }
        originalChunk = nextOriginalChunk;
      }
      cloned.lastChunk = clonedChunk;
      if (this.indentExclusionRanges) {
        cloned.indentExclusionRanges = this.indentExclusionRanges.slice();
      }
      cloned.sourcemapLocations = new BitSet$1(this.sourcemapLocations);
      cloned.intro = this.intro;
      cloned.outro = this.outro;
      return cloned;
    };
    MagicString$1.prototype.generateDecodedMap = function generateDecodedMap(options2) {
      var this$1$1 = this;
      options2 = options2 || {};
      var sourceIndex = 0;
      var names = Object.keys(this.storedNames);
      var mappings = new Mappings$1(options2.hires);
      var locate = getLocator$1(this.original);
      if (this.intro) {
        mappings.advance(this.intro);
      }
      this.firstChunk.eachNext(function(chunk) {
        var loc = locate(chunk.start);
        if (chunk.intro.length) {
          mappings.advance(chunk.intro);
        }
        if (chunk.edited) {
          mappings.addEdit(sourceIndex, chunk.content, loc, chunk.storeName ? names.indexOf(chunk.original) : -1);
        } else {
          mappings.addUneditedChunk(sourceIndex, chunk, this$1$1.original, loc, this$1$1.sourcemapLocations);
        }
        if (chunk.outro.length) {
          mappings.advance(chunk.outro);
        }
      });
      return {
        file: options2.file ? options2.file.split(/[/\\]/).pop() : null,
        sources: [options2.source ? getRelativePath$1(options2.file || "", options2.source) : null],
        sourcesContent: options2.includeContent ? [this.original] : [null],
        names,
        mappings: mappings.raw
      };
    };
    MagicString$1.prototype.generateMap = function generateMap(options2) {
      return new SourceMap$1(this.generateDecodedMap(options2));
    };
    MagicString$1.prototype.getIndentString = function getIndentString() {
      return this.indentStr === null ? "	" : this.indentStr;
    };
    MagicString$1.prototype.indent = function indent(indentStr, options2) {
      var pattern2 = /^[^\r\n]/gm;
      if (isObject$3(indentStr)) {
        options2 = indentStr;
        indentStr = void 0;
      }
      indentStr = indentStr !== void 0 ? indentStr : this.indentStr || "	";
      if (indentStr === "") {
        return this;
      }
      options2 = options2 || {};
      var isExcluded = {};
      if (options2.exclude) {
        var exclusions = typeof options2.exclude[0] === "number" ? [options2.exclude] : options2.exclude;
        exclusions.forEach(function(exclusion) {
          for (var i2 = exclusion[0]; i2 < exclusion[1]; i2 += 1) {
            isExcluded[i2] = true;
          }
        });
      }
      var shouldIndentNextCharacter = options2.indentStart !== false;
      var replacer = function(match2) {
        if (shouldIndentNextCharacter) {
          return "" + indentStr + match2;
        }
        shouldIndentNextCharacter = true;
        return match2;
      };
      this.intro = this.intro.replace(pattern2, replacer);
      var charIndex = 0;
      var chunk = this.firstChunk;
      while (chunk) {
        var end = chunk.end;
        if (chunk.edited) {
          if (!isExcluded[charIndex]) {
            chunk.content = chunk.content.replace(pattern2, replacer);
            if (chunk.content.length) {
              shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === "\n";
            }
          }
        } else {
          charIndex = chunk.start;
          while (charIndex < end) {
            if (!isExcluded[charIndex]) {
              var char = this.original[charIndex];
              if (char === "\n") {
                shouldIndentNextCharacter = true;
              } else if (char !== "\r" && shouldIndentNextCharacter) {
                shouldIndentNextCharacter = false;
                if (charIndex === chunk.start) {
                  chunk.prependRight(indentStr);
                } else {
                  this._splitChunk(chunk, charIndex);
                  chunk = chunk.next;
                  chunk.prependRight(indentStr);
                }
              }
            }
            charIndex += 1;
          }
        }
        charIndex = chunk.end;
        chunk = chunk.next;
      }
      this.outro = this.outro.replace(pattern2, replacer);
      return this;
    };
    MagicString$1.prototype.insert = function insert() {
      throw new Error("magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)");
    };
    MagicString$1.prototype.insertLeft = function insertLeft(index2, content2) {
      if (!warned$2.insertLeft) {
        console.warn("magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead");
        warned$2.insertLeft = true;
      }
      return this.appendLeft(index2, content2);
    };
    MagicString$1.prototype.insertRight = function insertRight(index2, content2) {
      if (!warned$2.insertRight) {
        console.warn("magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead");
        warned$2.insertRight = true;
      }
      return this.prependRight(index2, content2);
    };
    MagicString$1.prototype.move = function move(start, end, index2) {
      if (index2 >= start && index2 <= end) {
        throw new Error("Cannot move a selection inside itself");
      }
      this._split(start);
      this._split(end);
      this._split(index2);
      var first2 = this.byStart[start];
      var last = this.byEnd[end];
      var oldLeft = first2.previous;
      var oldRight = last.next;
      var newRight = this.byStart[index2];
      if (!newRight && last === this.lastChunk) {
        return this;
      }
      var newLeft = newRight ? newRight.previous : this.lastChunk;
      if (oldLeft) {
        oldLeft.next = oldRight;
      }
      if (oldRight) {
        oldRight.previous = oldLeft;
      }
      if (newLeft) {
        newLeft.next = first2;
      }
      if (newRight) {
        newRight.previous = last;
      }
      if (!first2.previous) {
        this.firstChunk = last.next;
      }
      if (!last.next) {
        this.lastChunk = first2.previous;
        this.lastChunk.next = null;
      }
      first2.previous = newLeft;
      last.next = newRight || null;
      if (!newLeft) {
        this.firstChunk = first2;
      }
      if (!newRight) {
        this.lastChunk = last;
      }
      return this;
    };
    MagicString$1.prototype.overwrite = function overwrite(start, end, content2, options2) {
      if (typeof content2 !== "string") {
        throw new TypeError("replacement content must be a string");
      }
      while (start < 0) {
        start += this.original.length;
      }
      while (end < 0) {
        end += this.original.length;
      }
      if (end > this.original.length) {
        throw new Error("end is out of bounds");
      }
      if (start === end) {
        throw new Error("Cannot overwrite a zero-length range \u2013 use appendLeft or prependRight instead");
      }
      this._split(start);
      this._split(end);
      if (options2 === true) {
        if (!warned$2.storeName) {
          console.warn("The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string");
          warned$2.storeName = true;
        }
        options2 = { storeName: true };
      }
      var storeName = options2 !== void 0 ? options2.storeName : false;
      var contentOnly = options2 !== void 0 ? options2.contentOnly : false;
      if (storeName) {
        var original = this.original.slice(start, end);
        this.storedNames[original] = true;
      }
      var first2 = this.byStart[start];
      var last = this.byEnd[end];
      if (first2) {
        if (end > first2.end && first2.next !== this.byStart[first2.end]) {
          throw new Error("Cannot overwrite across a split point");
        }
        first2.edit(content2, storeName, contentOnly);
        if (first2 !== last) {
          var chunk = first2.next;
          while (chunk !== last) {
            chunk.edit("", false);
            chunk = chunk.next;
          }
          chunk.edit("", false);
        }
      } else {
        var newChunk = new Chunk$1(start, end, "").edit(content2, storeName);
        last.next = newChunk;
        newChunk.previous = last;
      }
      return this;
    };
    MagicString$1.prototype.prepend = function prepend(content2) {
      if (typeof content2 !== "string") {
        throw new TypeError("outro content must be a string");
      }
      this.intro = content2 + this.intro;
      return this;
    };
    MagicString$1.prototype.prependLeft = function prependLeft(index2, content2) {
      if (typeof content2 !== "string") {
        throw new TypeError("inserted content must be a string");
      }
      this._split(index2);
      var chunk = this.byEnd[index2];
      if (chunk) {
        chunk.prependLeft(content2);
      } else {
        this.intro = content2 + this.intro;
      }
      return this;
    };
    MagicString$1.prototype.prependRight = function prependRight(index2, content2) {
      if (typeof content2 !== "string") {
        throw new TypeError("inserted content must be a string");
      }
      this._split(index2);
      var chunk = this.byStart[index2];
      if (chunk) {
        chunk.prependRight(content2);
      } else {
        this.outro = content2 + this.outro;
      }
      return this;
    };
    MagicString$1.prototype.remove = function remove2(start, end) {
      while (start < 0) {
        start += this.original.length;
      }
      while (end < 0) {
        end += this.original.length;
      }
      if (start === end) {
        return this;
      }
      if (start < 0 || end > this.original.length) {
        throw new Error("Character is out of bounds");
      }
      if (start > end) {
        throw new Error("end must be greater than start");
      }
      this._split(start);
      this._split(end);
      var chunk = this.byStart[start];
      while (chunk) {
        chunk.intro = "";
        chunk.outro = "";
        chunk.edit("");
        chunk = end > chunk.end ? this.byStart[chunk.end] : null;
      }
      return this;
    };
    MagicString$1.prototype.lastChar = function lastChar() {
      if (this.outro.length) {
        return this.outro[this.outro.length - 1];
      }
      var chunk = this.lastChunk;
      do {
        if (chunk.outro.length) {
          return chunk.outro[chunk.outro.length - 1];
        }
        if (chunk.content.length) {
          return chunk.content[chunk.content.length - 1];
        }
        if (chunk.intro.length) {
          return chunk.intro[chunk.intro.length - 1];
        }
      } while (chunk = chunk.previous);
      if (this.intro.length) {
        return this.intro[this.intro.length - 1];
      }
      return "";
    };
    MagicString$1.prototype.lastLine = function lastLine() {
      var lineIndex = this.outro.lastIndexOf(n$1);
      if (lineIndex !== -1) {
        return this.outro.substr(lineIndex + 1);
      }
      var lineStr = this.outro;
      var chunk = this.lastChunk;
      do {
        if (chunk.outro.length > 0) {
          lineIndex = chunk.outro.lastIndexOf(n$1);
          if (lineIndex !== -1) {
            return chunk.outro.substr(lineIndex + 1) + lineStr;
          }
          lineStr = chunk.outro + lineStr;
        }
        if (chunk.content.length > 0) {
          lineIndex = chunk.content.lastIndexOf(n$1);
          if (lineIndex !== -1) {
            return chunk.content.substr(lineIndex + 1) + lineStr;
          }
          lineStr = chunk.content + lineStr;
        }
        if (chunk.intro.length > 0) {
          lineIndex = chunk.intro.lastIndexOf(n$1);
          if (lineIndex !== -1) {
            return chunk.intro.substr(lineIndex + 1) + lineStr;
          }
          lineStr = chunk.intro + lineStr;
        }
      } while (chunk = chunk.previous);
      lineIndex = this.intro.lastIndexOf(n$1);
      if (lineIndex !== -1) {
        return this.intro.substr(lineIndex + 1) + lineStr;
      }
      return this.intro + lineStr;
    };
    MagicString$1.prototype.slice = function slice2(start, end) {
      if (start === void 0)
        start = 0;
      if (end === void 0)
        end = this.original.length;
      while (start < 0) {
        start += this.original.length;
      }
      while (end < 0) {
        end += this.original.length;
      }
      var result2 = "";
      var chunk = this.firstChunk;
      while (chunk && (chunk.start > start || chunk.end <= start)) {
        if (chunk.start < end && chunk.end >= end) {
          return result2;
        }
        chunk = chunk.next;
      }
      if (chunk && chunk.edited && chunk.start !== start) {
        throw new Error("Cannot use replaced character " + start + " as slice start anchor.");
      }
      var startChunk = chunk;
      while (chunk) {
        if (chunk.intro && (startChunk !== chunk || chunk.start === start)) {
          result2 += chunk.intro;
        }
        var containsEnd = chunk.start < end && chunk.end >= end;
        if (containsEnd && chunk.edited && chunk.end !== end) {
          throw new Error("Cannot use replaced character " + end + " as slice end anchor.");
        }
        var sliceStart = startChunk === chunk ? start - chunk.start : 0;
        var sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;
        result2 += chunk.content.slice(sliceStart, sliceEnd);
        if (chunk.outro && (!containsEnd || chunk.end === end)) {
          result2 += chunk.outro;
        }
        if (containsEnd) {
          break;
        }
        chunk = chunk.next;
      }
      return result2;
    };
    MagicString$1.prototype.snip = function snip(start, end) {
      var clone = this.clone();
      clone.remove(0, start);
      clone.remove(end, clone.original.length);
      return clone;
    };
    MagicString$1.prototype._split = function _split(index2) {
      if (this.byStart[index2] || this.byEnd[index2]) {
        return;
      }
      var chunk = this.lastSearchedChunk;
      var searchForward = index2 > chunk.end;
      while (chunk) {
        if (chunk.contains(index2)) {
          return this._splitChunk(chunk, index2);
        }
        chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];
      }
    };
    MagicString$1.prototype._splitChunk = function _splitChunk(chunk, index2) {
      if (chunk.edited && chunk.content.length) {
        var loc = getLocator$1(this.original)(index2);
        throw new Error("Cannot split a chunk that has already been edited (" + loc.line + ":" + loc.column + ' \u2013 "' + chunk.original + '")');
      }
      var newChunk = chunk.split(index2);
      this.byEnd[index2] = chunk;
      this.byStart[index2] = newChunk;
      this.byEnd[newChunk.end] = newChunk;
      if (chunk === this.lastChunk) {
        this.lastChunk = newChunk;
      }
      this.lastSearchedChunk = chunk;
      return true;
    };
    MagicString$1.prototype.toString = function toString2() {
      var str = this.intro;
      var chunk = this.firstChunk;
      while (chunk) {
        str += chunk.toString();
        chunk = chunk.next;
      }
      return str + this.outro;
    };
    MagicString$1.prototype.isEmpty = function isEmpty2() {
      var chunk = this.firstChunk;
      do {
        if (chunk.intro.length && chunk.intro.trim() || chunk.content.length && chunk.content.trim() || chunk.outro.length && chunk.outro.trim()) {
          return false;
        }
      } while (chunk = chunk.next);
      return true;
    };
    MagicString$1.prototype.length = function length() {
      var chunk = this.firstChunk;
      var length2 = 0;
      do {
        length2 += chunk.intro.length + chunk.content.length + chunk.outro.length;
      } while (chunk = chunk.next);
      return length2;
    };
    MagicString$1.prototype.trimLines = function trimLines() {
      return this.trim("[\\r\\n]");
    };
    MagicString$1.prototype.trim = function trim(charType) {
      return this.trimStart(charType).trimEnd(charType);
    };
    MagicString$1.prototype.trimEndAborted = function trimEndAborted(charType) {
      var rx = new RegExp((charType || "\\s") + "+$");
      this.outro = this.outro.replace(rx, "");
      if (this.outro.length) {
        return true;
      }
      var chunk = this.lastChunk;
      do {
        var end = chunk.end;
        var aborted = chunk.trimEnd(rx);
        if (chunk.end !== end) {
          if (this.lastChunk === chunk) {
            this.lastChunk = chunk.next;
          }
          this.byEnd[chunk.end] = chunk;
          this.byStart[chunk.next.start] = chunk.next;
          this.byEnd[chunk.next.end] = chunk.next;
        }
        if (aborted) {
          return true;
        }
        chunk = chunk.previous;
      } while (chunk);
      return false;
    };
    MagicString$1.prototype.trimEnd = function trimEnd(charType) {
      this.trimEndAborted(charType);
      return this;
    };
    MagicString$1.prototype.trimStartAborted = function trimStartAborted(charType) {
      var rx = new RegExp("^" + (charType || "\\s") + "+");
      this.intro = this.intro.replace(rx, "");
      if (this.intro.length) {
        return true;
      }
      var chunk = this.firstChunk;
      do {
        var end = chunk.end;
        var aborted = chunk.trimStart(rx);
        if (chunk.end !== end) {
          if (chunk === this.lastChunk) {
            this.lastChunk = chunk.next;
          }
          this.byEnd[chunk.end] = chunk;
          this.byStart[chunk.next.start] = chunk.next;
          this.byEnd[chunk.next.end] = chunk.next;
        }
        if (aborted) {
          return true;
        }
        chunk = chunk.next;
      } while (chunk);
      return false;
    };
    MagicString$1.prototype.trimStart = function trimStart(charType) {
      this.trimStartAborted(charType);
      return this;
    };
    function isReference(node2, parent) {
      if (node2.type === "MemberExpression") {
        return !node2.computed && isReference(node2.object, node2);
      }
      if (node2.type === "Identifier") {
        if (!parent)
          return true;
        switch (parent.type) {
          case "MemberExpression":
            return parent.computed || node2 === parent.object;
          case "MethodDefinition":
            return parent.computed;
          case "FieldDefinition":
            return parent.computed || node2 === parent.value;
          case "Property":
            return parent.computed || node2 === parent.value;
          case "ExportSpecifier":
          case "ImportSpecifier":
            return node2 === parent.local;
          case "LabeledStatement":
          case "BreakStatement":
          case "ContinueStatement":
            return false;
          default:
            return true;
        }
      }
      return false;
    }
    var peerDependencies = {
      rollup: "^2.38.3"
    };
    function tryParse(parse2, code, id) {
      try {
        return parse2(code, { allowReturnOutsideFunction: true });
      } catch (err) {
        err.message += ` in ${id}`;
        throw err;
      }
    }
    var firstpassGlobal = /\b(?:require|module|exports|global)\b/;
    var firstpassNoGlobal = /\b(?:require|module|exports)\b/;
    function hasCjsKeywords(code, ignoreGlobal) {
      const firstpass = ignoreGlobal ? firstpassNoGlobal : firstpassGlobal;
      return firstpass.test(code);
    }
    function analyzeTopLevelStatements(parse2, code, id) {
      const ast = tryParse(parse2, code, id);
      let isEsModule = false;
      let hasDefaultExport = false;
      let hasNamedExports = false;
      for (const node2 of ast.body) {
        switch (node2.type) {
          case "ExportDefaultDeclaration":
            isEsModule = true;
            hasDefaultExport = true;
            break;
          case "ExportNamedDeclaration":
            isEsModule = true;
            if (node2.declaration) {
              hasNamedExports = true;
            } else {
              for (const specifier of node2.specifiers) {
                if (specifier.exported.name === "default") {
                  hasDefaultExport = true;
                } else {
                  hasNamedExports = true;
                }
              }
            }
            break;
          case "ExportAllDeclaration":
            isEsModule = true;
            if (node2.exported && node2.exported.name === "default") {
              hasDefaultExport = true;
            } else {
              hasNamedExports = true;
            }
            break;
          case "ImportDeclaration":
            isEsModule = true;
            break;
        }
      }
      return { isEsModule, hasDefaultExport, hasNamedExports, ast };
    }
    var isWrappedId = (id, suffix) => id.endsWith(suffix);
    var wrapId = (id, suffix) => `\0${id}${suffix}`;
    var unwrapId = (wrappedId, suffix) => wrappedId.slice(1, -suffix.length);
    var PROXY_SUFFIX = "?commonjs-proxy";
    var REQUIRE_SUFFIX = "?commonjs-require";
    var EXTERNAL_SUFFIX = "?commonjs-external";
    var EXPORTS_SUFFIX = "?commonjs-exports";
    var MODULE_SUFFIX = "?commonjs-module";
    var DYNAMIC_REGISTER_SUFFIX = "?commonjs-dynamic-register";
    var DYNAMIC_JSON_PREFIX = "\0commonjs-dynamic-json:";
    var DYNAMIC_PACKAGES_ID = "\0commonjs-dynamic-packages";
    var HELPERS_ID = "\0commonjsHelpers.js";
    var HELPERS = `
export var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

export function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

export function getDefaultExportFromNamespaceIfPresent (n) {
	return n && Object.prototype.hasOwnProperty.call(n, 'default') ? n['default'] : n;
}

export function getDefaultExportFromNamespaceIfNotNamed (n) {
	return n && Object.prototype.hasOwnProperty.call(n, 'default') && Object.keys(n).length === 1 ? n['default'] : n;
}

export function getAugmentedNamespace(n) {
	if (n.__esModule) return n;
	var a = Object.defineProperty({}, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}
`;
    var FAILED_REQUIRE_ERROR = `throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');`;
    var HELPER_NON_DYNAMIC = `
export function commonjsRequire (path) {
	${FAILED_REQUIRE_ERROR}
}
`;
    var getDynamicHelpers = (ignoreDynamicRequires) => `
export function createModule(modulePath) {
	return {
		path: modulePath,
		exports: {},
		require: function (path, base) {
			return commonjsRequire(path, base == null ? modulePath : base);
		}
	};
}

export function commonjsRegister (path, loader) {
	DYNAMIC_REQUIRE_LOADERS[path] = loader;
}

export function commonjsRegisterOrShort (path, to) {
	var resolvedPath = commonjsResolveImpl(path, null, true);
	if (resolvedPath !== null && DYNAMIC_REQUIRE_CACHE[resolvedPath]) {
	  DYNAMIC_REQUIRE_CACHE[path] = DYNAMIC_REQUIRE_CACHE[resolvedPath];
	} else {
	  DYNAMIC_REQUIRE_SHORTS[path] = to;
	}
}

var DYNAMIC_REQUIRE_LOADERS = Object.create(null);
var DYNAMIC_REQUIRE_CACHE = Object.create(null);
var DYNAMIC_REQUIRE_SHORTS = Object.create(null);
var DEFAULT_PARENT_MODULE = {
	id: '<' + 'rollup>', exports: {}, parent: undefined, filename: null, loaded: false, children: [], paths: []
};
var CHECKED_EXTENSIONS = ['', '.js', '.json'];

function normalize (path) {
	path = path.replace(/\\\\/g, '/');
	var parts = path.split('/');
	var slashed = parts[0] === '';
	for (var i = 1; i < parts.length; i++) {
		if (parts[i] === '.' || parts[i] === '') {
			parts.splice(i--, 1);
		}
	}
	for (var i = 1; i < parts.length; i++) {
		if (parts[i] !== '..') continue;
		if (i > 0 && parts[i - 1] !== '..' && parts[i - 1] !== '.') {
			parts.splice(--i, 2);
			i--;
		}
	}
	path = parts.join('/');
	if (slashed && path[0] !== '/')
	  path = '/' + path;
	else if (path.length === 0)
	  path = '.';
	return path;
}

function join () {
	if (arguments.length === 0)
	  return '.';
	var joined;
	for (var i = 0; i < arguments.length; ++i) {
	  var arg = arguments[i];
	  if (arg.length > 0) {
		if (joined === undefined)
		  joined = arg;
		else
		  joined += '/' + arg;
	  }
	}
	if (joined === undefined)
	  return '.';

	return joined;
}

function isPossibleNodeModulesPath (modulePath) {
	var c0 = modulePath[0];
	if (c0 === '/' || c0 === '\\\\') return false;
	var c1 = modulePath[1], c2 = modulePath[2];
	if ((c0 === '.' && (!c1 || c1 === '/' || c1 === '\\\\')) ||
		(c0 === '.' && c1 === '.' && (!c2 || c2 === '/' || c2 === '\\\\'))) return false;
	if (c1 === ':' && (c2 === '/' || c2 === '\\\\'))
		return false;
	return true;
}

function dirname (path) {
  if (path.length === 0)
    return '.';

  var i = path.length - 1;
  while (i > 0) {
    var c = path.charCodeAt(i);
    if ((c === 47 || c === 92) && i !== path.length - 1)
      break;
    i--;
  }

  if (i > 0)
    return path.substr(0, i);

  if (path.chartCodeAt(0) === 47 || path.chartCodeAt(0) === 92)
    return path.charAt(0);

  return '.';
}

export function commonjsResolveImpl (path, originalModuleDir, testCache) {
	var shouldTryNodeModules = isPossibleNodeModulesPath(path);
	path = normalize(path);
	var relPath;
	if (path[0] === '/') {
		originalModuleDir = '/';
	}
	while (true) {
		if (!shouldTryNodeModules) {
			relPath = originalModuleDir ? normalize(originalModuleDir + '/' + path) : path;
		} else if (originalModuleDir) {
			relPath = normalize(originalModuleDir + '/node_modules/' + path);
		} else {
			relPath = normalize(join('node_modules', path));
		}

		if (relPath.endsWith('/..')) {
			break; // Travelled too far up, avoid infinite loop
		}

		for (var extensionIndex = 0; extensionIndex < CHECKED_EXTENSIONS.length; extensionIndex++) {
			var resolvedPath = relPath + CHECKED_EXTENSIONS[extensionIndex];
			if (DYNAMIC_REQUIRE_CACHE[resolvedPath]) {
				return resolvedPath;
			}
			if (DYNAMIC_REQUIRE_SHORTS[resolvedPath]) {
			  return resolvedPath;
			}
			if (DYNAMIC_REQUIRE_LOADERS[resolvedPath]) {
				return resolvedPath;
			}
		}
		if (!shouldTryNodeModules) break;
		var nextDir = normalize(originalModuleDir + '/..');
		if (nextDir === originalModuleDir) break;
		originalModuleDir = nextDir;
	}
	return null;
}

export function commonjsResolve (path, originalModuleDir) {
	var resolvedPath = commonjsResolveImpl(path, originalModuleDir);
	if (resolvedPath !== null) {
		return resolvedPath;
	}
	return require.resolve(path);
}

export function commonjsRequire (path, originalModuleDir) {
	var resolvedPath = commonjsResolveImpl(path, originalModuleDir, true);
	if (resolvedPath !== null) {
    var cachedModule = DYNAMIC_REQUIRE_CACHE[resolvedPath];
    if (cachedModule) return cachedModule.exports;
    var shortTo = DYNAMIC_REQUIRE_SHORTS[resolvedPath];
    if (shortTo) {
      cachedModule = DYNAMIC_REQUIRE_CACHE[shortTo];
      if (cachedModule)
        return cachedModule.exports;
      resolvedPath = commonjsResolveImpl(shortTo, null, true);
    }
    var loader = DYNAMIC_REQUIRE_LOADERS[resolvedPath];
    if (loader) {
      DYNAMIC_REQUIRE_CACHE[resolvedPath] = cachedModule = {
        id: resolvedPath,
        filename: resolvedPath,
        path: dirname(resolvedPath),
        exports: {},
        parent: DEFAULT_PARENT_MODULE,
        loaded: false,
        children: [],
        paths: [],
        require: function (path, base) {
          return commonjsRequire(path, (base === undefined || base === null) ? cachedModule.path : base);
        }
      };
      try {
        loader.call(commonjsGlobal, cachedModule, cachedModule.exports);
      } catch (error) {
        delete DYNAMIC_REQUIRE_CACHE[resolvedPath];
        throw error;
      }
      cachedModule.loaded = true;
      return cachedModule.exports;
    };
	}
	${ignoreDynamicRequires ? "return require(path);" : FAILED_REQUIRE_ERROR}
}

commonjsRequire.cache = DYNAMIC_REQUIRE_CACHE;
commonjsRequire.resolve = commonjsResolve;
`;
    function getHelpersModule(isDynamicRequireModulesEnabled, ignoreDynamicRequires) {
      return `${HELPERS}${isDynamicRequireModulesEnabled ? getDynamicHelpers(ignoreDynamicRequires) : HELPER_NON_DYNAMIC}`;
    }
    function deconflict(scopes, globals, identifier) {
      let i2 = 1;
      let deconflicted = makeLegalIdentifier(identifier);
      const hasConflicts = () => scopes.some((scope) => scope.contains(deconflicted)) || globals.has(deconflicted);
      while (hasConflicts()) {
        deconflicted = makeLegalIdentifier(`${identifier}_${i2}`);
        i2 += 1;
      }
      for (const scope of scopes) {
        scope.declarations[deconflicted] = true;
      }
      return deconflicted;
    }
    function getName(id) {
      const name = makeLegalIdentifier(path$r.basename(id, path$r.extname(id)));
      if (name !== "index") {
        return name;
      }
      return makeLegalIdentifier(path$r.basename(path$r.dirname(id)));
    }
    function normalizePathSlashes(path2) {
      return path2.replace(/\\/g, "/");
    }
    var VIRTUAL_PATH_BASE = "/$$rollup_base$$";
    var getVirtualPathForDynamicRequirePath = (path2, commonDir) => {
      const normalizedPath = normalizePathSlashes(path2);
      return normalizedPath.startsWith(commonDir) ? VIRTUAL_PATH_BASE + normalizedPath.slice(commonDir.length) : normalizedPath;
    };
    function getPackageEntryPoint(dirPath) {
      let entryPoint = "index.js";
      try {
        if (fs$n.existsSync(path$r.join(dirPath, "package.json"))) {
          entryPoint = JSON.parse(fs$n.readFileSync(path$r.join(dirPath, "package.json"), { encoding: "utf8" })).main || entryPoint;
        }
      } catch (ignored) {
      }
      return entryPoint;
    }
    function getDynamicPackagesModule(dynamicRequireModuleDirPaths, commonDir) {
      let code = `const commonjsRegisterOrShort = require('${HELPERS_ID}?commonjsRegisterOrShort');`;
      for (const dir of dynamicRequireModuleDirPaths) {
        const entryPoint = getPackageEntryPoint(dir);
        code += `
commonjsRegisterOrShort(${JSON.stringify(getVirtualPathForDynamicRequirePath(dir, commonDir))}, ${JSON.stringify(getVirtualPathForDynamicRequirePath(path$r.join(dir, entryPoint), commonDir))});`;
      }
      return code;
    }
    function getDynamicPackagesEntryIntro(dynamicRequireModuleDirPaths, dynamicRequireModuleSet) {
      let dynamicImports = Array.from(dynamicRequireModuleSet, (dynamicId) => `require(${JSON.stringify(wrapId(dynamicId, DYNAMIC_REGISTER_SUFFIX))});`).join("\n");
      if (dynamicRequireModuleDirPaths.length) {
        dynamicImports += `require(${JSON.stringify(wrapId(DYNAMIC_PACKAGES_ID, DYNAMIC_REGISTER_SUFFIX))});`;
      }
      return dynamicImports;
    }
    function isDynamicModuleImport(id, dynamicRequireModuleSet) {
      const normalizedPath = normalizePathSlashes(id);
      return dynamicRequireModuleSet.has(normalizedPath) && !normalizedPath.endsWith(".json");
    }
    function isDirectory(path2) {
      try {
        if (fs$n.statSync(path2).isDirectory())
          return true;
      } catch (ignored) {
      }
      return false;
    }
    function getDynamicRequirePaths(patterns2) {
      const dynamicRequireModuleSet = /* @__PURE__ */ new Set();
      for (const pattern2 of !patterns2 || Array.isArray(patterns2) ? patterns2 || [] : [patterns2]) {
        const isNegated = pattern2.startsWith("!");
        const modifySet = Set.prototype[isNegated ? "delete" : "add"].bind(dynamicRequireModuleSet);
        for (const path2 of glob_1.sync(isNegated ? pattern2.substr(1) : pattern2)) {
          modifySet(normalizePathSlashes(path$r.resolve(path2)));
          if (isDirectory(path2)) {
            modifySet(normalizePathSlashes(path$r.resolve(path$r.join(path2, getPackageEntryPoint(path2)))));
          }
        }
      }
      const dynamicRequireModuleDirPaths = Array.from(dynamicRequireModuleSet.values()).filter((path2) => isDirectory(path2));
      return { dynamicRequireModuleSet, dynamicRequireModuleDirPaths };
    }
    function getCommonJSMetaPromise(commonJSMetaPromises, id) {
      let commonJSMetaPromise = commonJSMetaPromises.get(id);
      if (commonJSMetaPromise)
        return commonJSMetaPromise.promise;
      const promise2 = new Promise((resolve2) => {
        commonJSMetaPromise = {
          resolve: resolve2,
          promise: null
        };
        commonJSMetaPromises.set(id, commonJSMetaPromise);
      });
      commonJSMetaPromise.promise = promise2;
      return promise2;
    }
    function setCommonJSMetaPromise(commonJSMetaPromises, id, commonjsMeta) {
      const commonJSMetaPromise = commonJSMetaPromises.get(id);
      if (commonJSMetaPromise) {
        if (commonJSMetaPromise.resolve) {
          commonJSMetaPromise.resolve(commonjsMeta);
          commonJSMetaPromise.resolve = null;
        }
      } else {
        commonJSMetaPromises.set(id, { promise: Promise.resolve(commonjsMeta), resolve: null });
      }
    }
    function getSpecificHelperProxy(id) {
      return `export {${id.split("?")[1]} as default} from "${HELPERS_ID}";`;
    }
    function getUnknownRequireProxy(id, requireReturnsDefault) {
      if (requireReturnsDefault === true || id.endsWith(".json")) {
        return `export {default} from ${JSON.stringify(id)};`;
      }
      const name = getName(id);
      const exported = requireReturnsDefault === "auto" ? `import {getDefaultExportFromNamespaceIfNotNamed} from "${HELPERS_ID}"; export default /*@__PURE__*/getDefaultExportFromNamespaceIfNotNamed(${name});` : requireReturnsDefault === "preferred" ? `import {getDefaultExportFromNamespaceIfPresent} from "${HELPERS_ID}"; export default /*@__PURE__*/getDefaultExportFromNamespaceIfPresent(${name});` : !requireReturnsDefault ? `import {getAugmentedNamespace} from "${HELPERS_ID}"; export default /*@__PURE__*/getAugmentedNamespace(${name});` : `export default ${name};`;
      return `import * as ${name} from ${JSON.stringify(id)}; ${exported}`;
    }
    function getDynamicJsonProxy(id, commonDir) {
      const normalizedPath = normalizePathSlashes(id.slice(DYNAMIC_JSON_PREFIX.length));
      return `const commonjsRegister = require('${HELPERS_ID}?commonjsRegister');
commonjsRegister(${JSON.stringify(getVirtualPathForDynamicRequirePath(normalizedPath, commonDir))}, function (module, exports) {
  module.exports = require(${JSON.stringify(normalizedPath)});
});`;
    }
    function getDynamicRequireProxy(normalizedPath, commonDir) {
      return `const commonjsRegister = require('${HELPERS_ID}?commonjsRegister');
commonjsRegister(${JSON.stringify(getVirtualPathForDynamicRequirePath(normalizedPath, commonDir))}, function (module, exports) {
  ${fs$n.readFileSync(normalizedPath, { encoding: "utf8" })}
});`;
    }
    async function getStaticRequireProxy(id, requireReturnsDefault, esModulesWithDefaultExport, esModulesWithNamedExports, commonJsMetaPromises) {
      const name = getName(id);
      const commonjsMeta = await getCommonJSMetaPromise(commonJsMetaPromises, id);
      if (commonjsMeta && commonjsMeta.isCommonJS) {
        return `export { __moduleExports as default } from ${JSON.stringify(id)};`;
      } else if (commonjsMeta === null) {
        return getUnknownRequireProxy(id, requireReturnsDefault);
      } else if (!requireReturnsDefault) {
        return `import { getAugmentedNamespace } from "${HELPERS_ID}"; import * as ${name} from ${JSON.stringify(id)}; export default /*@__PURE__*/getAugmentedNamespace(${name});`;
      } else if (requireReturnsDefault !== true && (requireReturnsDefault === "namespace" || !esModulesWithDefaultExport.has(id) || requireReturnsDefault === "auto" && esModulesWithNamedExports.has(id))) {
        return `import * as ${name} from ${JSON.stringify(id)}; export default ${name};`;
      }
      return `export { default } from ${JSON.stringify(id)};`;
    }
    function getCandidatesForExtension(resolved, extension2) {
      return [resolved + extension2, `${resolved}${path$r.sep}index${extension2}`];
    }
    function getCandidates(resolved, extensions2) {
      return extensions2.reduce((paths, extension2) => paths.concat(getCandidatesForExtension(resolved, extension2)), [resolved]);
    }
    function getResolveId(extensions2) {
      function resolveExtensions(importee, importer) {
        if (importee[0] !== "." || !importer)
          return void 0;
        const resolved = path$r.resolve(path$r.dirname(importer), importee);
        const candidates = getCandidates(resolved, extensions2);
        for (let i2 = 0; i2 < candidates.length; i2 += 1) {
          try {
            const stats = fs$n.statSync(candidates[i2]);
            if (stats.isFile())
              return { id: candidates[i2] };
          } catch (err) {
          }
        }
        return void 0;
      }
      return function resolveId2(importee, rawImporter, resolveOptions) {
        if (isWrappedId(importee, MODULE_SUFFIX) || isWrappedId(importee, EXPORTS_SUFFIX)) {
          return importee;
        }
        const importer = rawImporter && isWrappedId(rawImporter, DYNAMIC_REGISTER_SUFFIX) ? unwrapId(rawImporter, DYNAMIC_REGISTER_SUFFIX) : rawImporter;
        if (importer && isWrappedId(importer, PROXY_SUFFIX)) {
          return importee;
        }
        const isProxyModule = isWrappedId(importee, PROXY_SUFFIX);
        const isRequiredModule = isWrappedId(importee, REQUIRE_SUFFIX);
        let isModuleRegistration = false;
        if (isProxyModule) {
          importee = unwrapId(importee, PROXY_SUFFIX);
        } else if (isRequiredModule) {
          importee = unwrapId(importee, REQUIRE_SUFFIX);
          isModuleRegistration = isWrappedId(importee, DYNAMIC_REGISTER_SUFFIX);
          if (isModuleRegistration) {
            importee = unwrapId(importee, DYNAMIC_REGISTER_SUFFIX);
          }
        }
        if (importee.startsWith(HELPERS_ID) || importee === DYNAMIC_PACKAGES_ID || importee.startsWith(DYNAMIC_JSON_PREFIX)) {
          return importee;
        }
        if (importee.startsWith("\0")) {
          return null;
        }
        return this.resolve(importee, importer, Object.assign({}, resolveOptions, {
          skipSelf: true,
          custom: Object.assign({}, resolveOptions.custom, {
            "node-resolve": { isRequire: isProxyModule || isRequiredModule }
          })
        })).then((resolved) => {
          if (!resolved) {
            resolved = resolveExtensions(importee, importer);
          }
          if (resolved && isProxyModule) {
            resolved.id = wrapId(resolved.id, resolved.external ? EXTERNAL_SUFFIX : PROXY_SUFFIX);
            resolved.external = false;
          } else if (resolved && isModuleRegistration) {
            resolved.id = wrapId(resolved.id, DYNAMIC_REGISTER_SUFFIX);
          } else if (!resolved && (isProxyModule || isRequiredModule)) {
            return { id: wrapId(importee, EXTERNAL_SUFFIX), external: false };
          }
          return resolved;
        });
      };
    }
    function validateRollupVersion(rollupVersion, peerDependencyVersion) {
      const [major, minor] = rollupVersion.split(".").map(Number);
      const versionRegexp = /\^(\d+\.\d+)\.\d+/g;
      let minMajor = Infinity;
      let minMinor = Infinity;
      let foundVersion;
      while (foundVersion = versionRegexp.exec(peerDependencyVersion)) {
        const [foundMajor, foundMinor] = foundVersion[1].split(".").map(Number);
        if (foundMajor < minMajor) {
          minMajor = foundMajor;
          minMinor = foundMinor;
        }
      }
      if (major < minMajor || major === minMajor && minor < minMinor) {
        throw new Error(`Insufficient Rollup version: "@rollup/plugin-commonjs" requires at least rollup@${minMajor}.${minMinor} but found rollup@${rollupVersion}.`);
      }
    }
    var operators = {
      "==": (x2) => equals(x2.left, x2.right, false),
      "!=": (x2) => not(operators["=="](x2)),
      "===": (x2) => equals(x2.left, x2.right, true),
      "!==": (x2) => not(operators["==="](x2)),
      "!": (x2) => isFalsy(x2.argument),
      "&&": (x2) => isTruthy(x2.left) && isTruthy(x2.right),
      "||": (x2) => isTruthy(x2.left) || isTruthy(x2.right)
    };
    function not(value) {
      return value === null ? value : !value;
    }
    function equals(a2, b2, strict) {
      if (a2.type !== b2.type)
        return null;
      if (a2.type === "Literal")
        return strict ? a2.value === b2.value : a2.value == b2.value;
      return null;
    }
    function isTruthy(node2) {
      if (!node2)
        return false;
      if (node2.type === "Literal")
        return !!node2.value;
      if (node2.type === "ParenthesizedExpression")
        return isTruthy(node2.expression);
      if (node2.operator in operators)
        return operators[node2.operator](node2);
      return null;
    }
    function isFalsy(node2) {
      return not(isTruthy(node2));
    }
    function getKeypath(node2) {
      const parts = [];
      while (node2.type === "MemberExpression") {
        if (node2.computed)
          return null;
        parts.unshift(node2.property.name);
        node2 = node2.object;
      }
      if (node2.type !== "Identifier")
        return null;
      const { name } = node2;
      parts.unshift(name);
      return { name, keypath: parts.join(".") };
    }
    var KEY_COMPILED_ESM = "__esModule";
    function isDefineCompiledEsm(node2) {
      const definedProperty = getDefinePropertyCallName(node2, "exports") || getDefinePropertyCallName(node2, "module.exports");
      if (definedProperty && definedProperty.key === KEY_COMPILED_ESM) {
        return isTruthy(definedProperty.value);
      }
      return false;
    }
    function getDefinePropertyCallName(node2, targetName) {
      const {
        callee: { object, property }
      } = node2;
      if (!object || object.type !== "Identifier" || object.name !== "Object")
        return;
      if (!property || property.type !== "Identifier" || property.name !== "defineProperty")
        return;
      if (node2.arguments.length !== 3)
        return;
      const targetNames = targetName.split(".");
      const [target, key2, value] = node2.arguments;
      if (targetNames.length === 1) {
        if (target.type !== "Identifier" || target.name !== targetNames[0]) {
          return;
        }
      }
      if (targetNames.length === 2) {
        if (target.type !== "MemberExpression" || target.object.name !== targetNames[0] || target.property.name !== targetNames[1]) {
          return;
        }
      }
      if (value.type !== "ObjectExpression" || !value.properties)
        return;
      const valueProperty = value.properties.find((p2) => p2.key && p2.key.name === "value");
      if (!valueProperty || !valueProperty.value)
        return;
      return { key: key2.value, value: valueProperty.value };
    }
    function isShorthandProperty(parent) {
      return parent && parent.type === "Property" && parent.shorthand;
    }
    function hasDefineEsmProperty(node2) {
      return node2.properties.some((property) => {
        if (property.type === "Property" && property.key.type === "Identifier" && property.key.name === "__esModule" && isTruthy(property.value)) {
          return true;
        }
        return false;
      });
    }
    function wrapCode(magicString, uses, moduleName, exportsName) {
      const args = [];
      const passedArgs = [];
      if (uses.module) {
        args.push("module");
        passedArgs.push(moduleName);
      }
      if (uses.exports) {
        args.push("exports");
        passedArgs.push(exportsName);
      }
      magicString.trim().prepend(`(function (${args.join(", ")}) {
`).append(`
}(${passedArgs.join(", ")}));`);
    }
    function rewriteExportsAndGetExportsBlock(magicString, moduleName, exportsName, wrapped, moduleExportsAssignments, firstTopLevelModuleExportsAssignment, exportsAssignmentsByName, topLevelAssignments, defineCompiledEsmExpressions, deconflictedExportNames, code, HELPERS_NAME, exportMode, detectWrappedDefault, defaultIsModuleExports) {
      const exports2 = [];
      const exportDeclarations = [];
      if (exportMode === "replace") {
        getExportsForReplacedModuleExports(magicString, exports2, exportDeclarations, moduleExportsAssignments, firstTopLevelModuleExportsAssignment, exportsName);
      } else {
        exports2.push(`${exportsName} as __moduleExports`);
        if (wrapped) {
          getExportsWhenWrapping(exportDeclarations, exportsName, detectWrappedDefault, HELPERS_NAME, defaultIsModuleExports);
        } else {
          getExports(magicString, exports2, exportDeclarations, moduleExportsAssignments, exportsAssignmentsByName, deconflictedExportNames, topLevelAssignments, moduleName, exportsName, defineCompiledEsmExpressions, HELPERS_NAME, defaultIsModuleExports);
        }
      }
      if (exports2.length) {
        exportDeclarations.push(`export { ${exports2.join(", ")} };`);
      }
      return `

${exportDeclarations.join("\n")}`;
    }
    function getExportsForReplacedModuleExports(magicString, exports2, exportDeclarations, moduleExportsAssignments, firstTopLevelModuleExportsAssignment, exportsName) {
      for (const { left } of moduleExportsAssignments) {
        magicString.overwrite(left.start, left.end, exportsName);
      }
      magicString.prependRight(firstTopLevelModuleExportsAssignment.left.start, "var ");
      exports2.push(`${exportsName} as __moduleExports`);
      exportDeclarations.push(`export default ${exportsName};`);
    }
    function getExportsWhenWrapping(exportDeclarations, exportsName, detectWrappedDefault, HELPERS_NAME, defaultIsModuleExports) {
      exportDeclarations.push(`export default ${detectWrappedDefault && defaultIsModuleExports === "auto" ? `/*@__PURE__*/${HELPERS_NAME}.getDefaultExportFromCjs(${exportsName})` : defaultIsModuleExports === false ? `${exportsName}.default` : exportsName};`);
    }
    function getExports(magicString, exports2, exportDeclarations, moduleExportsAssignments, exportsAssignmentsByName, deconflictedExportNames, topLevelAssignments, moduleName, exportsName, defineCompiledEsmExpressions, HELPERS_NAME, defaultIsModuleExports) {
      let deconflictedDefaultExportName;
      for (const { left } of moduleExportsAssignments) {
        magicString.overwrite(left.start, left.end, `${moduleName}.exports`);
      }
      for (const [exportName, { nodes }] of exportsAssignmentsByName) {
        const deconflicted = deconflictedExportNames[exportName];
        let needsDeclaration = true;
        for (const node2 of nodes) {
          let replacement2 = `${deconflicted} = ${exportsName}.${exportName}`;
          if (needsDeclaration && topLevelAssignments.has(node2)) {
            replacement2 = `var ${replacement2}`;
            needsDeclaration = false;
          }
          magicString.overwrite(node2.start, node2.left.end, replacement2);
        }
        if (needsDeclaration) {
          magicString.prepend(`var ${deconflicted};
`);
        }
        if (exportName === "default") {
          deconflictedDefaultExportName = deconflicted;
        } else {
          exports2.push(exportName === deconflicted ? exportName : `${deconflicted} as ${exportName}`);
        }
      }
      let isRestorableCompiledEsm = false;
      for (const expression of defineCompiledEsmExpressions) {
        isRestorableCompiledEsm = true;
        const moduleExportsExpression = expression.type === "CallExpression" ? expression.arguments[0] : expression.left.object;
        magicString.overwrite(moduleExportsExpression.start, moduleExportsExpression.end, exportsName);
      }
      if (!isRestorableCompiledEsm || defaultIsModuleExports === true) {
        exportDeclarations.push(`export default ${exportsName};`);
      } else if (moduleExportsAssignments.length === 0 || defaultIsModuleExports === false) {
        exports2.push(`${deconflictedDefaultExportName || exportsName} as default`);
      } else {
        exportDeclarations.push(`export default /*@__PURE__*/${HELPERS_NAME}.getDefaultExportFromCjs(${exportsName});`);
      }
    }
    function isRequireStatement(node2, scope) {
      if (!node2)
        return false;
      if (node2.type !== "CallExpression")
        return false;
      if (node2.arguments.length === 0)
        return false;
      return isRequire(node2.callee, scope);
    }
    function isRequire(node2, scope) {
      return node2.type === "Identifier" && node2.name === "require" && !scope.contains("require") || node2.type === "MemberExpression" && isModuleRequire(node2, scope);
    }
    function isModuleRequire({ object, property }, scope) {
      return object.type === "Identifier" && object.name === "module" && property.type === "Identifier" && property.name === "require" && !scope.contains("module");
    }
    function isStaticRequireStatement(node2, scope) {
      if (!isRequireStatement(node2, scope))
        return false;
      return !hasDynamicArguments(node2);
    }
    function hasDynamicArguments(node2) {
      return node2.arguments.length > 1 || node2.arguments[0].type !== "Literal" && (node2.arguments[0].type !== "TemplateLiteral" || node2.arguments[0].expressions.length > 0);
    }
    var reservedMethod = { resolve: true, cache: true, main: true };
    function isNodeRequirePropertyAccess(parent) {
      return parent && parent.property && reservedMethod[parent.property.name];
    }
    function isIgnoredRequireStatement(requiredNode, ignoreRequire) {
      return ignoreRequire(requiredNode.arguments[0].value);
    }
    function getRequireStringArg(node2) {
      return node2.arguments[0].type === "Literal" ? node2.arguments[0].value : node2.arguments[0].quasis[0].value.cooked;
    }
    function hasDynamicModuleForPath(source2, id, dynamicRequireModuleSet) {
      if (!/^(?:\.{0,2}[/\\]|[A-Za-z]:[/\\])/.test(source2)) {
        try {
          const resolvedPath = normalizePathSlashes(resolve$4.sync(source2, { basedir: path$r.dirname(id) }));
          if (dynamicRequireModuleSet.has(resolvedPath)) {
            return true;
          }
        } catch (ex) {
          return false;
        }
        return false;
      }
      for (const attemptExt of ["", ".js", ".json"]) {
        const resolvedPath = normalizePathSlashes(path$r.resolve(path$r.dirname(id), source2 + attemptExt));
        if (dynamicRequireModuleSet.has(resolvedPath)) {
          return true;
        }
      }
      return false;
    }
    function getRequireHandlers() {
      const requiredSources = [];
      const requiredBySource = /* @__PURE__ */ Object.create(null);
      const requiredByNode = /* @__PURE__ */ new Map();
      const requireExpressionsWithUsedReturnValue = [];
      function addRequireStatement(sourceId, node2, scope, usesReturnValue) {
        const required = getRequired(sourceId);
        requiredByNode.set(node2, { scope, required });
        if (usesReturnValue) {
          required.nodesUsingRequired.push(node2);
          requireExpressionsWithUsedReturnValue.push(node2);
        }
      }
      function getRequired(sourceId) {
        if (!requiredBySource[sourceId]) {
          requiredSources.push(sourceId);
          requiredBySource[sourceId] = {
            source: sourceId,
            name: null,
            nodesUsingRequired: []
          };
        }
        return requiredBySource[sourceId];
      }
      function rewriteRequireExpressionsAndGetImportBlock(magicString, topLevelDeclarations, topLevelRequireDeclarators, reassignedNames, helpersName, dynamicRegisterSources, moduleName, exportsName, id, exportMode) {
        setRemainingImportNamesAndRewriteRequires(requireExpressionsWithUsedReturnValue, requiredByNode, magicString);
        const imports = [];
        imports.push(`import * as ${helpersName} from "${HELPERS_ID}";`);
        if (exportMode === "module") {
          imports.push(`import { __module as ${moduleName}, exports as ${exportsName} } from ${JSON.stringify(wrapId(id, MODULE_SUFFIX))}`);
        } else if (exportMode === "exports") {
          imports.push(`import { __exports as ${exportsName} } from ${JSON.stringify(wrapId(id, EXPORTS_SUFFIX))}`);
        }
        for (const source2 of dynamicRegisterSources) {
          imports.push(`import ${JSON.stringify(wrapId(source2, REQUIRE_SUFFIX))};`);
        }
        for (const source2 of requiredSources) {
          if (!source2.startsWith("\0")) {
            imports.push(`import ${JSON.stringify(wrapId(source2, REQUIRE_SUFFIX))};`);
          }
          const { name, nodesUsingRequired } = requiredBySource[source2];
          imports.push(`import ${nodesUsingRequired.length ? `${name} from ` : ""}${JSON.stringify(source2.startsWith("\0") ? source2 : wrapId(source2, PROXY_SUFFIX))};`);
        }
        return imports.length ? `${imports.join("\n")}

` : "";
      }
      return {
        addRequireStatement,
        requiredSources,
        rewriteRequireExpressionsAndGetImportBlock
      };
    }
    function setRemainingImportNamesAndRewriteRequires(requireExpressionsWithUsedReturnValue, requiredByNode, magicString) {
      let uid = 0;
      for (const requireExpression of requireExpressionsWithUsedReturnValue) {
        const { required } = requiredByNode.get(requireExpression);
        if (!required.name) {
          let potentialName;
          const isUsedName = (node2) => requiredByNode.get(node2).scope.contains(potentialName);
          do {
            potentialName = `require$$${uid}`;
            uid += 1;
          } while (required.nodesUsingRequired.some(isUsedName));
          required.name = potentialName;
        }
        magicString.overwrite(requireExpression.start, requireExpression.end, required.name);
      }
    }
    var exportsPattern = /^(?:module\.)?exports(?:\.([a-zA-Z_$][a-zA-Z_$0-9]*))?$/;
    var functionType = /^(?:FunctionDeclaration|FunctionExpression|ArrowFunctionExpression)$/;
    function transformCommonjs(parse2, code, id, isEsModule, ignoreGlobal, ignoreRequire, ignoreDynamicRequires, getIgnoreTryCatchRequireStatementMode, sourceMap, isDynamicRequireModulesEnabled, dynamicRequireModuleSet, disableWrap, commonDir, astCache, defaultIsModuleExports) {
      const ast = astCache || tryParse(parse2, code, id);
      const magicString = new MagicString$1(code);
      const uses = {
        module: false,
        exports: false,
        global: false,
        require: false
      };
      let usesDynamicRequire = false;
      const virtualDynamicRequirePath = isDynamicRequireModulesEnabled && getVirtualPathForDynamicRequirePath(path$r.dirname(id), commonDir);
      let scope = attachScopes(ast, "scope");
      let lexicalDepth = 0;
      let programDepth = 0;
      let currentTryBlockEnd = null;
      let shouldWrap = false;
      const globals = /* @__PURE__ */ new Set();
      const HELPERS_NAME = deconflict([scope], globals, "commonjsHelpers");
      const dynamicRegisterSources = /* @__PURE__ */ new Set();
      let hasRemovedRequire = false;
      const {
        addRequireStatement,
        requiredSources,
        rewriteRequireExpressionsAndGetImportBlock
      } = getRequireHandlers();
      const reassignedNames = /* @__PURE__ */ new Set();
      const topLevelDeclarations = [];
      const topLevelRequireDeclarators = /* @__PURE__ */ new Set();
      const skippedNodes = /* @__PURE__ */ new Set();
      const moduleAccessScopes = /* @__PURE__ */ new Set([scope]);
      const exportsAccessScopes = /* @__PURE__ */ new Set([scope]);
      const moduleExportsAssignments = [];
      let firstTopLevelModuleExportsAssignment = null;
      const exportsAssignmentsByName = /* @__PURE__ */ new Map();
      const topLevelAssignments = /* @__PURE__ */ new Set();
      const topLevelDefineCompiledEsmExpressions = [];
      walk$2(ast, {
        enter(node2, parent) {
          if (skippedNodes.has(node2)) {
            this.skip();
            return;
          }
          if (currentTryBlockEnd !== null && node2.start > currentTryBlockEnd) {
            currentTryBlockEnd = null;
          }
          programDepth += 1;
          if (node2.scope)
            ({ scope } = node2);
          if (functionType.test(node2.type))
            lexicalDepth += 1;
          if (sourceMap) {
            magicString.addSourcemapLocation(node2.start);
            magicString.addSourcemapLocation(node2.end);
          }
          switch (node2.type) {
            case "TryStatement":
              if (currentTryBlockEnd === null) {
                currentTryBlockEnd = node2.block.end;
              }
              return;
            case "AssignmentExpression":
              if (node2.left.type === "MemberExpression") {
                const flattened = getKeypath(node2.left);
                if (!flattened || scope.contains(flattened.name))
                  return;
                const exportsPatternMatch = exportsPattern.exec(flattened.keypath);
                if (!exportsPatternMatch || flattened.keypath === "exports")
                  return;
                const [, exportName] = exportsPatternMatch;
                uses[flattened.name] = true;
                if (flattened.keypath === "module.exports") {
                  moduleExportsAssignments.push(node2);
                  if (programDepth > 3) {
                    moduleAccessScopes.add(scope);
                  } else if (!firstTopLevelModuleExportsAssignment) {
                    firstTopLevelModuleExportsAssignment = node2;
                  }
                  if (defaultIsModuleExports === false) {
                    shouldWrap = true;
                  } else if (defaultIsModuleExports === "auto") {
                    if (node2.right.type === "ObjectExpression") {
                      if (hasDefineEsmProperty(node2.right)) {
                        shouldWrap = true;
                      }
                    } else if (defaultIsModuleExports === false) {
                      shouldWrap = true;
                    }
                  }
                } else if (exportName === KEY_COMPILED_ESM) {
                  if (programDepth > 3) {
                    shouldWrap = true;
                  } else {
                    topLevelDefineCompiledEsmExpressions.push(node2);
                  }
                } else {
                  const exportsAssignments = exportsAssignmentsByName.get(exportName) || {
                    nodes: [],
                    scopes: /* @__PURE__ */ new Set()
                  };
                  exportsAssignments.nodes.push(node2);
                  exportsAssignments.scopes.add(scope);
                  exportsAccessScopes.add(scope);
                  exportsAssignmentsByName.set(exportName, exportsAssignments);
                  if (programDepth <= 3) {
                    topLevelAssignments.add(node2);
                  }
                }
                skippedNodes.add(node2.left);
              } else {
                for (const name of extractAssignedNames(node2.left)) {
                  reassignedNames.add(name);
                }
              }
              return;
            case "CallExpression": {
              if (isDefineCompiledEsm(node2)) {
                if (programDepth === 3 && parent.type === "ExpressionStatement") {
                  skippedNodes.add(node2.arguments[0]);
                  topLevelDefineCompiledEsmExpressions.push(node2);
                } else {
                  shouldWrap = true;
                }
                return;
              }
              if (node2.callee.object && node2.callee.object.name === "require" && node2.callee.property.name === "resolve" && hasDynamicModuleForPath(id, "/", dynamicRequireModuleSet)) {
                const requireNode = node2.callee.object;
                magicString.appendLeft(node2.end - 1, `,${JSON.stringify(path$r.dirname(id) === "." ? null : virtualDynamicRequirePath)}`);
                magicString.overwrite(requireNode.start, requireNode.end, `${HELPERS_NAME}.commonjsRequire`, {
                  storeName: true
                });
                return;
              }
              if (!isStaticRequireStatement(node2, scope))
                return;
              if (!isDynamicRequireModulesEnabled) {
                skippedNodes.add(node2.callee);
              }
              if (!isIgnoredRequireStatement(node2, ignoreRequire)) {
                skippedNodes.add(node2.callee);
                const usesReturnValue = parent.type !== "ExpressionStatement";
                let canConvertRequire = true;
                let shouldRemoveRequireStatement = false;
                if (currentTryBlockEnd !== null) {
                  ({
                    canConvertRequire,
                    shouldRemoveRequireStatement
                  } = getIgnoreTryCatchRequireStatementMode(node2.arguments[0].value));
                  if (shouldRemoveRequireStatement) {
                    hasRemovedRequire = true;
                  }
                }
                let sourceId = getRequireStringArg(node2);
                const isDynamicRegister = isWrappedId(sourceId, DYNAMIC_REGISTER_SUFFIX);
                if (isDynamicRegister) {
                  sourceId = unwrapId(sourceId, DYNAMIC_REGISTER_SUFFIX);
                  if (sourceId.endsWith(".json")) {
                    sourceId = DYNAMIC_JSON_PREFIX + sourceId;
                  }
                  dynamicRegisterSources.add(wrapId(sourceId, DYNAMIC_REGISTER_SUFFIX));
                } else {
                  if (!sourceId.endsWith(".json") && hasDynamicModuleForPath(sourceId, id, dynamicRequireModuleSet)) {
                    if (shouldRemoveRequireStatement) {
                      magicString.overwrite(node2.start, node2.end, `undefined`);
                    } else if (canConvertRequire) {
                      magicString.overwrite(node2.start, node2.end, `${HELPERS_NAME}.commonjsRequire(${JSON.stringify(getVirtualPathForDynamicRequirePath(sourceId, commonDir))}, ${JSON.stringify(path$r.dirname(id) === "." ? null : virtualDynamicRequirePath)})`);
                      usesDynamicRequire = true;
                    }
                    return;
                  }
                  if (canConvertRequire) {
                    addRequireStatement(sourceId, node2, scope, usesReturnValue);
                  }
                }
                if (usesReturnValue) {
                  if (shouldRemoveRequireStatement) {
                    magicString.overwrite(node2.start, node2.end, `undefined`);
                    return;
                  }
                  if (parent.type === "VariableDeclarator" && !scope.parent && parent.id.type === "Identifier") {
                    topLevelRequireDeclarators.add(parent);
                  }
                } else {
                  if (!canConvertRequire && !shouldRemoveRequireStatement) {
                    return;
                  }
                  magicString.remove(parent.start, parent.end);
                }
              }
              return;
            }
            case "ConditionalExpression":
            case "IfStatement":
              if (isFalsy(node2.test)) {
                skippedNodes.add(node2.consequent);
              } else if (node2.alternate && isTruthy(node2.test)) {
                skippedNodes.add(node2.alternate);
              }
              return;
            case "Identifier": {
              const { name } = node2;
              if (!(isReference(node2, parent) && !scope.contains(name)))
                return;
              switch (name) {
                case "require":
                  if (isNodeRequirePropertyAccess(parent)) {
                    if (hasDynamicModuleForPath(id, "/", dynamicRequireModuleSet)) {
                      if (parent.property.name === "cache") {
                        magicString.overwrite(node2.start, node2.end, `${HELPERS_NAME}.commonjsRequire`, {
                          storeName: true
                        });
                      }
                    }
                    return;
                  }
                  if (isDynamicRequireModulesEnabled && isRequireStatement(parent, scope)) {
                    magicString.appendLeft(parent.end - 1, `,${JSON.stringify(path$r.dirname(id) === "." ? null : virtualDynamicRequirePath)}`);
                  }
                  if (!ignoreDynamicRequires) {
                    if (isShorthandProperty(parent)) {
                      magicString.appendRight(node2.end, `: ${HELPERS_NAME}.commonjsRequire`);
                    } else {
                      magicString.overwrite(node2.start, node2.end, `${HELPERS_NAME}.commonjsRequire`, {
                        storeName: true
                      });
                    }
                  }
                  usesDynamicRequire = true;
                  return;
                case "module":
                case "exports":
                  shouldWrap = true;
                  uses[name] = true;
                  return;
                case "global":
                  uses.global = true;
                  if (!ignoreGlobal) {
                    magicString.overwrite(node2.start, node2.end, `${HELPERS_NAME}.commonjsGlobal`, {
                      storeName: true
                    });
                  }
                  return;
                case "define":
                  magicString.overwrite(node2.start, node2.end, "undefined", {
                    storeName: true
                  });
                  return;
                default:
                  globals.add(name);
                  return;
              }
            }
            case "MemberExpression":
              if (!isDynamicRequireModulesEnabled && isModuleRequire(node2, scope)) {
                magicString.overwrite(node2.start, node2.end, `${HELPERS_NAME}.commonjsRequire`, {
                  storeName: true
                });
                skippedNodes.add(node2.object);
                skippedNodes.add(node2.property);
              }
              return;
            case "ReturnStatement":
              if (lexicalDepth === 0) {
                shouldWrap = true;
              }
              return;
            case "ThisExpression":
              if (lexicalDepth === 0) {
                uses.global = true;
                if (!ignoreGlobal) {
                  magicString.overwrite(node2.start, node2.end, `${HELPERS_NAME}.commonjsGlobal`, {
                    storeName: true
                  });
                }
              }
              return;
            case "UnaryExpression":
              if (node2.operator === "typeof") {
                const flattened = getKeypath(node2.argument);
                if (!flattened)
                  return;
                if (scope.contains(flattened.name))
                  return;
                if (flattened.keypath === "module.exports" || flattened.keypath === "module" || flattened.keypath === "exports") {
                  magicString.overwrite(node2.start, node2.end, `'object'`, {
                    storeName: false
                  });
                }
              }
              return;
            case "VariableDeclaration":
              if (!scope.parent) {
                topLevelDeclarations.push(node2);
              }
          }
        },
        leave(node2) {
          programDepth -= 1;
          if (node2.scope)
            scope = scope.parent;
          if (functionType.test(node2.type))
            lexicalDepth -= 1;
        }
      });
      const nameBase = getName(id);
      const exportsName = deconflict([...exportsAccessScopes], globals, nameBase);
      const moduleName = deconflict([...moduleAccessScopes], globals, `${nameBase}Module`);
      const deconflictedExportNames = /* @__PURE__ */ Object.create(null);
      for (const [exportName, { scopes }] of exportsAssignmentsByName) {
        deconflictedExportNames[exportName] = deconflict([...scopes], globals, exportName);
      }
      shouldWrap = !isEsModule && !disableWrap && (shouldWrap || uses.exports && moduleExportsAssignments.length > 0);
      const detectWrappedDefault = shouldWrap && (topLevelDefineCompiledEsmExpressions.length > 0 || code.indexOf("__esModule") >= 0);
      if (!(requiredSources.length || dynamicRegisterSources.size || uses.module || uses.exports || uses.require || usesDynamicRequire || hasRemovedRequire || topLevelDefineCompiledEsmExpressions.length > 0) && (ignoreGlobal || !uses.global)) {
        return { meta: { commonjs: { isCommonJS: false } } };
      }
      let leadingComment = "";
      if (code.startsWith("/*")) {
        const commentEnd = code.indexOf("*/", 2) + 2;
        leadingComment = `${code.slice(0, commentEnd)}
`;
        magicString.remove(0, commentEnd).trim();
      }
      const exportMode = shouldWrap ? uses.module ? "module" : "exports" : firstTopLevelModuleExportsAssignment ? exportsAssignmentsByName.size === 0 && topLevelDefineCompiledEsmExpressions.length === 0 ? "replace" : "module" : moduleExportsAssignments.length === 0 ? "exports" : "module";
      const importBlock = rewriteRequireExpressionsAndGetImportBlock(magicString, topLevelDeclarations, topLevelRequireDeclarators, reassignedNames, HELPERS_NAME, dynamicRegisterSources, moduleName, exportsName, id, exportMode);
      const exportBlock = isEsModule ? "" : rewriteExportsAndGetExportsBlock(magicString, moduleName, exportsName, shouldWrap, moduleExportsAssignments, firstTopLevelModuleExportsAssignment, exportsAssignmentsByName, topLevelAssignments, topLevelDefineCompiledEsmExpressions, deconflictedExportNames, code, HELPERS_NAME, exportMode, detectWrappedDefault, defaultIsModuleExports);
      if (shouldWrap) {
        wrapCode(magicString, uses, moduleName, exportsName);
      }
      magicString.trim().prepend(leadingComment + importBlock).append(exportBlock);
      return {
        code: magicString.toString(),
        map: sourceMap ? magicString.generateMap() : null,
        syntheticNamedExports: isEsModule ? false : "__moduleExports",
        meta: { commonjs: { isCommonJS: !isEsModule } }
      };
    }
    function commonjs(options2 = {}) {
      const extensions2 = options2.extensions || [".js"];
      const filter2 = createFilter(options2.include, options2.exclude);
      const {
        ignoreGlobal,
        ignoreDynamicRequires,
        requireReturnsDefault: requireReturnsDefaultOption,
        esmExternals
      } = options2;
      const getRequireReturnsDefault = typeof requireReturnsDefaultOption === "function" ? requireReturnsDefaultOption : () => requireReturnsDefaultOption;
      let esmExternalIds;
      const isEsmExternal = typeof esmExternals === "function" ? esmExternals : Array.isArray(esmExternals) ? (esmExternalIds = new Set(esmExternals), (id) => esmExternalIds.has(id)) : () => esmExternals;
      const defaultIsModuleExports = typeof options2.defaultIsModuleExports === "boolean" ? options2.defaultIsModuleExports : "auto";
      const { dynamicRequireModuleSet, dynamicRequireModuleDirPaths } = getDynamicRequirePaths(options2.dynamicRequireTargets);
      const isDynamicRequireModulesEnabled = dynamicRequireModuleSet.size > 0;
      const commonDir = isDynamicRequireModulesEnabled ? commondir(null, Array.from(dynamicRequireModuleSet).concat(process.cwd())) : null;
      const esModulesWithDefaultExport = /* @__PURE__ */ new Set();
      const esModulesWithNamedExports = /* @__PURE__ */ new Set();
      const commonJsMetaPromises = /* @__PURE__ */ new Map();
      const ignoreRequire = typeof options2.ignore === "function" ? options2.ignore : Array.isArray(options2.ignore) ? (id) => options2.ignore.includes(id) : () => false;
      const getIgnoreTryCatchRequireStatementMode = (id) => {
        const mode2 = typeof options2.ignoreTryCatch === "function" ? options2.ignoreTryCatch(id) : Array.isArray(options2.ignoreTryCatch) ? options2.ignoreTryCatch.includes(id) : typeof options2.ignoreTryCatch !== "undefined" ? options2.ignoreTryCatch : true;
        return {
          canConvertRequire: mode2 !== "remove" && mode2 !== true,
          shouldRemoveRequireStatement: mode2 === "remove"
        };
      };
      const resolveId2 = getResolveId(extensions2);
      const sourceMap = options2.sourceMap !== false;
      function transformAndCheckExports(code, id) {
        if (isDynamicRequireModulesEnabled && this.getModuleInfo(id).isEntry) {
          code = getDynamicPackagesEntryIntro(dynamicRequireModuleDirPaths, dynamicRequireModuleSet) + code;
        }
        const { isEsModule, hasDefaultExport, hasNamedExports, ast } = analyzeTopLevelStatements(this.parse, code, id);
        if (hasDefaultExport) {
          esModulesWithDefaultExport.add(id);
        }
        if (hasNamedExports) {
          esModulesWithNamedExports.add(id);
        }
        if (!dynamicRequireModuleSet.has(normalizePathSlashes(id)) && (!hasCjsKeywords(code, ignoreGlobal) || isEsModule && !options2.transformMixedEsModules)) {
          return { meta: { commonjs: { isCommonJS: false } } };
        }
        const disableWrap = isWrappedId(id, DYNAMIC_REGISTER_SUFFIX);
        if (disableWrap) {
          id = unwrapId(id, DYNAMIC_REGISTER_SUFFIX);
        }
        return transformCommonjs(this.parse, code, id, isEsModule, ignoreGlobal || isEsModule, ignoreRequire, ignoreDynamicRequires && !isDynamicRequireModulesEnabled, getIgnoreTryCatchRequireStatementMode, sourceMap, isDynamicRequireModulesEnabled, dynamicRequireModuleSet, disableWrap, commonDir, ast, defaultIsModuleExports);
      }
      return {
        name: "commonjs",
        buildStart() {
          validateRollupVersion(this.meta.rollupVersion, peerDependencies.rollup);
          if (options2.namedExports != null) {
            this.warn('The namedExports option from "@rollup/plugin-commonjs" is deprecated. Named exports are now handled automatically.');
          }
        },
        resolveId: resolveId2,
        load(id) {
          if (id === HELPERS_ID) {
            return getHelpersModule(isDynamicRequireModulesEnabled, ignoreDynamicRequires);
          }
          if (id.startsWith(HELPERS_ID)) {
            return getSpecificHelperProxy(id);
          }
          if (isWrappedId(id, MODULE_SUFFIX)) {
            const actualId = unwrapId(id, MODULE_SUFFIX);
            let name = getName(actualId);
            let code;
            if (isDynamicRequireModulesEnabled) {
              if (["modulePath", "commonjsRequire", "createModule"].includes(name)) {
                name = `${name}_`;
              }
              code = `import {commonjsRequire, createModule} from "${HELPERS_ID}";
var ${name} = createModule(${JSON.stringify(getVirtualPathForDynamicRequirePath(path$r.dirname(actualId), commonDir))});
export {${name} as __module}`;
            } else {
              code = `var ${name} = {exports: {}}; export {${name} as __module}`;
            }
            return {
              code,
              syntheticNamedExports: "__module",
              meta: { commonjs: { isCommonJS: false } }
            };
          }
          if (isWrappedId(id, EXPORTS_SUFFIX)) {
            const actualId = unwrapId(id, EXPORTS_SUFFIX);
            const name = getName(actualId);
            return {
              code: `var ${name} = {}; export {${name} as __exports}`,
              meta: { commonjs: { isCommonJS: false } }
            };
          }
          if (isWrappedId(id, EXTERNAL_SUFFIX)) {
            const actualId = unwrapId(id, EXTERNAL_SUFFIX);
            return getUnknownRequireProxy(actualId, isEsmExternal(actualId) ? getRequireReturnsDefault(actualId) : true);
          }
          if (id === DYNAMIC_PACKAGES_ID) {
            return getDynamicPackagesModule(dynamicRequireModuleDirPaths, commonDir);
          }
          if (id.startsWith(DYNAMIC_JSON_PREFIX)) {
            return getDynamicJsonProxy(id, commonDir);
          }
          if (isDynamicModuleImport(id, dynamicRequireModuleSet)) {
            return `export default require(${JSON.stringify(normalizePathSlashes(id))});`;
          }
          if (isWrappedId(id, DYNAMIC_REGISTER_SUFFIX)) {
            return getDynamicRequireProxy(normalizePathSlashes(unwrapId(id, DYNAMIC_REGISTER_SUFFIX)), commonDir);
          }
          if (isWrappedId(id, PROXY_SUFFIX)) {
            const actualId = unwrapId(id, PROXY_SUFFIX);
            return getStaticRequireProxy(actualId, getRequireReturnsDefault(actualId), esModulesWithDefaultExport, esModulesWithNamedExports, commonJsMetaPromises);
          }
          return null;
        },
        transform(code, rawId) {
          let id = rawId;
          if (isWrappedId(id, DYNAMIC_REGISTER_SUFFIX)) {
            id = unwrapId(id, DYNAMIC_REGISTER_SUFFIX);
          }
          const extName = path$r.extname(id);
          if (extName !== ".cjs" && id !== DYNAMIC_PACKAGES_ID && !id.startsWith(DYNAMIC_JSON_PREFIX) && (!filter2(id) || !extensions2.includes(extName))) {
            return null;
          }
          try {
            return transformAndCheckExports.call(this, code, rawId);
          } catch (err) {
            return this.error(err, err.loc);
          }
        },
        moduleParsed({ id, meta: { commonjs: commonjsMeta } }) {
          if (commonjsMeta && commonjsMeta.isCommonJS != null) {
            setCommonJSMetaPromise(commonJsMetaPromises, id, commonjsMeta);
            return;
          }
          setCommonJSMetaPromise(commonJsMetaPromises, id, null);
        }
      };
    }
    var tasks = {};
    var utils$l = {};
    var array$1 = {};
    Object.defineProperty(array$1, "__esModule", { value: true });
    array$1.splitWhen = array$1.flatten = void 0;
    function flatten$1(items) {
      return items.reduce((collection, item) => [].concat(collection, item), []);
    }
    array$1.flatten = flatten$1;
    function splitWhen(items, predicate) {
      const result2 = [[]];
      let groupIndex = 0;
      for (const item of items) {
        if (predicate(item)) {
          groupIndex++;
          result2[groupIndex] = [];
        } else {
          result2[groupIndex].push(item);
        }
      }
      return result2;
    }
    array$1.splitWhen = splitWhen;
    var errno$1 = {};
    Object.defineProperty(errno$1, "__esModule", { value: true });
    errno$1.isEnoentCodeError = void 0;
    function isEnoentCodeError(error2) {
      return error2.code === "ENOENT";
    }
    errno$1.isEnoentCodeError = isEnoentCodeError;
    var fs$j = {};
    Object.defineProperty(fs$j, "__esModule", { value: true });
    fs$j.createDirentFromStats = void 0;
    var DirentFromStats$1 = class {
      constructor(name, stats) {
        this.name = name;
        this.isBlockDevice = stats.isBlockDevice.bind(stats);
        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
        this.isDirectory = stats.isDirectory.bind(stats);
        this.isFIFO = stats.isFIFO.bind(stats);
        this.isFile = stats.isFile.bind(stats);
        this.isSocket = stats.isSocket.bind(stats);
        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
      }
    };
    function createDirentFromStats$1(name, stats) {
      return new DirentFromStats$1(name, stats);
    }
    fs$j.createDirentFromStats = createDirentFromStats$1;
    var path$j = {};
    Object.defineProperty(path$j, "__esModule", { value: true });
    path$j.removeLeadingDotSegment = path$j.escape = path$j.makeAbsolute = path$j.unixify = void 0;
    var path$i = path__default;
    var LEADING_DOT_SEGMENT_CHARACTERS_COUNT = 2;
    var UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([()*?[\]{|}]|^!|[!+@](?=\())/g;
    function unixify(filepath) {
      return filepath.replace(/\\/g, "/");
    }
    path$j.unixify = unixify;
    function makeAbsolute(cwd, filepath) {
      return path$i.resolve(cwd, filepath);
    }
    path$j.makeAbsolute = makeAbsolute;
    function escape$2(pattern2) {
      return pattern2.replace(UNESCAPED_GLOB_SYMBOLS_RE, "\\$2");
    }
    path$j.escape = escape$2;
    function removeLeadingDotSegment(entry2) {
      if (entry2.charAt(0) === ".") {
        const secondCharactery = entry2.charAt(1);
        if (secondCharactery === "/" || secondCharactery === "\\") {
          return entry2.slice(LEADING_DOT_SEGMENT_CHARACTERS_COUNT);
        }
      }
      return entry2;
    }
    path$j.removeLeadingDotSegment = removeLeadingDotSegment;
    var pattern$1 = {};
    var isExtglob$1 = function isExtglob2(str) {
      if (typeof str !== "string" || str === "") {
        return false;
      }
      var match2;
      while (match2 = /(\\).|([@?!+*]\(.*\))/g.exec(str)) {
        if (match2[2])
          return true;
        str = str.slice(match2.index + match2[0].length);
      }
      return false;
    };
    var isExtglob = isExtglob$1;
    var chars = { "{": "}", "(": ")", "[": "]" };
    var strictCheck = function(str) {
      if (str[0] === "!") {
        return true;
      }
      var index2 = 0;
      var pipeIndex = -2;
      var closeSquareIndex = -2;
      var closeCurlyIndex = -2;
      var closeParenIndex = -2;
      var backSlashIndex = -2;
      while (index2 < str.length) {
        if (str[index2] === "*") {
          return true;
        }
        if (str[index2 + 1] === "?" && /[\].+)]/.test(str[index2])) {
          return true;
        }
        if (closeSquareIndex !== -1 && str[index2] === "[" && str[index2 + 1] !== "]") {
          if (closeSquareIndex < index2) {
            closeSquareIndex = str.indexOf("]", index2);
          }
          if (closeSquareIndex > index2) {
            if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
              return true;
            }
            backSlashIndex = str.indexOf("\\", index2);
            if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
              return true;
            }
          }
        }
        if (closeCurlyIndex !== -1 && str[index2] === "{" && str[index2 + 1] !== "}") {
          closeCurlyIndex = str.indexOf("}", index2);
          if (closeCurlyIndex > index2) {
            backSlashIndex = str.indexOf("\\", index2);
            if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {
              return true;
            }
          }
        }
        if (closeParenIndex !== -1 && str[index2] === "(" && str[index2 + 1] === "?" && /[:!=]/.test(str[index2 + 2]) && str[index2 + 3] !== ")") {
          closeParenIndex = str.indexOf(")", index2);
          if (closeParenIndex > index2) {
            backSlashIndex = str.indexOf("\\", index2);
            if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
              return true;
            }
          }
        }
        if (pipeIndex !== -1 && str[index2] === "(" && str[index2 + 1] !== "|") {
          if (pipeIndex < index2) {
            pipeIndex = str.indexOf("|", index2);
          }
          if (pipeIndex !== -1 && str[pipeIndex + 1] !== ")") {
            closeParenIndex = str.indexOf(")", pipeIndex);
            if (closeParenIndex > pipeIndex) {
              backSlashIndex = str.indexOf("\\", pipeIndex);
              if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
                return true;
              }
            }
          }
        }
        if (str[index2] === "\\") {
          var open2 = str[index2 + 1];
          index2 += 2;
          var close2 = chars[open2];
          if (close2) {
            var n3 = str.indexOf(close2, index2);
            if (n3 !== -1) {
              index2 = n3 + 1;
            }
          }
          if (str[index2] === "!") {
            return true;
          }
        } else {
          index2++;
        }
      }
      return false;
    };
    var relaxedCheck = function(str) {
      if (str[0] === "!") {
        return true;
      }
      var index2 = 0;
      while (index2 < str.length) {
        if (/[*?{}()[\]]/.test(str[index2])) {
          return true;
        }
        if (str[index2] === "\\") {
          var open2 = str[index2 + 1];
          index2 += 2;
          var close2 = chars[open2];
          if (close2) {
            var n3 = str.indexOf(close2, index2);
            if (n3 !== -1) {
              index2 = n3 + 1;
            }
          }
          if (str[index2] === "!") {
            return true;
          }
        } else {
          index2++;
        }
      }
      return false;
    };
    var isGlob$2 = function isGlob2(str, options2) {
      if (typeof str !== "string" || str === "") {
        return false;
      }
      if (isExtglob(str)) {
        return true;
      }
      var check = strictCheck;
      if (options2 && options2.strict === false) {
        check = relaxedCheck;
      }
      return check(str);
    };
    var isGlob$1 = isGlob$2;
    var pathPosixDirname = path__default.posix.dirname;
    var isWin32 = require$$1__default.platform() === "win32";
    var slash = "/";
    var backslash = /\\/g;
    var enclosure = /[\{\[].*[\}\]]$/;
    var globby = /(^|[^\\])([\{\[]|\([^\)]+$)/;
    var escaped = /\\([\!\*\?\|\[\]\(\)\{\}])/g;
    var globParent$2 = function globParent2(str, opts) {
      var options2 = Object.assign({ flipBackslashes: true }, opts);
      if (options2.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {
        str = str.replace(backslash, slash);
      }
      if (enclosure.test(str)) {
        str += slash;
      }
      str += "a";
      do {
        str = pathPosixDirname(str);
      } while (isGlob$1(str) || globby.test(str));
      return str.replace(escaped, "$1");
    };
    var utils$k = {};
    (function(exports2) {
      exports2.isInteger = (num) => {
        if (typeof num === "number") {
          return Number.isInteger(num);
        }
        if (typeof num === "string" && num.trim() !== "") {
          return Number.isInteger(Number(num));
        }
        return false;
      };
      exports2.find = (node2, type) => node2.nodes.find((node3) => node3.type === type);
      exports2.exceedsLimit = (min2, max, step = 1, limit) => {
        if (limit === false)
          return false;
        if (!exports2.isInteger(min2) || !exports2.isInteger(max))
          return false;
        return (Number(max) - Number(min2)) / Number(step) >= limit;
      };
      exports2.escapeNode = (block, n3 = 0, type) => {
        let node2 = block.nodes[n3];
        if (!node2)
          return;
        if (type && node2.type === type || node2.type === "open" || node2.type === "close") {
          if (node2.escaped !== true) {
            node2.value = "\\" + node2.value;
            node2.escaped = true;
          }
        }
      };
      exports2.encloseBrace = (node2) => {
        if (node2.type !== "brace")
          return false;
        if (node2.commas >> 0 + node2.ranges >> 0 === 0) {
          node2.invalid = true;
          return true;
        }
        return false;
      };
      exports2.isInvalidBrace = (block) => {
        if (block.type !== "brace")
          return false;
        if (block.invalid === true || block.dollar)
          return true;
        if (block.commas >> 0 + block.ranges >> 0 === 0) {
          block.invalid = true;
          return true;
        }
        if (block.open !== true || block.close !== true) {
          block.invalid = true;
          return true;
        }
        return false;
      };
      exports2.isOpenOrClose = (node2) => {
        if (node2.type === "open" || node2.type === "close") {
          return true;
        }
        return node2.open === true || node2.close === true;
      };
      exports2.reduce = (nodes) => nodes.reduce((acc, node2) => {
        if (node2.type === "text")
          acc.push(node2.value);
        if (node2.type === "range")
          node2.type = "text";
        return acc;
      }, []);
      exports2.flatten = (...args) => {
        const result2 = [];
        const flat = (arr) => {
          for (let i2 = 0; i2 < arr.length; i2++) {
            let ele = arr[i2];
            Array.isArray(ele) ? flat(ele) : ele !== void 0 && result2.push(ele);
          }
          return result2;
        };
        flat(args);
        return result2;
      };
    })(utils$k);
    var utils$j = utils$k;
    var stringify$7 = (ast, options2 = {}) => {
      let stringify2 = (node2, parent = {}) => {
        let invalidBlock = options2.escapeInvalid && utils$j.isInvalidBrace(parent);
        let invalidNode = node2.invalid === true && options2.escapeInvalid === true;
        let output = "";
        if (node2.value) {
          if ((invalidBlock || invalidNode) && utils$j.isOpenOrClose(node2)) {
            return "\\" + node2.value;
          }
          return node2.value;
        }
        if (node2.value) {
          return node2.value;
        }
        if (node2.nodes) {
          for (let child of node2.nodes) {
            output += stringify2(child);
          }
        }
        return output;
      };
      return stringify2(ast);
    };
    var isNumber$2 = function(num) {
      if (typeof num === "number") {
        return num - num === 0;
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
      }
      return false;
    };
    var isNumber$1 = isNumber$2;
    var toRegexRange$1 = (min2, max, options2) => {
      if (isNumber$1(min2) === false) {
        throw new TypeError("toRegexRange: expected the first argument to be a number");
      }
      if (max === void 0 || min2 === max) {
        return String(min2);
      }
      if (isNumber$1(max) === false) {
        throw new TypeError("toRegexRange: expected the second argument to be a number.");
      }
      let opts = __spreadValues2({ relaxZeros: true }, options2);
      if (typeof opts.strictZeros === "boolean") {
        opts.relaxZeros = opts.strictZeros === false;
      }
      let relax = String(opts.relaxZeros);
      let shorthand = String(opts.shorthand);
      let capture = String(opts.capture);
      let wrap2 = String(opts.wrap);
      let cacheKey = min2 + ":" + max + "=" + relax + shorthand + capture + wrap2;
      if (toRegexRange$1.cache.hasOwnProperty(cacheKey)) {
        return toRegexRange$1.cache[cacheKey].result;
      }
      let a2 = Math.min(min2, max);
      let b2 = Math.max(min2, max);
      if (Math.abs(a2 - b2) === 1) {
        let result2 = min2 + "|" + max;
        if (opts.capture) {
          return `(${result2})`;
        }
        if (opts.wrap === false) {
          return result2;
        }
        return `(?:${result2})`;
      }
      let isPadded2 = hasPadding(min2) || hasPadding(max);
      let state = { min: min2, max, a: a2, b: b2 };
      let positives = [];
      let negatives = [];
      if (isPadded2) {
        state.isPadded = isPadded2;
        state.maxLen = String(state.max).length;
      }
      if (a2 < 0) {
        let newMin = b2 < 0 ? Math.abs(b2) : 1;
        negatives = splitToPatterns(newMin, Math.abs(a2), state, opts);
        a2 = state.a = 0;
      }
      if (b2 >= 0) {
        positives = splitToPatterns(a2, b2, state, opts);
      }
      state.negatives = negatives;
      state.positives = positives;
      state.result = collatePatterns(negatives, positives);
      if (opts.capture === true) {
        state.result = `(${state.result})`;
      } else if (opts.wrap !== false && positives.length + negatives.length > 1) {
        state.result = `(?:${state.result})`;
      }
      toRegexRange$1.cache[cacheKey] = state;
      return state.result;
    };
    function collatePatterns(neg, pos2, options2) {
      let onlyNegative = filterPatterns(neg, pos2, "-", false) || [];
      let onlyPositive = filterPatterns(pos2, neg, "", false) || [];
      let intersected = filterPatterns(neg, pos2, "-?", true) || [];
      let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
      return subpatterns.join("|");
    }
    function splitToRanges(min2, max) {
      let nines = 1;
      let zeros2 = 1;
      let stop = countNines(min2, nines);
      let stops = /* @__PURE__ */ new Set([max]);
      while (min2 <= stop && stop <= max) {
        stops.add(stop);
        nines += 1;
        stop = countNines(min2, nines);
      }
      stop = countZeros(max + 1, zeros2) - 1;
      while (min2 < stop && stop <= max) {
        stops.add(stop);
        zeros2 += 1;
        stop = countZeros(max + 1, zeros2) - 1;
      }
      stops = [...stops];
      stops.sort(compare);
      return stops;
    }
    function rangeToPattern(start, stop, options2) {
      if (start === stop) {
        return { pattern: start, count: [], digits: 0 };
      }
      let zipped = zip(start, stop);
      let digits = zipped.length;
      let pattern2 = "";
      let count = 0;
      for (let i2 = 0; i2 < digits; i2++) {
        let [startDigit, stopDigit] = zipped[i2];
        if (startDigit === stopDigit) {
          pattern2 += startDigit;
        } else if (startDigit !== "0" || stopDigit !== "9") {
          pattern2 += toCharacterClass(startDigit, stopDigit);
        } else {
          count++;
        }
      }
      if (count) {
        pattern2 += options2.shorthand === true ? "\\d" : "[0-9]";
      }
      return { pattern: pattern2, count: [count], digits };
    }
    function splitToPatterns(min2, max, tok, options2) {
      let ranges = splitToRanges(min2, max);
      let tokens = [];
      let start = min2;
      let prev;
      for (let i2 = 0; i2 < ranges.length; i2++) {
        let max2 = ranges[i2];
        let obj = rangeToPattern(String(start), String(max2), options2);
        let zeros2 = "";
        if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
          if (prev.count.length > 1) {
            prev.count.pop();
          }
          prev.count.push(obj.count[0]);
          prev.string = prev.pattern + toQuantifier(prev.count);
          start = max2 + 1;
          continue;
        }
        if (tok.isPadded) {
          zeros2 = padZeros(max2, tok, options2);
        }
        obj.string = zeros2 + obj.pattern + toQuantifier(obj.count);
        tokens.push(obj);
        start = max2 + 1;
        prev = obj;
      }
      return tokens;
    }
    function filterPatterns(arr, comparison, prefix, intersection, options2) {
      let result2 = [];
      for (let ele of arr) {
        let { string: string2 } = ele;
        if (!intersection && !contains(comparison, "string", string2)) {
          result2.push(prefix + string2);
        }
        if (intersection && contains(comparison, "string", string2)) {
          result2.push(prefix + string2);
        }
      }
      return result2;
    }
    function zip(a2, b2) {
      let arr = [];
      for (let i2 = 0; i2 < a2.length; i2++)
        arr.push([a2[i2], b2[i2]]);
      return arr;
    }
    function compare(a2, b2) {
      return a2 > b2 ? 1 : b2 > a2 ? -1 : 0;
    }
    function contains(arr, key2, val) {
      return arr.some((ele) => ele[key2] === val);
    }
    function countNines(min2, len) {
      return Number(String(min2).slice(0, -len) + "9".repeat(len));
    }
    function countZeros(integer, zeros2) {
      return integer - integer % Math.pow(10, zeros2);
    }
    function toQuantifier(digits) {
      let [start = 0, stop = ""] = digits;
      if (stop || start > 1) {
        return `{${start + (stop ? "," + stop : "")}}`;
      }
      return "";
    }
    function toCharacterClass(a2, b2, options2) {
      return `[${a2}${b2 - a2 === 1 ? "" : "-"}${b2}]`;
    }
    function hasPadding(str) {
      return /^-?(0+)\d/.test(str);
    }
    function padZeros(value, tok, options2) {
      if (!tok.isPadded) {
        return value;
      }
      let diff = Math.abs(tok.maxLen - String(value).length);
      let relax = options2.relaxZeros !== false;
      switch (diff) {
        case 0:
          return "";
        case 1:
          return relax ? "0?" : "0";
        case 2:
          return relax ? "0{0,2}" : "00";
        default: {
          return relax ? `0{0,${diff}}` : `0{${diff}}`;
        }
      }
    }
    toRegexRange$1.cache = {};
    toRegexRange$1.clearCache = () => toRegexRange$1.cache = {};
    var toRegexRange_1 = toRegexRange$1;
    var util$3 = require$$0__default$1;
    var toRegexRange = toRegexRange_1;
    var isObject$2 = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    var transform$1 = (toNumber) => {
      return (value) => toNumber === true ? Number(value) : String(value);
    };
    var isValidValue = (value) => {
      return typeof value === "number" || typeof value === "string" && value !== "";
    };
    var isNumber = (num) => Number.isInteger(+num);
    var zeros = (input) => {
      let value = `${input}`;
      let index2 = -1;
      if (value[0] === "-")
        value = value.slice(1);
      if (value === "0")
        return false;
      while (value[++index2] === "0")
        ;
      return index2 > 0;
    };
    var stringify$6 = (start, end, options2) => {
      if (typeof start === "string" || typeof end === "string") {
        return true;
      }
      return options2.stringify === true;
    };
    var pad = (input, maxLength, toNumber) => {
      if (maxLength > 0) {
        let dash = input[0] === "-" ? "-" : "";
        if (dash)
          input = input.slice(1);
        input = dash + input.padStart(dash ? maxLength - 1 : maxLength, "0");
      }
      if (toNumber === false) {
        return String(input);
      }
      return input;
    };
    var toMaxLen = (input, maxLength) => {
      let negative = input[0] === "-" ? "-" : "";
      if (negative) {
        input = input.slice(1);
        maxLength--;
      }
      while (input.length < maxLength)
        input = "0" + input;
      return negative ? "-" + input : input;
    };
    var toSequence = (parts, options2) => {
      parts.negatives.sort((a2, b2) => a2 < b2 ? -1 : a2 > b2 ? 1 : 0);
      parts.positives.sort((a2, b2) => a2 < b2 ? -1 : a2 > b2 ? 1 : 0);
      let prefix = options2.capture ? "" : "?:";
      let positives = "";
      let negatives = "";
      let result2;
      if (parts.positives.length) {
        positives = parts.positives.join("|");
      }
      if (parts.negatives.length) {
        negatives = `-(${prefix}${parts.negatives.join("|")})`;
      }
      if (positives && negatives) {
        result2 = `${positives}|${negatives}`;
      } else {
        result2 = positives || negatives;
      }
      if (options2.wrap) {
        return `(${prefix}${result2})`;
      }
      return result2;
    };
    var toRange = (a2, b2, isNumbers, options2) => {
      if (isNumbers) {
        return toRegexRange(a2, b2, __spreadValues2({ wrap: false }, options2));
      }
      let start = String.fromCharCode(a2);
      if (a2 === b2)
        return start;
      let stop = String.fromCharCode(b2);
      return `[${start}-${stop}]`;
    };
    var toRegex = (start, end, options2) => {
      if (Array.isArray(start)) {
        let wrap2 = options2.wrap === true;
        let prefix = options2.capture ? "" : "?:";
        return wrap2 ? `(${prefix}${start.join("|")})` : start.join("|");
      }
      return toRegexRange(start, end, options2);
    };
    var rangeError = (...args) => {
      return new RangeError("Invalid range arguments: " + util$3.inspect(...args));
    };
    var invalidRange = (start, end, options2) => {
      if (options2.strictRanges === true)
        throw rangeError([start, end]);
      return [];
    };
    var invalidStep = (step, options2) => {
      if (options2.strictRanges === true) {
        throw new TypeError(`Expected step "${step}" to be a number`);
      }
      return [];
    };
    var fillNumbers = (start, end, step = 1, options2 = {}) => {
      let a2 = Number(start);
      let b2 = Number(end);
      if (!Number.isInteger(a2) || !Number.isInteger(b2)) {
        if (options2.strictRanges === true)
          throw rangeError([start, end]);
        return [];
      }
      if (a2 === 0)
        a2 = 0;
      if (b2 === 0)
        b2 = 0;
      let descending = a2 > b2;
      let startString = String(start);
      let endString = String(end);
      let stepString = String(step);
      step = Math.max(Math.abs(step), 1);
      let padded = zeros(startString) || zeros(endString) || zeros(stepString);
      let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
      let toNumber = padded === false && stringify$6(start, end, options2) === false;
      let format2 = options2.transform || transform$1(toNumber);
      if (options2.toRegex && step === 1) {
        return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options2);
      }
      let parts = { negatives: [], positives: [] };
      let push2 = (num) => parts[num < 0 ? "negatives" : "positives"].push(Math.abs(num));
      let range2 = [];
      let index2 = 0;
      while (descending ? a2 >= b2 : a2 <= b2) {
        if (options2.toRegex === true && step > 1) {
          push2(a2);
        } else {
          range2.push(pad(format2(a2, index2), maxLen, toNumber));
        }
        a2 = descending ? a2 - step : a2 + step;
        index2++;
      }
      if (options2.toRegex === true) {
        return step > 1 ? toSequence(parts, options2) : toRegex(range2, null, __spreadValues2({ wrap: false }, options2));
      }
      return range2;
    };
    var fillLetters = (start, end, step = 1, options2 = {}) => {
      if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1) {
        return invalidRange(start, end, options2);
      }
      let format2 = options2.transform || ((val) => String.fromCharCode(val));
      let a2 = `${start}`.charCodeAt(0);
      let b2 = `${end}`.charCodeAt(0);
      let descending = a2 > b2;
      let min2 = Math.min(a2, b2);
      let max = Math.max(a2, b2);
      if (options2.toRegex && step === 1) {
        return toRange(min2, max, false, options2);
      }
      let range2 = [];
      let index2 = 0;
      while (descending ? a2 >= b2 : a2 <= b2) {
        range2.push(format2(a2, index2));
        a2 = descending ? a2 - step : a2 + step;
        index2++;
      }
      if (options2.toRegex === true) {
        return toRegex(range2, null, { wrap: false, options: options2 });
      }
      return range2;
    };
    var fill$2 = (start, end, step, options2 = {}) => {
      if (end == null && isValidValue(start)) {
        return [start];
      }
      if (!isValidValue(start) || !isValidValue(end)) {
        return invalidRange(start, end, options2);
      }
      if (typeof step === "function") {
        return fill$2(start, end, 1, { transform: step });
      }
      if (isObject$2(step)) {
        return fill$2(start, end, 0, step);
      }
      let opts = __spreadValues2({}, options2);
      if (opts.capture === true)
        opts.wrap = true;
      step = step || opts.step || 1;
      if (!isNumber(step)) {
        if (step != null && !isObject$2(step))
          return invalidStep(step, opts);
        return fill$2(start, end, 1, step);
      }
      if (isNumber(start) && isNumber(end)) {
        return fillNumbers(start, end, step, opts);
      }
      return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
    };
    var fillRange = fill$2;
    var fill$1 = fillRange;
    var utils$i = utils$k;
    var compile$1 = (ast, options2 = {}) => {
      let walk2 = (node2, parent = {}) => {
        let invalidBlock = utils$i.isInvalidBrace(parent);
        let invalidNode = node2.invalid === true && options2.escapeInvalid === true;
        let invalid = invalidBlock === true || invalidNode === true;
        let prefix = options2.escapeInvalid === true ? "\\" : "";
        let output = "";
        if (node2.isOpen === true) {
          return prefix + node2.value;
        }
        if (node2.isClose === true) {
          return prefix + node2.value;
        }
        if (node2.type === "open") {
          return invalid ? prefix + node2.value : "(";
        }
        if (node2.type === "close") {
          return invalid ? prefix + node2.value : ")";
        }
        if (node2.type === "comma") {
          return node2.prev.type === "comma" ? "" : invalid ? node2.value : "|";
        }
        if (node2.value) {
          return node2.value;
        }
        if (node2.nodes && node2.ranges > 0) {
          let args = utils$i.reduce(node2.nodes);
          let range2 = fill$1(...args, __spreadProps2(__spreadValues2({}, options2), { wrap: false, toRegex: true }));
          if (range2.length !== 0) {
            return args.length > 1 && range2.length > 1 ? `(${range2})` : range2;
          }
        }
        if (node2.nodes) {
          for (let child of node2.nodes) {
            output += walk2(child, node2);
          }
        }
        return output;
      };
      return walk2(ast);
    };
    var compile_1 = compile$1;
    var fill = fillRange;
    var stringify$5 = stringify$7;
    var utils$h = utils$k;
    var append$1 = (queue2 = "", stash = "", enclose = false) => {
      let result2 = [];
      queue2 = [].concat(queue2);
      stash = [].concat(stash);
      if (!stash.length)
        return queue2;
      if (!queue2.length) {
        return enclose ? utils$h.flatten(stash).map((ele) => `{${ele}}`) : stash;
      }
      for (let item of queue2) {
        if (Array.isArray(item)) {
          for (let value of item) {
            result2.push(append$1(value, stash, enclose));
          }
        } else {
          for (let ele of stash) {
            if (enclose === true && typeof ele === "string")
              ele = `{${ele}}`;
            result2.push(Array.isArray(ele) ? append$1(item, ele, enclose) : item + ele);
          }
        }
      }
      return utils$h.flatten(result2);
    };
    var expand$1 = (ast, options2 = {}) => {
      let rangeLimit = options2.rangeLimit === void 0 ? 1e3 : options2.rangeLimit;
      let walk2 = (node2, parent = {}) => {
        node2.queue = [];
        let p2 = parent;
        let q2 = parent.queue;
        while (p2.type !== "brace" && p2.type !== "root" && p2.parent) {
          p2 = p2.parent;
          q2 = p2.queue;
        }
        if (node2.invalid || node2.dollar) {
          q2.push(append$1(q2.pop(), stringify$5(node2, options2)));
          return;
        }
        if (node2.type === "brace" && node2.invalid !== true && node2.nodes.length === 2) {
          q2.push(append$1(q2.pop(), ["{}"]));
          return;
        }
        if (node2.nodes && node2.ranges > 0) {
          let args = utils$h.reduce(node2.nodes);
          if (utils$h.exceedsLimit(...args, options2.step, rangeLimit)) {
            throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
          }
          let range2 = fill(...args, options2);
          if (range2.length === 0) {
            range2 = stringify$5(node2, options2);
          }
          q2.push(append$1(q2.pop(), range2));
          node2.nodes = [];
          return;
        }
        let enclose = utils$h.encloseBrace(node2);
        let queue2 = node2.queue;
        let block = node2;
        while (block.type !== "brace" && block.type !== "root" && block.parent) {
          block = block.parent;
          queue2 = block.queue;
        }
        for (let i2 = 0; i2 < node2.nodes.length; i2++) {
          let child = node2.nodes[i2];
          if (child.type === "comma" && node2.type === "brace") {
            if (i2 === 1)
              queue2.push("");
            queue2.push("");
            continue;
          }
          if (child.type === "close") {
            q2.push(append$1(q2.pop(), queue2, enclose));
            continue;
          }
          if (child.value && child.type !== "open") {
            queue2.push(append$1(queue2.pop(), child.value));
            continue;
          }
          if (child.nodes) {
            walk2(child, node2);
          }
        }
        return queue2;
      };
      return utils$h.flatten(walk2(ast));
    };
    var expand_1 = expand$1;
    var constants$6 = {
      MAX_LENGTH: 1024 * 64,
      CHAR_0: "0",
      CHAR_9: "9",
      CHAR_UPPERCASE_A: "A",
      CHAR_LOWERCASE_A: "a",
      CHAR_UPPERCASE_Z: "Z",
      CHAR_LOWERCASE_Z: "z",
      CHAR_LEFT_PARENTHESES: "(",
      CHAR_RIGHT_PARENTHESES: ")",
      CHAR_ASTERISK: "*",
      CHAR_AMPERSAND: "&",
      CHAR_AT: "@",
      CHAR_BACKSLASH: "\\",
      CHAR_BACKTICK: "`",
      CHAR_CARRIAGE_RETURN: "\r",
      CHAR_CIRCUMFLEX_ACCENT: "^",
      CHAR_COLON: ":",
      CHAR_COMMA: ",",
      CHAR_DOLLAR: "$",
      CHAR_DOT: ".",
      CHAR_DOUBLE_QUOTE: '"',
      CHAR_EQUAL: "=",
      CHAR_EXCLAMATION_MARK: "!",
      CHAR_FORM_FEED: "\f",
      CHAR_FORWARD_SLASH: "/",
      CHAR_HASH: "#",
      CHAR_HYPHEN_MINUS: "-",
      CHAR_LEFT_ANGLE_BRACKET: "<",
      CHAR_LEFT_CURLY_BRACE: "{",
      CHAR_LEFT_SQUARE_BRACKET: "[",
      CHAR_LINE_FEED: "\n",
      CHAR_NO_BREAK_SPACE: "\xA0",
      CHAR_PERCENT: "%",
      CHAR_PLUS: "+",
      CHAR_QUESTION_MARK: "?",
      CHAR_RIGHT_ANGLE_BRACKET: ">",
      CHAR_RIGHT_CURLY_BRACE: "}",
      CHAR_RIGHT_SQUARE_BRACKET: "]",
      CHAR_SEMICOLON: ";",
      CHAR_SINGLE_QUOTE: "'",
      CHAR_SPACE: " ",
      CHAR_TAB: "	",
      CHAR_UNDERSCORE: "_",
      CHAR_VERTICAL_LINE: "|",
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
    };
    var stringify$4 = stringify$7;
    var {
      MAX_LENGTH: MAX_LENGTH$1,
      CHAR_BACKSLASH,
      CHAR_BACKTICK,
      CHAR_COMMA: CHAR_COMMA$1,
      CHAR_DOT: CHAR_DOT$1,
      CHAR_LEFT_PARENTHESES: CHAR_LEFT_PARENTHESES$1,
      CHAR_RIGHT_PARENTHESES: CHAR_RIGHT_PARENTHESES$1,
      CHAR_LEFT_CURLY_BRACE: CHAR_LEFT_CURLY_BRACE$1,
      CHAR_RIGHT_CURLY_BRACE: CHAR_RIGHT_CURLY_BRACE$1,
      CHAR_LEFT_SQUARE_BRACKET: CHAR_LEFT_SQUARE_BRACKET$1,
      CHAR_RIGHT_SQUARE_BRACKET: CHAR_RIGHT_SQUARE_BRACKET$1,
      CHAR_DOUBLE_QUOTE,
      CHAR_SINGLE_QUOTE,
      CHAR_NO_BREAK_SPACE,
      CHAR_ZERO_WIDTH_NOBREAK_SPACE
    } = constants$6;
    var parse$j = (input, options2 = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      let opts = options2 || {};
      let max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH$1, opts.maxLength) : MAX_LENGTH$1;
      if (input.length > max) {
        throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);
      }
      let ast = { type: "root", input, nodes: [] };
      let stack2 = [ast];
      let block = ast;
      let prev = ast;
      let brackets = 0;
      let length = input.length;
      let index2 = 0;
      let depth2 = 0;
      let value;
      const advance = () => input[index2++];
      const push2 = (node2) => {
        if (node2.type === "text" && prev.type === "dot") {
          prev.type = "text";
        }
        if (prev && prev.type === "text" && node2.type === "text") {
          prev.value += node2.value;
          return;
        }
        block.nodes.push(node2);
        node2.parent = block;
        node2.prev = prev;
        prev = node2;
        return node2;
      };
      push2({ type: "bos" });
      while (index2 < length) {
        block = stack2[stack2.length - 1];
        value = advance();
        if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {
          continue;
        }
        if (value === CHAR_BACKSLASH) {
          push2({ type: "text", value: (options2.keepEscaping ? value : "") + advance() });
          continue;
        }
        if (value === CHAR_RIGHT_SQUARE_BRACKET$1) {
          push2({ type: "text", value: "\\" + value });
          continue;
        }
        if (value === CHAR_LEFT_SQUARE_BRACKET$1) {
          brackets++;
          let next;
          while (index2 < length && (next = advance())) {
            value += next;
            if (next === CHAR_LEFT_SQUARE_BRACKET$1) {
              brackets++;
              continue;
            }
            if (next === CHAR_BACKSLASH) {
              value += advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET$1) {
              brackets--;
              if (brackets === 0) {
                break;
              }
            }
          }
          push2({ type: "text", value });
          continue;
        }
        if (value === CHAR_LEFT_PARENTHESES$1) {
          block = push2({ type: "paren", nodes: [] });
          stack2.push(block);
          push2({ type: "text", value });
          continue;
        }
        if (value === CHAR_RIGHT_PARENTHESES$1) {
          if (block.type !== "paren") {
            push2({ type: "text", value });
            continue;
          }
          block = stack2.pop();
          push2({ type: "text", value });
          block = stack2[stack2.length - 1];
          continue;
        }
        if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
          let open2 = value;
          let next;
          if (options2.keepQuotes !== true) {
            value = "";
          }
          while (index2 < length && (next = advance())) {
            if (next === CHAR_BACKSLASH) {
              value += next + advance();
              continue;
            }
            if (next === open2) {
              if (options2.keepQuotes === true)
                value += next;
              break;
            }
            value += next;
          }
          push2({ type: "text", value });
          continue;
        }
        if (value === CHAR_LEFT_CURLY_BRACE$1) {
          depth2++;
          let dollar = prev.value && prev.value.slice(-1) === "$" || block.dollar === true;
          let brace = {
            type: "brace",
            open: true,
            close: false,
            dollar,
            depth: depth2,
            commas: 0,
            ranges: 0,
            nodes: []
          };
          block = push2(brace);
          stack2.push(block);
          push2({ type: "open", value });
          continue;
        }
        if (value === CHAR_RIGHT_CURLY_BRACE$1) {
          if (block.type !== "brace") {
            push2({ type: "text", value });
            continue;
          }
          let type = "close";
          block = stack2.pop();
          block.close = true;
          push2({ type, value });
          depth2--;
          block = stack2[stack2.length - 1];
          continue;
        }
        if (value === CHAR_COMMA$1 && depth2 > 0) {
          if (block.ranges > 0) {
            block.ranges = 0;
            let open2 = block.nodes.shift();
            block.nodes = [open2, { type: "text", value: stringify$4(block) }];
          }
          push2({ type: "comma", value });
          block.commas++;
          continue;
        }
        if (value === CHAR_DOT$1 && depth2 > 0 && block.commas === 0) {
          let siblings = block.nodes;
          if (depth2 === 0 || siblings.length === 0) {
            push2({ type: "text", value });
            continue;
          }
          if (prev.type === "dot") {
            block.range = [];
            prev.value += value;
            prev.type = "range";
            if (block.nodes.length !== 3 && block.nodes.length !== 5) {
              block.invalid = true;
              block.ranges = 0;
              prev.type = "text";
              continue;
            }
            block.ranges++;
            block.args = [];
            continue;
          }
          if (prev.type === "range") {
            siblings.pop();
            let before = siblings[siblings.length - 1];
            before.value += prev.value + value;
            prev = before;
            block.ranges--;
            continue;
          }
          push2({ type: "dot", value });
          continue;
        }
        push2({ type: "text", value });
      }
      do {
        block = stack2.pop();
        if (block.type !== "root") {
          block.nodes.forEach((node2) => {
            if (!node2.nodes) {
              if (node2.type === "open")
                node2.isOpen = true;
              if (node2.type === "close")
                node2.isClose = true;
              if (!node2.nodes)
                node2.type = "text";
              node2.invalid = true;
            }
          });
          let parent = stack2[stack2.length - 1];
          let index3 = parent.nodes.indexOf(block);
          parent.nodes.splice(index3, 1, ...block.nodes);
        }
      } while (stack2.length > 0);
      push2({ type: "eos" });
      return ast;
    };
    var parse_1$2 = parse$j;
    var stringify$3 = stringify$7;
    var compile = compile_1;
    var expand = expand_1;
    var parse$i = parse_1$2;
    var braces$3 = (input, options2 = {}) => {
      let output = [];
      if (Array.isArray(input)) {
        for (let pattern2 of input) {
          let result2 = braces$3.create(pattern2, options2);
          if (Array.isArray(result2)) {
            output.push(...result2);
          } else {
            output.push(result2);
          }
        }
      } else {
        output = [].concat(braces$3.create(input, options2));
      }
      if (options2 && options2.expand === true && options2.nodupes === true) {
        output = [...new Set(output)];
      }
      return output;
    };
    braces$3.parse = (input, options2 = {}) => parse$i(input, options2);
    braces$3.stringify = (input, options2 = {}) => {
      if (typeof input === "string") {
        return stringify$3(braces$3.parse(input, options2), options2);
      }
      return stringify$3(input, options2);
    };
    braces$3.compile = (input, options2 = {}) => {
      if (typeof input === "string") {
        input = braces$3.parse(input, options2);
      }
      return compile(input, options2);
    };
    braces$3.expand = (input, options2 = {}) => {
      if (typeof input === "string") {
        input = braces$3.parse(input, options2);
      }
      let result2 = expand(input, options2);
      if (options2.noempty === true) {
        result2 = result2.filter(Boolean);
      }
      if (options2.nodupes === true) {
        result2 = [...new Set(result2)];
      }
      return result2;
    };
    braces$3.create = (input, options2 = {}) => {
      if (input === "" || input.length < 3) {
        return [input];
      }
      return options2.expand !== true ? braces$3.compile(input, options2) : braces$3.expand(input, options2);
    };
    var braces_1 = braces$3;
    var util$2 = require$$0__default$1;
    var braces$2 = braces_1;
    var picomatch$5 = picomatch$6;
    var utils$g = utils$p;
    var isEmptyString$1 = (val) => val === "" || val === "./";
    var micromatch$2 = (list2, patterns2, options2) => {
      patterns2 = [].concat(patterns2);
      list2 = [].concat(list2);
      let omit = /* @__PURE__ */ new Set();
      let keep = /* @__PURE__ */ new Set();
      let items = /* @__PURE__ */ new Set();
      let negatives = 0;
      let onResult = (state) => {
        items.add(state.output);
        if (options2 && options2.onResult) {
          options2.onResult(state);
        }
      };
      for (let i2 = 0; i2 < patterns2.length; i2++) {
        let isMatch2 = picomatch$5(String(patterns2[i2]), __spreadProps2(__spreadValues2({}, options2), { onResult }), true);
        let negated = isMatch2.state.negated || isMatch2.state.negatedExtglob;
        if (negated)
          negatives++;
        for (let item of list2) {
          let matched = isMatch2(item, true);
          let match2 = negated ? !matched.isMatch : matched.isMatch;
          if (!match2)
            continue;
          if (negated) {
            omit.add(matched.output);
          } else {
            omit.delete(matched.output);
            keep.add(matched.output);
          }
        }
      }
      let result2 = negatives === patterns2.length ? [...items] : [...keep];
      let matches2 = result2.filter((item) => !omit.has(item));
      if (options2 && matches2.length === 0) {
        if (options2.failglob === true) {
          throw new Error(`No matches found for "${patterns2.join(", ")}"`);
        }
        if (options2.nonull === true || options2.nullglob === true) {
          return options2.unescape ? patterns2.map((p2) => p2.replace(/\\/g, "")) : patterns2;
        }
      }
      return matches2;
    };
    micromatch$2.match = micromatch$2;
    micromatch$2.matcher = (pattern2, options2) => picomatch$5(pattern2, options2);
    micromatch$2.isMatch = (str, patterns2, options2) => picomatch$5(patterns2, options2)(str);
    micromatch$2.any = micromatch$2.isMatch;
    micromatch$2.not = (list2, patterns2, options2 = {}) => {
      patterns2 = [].concat(patterns2).map(String);
      let result2 = /* @__PURE__ */ new Set();
      let items = [];
      let onResult = (state) => {
        if (options2.onResult)
          options2.onResult(state);
        items.push(state.output);
      };
      let matches2 = micromatch$2(list2, patterns2, __spreadProps2(__spreadValues2({}, options2), { onResult }));
      for (let item of items) {
        if (!matches2.includes(item)) {
          result2.add(item);
        }
      }
      return [...result2];
    };
    micromatch$2.contains = (str, pattern2, options2) => {
      if (typeof str !== "string") {
        throw new TypeError(`Expected a string: "${util$2.inspect(str)}"`);
      }
      if (Array.isArray(pattern2)) {
        return pattern2.some((p2) => micromatch$2.contains(str, p2, options2));
      }
      if (typeof pattern2 === "string") {
        if (isEmptyString$1(str) || isEmptyString$1(pattern2)) {
          return false;
        }
        if (str.includes(pattern2) || str.startsWith("./") && str.slice(2).includes(pattern2)) {
          return true;
        }
      }
      return micromatch$2.isMatch(str, pattern2, __spreadProps2(__spreadValues2({}, options2), { contains: true }));
    };
    micromatch$2.matchKeys = (obj, patterns2, options2) => {
      if (!utils$g.isObject(obj)) {
        throw new TypeError("Expected the first argument to be an object");
      }
      let keys = micromatch$2(Object.keys(obj), patterns2, options2);
      let res = {};
      for (let key2 of keys)
        res[key2] = obj[key2];
      return res;
    };
    micromatch$2.some = (list2, patterns2, options2) => {
      let items = [].concat(list2);
      for (let pattern2 of [].concat(patterns2)) {
        let isMatch2 = picomatch$5(String(pattern2), options2);
        if (items.some((item) => isMatch2(item))) {
          return true;
        }
      }
      return false;
    };
    micromatch$2.every = (list2, patterns2, options2) => {
      let items = [].concat(list2);
      for (let pattern2 of [].concat(patterns2)) {
        let isMatch2 = picomatch$5(String(pattern2), options2);
        if (!items.every((item) => isMatch2(item))) {
          return false;
        }
      }
      return true;
    };
    micromatch$2.all = (str, patterns2, options2) => {
      if (typeof str !== "string") {
        throw new TypeError(`Expected a string: "${util$2.inspect(str)}"`);
      }
      return [].concat(patterns2).every((p2) => picomatch$5(p2, options2)(str));
    };
    micromatch$2.capture = (glob2, input, options2) => {
      let posix2 = utils$g.isWindows(options2);
      let regex = picomatch$5.makeRe(String(glob2), __spreadProps2(__spreadValues2({}, options2), { capture: true }));
      let match2 = regex.exec(posix2 ? utils$g.toPosixSlashes(input) : input);
      if (match2) {
        return match2.slice(1).map((v2) => v2 === void 0 ? "" : v2);
      }
    };
    micromatch$2.makeRe = (...args) => picomatch$5.makeRe(...args);
    micromatch$2.scan = (...args) => picomatch$5.scan(...args);
    micromatch$2.parse = (patterns2, options2) => {
      let res = [];
      for (let pattern2 of [].concat(patterns2 || [])) {
        for (let str of braces$2(String(pattern2), options2)) {
          res.push(picomatch$5.parse(str, options2));
        }
      }
      return res;
    };
    micromatch$2.braces = (pattern2, options2) => {
      if (typeof pattern2 !== "string")
        throw new TypeError("Expected a string");
      if (options2 && options2.nobrace === true || !/\{.*\}/.test(pattern2)) {
        return [pattern2];
      }
      return braces$2(pattern2, options2);
    };
    micromatch$2.braceExpand = (pattern2, options2) => {
      if (typeof pattern2 !== "string")
        throw new TypeError("Expected a string");
      return micromatch$2.braces(pattern2, __spreadProps2(__spreadValues2({}, options2), { expand: true }));
    };
    var micromatch_1$1 = micromatch$2;
    Object.defineProperty(pattern$1, "__esModule", { value: true });
    pattern$1.matchAny = pattern$1.convertPatternsToRe = pattern$1.makeRe = pattern$1.getPatternParts = pattern$1.expandBraceExpansion = pattern$1.expandPatternsWithBraceExpansion = pattern$1.isAffectDepthOfReadingPattern = pattern$1.endsWithSlashGlobStar = pattern$1.hasGlobStar = pattern$1.getBaseDirectory = pattern$1.isPatternRelatedToParentDirectory = pattern$1.getPatternsOutsideCurrentDirectory = pattern$1.getPatternsInsideCurrentDirectory = pattern$1.getPositivePatterns = pattern$1.getNegativePatterns = pattern$1.isPositivePattern = pattern$1.isNegativePattern = pattern$1.convertToNegativePattern = pattern$1.convertToPositivePattern = pattern$1.isDynamicPattern = pattern$1.isStaticPattern = void 0;
    var path$h = path__default;
    var globParent$1 = globParent$2;
    var micromatch$1 = micromatch_1$1;
    var GLOBSTAR$1 = "**";
    var ESCAPE_SYMBOL = "\\";
    var COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;
    var REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\[[^[]*]/;
    var REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\([^(]*\|[^|]*\)/;
    var GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\([^(]*\)/;
    var BRACE_EXPANSION_SEPARATORS_RE = /,|\.\./;
    function isStaticPattern(pattern2, options2 = {}) {
      return !isDynamicPattern(pattern2, options2);
    }
    pattern$1.isStaticPattern = isStaticPattern;
    function isDynamicPattern(pattern2, options2 = {}) {
      if (pattern2 === "") {
        return false;
      }
      if (options2.caseSensitiveMatch === false || pattern2.includes(ESCAPE_SYMBOL)) {
        return true;
      }
      if (COMMON_GLOB_SYMBOLS_RE.test(pattern2) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern2) || REGEX_GROUP_SYMBOLS_RE.test(pattern2)) {
        return true;
      }
      if (options2.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern2)) {
        return true;
      }
      if (options2.braceExpansion !== false && hasBraceExpansion(pattern2)) {
        return true;
      }
      return false;
    }
    pattern$1.isDynamicPattern = isDynamicPattern;
    function hasBraceExpansion(pattern2) {
      const openingBraceIndex = pattern2.indexOf("{");
      if (openingBraceIndex === -1) {
        return false;
      }
      const closingBraceIndex = pattern2.indexOf("}", openingBraceIndex + 1);
      if (closingBraceIndex === -1) {
        return false;
      }
      const braceContent = pattern2.slice(openingBraceIndex, closingBraceIndex);
      return BRACE_EXPANSION_SEPARATORS_RE.test(braceContent);
    }
    function convertToPositivePattern(pattern2) {
      return isNegativePattern(pattern2) ? pattern2.slice(1) : pattern2;
    }
    pattern$1.convertToPositivePattern = convertToPositivePattern;
    function convertToNegativePattern(pattern2) {
      return "!" + pattern2;
    }
    pattern$1.convertToNegativePattern = convertToNegativePattern;
    function isNegativePattern(pattern2) {
      return pattern2.startsWith("!") && pattern2[1] !== "(";
    }
    pattern$1.isNegativePattern = isNegativePattern;
    function isPositivePattern(pattern2) {
      return !isNegativePattern(pattern2);
    }
    pattern$1.isPositivePattern = isPositivePattern;
    function getNegativePatterns(patterns2) {
      return patterns2.filter(isNegativePattern);
    }
    pattern$1.getNegativePatterns = getNegativePatterns;
    function getPositivePatterns$1(patterns2) {
      return patterns2.filter(isPositivePattern);
    }
    pattern$1.getPositivePatterns = getPositivePatterns$1;
    function getPatternsInsideCurrentDirectory(patterns2) {
      return patterns2.filter((pattern2) => !isPatternRelatedToParentDirectory(pattern2));
    }
    pattern$1.getPatternsInsideCurrentDirectory = getPatternsInsideCurrentDirectory;
    function getPatternsOutsideCurrentDirectory(patterns2) {
      return patterns2.filter(isPatternRelatedToParentDirectory);
    }
    pattern$1.getPatternsOutsideCurrentDirectory = getPatternsOutsideCurrentDirectory;
    function isPatternRelatedToParentDirectory(pattern2) {
      return pattern2.startsWith("..") || pattern2.startsWith("./..");
    }
    pattern$1.isPatternRelatedToParentDirectory = isPatternRelatedToParentDirectory;
    function getBaseDirectory(pattern2) {
      return globParent$1(pattern2, { flipBackslashes: false });
    }
    pattern$1.getBaseDirectory = getBaseDirectory;
    function hasGlobStar(pattern2) {
      return pattern2.includes(GLOBSTAR$1);
    }
    pattern$1.hasGlobStar = hasGlobStar;
    function endsWithSlashGlobStar(pattern2) {
      return pattern2.endsWith("/" + GLOBSTAR$1);
    }
    pattern$1.endsWithSlashGlobStar = endsWithSlashGlobStar;
    function isAffectDepthOfReadingPattern(pattern2) {
      const basename = path$h.basename(pattern2);
      return endsWithSlashGlobStar(pattern2) || isStaticPattern(basename);
    }
    pattern$1.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;
    function expandPatternsWithBraceExpansion(patterns2) {
      return patterns2.reduce((collection, pattern2) => {
        return collection.concat(expandBraceExpansion(pattern2));
      }, []);
    }
    pattern$1.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;
    function expandBraceExpansion(pattern2) {
      return micromatch$1.braces(pattern2, {
        expand: true,
        nodupes: true
      });
    }
    pattern$1.expandBraceExpansion = expandBraceExpansion;
    function getPatternParts(pattern2, options2) {
      let { parts } = micromatch$1.scan(pattern2, Object.assign(Object.assign({}, options2), { parts: true }));
      if (parts.length === 0) {
        parts = [pattern2];
      }
      if (parts[0].startsWith("/")) {
        parts[0] = parts[0].slice(1);
        parts.unshift("");
      }
      return parts;
    }
    pattern$1.getPatternParts = getPatternParts;
    function makeRe(pattern2, options2) {
      return micromatch$1.makeRe(pattern2, options2);
    }
    pattern$1.makeRe = makeRe;
    function convertPatternsToRe(patterns2, options2) {
      return patterns2.map((pattern2) => makeRe(pattern2, options2));
    }
    pattern$1.convertPatternsToRe = convertPatternsToRe;
    function matchAny(entry2, patternsRe) {
      return patternsRe.some((patternRe) => patternRe.test(entry2));
    }
    pattern$1.matchAny = matchAny;
    var stream$4 = {};
    var Stream = require$$0__default$3;
    var PassThrough = Stream.PassThrough;
    var slice = Array.prototype.slice;
    var merge2_1 = merge2$1;
    function merge2$1() {
      const streamsQueue = [];
      const args = slice.call(arguments);
      let merging = false;
      let options2 = args[args.length - 1];
      if (options2 && !Array.isArray(options2) && options2.pipe == null) {
        args.pop();
      } else {
        options2 = {};
      }
      const doEnd = options2.end !== false;
      const doPipeError = options2.pipeError === true;
      if (options2.objectMode == null) {
        options2.objectMode = true;
      }
      if (options2.highWaterMark == null) {
        options2.highWaterMark = 64 * 1024;
      }
      const mergedStream = PassThrough(options2);
      function addStream() {
        for (let i2 = 0, len = arguments.length; i2 < len; i2++) {
          streamsQueue.push(pauseStreams(arguments[i2], options2));
        }
        mergeStream();
        return this;
      }
      function mergeStream() {
        if (merging) {
          return;
        }
        merging = true;
        let streams = streamsQueue.shift();
        if (!streams) {
          process.nextTick(endStream);
          return;
        }
        if (!Array.isArray(streams)) {
          streams = [streams];
        }
        let pipesCount = streams.length + 1;
        function next() {
          if (--pipesCount > 0) {
            return;
          }
          merging = false;
          mergeStream();
        }
        function pipe(stream2) {
          function onend() {
            stream2.removeListener("merge2UnpipeEnd", onend);
            stream2.removeListener("end", onend);
            if (doPipeError) {
              stream2.removeListener("error", onerror);
            }
            next();
          }
          function onerror(err) {
            mergedStream.emit("error", err);
          }
          if (stream2._readableState.endEmitted) {
            return next();
          }
          stream2.on("merge2UnpipeEnd", onend);
          stream2.on("end", onend);
          if (doPipeError) {
            stream2.on("error", onerror);
          }
          stream2.pipe(mergedStream, { end: false });
          stream2.resume();
        }
        for (let i2 = 0; i2 < streams.length; i2++) {
          pipe(streams[i2]);
        }
        next();
      }
      function endStream() {
        merging = false;
        mergedStream.emit("queueDrain");
        if (doEnd) {
          mergedStream.end();
        }
      }
      mergedStream.setMaxListeners(0);
      mergedStream.add = addStream;
      mergedStream.on("unpipe", function(stream2) {
        stream2.emit("merge2UnpipeEnd");
      });
      if (args.length) {
        addStream.apply(null, args);
      }
      return mergedStream;
    }
    function pauseStreams(streams, options2) {
      if (!Array.isArray(streams)) {
        if (!streams._readableState && streams.pipe) {
          streams = streams.pipe(PassThrough(options2));
        }
        if (!streams._readableState || !streams.pause || !streams.pipe) {
          throw new Error("Only readable stream can be merged.");
        }
        streams.pause();
      } else {
        for (let i2 = 0, len = streams.length; i2 < len; i2++) {
          streams[i2] = pauseStreams(streams[i2], options2);
        }
      }
      return streams;
    }
    Object.defineProperty(stream$4, "__esModule", { value: true });
    stream$4.merge = void 0;
    var merge2 = merge2_1;
    function merge$1(streams) {
      const mergedStream = merge2(streams);
      streams.forEach((stream2) => {
        stream2.once("error", (error2) => mergedStream.emit("error", error2));
      });
      mergedStream.once("close", () => propagateCloseEventToSources(streams));
      mergedStream.once("end", () => propagateCloseEventToSources(streams));
      return mergedStream;
    }
    stream$4.merge = merge$1;
    function propagateCloseEventToSources(streams) {
      streams.forEach((stream2) => stream2.emit("close"));
    }
    var string$2 = {};
    Object.defineProperty(string$2, "__esModule", { value: true });
    string$2.isEmpty = string$2.isString = void 0;
    function isString(input) {
      return typeof input === "string";
    }
    string$2.isString = isString;
    function isEmpty(input) {
      return input === "";
    }
    string$2.isEmpty = isEmpty;
    Object.defineProperty(utils$l, "__esModule", { value: true });
    utils$l.string = utils$l.stream = utils$l.pattern = utils$l.path = utils$l.fs = utils$l.errno = utils$l.array = void 0;
    var array = array$1;
    utils$l.array = array;
    var errno = errno$1;
    utils$l.errno = errno;
    var fs$i = fs$j;
    utils$l.fs = fs$i;
    var path$g = path$j;
    utils$l.path = path$g;
    var pattern = pattern$1;
    utils$l.pattern = pattern;
    var stream$3 = stream$4;
    utils$l.stream = stream$3;
    var string$1 = string$2;
    utils$l.string = string$1;
    Object.defineProperty(tasks, "__esModule", { value: true });
    tasks.convertPatternGroupToTask = tasks.convertPatternGroupsToTasks = tasks.groupPatternsByBaseDirectory = tasks.getNegativePatternsAsPositive = tasks.getPositivePatterns = tasks.convertPatternsToTasks = tasks.generate = void 0;
    var utils$f = utils$l;
    function generate(patterns2, settings2) {
      const positivePatterns = getPositivePatterns(patterns2);
      const negativePatterns = getNegativePatternsAsPositive(patterns2, settings2.ignore);
      const staticPatterns = positivePatterns.filter((pattern2) => utils$f.pattern.isStaticPattern(pattern2, settings2));
      const dynamicPatterns = positivePatterns.filter((pattern2) => utils$f.pattern.isDynamicPattern(pattern2, settings2));
      const staticTasks = convertPatternsToTasks(staticPatterns, negativePatterns, false);
      const dynamicTasks = convertPatternsToTasks(dynamicPatterns, negativePatterns, true);
      return staticTasks.concat(dynamicTasks);
    }
    tasks.generate = generate;
    function convertPatternsToTasks(positive, negative, dynamic) {
      const tasks2 = [];
      const patternsOutsideCurrentDirectory = utils$f.pattern.getPatternsOutsideCurrentDirectory(positive);
      const patternsInsideCurrentDirectory = utils$f.pattern.getPatternsInsideCurrentDirectory(positive);
      const outsideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsOutsideCurrentDirectory);
      const insideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsInsideCurrentDirectory);
      tasks2.push(...convertPatternGroupsToTasks(outsideCurrentDirectoryGroup, negative, dynamic));
      if ("." in insideCurrentDirectoryGroup) {
        tasks2.push(convertPatternGroupToTask(".", patternsInsideCurrentDirectory, negative, dynamic));
      } else {
        tasks2.push(...convertPatternGroupsToTasks(insideCurrentDirectoryGroup, negative, dynamic));
      }
      return tasks2;
    }
    tasks.convertPatternsToTasks = convertPatternsToTasks;
    function getPositivePatterns(patterns2) {
      return utils$f.pattern.getPositivePatterns(patterns2);
    }
    tasks.getPositivePatterns = getPositivePatterns;
    function getNegativePatternsAsPositive(patterns2, ignore) {
      const negative = utils$f.pattern.getNegativePatterns(patterns2).concat(ignore);
      const positive = negative.map(utils$f.pattern.convertToPositivePattern);
      return positive;
    }
    tasks.getNegativePatternsAsPositive = getNegativePatternsAsPositive;
    function groupPatternsByBaseDirectory(patterns2) {
      const group = {};
      return patterns2.reduce((collection, pattern2) => {
        const base2 = utils$f.pattern.getBaseDirectory(pattern2);
        if (base2 in collection) {
          collection[base2].push(pattern2);
        } else {
          collection[base2] = [pattern2];
        }
        return collection;
      }, group);
    }
    tasks.groupPatternsByBaseDirectory = groupPatternsByBaseDirectory;
    function convertPatternGroupsToTasks(positive, negative, dynamic) {
      return Object.keys(positive).map((base2) => {
        return convertPatternGroupToTask(base2, positive[base2], negative, dynamic);
      });
    }
    tasks.convertPatternGroupsToTasks = convertPatternGroupsToTasks;
    function convertPatternGroupToTask(base2, positive, negative, dynamic) {
      return {
        dynamic,
        positive,
        negative,
        base: base2,
        patterns: [].concat(positive, negative.map(utils$f.pattern.convertToNegativePattern))
      };
    }
    tasks.convertPatternGroupToTask = convertPatternGroupToTask;
    var patterns = {};
    Object.defineProperty(patterns, "__esModule", { value: true });
    patterns.removeDuplicateSlashes = patterns.transform = void 0;
    var DOUBLE_SLASH_RE$1 = /(?!^)\/{2,}/g;
    function transform(patterns2) {
      return patterns2.map((pattern2) => removeDuplicateSlashes(pattern2));
    }
    patterns.transform = transform;
    function removeDuplicateSlashes(pattern2) {
      return pattern2.replace(DOUBLE_SLASH_RE$1, "/");
    }
    patterns.removeDuplicateSlashes = removeDuplicateSlashes;
    var async$6 = {};
    var stream$2 = {};
    var out$3 = {};
    var async$5 = {};
    Object.defineProperty(async$5, "__esModule", { value: true });
    async$5.read = void 0;
    function read$4(path2, settings2, callback) {
      settings2.fs.lstat(path2, (lstatError, lstat2) => {
        if (lstatError !== null) {
          callFailureCallback$2(callback, lstatError);
          return;
        }
        if (!lstat2.isSymbolicLink() || !settings2.followSymbolicLink) {
          callSuccessCallback$2(callback, lstat2);
          return;
        }
        settings2.fs.stat(path2, (statError, stat2) => {
          if (statError !== null) {
            if (settings2.throwErrorOnBrokenSymbolicLink) {
              callFailureCallback$2(callback, statError);
              return;
            }
            callSuccessCallback$2(callback, lstat2);
            return;
          }
          if (settings2.markSymbolicLink) {
            stat2.isSymbolicLink = () => true;
          }
          callSuccessCallback$2(callback, stat2);
        });
      });
    }
    async$5.read = read$4;
    function callFailureCallback$2(callback, error2) {
      callback(error2);
    }
    function callSuccessCallback$2(callback, result2) {
      callback(null, result2);
    }
    var sync$a = {};
    Object.defineProperty(sync$a, "__esModule", { value: true });
    sync$a.read = void 0;
    function read$3(path2, settings2) {
      const lstat2 = settings2.fs.lstatSync(path2);
      if (!lstat2.isSymbolicLink() || !settings2.followSymbolicLink) {
        return lstat2;
      }
      try {
        const stat2 = settings2.fs.statSync(path2);
        if (settings2.markSymbolicLink) {
          stat2.isSymbolicLink = () => true;
        }
        return stat2;
      } catch (error2) {
        if (!settings2.throwErrorOnBrokenSymbolicLink) {
          return lstat2;
        }
        throw error2;
      }
    }
    sync$a.read = read$3;
    var settings$3 = {};
    var fs$h = {};
    (function(exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createFileSystemAdapter = exports2.FILE_SYSTEM_ADAPTER = void 0;
      const fs3 = fs__default;
      exports2.FILE_SYSTEM_ADAPTER = {
        lstat: fs3.lstat,
        stat: fs3.stat,
        lstatSync: fs3.lstatSync,
        statSync: fs3.statSync
      };
      function createFileSystemAdapter(fsMethods) {
        if (fsMethods === void 0) {
          return exports2.FILE_SYSTEM_ADAPTER;
        }
        return Object.assign(Object.assign({}, exports2.FILE_SYSTEM_ADAPTER), fsMethods);
      }
      exports2.createFileSystemAdapter = createFileSystemAdapter;
    })(fs$h);
    Object.defineProperty(settings$3, "__esModule", { value: true });
    var fs$g = fs$h;
    var Settings$2 = class {
      constructor(_options = {}) {
        this._options = _options;
        this.followSymbolicLink = this._getValue(this._options.followSymbolicLink, true);
        this.fs = fs$g.createFileSystemAdapter(this._options.fs);
        this.markSymbolicLink = this._getValue(this._options.markSymbolicLink, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
      }
      _getValue(option, value) {
        return option !== null && option !== void 0 ? option : value;
      }
    };
    settings$3.default = Settings$2;
    Object.defineProperty(out$3, "__esModule", { value: true });
    out$3.statSync = out$3.stat = out$3.Settings = void 0;
    var async$4 = async$5;
    var sync$9 = sync$a;
    var settings_1$3 = settings$3;
    out$3.Settings = settings_1$3.default;
    function stat$4(path2, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback === "function") {
        async$4.read(path2, getSettings$2(), optionsOrSettingsOrCallback);
        return;
      }
      async$4.read(path2, getSettings$2(optionsOrSettingsOrCallback), callback);
    }
    out$3.stat = stat$4;
    function statSync(path2, optionsOrSettings) {
      const settings2 = getSettings$2(optionsOrSettings);
      return sync$9.read(path2, settings2);
    }
    out$3.statSync = statSync;
    function getSettings$2(settingsOrOptions = {}) {
      if (settingsOrOptions instanceof settings_1$3.default) {
        return settingsOrOptions;
      }
      return new settings_1$3.default(settingsOrOptions);
    }
    var out$2 = {};
    var async$3 = {};
    var async$2 = {};
    var out$1 = {};
    var async$1 = {};
    var promise;
    var queueMicrotask_1 = typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : commonjsGlobal) : (cb) => (promise || (promise = Promise.resolve())).then(cb).catch((err) => setTimeout(() => {
      throw err;
    }, 0));
    var runParallel_1 = runParallel;
    var queueMicrotask$1 = queueMicrotask_1;
    function runParallel(tasks2, cb) {
      let results, pending, keys;
      let isSync = true;
      if (Array.isArray(tasks2)) {
        results = [];
        pending = tasks2.length;
      } else {
        keys = Object.keys(tasks2);
        results = {};
        pending = keys.length;
      }
      function done(err) {
        function end() {
          if (cb)
            cb(err, results);
          cb = null;
        }
        if (isSync)
          queueMicrotask$1(end);
        else
          end();
      }
      function each(i2, err, result2) {
        results[i2] = result2;
        if (--pending === 0 || err) {
          done(err);
        }
      }
      if (!pending) {
        done(null);
      } else if (keys) {
        keys.forEach(function(key2) {
          tasks2[key2](function(err, result2) {
            each(key2, err, result2);
          });
        });
      } else {
        tasks2.forEach(function(task, i2) {
          task(function(err, result2) {
            each(i2, err, result2);
          });
        });
      }
      isSync = false;
    }
    var constants$5 = {};
    Object.defineProperty(constants$5, "__esModule", { value: true });
    constants$5.IS_SUPPORT_READDIR_WITH_FILE_TYPES = void 0;
    var NODE_PROCESS_VERSION_PARTS = process.versions.node.split(".");
    if (NODE_PROCESS_VERSION_PARTS[0] === void 0 || NODE_PROCESS_VERSION_PARTS[1] === void 0) {
      throw new Error(`Unexpected behavior. The 'process.versions.node' variable has invalid value: ${process.versions.node}`);
    }
    var MAJOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[0], 10);
    var MINOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[1], 10);
    var SUPPORTED_MAJOR_VERSION = 10;
    var SUPPORTED_MINOR_VERSION = 10;
    var IS_MATCHED_BY_MAJOR = MAJOR_VERSION > SUPPORTED_MAJOR_VERSION;
    var IS_MATCHED_BY_MAJOR_AND_MINOR = MAJOR_VERSION === SUPPORTED_MAJOR_VERSION && MINOR_VERSION >= SUPPORTED_MINOR_VERSION;
    constants$5.IS_SUPPORT_READDIR_WITH_FILE_TYPES = IS_MATCHED_BY_MAJOR || IS_MATCHED_BY_MAJOR_AND_MINOR;
    var utils$e = {};
    var fs$f = {};
    Object.defineProperty(fs$f, "__esModule", { value: true });
    fs$f.createDirentFromStats = void 0;
    var DirentFromStats = class {
      constructor(name, stats) {
        this.name = name;
        this.isBlockDevice = stats.isBlockDevice.bind(stats);
        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
        this.isDirectory = stats.isDirectory.bind(stats);
        this.isFIFO = stats.isFIFO.bind(stats);
        this.isFile = stats.isFile.bind(stats);
        this.isSocket = stats.isSocket.bind(stats);
        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
      }
    };
    function createDirentFromStats(name, stats) {
      return new DirentFromStats(name, stats);
    }
    fs$f.createDirentFromStats = createDirentFromStats;
    Object.defineProperty(utils$e, "__esModule", { value: true });
    utils$e.fs = void 0;
    var fs$e = fs$f;
    utils$e.fs = fs$e;
    var common$a = {};
    Object.defineProperty(common$a, "__esModule", { value: true });
    common$a.joinPathSegments = void 0;
    function joinPathSegments$1(a2, b2, separator) {
      if (a2.endsWith(separator)) {
        return a2 + b2;
      }
      return a2 + separator + b2;
    }
    common$a.joinPathSegments = joinPathSegments$1;
    Object.defineProperty(async$1, "__esModule", { value: true });
    async$1.readdir = async$1.readdirWithFileTypes = async$1.read = void 0;
    var fsStat$5 = out$3;
    var rpl = runParallel_1;
    var constants_1$1 = constants$5;
    var utils$d = utils$e;
    var common$9 = common$a;
    function read$2(directory, settings2, callback) {
      if (!settings2.stats && constants_1$1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
        readdirWithFileTypes$1(directory, settings2, callback);
        return;
      }
      readdir$3(directory, settings2, callback);
    }
    async$1.read = read$2;
    function readdirWithFileTypes$1(directory, settings2, callback) {
      settings2.fs.readdir(directory, { withFileTypes: true }, (readdirError, dirents) => {
        if (readdirError !== null) {
          callFailureCallback$1(callback, readdirError);
          return;
        }
        const entries = dirents.map((dirent) => ({
          dirent,
          name: dirent.name,
          path: common$9.joinPathSegments(directory, dirent.name, settings2.pathSegmentSeparator)
        }));
        if (!settings2.followSymbolicLinks) {
          callSuccessCallback$1(callback, entries);
          return;
        }
        const tasks2 = entries.map((entry2) => makeRplTaskEntry(entry2, settings2));
        rpl(tasks2, (rplError, rplEntries) => {
          if (rplError !== null) {
            callFailureCallback$1(callback, rplError);
            return;
          }
          callSuccessCallback$1(callback, rplEntries);
        });
      });
    }
    async$1.readdirWithFileTypes = readdirWithFileTypes$1;
    function makeRplTaskEntry(entry2, settings2) {
      return (done) => {
        if (!entry2.dirent.isSymbolicLink()) {
          done(null, entry2);
          return;
        }
        settings2.fs.stat(entry2.path, (statError, stats) => {
          if (statError !== null) {
            if (settings2.throwErrorOnBrokenSymbolicLink) {
              done(statError);
              return;
            }
            done(null, entry2);
            return;
          }
          entry2.dirent = utils$d.fs.createDirentFromStats(entry2.name, stats);
          done(null, entry2);
        });
      };
    }
    function readdir$3(directory, settings2, callback) {
      settings2.fs.readdir(directory, (readdirError, names) => {
        if (readdirError !== null) {
          callFailureCallback$1(callback, readdirError);
          return;
        }
        const tasks2 = names.map((name) => {
          const path2 = common$9.joinPathSegments(directory, name, settings2.pathSegmentSeparator);
          return (done) => {
            fsStat$5.stat(path2, settings2.fsStatSettings, (error2, stats) => {
              if (error2 !== null) {
                done(error2);
                return;
              }
              const entry2 = {
                name,
                path: path2,
                dirent: utils$d.fs.createDirentFromStats(name, stats)
              };
              if (settings2.stats) {
                entry2.stats = stats;
              }
              done(null, entry2);
            });
          };
        });
        rpl(tasks2, (rplError, entries) => {
          if (rplError !== null) {
            callFailureCallback$1(callback, rplError);
            return;
          }
          callSuccessCallback$1(callback, entries);
        });
      });
    }
    async$1.readdir = readdir$3;
    function callFailureCallback$1(callback, error2) {
      callback(error2);
    }
    function callSuccessCallback$1(callback, result2) {
      callback(null, result2);
    }
    var sync$8 = {};
    Object.defineProperty(sync$8, "__esModule", { value: true });
    sync$8.readdir = sync$8.readdirWithFileTypes = sync$8.read = void 0;
    var fsStat$4 = out$3;
    var constants_1 = constants$5;
    var utils$c = utils$e;
    var common$8 = common$a;
    function read$1(directory, settings2) {
      if (!settings2.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
        return readdirWithFileTypes(directory, settings2);
      }
      return readdir$2(directory, settings2);
    }
    sync$8.read = read$1;
    function readdirWithFileTypes(directory, settings2) {
      const dirents = settings2.fs.readdirSync(directory, { withFileTypes: true });
      return dirents.map((dirent) => {
        const entry2 = {
          dirent,
          name: dirent.name,
          path: common$8.joinPathSegments(directory, dirent.name, settings2.pathSegmentSeparator)
        };
        if (entry2.dirent.isSymbolicLink() && settings2.followSymbolicLinks) {
          try {
            const stats = settings2.fs.statSync(entry2.path);
            entry2.dirent = utils$c.fs.createDirentFromStats(entry2.name, stats);
          } catch (error2) {
            if (settings2.throwErrorOnBrokenSymbolicLink) {
              throw error2;
            }
          }
        }
        return entry2;
      });
    }
    sync$8.readdirWithFileTypes = readdirWithFileTypes;
    function readdir$2(directory, settings2) {
      const names = settings2.fs.readdirSync(directory);
      return names.map((name) => {
        const entryPath = common$8.joinPathSegments(directory, name, settings2.pathSegmentSeparator);
        const stats = fsStat$4.statSync(entryPath, settings2.fsStatSettings);
        const entry2 = {
          name,
          path: entryPath,
          dirent: utils$c.fs.createDirentFromStats(name, stats)
        };
        if (settings2.stats) {
          entry2.stats = stats;
        }
        return entry2;
      });
    }
    sync$8.readdir = readdir$2;
    var settings$2 = {};
    var fs$d = {};
    (function(exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createFileSystemAdapter = exports2.FILE_SYSTEM_ADAPTER = void 0;
      const fs3 = fs__default;
      exports2.FILE_SYSTEM_ADAPTER = {
        lstat: fs3.lstat,
        stat: fs3.stat,
        lstatSync: fs3.lstatSync,
        statSync: fs3.statSync,
        readdir: fs3.readdir,
        readdirSync: fs3.readdirSync
      };
      function createFileSystemAdapter(fsMethods) {
        if (fsMethods === void 0) {
          return exports2.FILE_SYSTEM_ADAPTER;
        }
        return Object.assign(Object.assign({}, exports2.FILE_SYSTEM_ADAPTER), fsMethods);
      }
      exports2.createFileSystemAdapter = createFileSystemAdapter;
    })(fs$d);
    Object.defineProperty(settings$2, "__esModule", { value: true });
    var path$f = path__default;
    var fsStat$3 = out$3;
    var fs$c = fs$d;
    var Settings$1 = class {
      constructor(_options = {}) {
        this._options = _options;
        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, false);
        this.fs = fs$c.createFileSystemAdapter(this._options.fs);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path$f.sep);
        this.stats = this._getValue(this._options.stats, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
        this.fsStatSettings = new fsStat$3.Settings({
          followSymbolicLink: this.followSymbolicLinks,
          fs: this.fs,
          throwErrorOnBrokenSymbolicLink: this.throwErrorOnBrokenSymbolicLink
        });
      }
      _getValue(option, value) {
        return option !== null && option !== void 0 ? option : value;
      }
    };
    settings$2.default = Settings$1;
    Object.defineProperty(out$1, "__esModule", { value: true });
    out$1.Settings = out$1.scandirSync = out$1.scandir = void 0;
    var async = async$1;
    var sync$7 = sync$8;
    var settings_1$2 = settings$2;
    out$1.Settings = settings_1$2.default;
    function scandir(path2, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback === "function") {
        async.read(path2, getSettings$1(), optionsOrSettingsOrCallback);
        return;
      }
      async.read(path2, getSettings$1(optionsOrSettingsOrCallback), callback);
    }
    out$1.scandir = scandir;
    function scandirSync(path2, optionsOrSettings) {
      const settings2 = getSettings$1(optionsOrSettings);
      return sync$7.read(path2, settings2);
    }
    out$1.scandirSync = scandirSync;
    function getSettings$1(settingsOrOptions = {}) {
      if (settingsOrOptions instanceof settings_1$2.default) {
        return settingsOrOptions;
      }
      return new settings_1$2.default(settingsOrOptions);
    }
    var queue = { exports: {} };
    function reusify$1(Constructor) {
      var head = new Constructor();
      var tail = head;
      function get() {
        var current = head;
        if (current.next) {
          head = current.next;
        } else {
          head = new Constructor();
          tail = head;
        }
        current.next = null;
        return current;
      }
      function release(obj) {
        tail.next = obj;
        tail = obj;
      }
      return {
        get,
        release
      };
    }
    var reusify_1 = reusify$1;
    var reusify = reusify_1;
    function fastqueue(context2, worker, concurrency) {
      if (typeof context2 === "function") {
        concurrency = worker;
        worker = context2;
        context2 = null;
      }
      if (concurrency < 1) {
        throw new Error("fastqueue concurrency must be greater than 1");
      }
      var cache2 = reusify(Task);
      var queueHead = null;
      var queueTail = null;
      var _running = 0;
      var errorHandler = null;
      var self2 = {
        push: push2,
        drain: noop$3,
        saturated: noop$3,
        pause,
        paused: false,
        concurrency,
        running,
        resume: resume2,
        idle,
        length,
        getQueue,
        unshift,
        empty: noop$3,
        kill,
        killAndDrain,
        error: error2
      };
      return self2;
      function running() {
        return _running;
      }
      function pause() {
        self2.paused = true;
      }
      function length() {
        var current = queueHead;
        var counter = 0;
        while (current) {
          current = current.next;
          counter++;
        }
        return counter;
      }
      function getQueue() {
        var current = queueHead;
        var tasks2 = [];
        while (current) {
          tasks2.push(current.value);
          current = current.next;
        }
        return tasks2;
      }
      function resume2() {
        if (!self2.paused)
          return;
        self2.paused = false;
        for (var i2 = 0; i2 < self2.concurrency; i2++) {
          _running++;
          release();
        }
      }
      function idle() {
        return _running === 0 && self2.length() === 0;
      }
      function push2(value, done) {
        var current = cache2.get();
        current.context = context2;
        current.release = release;
        current.value = value;
        current.callback = done || noop$3;
        current.errorHandler = errorHandler;
        if (_running === self2.concurrency || self2.paused) {
          if (queueTail) {
            queueTail.next = current;
            queueTail = current;
          } else {
            queueHead = current;
            queueTail = current;
            self2.saturated();
          }
        } else {
          _running++;
          worker.call(context2, current.value, current.worked);
        }
      }
      function unshift(value, done) {
        var current = cache2.get();
        current.context = context2;
        current.release = release;
        current.value = value;
        current.callback = done || noop$3;
        if (_running === self2.concurrency || self2.paused) {
          if (queueHead) {
            current.next = queueHead;
            queueHead = current;
          } else {
            queueHead = current;
            queueTail = current;
            self2.saturated();
          }
        } else {
          _running++;
          worker.call(context2, current.value, current.worked);
        }
      }
      function release(holder) {
        if (holder) {
          cache2.release(holder);
        }
        var next = queueHead;
        if (next) {
          if (!self2.paused) {
            if (queueTail === queueHead) {
              queueTail = null;
            }
            queueHead = next.next;
            next.next = null;
            worker.call(context2, next.value, next.worked);
            if (queueTail === null) {
              self2.empty();
            }
          } else {
            _running--;
          }
        } else if (--_running === 0) {
          self2.drain();
        }
      }
      function kill() {
        queueHead = null;
        queueTail = null;
        self2.drain = noop$3;
      }
      function killAndDrain() {
        queueHead = null;
        queueTail = null;
        self2.drain();
        self2.drain = noop$3;
      }
      function error2(handler) {
        errorHandler = handler;
      }
    }
    function noop$3() {
    }
    function Task() {
      this.value = null;
      this.callback = noop$3;
      this.next = null;
      this.release = noop$3;
      this.context = null;
      this.errorHandler = null;
      var self2 = this;
      this.worked = function worked(err, result2) {
        var callback = self2.callback;
        var errorHandler = self2.errorHandler;
        var val = self2.value;
        self2.value = null;
        self2.callback = noop$3;
        if (self2.errorHandler) {
          errorHandler(err, val);
        }
        callback.call(self2.context, err, result2);
        self2.release(self2);
      };
    }
    function queueAsPromised(context2, worker, concurrency) {
      if (typeof context2 === "function") {
        concurrency = worker;
        worker = context2;
        context2 = null;
      }
      function asyncWrapper(arg, cb) {
        worker.call(this, arg).then(function(res) {
          cb(null, res);
        }, cb);
      }
      var queue2 = fastqueue(context2, asyncWrapper, concurrency);
      var pushCb = queue2.push;
      var unshiftCb = queue2.unshift;
      queue2.push = push2;
      queue2.unshift = unshift;
      queue2.drained = drained;
      return queue2;
      function push2(value) {
        var p2 = new Promise(function(resolve2, reject) {
          pushCb(value, function(err, result2) {
            if (err) {
              reject(err);
              return;
            }
            resolve2(result2);
          });
        });
        p2.catch(noop$3);
        return p2;
      }
      function unshift(value) {
        var p2 = new Promise(function(resolve2, reject) {
          unshiftCb(value, function(err, result2) {
            if (err) {
              reject(err);
              return;
            }
            resolve2(result2);
          });
        });
        p2.catch(noop$3);
        return p2;
      }
      function drained() {
        var previousDrain = queue2.drain;
        var p2 = new Promise(function(resolve2) {
          queue2.drain = function() {
            previousDrain();
            resolve2();
          };
        });
        return p2;
      }
    }
    queue.exports = fastqueue;
    queue.exports.promise = queueAsPromised;
    var common$7 = {};
    Object.defineProperty(common$7, "__esModule", { value: true });
    common$7.joinPathSegments = common$7.replacePathSegmentSeparator = common$7.isAppliedFilter = common$7.isFatalError = void 0;
    function isFatalError(settings2, error2) {
      if (settings2.errorFilter === null) {
        return true;
      }
      return !settings2.errorFilter(error2);
    }
    common$7.isFatalError = isFatalError;
    function isAppliedFilter(filter2, value) {
      return filter2 === null || filter2(value);
    }
    common$7.isAppliedFilter = isAppliedFilter;
    function replacePathSegmentSeparator(filepath, separator) {
      return filepath.split(/[/\\]/).join(separator);
    }
    common$7.replacePathSegmentSeparator = replacePathSegmentSeparator;
    function joinPathSegments(a2, b2, separator) {
      if (a2 === "") {
        return b2;
      }
      if (a2.endsWith(separator)) {
        return a2 + b2;
      }
      return a2 + separator + b2;
    }
    common$7.joinPathSegments = joinPathSegments;
    var reader$1 = {};
    Object.defineProperty(reader$1, "__esModule", { value: true });
    var common$6 = common$7;
    var Reader$1 = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._root = common$6.replacePathSegmentSeparator(_root, _settings.pathSegmentSeparator);
      }
    };
    reader$1.default = Reader$1;
    Object.defineProperty(async$2, "__esModule", { value: true });
    var events_1 = require$$0__default$2;
    var fsScandir$2 = out$1;
    var fastq = queue.exports;
    var common$5 = common$7;
    var reader_1$3 = reader$1;
    var AsyncReader = class extends reader_1$3.default {
      constructor(_root, _settings) {
        super(_root, _settings);
        this._settings = _settings;
        this._scandir = fsScandir$2.scandir;
        this._emitter = new events_1.EventEmitter();
        this._queue = fastq(this._worker.bind(this), this._settings.concurrency);
        this._isFatalError = false;
        this._isDestroyed = false;
        this._queue.drain = () => {
          if (!this._isFatalError) {
            this._emitter.emit("end");
          }
        };
      }
      read() {
        this._isFatalError = false;
        this._isDestroyed = false;
        setImmediate(() => {
          this._pushToQueue(this._root, this._settings.basePath);
        });
        return this._emitter;
      }
      get isDestroyed() {
        return this._isDestroyed;
      }
      destroy() {
        if (this._isDestroyed) {
          throw new Error("The reader is already destroyed");
        }
        this._isDestroyed = true;
        this._queue.killAndDrain();
      }
      onEntry(callback) {
        this._emitter.on("entry", callback);
      }
      onError(callback) {
        this._emitter.once("error", callback);
      }
      onEnd(callback) {
        this._emitter.once("end", callback);
      }
      _pushToQueue(directory, base2) {
        const queueItem = { directory, base: base2 };
        this._queue.push(queueItem, (error2) => {
          if (error2 !== null) {
            this._handleError(error2);
          }
        });
      }
      _worker(item, done) {
        this._scandir(item.directory, this._settings.fsScandirSettings, (error2, entries) => {
          if (error2 !== null) {
            done(error2, void 0);
            return;
          }
          for (const entry2 of entries) {
            this._handleEntry(entry2, item.base);
          }
          done(null, void 0);
        });
      }
      _handleError(error2) {
        if (this._isDestroyed || !common$5.isFatalError(this._settings, error2)) {
          return;
        }
        this._isFatalError = true;
        this._isDestroyed = true;
        this._emitter.emit("error", error2);
      }
      _handleEntry(entry2, base2) {
        if (this._isDestroyed || this._isFatalError) {
          return;
        }
        const fullpath = entry2.path;
        if (base2 !== void 0) {
          entry2.path = common$5.joinPathSegments(base2, entry2.name, this._settings.pathSegmentSeparator);
        }
        if (common$5.isAppliedFilter(this._settings.entryFilter, entry2)) {
          this._emitEntry(entry2);
        }
        if (entry2.dirent.isDirectory() && common$5.isAppliedFilter(this._settings.deepFilter, entry2)) {
          this._pushToQueue(fullpath, base2 === void 0 ? void 0 : entry2.path);
        }
      }
      _emitEntry(entry2) {
        this._emitter.emit("entry", entry2);
      }
    };
    async$2.default = AsyncReader;
    Object.defineProperty(async$3, "__esModule", { value: true });
    var async_1$3 = async$2;
    var AsyncProvider = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new async_1$3.default(this._root, this._settings);
        this._storage = [];
      }
      read(callback) {
        this._reader.onError((error2) => {
          callFailureCallback(callback, error2);
        });
        this._reader.onEntry((entry2) => {
          this._storage.push(entry2);
        });
        this._reader.onEnd(() => {
          callSuccessCallback(callback, this._storage);
        });
        this._reader.read();
      }
    };
    async$3.default = AsyncProvider;
    function callFailureCallback(callback, error2) {
      callback(error2);
    }
    function callSuccessCallback(callback, entries) {
      callback(null, entries);
    }
    var stream$1 = {};
    Object.defineProperty(stream$1, "__esModule", { value: true });
    var stream_1$5 = require$$0__default$3;
    var async_1$2 = async$2;
    var StreamProvider = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new async_1$2.default(this._root, this._settings);
        this._stream = new stream_1$5.Readable({
          objectMode: true,
          read: () => {
          },
          destroy: () => {
            if (!this._reader.isDestroyed) {
              this._reader.destroy();
            }
          }
        });
      }
      read() {
        this._reader.onError((error2) => {
          this._stream.emit("error", error2);
        });
        this._reader.onEntry((entry2) => {
          this._stream.push(entry2);
        });
        this._reader.onEnd(() => {
          this._stream.push(null);
        });
        this._reader.read();
        return this._stream;
      }
    };
    stream$1.default = StreamProvider;
    var sync$6 = {};
    var sync$5 = {};
    Object.defineProperty(sync$5, "__esModule", { value: true });
    var fsScandir$1 = out$1;
    var common$4 = common$7;
    var reader_1$2 = reader$1;
    var SyncReader = class extends reader_1$2.default {
      constructor() {
        super(...arguments);
        this._scandir = fsScandir$1.scandirSync;
        this._storage = [];
        this._queue = /* @__PURE__ */ new Set();
      }
      read() {
        this._pushToQueue(this._root, this._settings.basePath);
        this._handleQueue();
        return this._storage;
      }
      _pushToQueue(directory, base2) {
        this._queue.add({ directory, base: base2 });
      }
      _handleQueue() {
        for (const item of this._queue.values()) {
          this._handleDirectory(item.directory, item.base);
        }
      }
      _handleDirectory(directory, base2) {
        try {
          const entries = this._scandir(directory, this._settings.fsScandirSettings);
          for (const entry2 of entries) {
            this._handleEntry(entry2, base2);
          }
        } catch (error2) {
          this._handleError(error2);
        }
      }
      _handleError(error2) {
        if (!common$4.isFatalError(this._settings, error2)) {
          return;
        }
        throw error2;
      }
      _handleEntry(entry2, base2) {
        const fullpath = entry2.path;
        if (base2 !== void 0) {
          entry2.path = common$4.joinPathSegments(base2, entry2.name, this._settings.pathSegmentSeparator);
        }
        if (common$4.isAppliedFilter(this._settings.entryFilter, entry2)) {
          this._pushToStorage(entry2);
        }
        if (entry2.dirent.isDirectory() && common$4.isAppliedFilter(this._settings.deepFilter, entry2)) {
          this._pushToQueue(fullpath, base2 === void 0 ? void 0 : entry2.path);
        }
      }
      _pushToStorage(entry2) {
        this._storage.push(entry2);
      }
    };
    sync$5.default = SyncReader;
    Object.defineProperty(sync$6, "__esModule", { value: true });
    var sync_1$3 = sync$5;
    var SyncProvider = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new sync_1$3.default(this._root, this._settings);
      }
      read() {
        return this._reader.read();
      }
    };
    sync$6.default = SyncProvider;
    var settings$1 = {};
    Object.defineProperty(settings$1, "__esModule", { value: true });
    var path$e = path__default;
    var fsScandir = out$1;
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.basePath = this._getValue(this._options.basePath, void 0);
        this.concurrency = this._getValue(this._options.concurrency, Number.POSITIVE_INFINITY);
        this.deepFilter = this._getValue(this._options.deepFilter, null);
        this.entryFilter = this._getValue(this._options.entryFilter, null);
        this.errorFilter = this._getValue(this._options.errorFilter, null);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path$e.sep);
        this.fsScandirSettings = new fsScandir.Settings({
          followSymbolicLinks: this._options.followSymbolicLinks,
          fs: this._options.fs,
          pathSegmentSeparator: this._options.pathSegmentSeparator,
          stats: this._options.stats,
          throwErrorOnBrokenSymbolicLink: this._options.throwErrorOnBrokenSymbolicLink
        });
      }
      _getValue(option, value) {
        return option !== null && option !== void 0 ? option : value;
      }
    };
    settings$1.default = Settings;
    Object.defineProperty(out$2, "__esModule", { value: true });
    out$2.Settings = out$2.walkStream = out$2.walkSync = out$2.walk = void 0;
    var async_1$1 = async$3;
    var stream_1$4 = stream$1;
    var sync_1$2 = sync$6;
    var settings_1$1 = settings$1;
    out$2.Settings = settings_1$1.default;
    function walk$1(directory, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback === "function") {
        new async_1$1.default(directory, getSettings()).read(optionsOrSettingsOrCallback);
        return;
      }
      new async_1$1.default(directory, getSettings(optionsOrSettingsOrCallback)).read(callback);
    }
    out$2.walk = walk$1;
    function walkSync(directory, optionsOrSettings) {
      const settings2 = getSettings(optionsOrSettings);
      const provider2 = new sync_1$2.default(directory, settings2);
      return provider2.read();
    }
    out$2.walkSync = walkSync;
    function walkStream(directory, optionsOrSettings) {
      const settings2 = getSettings(optionsOrSettings);
      const provider2 = new stream_1$4.default(directory, settings2);
      return provider2.read();
    }
    out$2.walkStream = walkStream;
    function getSettings(settingsOrOptions = {}) {
      if (settingsOrOptions instanceof settings_1$1.default) {
        return settingsOrOptions;
      }
      return new settings_1$1.default(settingsOrOptions);
    }
    var reader = {};
    Object.defineProperty(reader, "__esModule", { value: true });
    var path$d = path__default;
    var fsStat$2 = out$3;
    var utils$b = utils$l;
    var Reader = class {
      constructor(_settings) {
        this._settings = _settings;
        this._fsStatSettings = new fsStat$2.Settings({
          followSymbolicLink: this._settings.followSymbolicLinks,
          fs: this._settings.fs,
          throwErrorOnBrokenSymbolicLink: this._settings.followSymbolicLinks
        });
      }
      _getFullEntryPath(filepath) {
        return path$d.resolve(this._settings.cwd, filepath);
      }
      _makeEntry(stats, pattern2) {
        const entry2 = {
          name: pattern2,
          path: pattern2,
          dirent: utils$b.fs.createDirentFromStats(pattern2, stats)
        };
        if (this._settings.stats) {
          entry2.stats = stats;
        }
        return entry2;
      }
      _isFatalError(error2) {
        return !utils$b.errno.isEnoentCodeError(error2) && !this._settings.suppressErrors;
      }
    };
    reader.default = Reader;
    Object.defineProperty(stream$2, "__esModule", { value: true });
    var stream_1$3 = require$$0__default$3;
    var fsStat$1 = out$3;
    var fsWalk$1 = out$2;
    var reader_1$1 = reader;
    var ReaderStream = class extends reader_1$1.default {
      constructor() {
        super(...arguments);
        this._walkStream = fsWalk$1.walkStream;
        this._stat = fsStat$1.stat;
      }
      dynamic(root2, options2) {
        return this._walkStream(root2, options2);
      }
      static(patterns2, options2) {
        const filepaths = patterns2.map(this._getFullEntryPath, this);
        const stream2 = new stream_1$3.PassThrough({ objectMode: true });
        stream2._write = (index2, _enc, done) => {
          return this._getEntry(filepaths[index2], patterns2[index2], options2).then((entry2) => {
            if (entry2 !== null && options2.entryFilter(entry2)) {
              stream2.push(entry2);
            }
            if (index2 === filepaths.length - 1) {
              stream2.end();
            }
            done();
          }).catch(done);
        };
        for (let i2 = 0; i2 < filepaths.length; i2++) {
          stream2.write(i2);
        }
        return stream2;
      }
      _getEntry(filepath, pattern2, options2) {
        return this._getStat(filepath).then((stats) => this._makeEntry(stats, pattern2)).catch((error2) => {
          if (options2.errorFilter(error2)) {
            return null;
          }
          throw error2;
        });
      }
      _getStat(filepath) {
        return new Promise((resolve2, reject) => {
          this._stat(filepath, this._fsStatSettings, (error2, stats) => {
            return error2 === null ? resolve2(stats) : reject(error2);
          });
        });
      }
    };
    stream$2.default = ReaderStream;
    var provider = {};
    var deep = {};
    var partial = {};
    var matcher = {};
    Object.defineProperty(matcher, "__esModule", { value: true });
    var utils$a = utils$l;
    var Matcher = class {
      constructor(_patterns, _settings, _micromatchOptions) {
        this._patterns = _patterns;
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
        this._storage = [];
        this._fillStorage();
      }
      _fillStorage() {
        const patterns2 = utils$a.pattern.expandPatternsWithBraceExpansion(this._patterns);
        for (const pattern2 of patterns2) {
          const segments = this._getPatternSegments(pattern2);
          const sections = this._splitSegmentsIntoSections(segments);
          this._storage.push({
            complete: sections.length <= 1,
            pattern: pattern2,
            segments,
            sections
          });
        }
      }
      _getPatternSegments(pattern2) {
        const parts = utils$a.pattern.getPatternParts(pattern2, this._micromatchOptions);
        return parts.map((part) => {
          const dynamic = utils$a.pattern.isDynamicPattern(part, this._settings);
          if (!dynamic) {
            return {
              dynamic: false,
              pattern: part
            };
          }
          return {
            dynamic: true,
            pattern: part,
            patternRe: utils$a.pattern.makeRe(part, this._micromatchOptions)
          };
        });
      }
      _splitSegmentsIntoSections(segments) {
        return utils$a.array.splitWhen(segments, (segment) => segment.dynamic && utils$a.pattern.hasGlobStar(segment.pattern));
      }
    };
    matcher.default = Matcher;
    Object.defineProperty(partial, "__esModule", { value: true });
    var matcher_1 = matcher;
    var PartialMatcher = class extends matcher_1.default {
      match(filepath) {
        const parts = filepath.split("/");
        const levels = parts.length;
        const patterns2 = this._storage.filter((info) => !info.complete || info.segments.length > levels);
        for (const pattern2 of patterns2) {
          const section = pattern2.sections[0];
          if (!pattern2.complete && levels > section.length) {
            return true;
          }
          const match2 = parts.every((part, index2) => {
            const segment = pattern2.segments[index2];
            if (segment.dynamic && segment.patternRe.test(part)) {
              return true;
            }
            if (!segment.dynamic && segment.pattern === part) {
              return true;
            }
            return false;
          });
          if (match2) {
            return true;
          }
        }
        return false;
      }
    };
    partial.default = PartialMatcher;
    Object.defineProperty(deep, "__esModule", { value: true });
    var utils$9 = utils$l;
    var partial_1 = partial;
    var DeepFilter = class {
      constructor(_settings, _micromatchOptions) {
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
      }
      getFilter(basePath, positive, negative) {
        const matcher2 = this._getMatcher(positive);
        const negativeRe = this._getNegativePatternsRe(negative);
        return (entry2) => this._filter(basePath, entry2, matcher2, negativeRe);
      }
      _getMatcher(patterns2) {
        return new partial_1.default(patterns2, this._settings, this._micromatchOptions);
      }
      _getNegativePatternsRe(patterns2) {
        const affectDepthOfReadingPatterns = patterns2.filter(utils$9.pattern.isAffectDepthOfReadingPattern);
        return utils$9.pattern.convertPatternsToRe(affectDepthOfReadingPatterns, this._micromatchOptions);
      }
      _filter(basePath, entry2, matcher2, negativeRe) {
        if (this._isSkippedByDeep(basePath, entry2.path)) {
          return false;
        }
        if (this._isSkippedSymbolicLink(entry2)) {
          return false;
        }
        const filepath = utils$9.path.removeLeadingDotSegment(entry2.path);
        if (this._isSkippedByPositivePatterns(filepath, matcher2)) {
          return false;
        }
        return this._isSkippedByNegativePatterns(filepath, negativeRe);
      }
      _isSkippedByDeep(basePath, entryPath) {
        if (this._settings.deep === Infinity) {
          return false;
        }
        return this._getEntryLevel(basePath, entryPath) >= this._settings.deep;
      }
      _getEntryLevel(basePath, entryPath) {
        const entryPathDepth = entryPath.split("/").length;
        if (basePath === "") {
          return entryPathDepth;
        }
        const basePathDepth = basePath.split("/").length;
        return entryPathDepth - basePathDepth;
      }
      _isSkippedSymbolicLink(entry2) {
        return !this._settings.followSymbolicLinks && entry2.dirent.isSymbolicLink();
      }
      _isSkippedByPositivePatterns(entryPath, matcher2) {
        return !this._settings.baseNameMatch && !matcher2.match(entryPath);
      }
      _isSkippedByNegativePatterns(entryPath, patternsRe) {
        return !utils$9.pattern.matchAny(entryPath, patternsRe);
      }
    };
    deep.default = DeepFilter;
    var entry$1 = {};
    Object.defineProperty(entry$1, "__esModule", { value: true });
    var utils$8 = utils$l;
    var EntryFilter = class {
      constructor(_settings, _micromatchOptions) {
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
        this.index = /* @__PURE__ */ new Map();
      }
      getFilter(positive, negative) {
        const positiveRe = utils$8.pattern.convertPatternsToRe(positive, this._micromatchOptions);
        const negativeRe = utils$8.pattern.convertPatternsToRe(negative, this._micromatchOptions);
        return (entry2) => this._filter(entry2, positiveRe, negativeRe);
      }
      _filter(entry2, positiveRe, negativeRe) {
        if (this._settings.unique && this._isDuplicateEntry(entry2)) {
          return false;
        }
        if (this._onlyFileFilter(entry2) || this._onlyDirectoryFilter(entry2)) {
          return false;
        }
        if (this._isSkippedByAbsoluteNegativePatterns(entry2.path, negativeRe)) {
          return false;
        }
        const filepath = this._settings.baseNameMatch ? entry2.name : entry2.path;
        const isMatched = this._isMatchToPatterns(filepath, positiveRe) && !this._isMatchToPatterns(entry2.path, negativeRe);
        if (this._settings.unique && isMatched) {
          this._createIndexRecord(entry2);
        }
        return isMatched;
      }
      _isDuplicateEntry(entry2) {
        return this.index.has(entry2.path);
      }
      _createIndexRecord(entry2) {
        this.index.set(entry2.path, void 0);
      }
      _onlyFileFilter(entry2) {
        return this._settings.onlyFiles && !entry2.dirent.isFile();
      }
      _onlyDirectoryFilter(entry2) {
        return this._settings.onlyDirectories && !entry2.dirent.isDirectory();
      }
      _isSkippedByAbsoluteNegativePatterns(entryPath, patternsRe) {
        if (!this._settings.absolute) {
          return false;
        }
        const fullpath = utils$8.path.makeAbsolute(this._settings.cwd, entryPath);
        return utils$8.pattern.matchAny(fullpath, patternsRe);
      }
      _isMatchToPatterns(entryPath, patternsRe) {
        const filepath = utils$8.path.removeLeadingDotSegment(entryPath);
        return utils$8.pattern.matchAny(filepath, patternsRe) || utils$8.pattern.matchAny(filepath + "/", patternsRe);
      }
    };
    entry$1.default = EntryFilter;
    var error$3 = {};
    Object.defineProperty(error$3, "__esModule", { value: true });
    var utils$7 = utils$l;
    var ErrorFilter = class {
      constructor(_settings) {
        this._settings = _settings;
      }
      getFilter() {
        return (error2) => this._isNonFatalError(error2);
      }
      _isNonFatalError(error2) {
        return utils$7.errno.isEnoentCodeError(error2) || this._settings.suppressErrors;
      }
    };
    error$3.default = ErrorFilter;
    var entry = {};
    Object.defineProperty(entry, "__esModule", { value: true });
    var utils$6 = utils$l;
    var EntryTransformer = class {
      constructor(_settings) {
        this._settings = _settings;
      }
      getTransformer() {
        return (entry2) => this._transform(entry2);
      }
      _transform(entry2) {
        let filepath = entry2.path;
        if (this._settings.absolute) {
          filepath = utils$6.path.makeAbsolute(this._settings.cwd, filepath);
          filepath = utils$6.path.unixify(filepath);
        }
        if (this._settings.markDirectories && entry2.dirent.isDirectory()) {
          filepath += "/";
        }
        if (!this._settings.objectMode) {
          return filepath;
        }
        return Object.assign(Object.assign({}, entry2), { path: filepath });
      }
    };
    entry.default = EntryTransformer;
    Object.defineProperty(provider, "__esModule", { value: true });
    var path$c = path__default;
    var deep_1 = deep;
    var entry_1 = entry$1;
    var error_1 = error$3;
    var entry_2 = entry;
    var Provider = class {
      constructor(_settings) {
        this._settings = _settings;
        this.errorFilter = new error_1.default(this._settings);
        this.entryFilter = new entry_1.default(this._settings, this._getMicromatchOptions());
        this.deepFilter = new deep_1.default(this._settings, this._getMicromatchOptions());
        this.entryTransformer = new entry_2.default(this._settings);
      }
      _getRootDirectory(task) {
        return path$c.resolve(this._settings.cwd, task.base);
      }
      _getReaderOptions(task) {
        const basePath = task.base === "." ? "" : task.base;
        return {
          basePath,
          pathSegmentSeparator: "/",
          concurrency: this._settings.concurrency,
          deepFilter: this.deepFilter.getFilter(basePath, task.positive, task.negative),
          entryFilter: this.entryFilter.getFilter(task.positive, task.negative),
          errorFilter: this.errorFilter.getFilter(),
          followSymbolicLinks: this._settings.followSymbolicLinks,
          fs: this._settings.fs,
          stats: this._settings.stats,
          throwErrorOnBrokenSymbolicLink: this._settings.throwErrorOnBrokenSymbolicLink,
          transform: this.entryTransformer.getTransformer()
        };
      }
      _getMicromatchOptions() {
        return {
          dot: this._settings.dot,
          matchBase: this._settings.baseNameMatch,
          nobrace: !this._settings.braceExpansion,
          nocase: !this._settings.caseSensitiveMatch,
          noext: !this._settings.extglob,
          noglobstar: !this._settings.globstar,
          posix: true,
          strictSlashes: false
        };
      }
    };
    provider.default = Provider;
    Object.defineProperty(async$6, "__esModule", { value: true });
    var stream_1$2 = stream$2;
    var provider_1$2 = provider;
    var ProviderAsync = class extends provider_1$2.default {
      constructor() {
        super(...arguments);
        this._reader = new stream_1$2.default(this._settings);
      }
      read(task) {
        const root2 = this._getRootDirectory(task);
        const options2 = this._getReaderOptions(task);
        const entries = [];
        return new Promise((resolve2, reject) => {
          const stream2 = this.api(root2, task, options2);
          stream2.once("error", reject);
          stream2.on("data", (entry2) => entries.push(options2.transform(entry2)));
          stream2.once("end", () => resolve2(entries));
        });
      }
      api(root2, task, options2) {
        if (task.dynamic) {
          return this._reader.dynamic(root2, options2);
        }
        return this._reader.static(task.patterns, options2);
      }
    };
    async$6.default = ProviderAsync;
    var stream = {};
    Object.defineProperty(stream, "__esModule", { value: true });
    var stream_1$1 = require$$0__default$3;
    var stream_2 = stream$2;
    var provider_1$1 = provider;
    var ProviderStream = class extends provider_1$1.default {
      constructor() {
        super(...arguments);
        this._reader = new stream_2.default(this._settings);
      }
      read(task) {
        const root2 = this._getRootDirectory(task);
        const options2 = this._getReaderOptions(task);
        const source2 = this.api(root2, task, options2);
        const destination = new stream_1$1.Readable({ objectMode: true, read: () => {
        } });
        source2.once("error", (error2) => destination.emit("error", error2)).on("data", (entry2) => destination.emit("data", options2.transform(entry2))).once("end", () => destination.emit("end"));
        destination.once("close", () => source2.destroy());
        return destination;
      }
      api(root2, task, options2) {
        if (task.dynamic) {
          return this._reader.dynamic(root2, options2);
        }
        return this._reader.static(task.patterns, options2);
      }
    };
    stream.default = ProviderStream;
    var sync$4 = {};
    var sync$3 = {};
    Object.defineProperty(sync$3, "__esModule", { value: true });
    var fsStat = out$3;
    var fsWalk = out$2;
    var reader_1 = reader;
    var ReaderSync = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._walkSync = fsWalk.walkSync;
        this._statSync = fsStat.statSync;
      }
      dynamic(root2, options2) {
        return this._walkSync(root2, options2);
      }
      static(patterns2, options2) {
        const entries = [];
        for (const pattern2 of patterns2) {
          const filepath = this._getFullEntryPath(pattern2);
          const entry2 = this._getEntry(filepath, pattern2, options2);
          if (entry2 === null || !options2.entryFilter(entry2)) {
            continue;
          }
          entries.push(entry2);
        }
        return entries;
      }
      _getEntry(filepath, pattern2, options2) {
        try {
          const stats = this._getStat(filepath);
          return this._makeEntry(stats, pattern2);
        } catch (error2) {
          if (options2.errorFilter(error2)) {
            return null;
          }
          throw error2;
        }
      }
      _getStat(filepath) {
        return this._statSync(filepath, this._fsStatSettings);
      }
    };
    sync$3.default = ReaderSync;
    Object.defineProperty(sync$4, "__esModule", { value: true });
    var sync_1$1 = sync$3;
    var provider_1 = provider;
    var ProviderSync = class extends provider_1.default {
      constructor() {
        super(...arguments);
        this._reader = new sync_1$1.default(this._settings);
      }
      read(task) {
        const root2 = this._getRootDirectory(task);
        const options2 = this._getReaderOptions(task);
        const entries = this.api(root2, task, options2);
        return entries.map(options2.transform);
      }
      api(root2, task, options2) {
        if (task.dynamic) {
          return this._reader.dynamic(root2, options2);
        }
        return this._reader.static(task.patterns, options2);
      }
    };
    sync$4.default = ProviderSync;
    var settings = {};
    (function(exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DEFAULT_FILE_SYSTEM_ADAPTER = void 0;
      const fs3 = fs__default;
      const os3 = require$$1__default;
      const CPU_COUNT = Math.max(os3.cpus().length, 1);
      exports2.DEFAULT_FILE_SYSTEM_ADAPTER = {
        lstat: fs3.lstat,
        lstatSync: fs3.lstatSync,
        stat: fs3.stat,
        statSync: fs3.statSync,
        readdir: fs3.readdir,
        readdirSync: fs3.readdirSync
      };
      class Settings2 {
        constructor(_options = {}) {
          this._options = _options;
          this.absolute = this._getValue(this._options.absolute, false);
          this.baseNameMatch = this._getValue(this._options.baseNameMatch, false);
          this.braceExpansion = this._getValue(this._options.braceExpansion, true);
          this.caseSensitiveMatch = this._getValue(this._options.caseSensitiveMatch, true);
          this.concurrency = this._getValue(this._options.concurrency, CPU_COUNT);
          this.cwd = this._getValue(this._options.cwd, process.cwd());
          this.deep = this._getValue(this._options.deep, Infinity);
          this.dot = this._getValue(this._options.dot, false);
          this.extglob = this._getValue(this._options.extglob, true);
          this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, true);
          this.fs = this._getFileSystemMethods(this._options.fs);
          this.globstar = this._getValue(this._options.globstar, true);
          this.ignore = this._getValue(this._options.ignore, []);
          this.markDirectories = this._getValue(this._options.markDirectories, false);
          this.objectMode = this._getValue(this._options.objectMode, false);
          this.onlyDirectories = this._getValue(this._options.onlyDirectories, false);
          this.onlyFiles = this._getValue(this._options.onlyFiles, true);
          this.stats = this._getValue(this._options.stats, false);
          this.suppressErrors = this._getValue(this._options.suppressErrors, false);
          this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, false);
          this.unique = this._getValue(this._options.unique, true);
          if (this.onlyDirectories) {
            this.onlyFiles = false;
          }
          if (this.stats) {
            this.objectMode = true;
          }
        }
        _getValue(option, value) {
          return option === void 0 ? value : option;
        }
        _getFileSystemMethods(methods = {}) {
          return Object.assign(Object.assign({}, exports2.DEFAULT_FILE_SYSTEM_ADAPTER), methods);
        }
      }
      exports2.default = Settings2;
    })(settings);
    var taskManager = tasks;
    var patternManager = patterns;
    var async_1 = async$6;
    var stream_1 = stream;
    var sync_1 = sync$4;
    var settings_1 = settings;
    var utils$5 = utils$l;
    async function FastGlob(source2, options2) {
      assertPatternsInput(source2);
      const works = getWorks(source2, async_1.default, options2);
      const result2 = await Promise.all(works);
      return utils$5.array.flatten(result2);
    }
    (function(FastGlob2) {
      function sync2(source2, options2) {
        assertPatternsInput(source2);
        const works = getWorks(source2, sync_1.default, options2);
        return utils$5.array.flatten(works);
      }
      FastGlob2.sync = sync2;
      function stream2(source2, options2) {
        assertPatternsInput(source2);
        const works = getWorks(source2, stream_1.default, options2);
        return utils$5.stream.merge(works);
      }
      FastGlob2.stream = stream2;
      function generateTasks(source2, options2) {
        assertPatternsInput(source2);
        const patterns2 = patternManager.transform([].concat(source2));
        const settings2 = new settings_1.default(options2);
        return taskManager.generate(patterns2, settings2);
      }
      FastGlob2.generateTasks = generateTasks;
      function isDynamicPattern2(source2, options2) {
        assertPatternsInput(source2);
        const settings2 = new settings_1.default(options2);
        return utils$5.pattern.isDynamicPattern(source2, settings2);
      }
      FastGlob2.isDynamicPattern = isDynamicPattern2;
      function escapePath(source2) {
        assertPatternsInput(source2);
        return utils$5.path.escape(source2);
      }
      FastGlob2.escapePath = escapePath;
    })(FastGlob || (FastGlob = {}));
    function getWorks(source2, _Provider, options2) {
      const patterns2 = patternManager.transform([].concat(source2));
      const settings2 = new settings_1.default(options2);
      const tasks2 = taskManager.generate(patterns2, settings2);
      const provider2 = new _Provider(settings2);
      return tasks2.map(provider2.read, provider2);
    }
    function assertPatternsInput(input) {
      const source2 = [].concat(input);
      const isValidSource = source2.every((item) => utils$5.string.isString(item) && !utils$5.string.isEmpty(item));
      if (!isValidSource) {
        throw new TypeError("Patterns must be a string (non empty) or an array of strings");
      }
    }
    var out = FastGlob;
    var VariableDynamicImportError = class extends Error {
    };
    var example = "For example: import(`./foo/${bar}.js`).";
    function sanitizeString(str) {
      if (str.includes("*")) {
        throw new VariableDynamicImportError("A dynamic import cannot contain * characters.");
      }
      return str;
    }
    function templateLiteralToGlob(node2) {
      let glob2 = "";
      for (let i2 = 0; i2 < node2.quasis.length; i2 += 1) {
        glob2 += sanitizeString(node2.quasis[i2].value.raw);
        if (node2.expressions[i2]) {
          glob2 += expressionToGlob(node2.expressions[i2]);
        }
      }
      return glob2;
    }
    function callExpressionToGlob(node2) {
      const { callee } = node2;
      if (callee.type === "MemberExpression" && callee.property.type === "Identifier" && callee.property.name === "concat") {
        return `${expressionToGlob(callee.object)}${node2.arguments.map(expressionToGlob).join("")}`;
      }
      return "*";
    }
    function binaryExpressionToGlob(node2) {
      if (node2.operator !== "+") {
        throw new VariableDynamicImportError(`${node2.operator} operator is not supported.`);
      }
      return `${expressionToGlob(node2.left)}${expressionToGlob(node2.right)}`;
    }
    function expressionToGlob(node2) {
      switch (node2.type) {
        case "TemplateLiteral":
          return templateLiteralToGlob(node2);
        case "CallExpression":
          return callExpressionToGlob(node2);
        case "BinaryExpression":
          return binaryExpressionToGlob(node2);
        case "Literal": {
          return sanitizeString(node2.value);
        }
        default:
          return "*";
      }
    }
    function dynamicImportToGlob(node2, sourceString) {
      let glob2 = expressionToGlob(node2);
      if (!glob2.includes("*") || glob2.startsWith("data:")) {
        return null;
      }
      glob2 = glob2.replace(/\*\*/g, "*");
      if (glob2.startsWith("*")) {
        throw new VariableDynamicImportError(`invalid import "${sourceString}". It cannot be statically analyzed. Variable dynamic imports must start with ./ and be limited to a specific directory. ${example}`);
      }
      if (glob2.startsWith("/")) {
        throw new VariableDynamicImportError(`invalid import "${sourceString}". Variable absolute imports are not supported, imports must start with ./ in the static part of the import. ${example}`);
      }
      if (!glob2.startsWith("./") && !glob2.startsWith("../")) {
        throw new VariableDynamicImportError(`invalid import "${sourceString}". Variable bare imports are not supported, imports must start with ./ in the static part of the import. ${example}`);
      }
      const ownDirectoryStarExtension = /^\.\/\*\.[\w]+$/;
      if (ownDirectoryStarExtension.test(glob2)) {
        throw new VariableDynamicImportError(`${`invalid import "${sourceString}". Variable imports cannot import their own directory, place imports in a separate directory or make the import filename more specific. `}${example}`);
      }
      if (path__default.extname(glob2) === "") {
        throw new VariableDynamicImportError(`invalid import "${sourceString}". A file extension must be included in the static part of the import. ${example}`);
      }
      return glob2;
    }
    function dynamicImportVariables({ include, exclude, warnOnError } = {}) {
      const filter2 = createFilter$1(include, exclude);
      return {
        name: "rollup-plugin-dynamic-import-variables",
        transform(code, id) {
          if (!filter2(id)) {
            return null;
          }
          const parsed = this.parse(code);
          let dynamicImportIndex = -1;
          let ms3;
          walk$2(parsed, {
            enter: (node2) => {
              if (node2.type !== "ImportExpression") {
                return;
              }
              dynamicImportIndex += 1;
              try {
                const glob2 = dynamicImportToGlob(node2.source, code.substring(node2.start, node2.end));
                if (!glob2) {
                  return;
                }
                const result2 = out.sync(glob2, { cwd: path__default.dirname(id) });
                const paths = result2.map((r2) => r2.startsWith("./") || r2.startsWith("../") ? r2 : `./${r2}`);
                ms3 = ms3 || new MagicString$1(code);
                ms3.prepend(`function __variableDynamicImportRuntime${dynamicImportIndex}__(path) {
  switch (path) {
${paths.map((p2) => `    case '${p2}': return import('${p2}');`).join("\n")}
${`    default: return new Promise(function(resolve, reject) {
      (typeof queueMicrotask === 'function' ? queueMicrotask : setTimeout)(
        reject.bind(null, new Error("Unknown variable dynamic import: " + path))
      );
    })
`}   }
 }

`);
                ms3.overwrite(node2.start, node2.start + 6, `__variableDynamicImportRuntime${dynamicImportIndex}__`);
              } catch (error2) {
                if (error2 instanceof VariableDynamicImportError) {
                  if (warnOnError) {
                    this.warn(error2);
                  } else {
                    this.error(error2);
                  }
                } else {
                  this.error(error2);
                }
              }
            }
          });
          if (ms3 && dynamicImportIndex !== -1) {
            return {
              code: ms3.toString(),
              map: ms3.generateMap({
                file: id,
                includeContent: true,
                hires: true
              })
            };
          }
          return null;
        }
      };
    }
    var dataUriRE = /^([^/]+\/[^;,]+)(;base64)?,([\s\S]*)$/;
    var dataUriPrefix = `/@data-uri/`;
    function dataURIPlugin() {
      let resolved;
      return {
        name: "vite:data-uri",
        buildStart() {
          resolved = {};
        },
        resolveId(id) {
          if (!dataUriRE.test(id)) {
            return null;
          }
          const uri = new require$$0$4.URL(id);
          if (uri.protocol !== "data:") {
            return null;
          }
          const match2 = uri.pathname.match(dataUriRE);
          if (!match2) {
            return null;
          }
          const [, mime, format2, data2] = match2;
          if (mime !== "text/javascript") {
            throw new Error(`data URI with non-JavaScript mime type is not supported.`);
          }
          const base64 = format2 && /base64/i.test(format2.substring(1));
          const content2 = base64 ? Buffer.from(data2, "base64").toString("utf-8") : data2;
          resolved[id] = content2;
          return dataUriPrefix + id;
        },
        load(id) {
          if (id.startsWith(dataUriPrefix)) {
            id = id.slice(dataUriPrefix.length);
            return resolved[id] || null;
          }
        }
      };
    }
    var BitSet = class {
      constructor(arg) {
        this.bits = arg instanceof BitSet ? arg.bits.slice() : [];
      }
      add(n3) {
        this.bits[n3 >> 5] |= 1 << (n3 & 31);
      }
      has(n3) {
        return !!(this.bits[n3 >> 5] & 1 << (n3 & 31));
      }
    };
    var Chunk = class {
      constructor(start, end, content2) {
        this.start = start;
        this.end = end;
        this.original = content2;
        this.intro = "";
        this.outro = "";
        this.content = content2;
        this.storeName = false;
        this.edited = false;
        Object.defineProperties(this, {
          previous: { writable: true, value: null },
          next: { writable: true, value: null }
        });
      }
      appendLeft(content2) {
        this.outro += content2;
      }
      appendRight(content2) {
        this.intro = this.intro + content2;
      }
      clone() {
        const chunk = new Chunk(this.start, this.end, this.original);
        chunk.intro = this.intro;
        chunk.outro = this.outro;
        chunk.content = this.content;
        chunk.storeName = this.storeName;
        chunk.edited = this.edited;
        return chunk;
      }
      contains(index2) {
        return this.start < index2 && index2 < this.end;
      }
      eachNext(fn2) {
        let chunk = this;
        while (chunk) {
          fn2(chunk);
          chunk = chunk.next;
        }
      }
      eachPrevious(fn2) {
        let chunk = this;
        while (chunk) {
          fn2(chunk);
          chunk = chunk.previous;
        }
      }
      edit(content2, storeName, contentOnly) {
        this.content = content2;
        if (!contentOnly) {
          this.intro = "";
          this.outro = "";
        }
        this.storeName = storeName;
        this.edited = true;
        return this;
      }
      prependLeft(content2) {
        this.outro = content2 + this.outro;
      }
      prependRight(content2) {
        this.intro = content2 + this.intro;
      }
      split(index2) {
        const sliceIndex = index2 - this.start;
        const originalBefore = this.original.slice(0, sliceIndex);
        const originalAfter = this.original.slice(sliceIndex);
        this.original = originalBefore;
        const newChunk = new Chunk(index2, this.end, originalAfter);
        newChunk.outro = this.outro;
        this.outro = "";
        this.end = index2;
        if (this.edited) {
          newChunk.edit("", false);
          this.content = "";
        } else {
          this.content = originalBefore;
        }
        newChunk.next = this.next;
        if (newChunk.next)
          newChunk.next.previous = newChunk;
        newChunk.previous = this;
        this.next = newChunk;
        return newChunk;
      }
      toString() {
        return this.intro + this.content + this.outro;
      }
      trimEnd(rx) {
        this.outro = this.outro.replace(rx, "");
        if (this.outro.length)
          return true;
        const trimmed = this.content.replace(rx, "");
        if (trimmed.length) {
          if (trimmed !== this.content) {
            this.split(this.start + trimmed.length).edit("", void 0, true);
          }
          return true;
        } else {
          this.edit("", void 0, true);
          this.intro = this.intro.replace(rx, "");
          if (this.intro.length)
            return true;
        }
      }
      trimStart(rx) {
        this.intro = this.intro.replace(rx, "");
        if (this.intro.length)
          return true;
        const trimmed = this.content.replace(rx, "");
        if (trimmed.length) {
          if (trimmed !== this.content) {
            this.split(this.end - trimmed.length);
            this.edit("", void 0, true);
          }
          return true;
        } else {
          this.edit("", void 0, true);
          this.outro = this.outro.replace(rx, "");
          if (this.outro.length)
            return true;
        }
      }
    };
    var btoa$1 = () => {
      throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.");
    };
    if (typeof window !== "undefined" && typeof window.btoa === "function") {
      btoa$1 = (str) => window.btoa(unescape(encodeURIComponent(str)));
    } else if (typeof Buffer === "function") {
      btoa$1 = (str) => Buffer.from(str, "utf-8").toString("base64");
    }
    var SourceMap = class {
      constructor(properties) {
        this.version = 3;
        this.file = properties.file;
        this.sources = properties.sources;
        this.sourcesContent = properties.sourcesContent;
        this.names = properties.names;
        this.mappings = encode(properties.mappings);
      }
      toString() {
        return JSON.stringify(this);
      }
      toUrl() {
        return "data:application/json;charset=utf-8;base64," + btoa$1(this.toString());
      }
    };
    function guessIndent(code) {
      const lines = code.split("\n");
      const tabbed = lines.filter((line2) => /^\t+/.test(line2));
      const spaced = lines.filter((line2) => /^ {2,}/.test(line2));
      if (tabbed.length === 0 && spaced.length === 0) {
        return null;
      }
      if (tabbed.length >= spaced.length) {
        return "	";
      }
      const min2 = spaced.reduce((previous, current) => {
        const numSpaces = /^ +/.exec(current)[0].length;
        return Math.min(numSpaces, previous);
      }, Infinity);
      return new Array(min2 + 1).join(" ");
    }
    function getRelativePath(from, to2) {
      const fromParts = from.split(/[/\\]/);
      const toParts = to2.split(/[/\\]/);
      fromParts.pop();
      while (fromParts[0] === toParts[0]) {
        fromParts.shift();
        toParts.shift();
      }
      if (fromParts.length) {
        let i2 = fromParts.length;
        while (i2--)
          fromParts[i2] = "..";
      }
      return fromParts.concat(toParts).join("/");
    }
    var toString$2 = Object.prototype.toString;
    function isObject$1(thing) {
      return toString$2.call(thing) === "[object Object]";
    }
    function getLocator(source2) {
      const originalLines = source2.split("\n");
      const lineOffsets = [];
      for (let i2 = 0, pos2 = 0; i2 < originalLines.length; i2++) {
        lineOffsets.push(pos2);
        pos2 += originalLines[i2].length + 1;
      }
      return function locate(index2) {
        let i2 = 0;
        let j2 = lineOffsets.length;
        while (i2 < j2) {
          const m3 = i2 + j2 >> 1;
          if (index2 < lineOffsets[m3]) {
            j2 = m3;
          } else {
            i2 = m3 + 1;
          }
        }
        const line2 = i2 - 1;
        const column2 = index2 - lineOffsets[line2];
        return { line: line2, column: column2 };
      };
    }
    var Mappings = class {
      constructor(hires) {
        this.hires = hires;
        this.generatedCodeLine = 0;
        this.generatedCodeColumn = 0;
        this.raw = [];
        this.rawSegments = this.raw[this.generatedCodeLine] = [];
        this.pending = null;
      }
      addEdit(sourceIndex, content2, loc, nameIndex) {
        if (content2.length) {
          const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
          if (nameIndex >= 0) {
            segment.push(nameIndex);
          }
          this.rawSegments.push(segment);
        } else if (this.pending) {
          this.rawSegments.push(this.pending);
        }
        this.advance(content2);
        this.pending = null;
      }
      addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {
        let originalCharIndex = chunk.start;
        let first2 = true;
        while (originalCharIndex < chunk.end) {
          if (this.hires || first2 || sourcemapLocations.has(originalCharIndex)) {
            this.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);
          }
          if (original[originalCharIndex] === "\n") {
            loc.line += 1;
            loc.column = 0;
            this.generatedCodeLine += 1;
            this.raw[this.generatedCodeLine] = this.rawSegments = [];
            this.generatedCodeColumn = 0;
            first2 = true;
          } else {
            loc.column += 1;
            this.generatedCodeColumn += 1;
            first2 = false;
          }
          originalCharIndex += 1;
        }
        this.pending = null;
      }
      advance(str) {
        if (!str)
          return;
        const lines = str.split("\n");
        if (lines.length > 1) {
          for (let i2 = 0; i2 < lines.length - 1; i2++) {
            this.generatedCodeLine++;
            this.raw[this.generatedCodeLine] = this.rawSegments = [];
          }
          this.generatedCodeColumn = 0;
        }
        this.generatedCodeColumn += lines[lines.length - 1].length;
      }
    };
    var n = "\n";
    var warned$1 = {
      insertLeft: false,
      insertRight: false,
      storeName: false
    };
    var MagicString = class {
      constructor(string2, options2 = {}) {
        const chunk = new Chunk(0, string2.length, string2);
        Object.defineProperties(this, {
          original: { writable: true, value: string2 },
          outro: { writable: true, value: "" },
          intro: { writable: true, value: "" },
          firstChunk: { writable: true, value: chunk },
          lastChunk: { writable: true, value: chunk },
          lastSearchedChunk: { writable: true, value: chunk },
          byStart: { writable: true, value: {} },
          byEnd: { writable: true, value: {} },
          filename: { writable: true, value: options2.filename },
          indentExclusionRanges: { writable: true, value: options2.indentExclusionRanges },
          sourcemapLocations: { writable: true, value: new BitSet() },
          storedNames: { writable: true, value: {} },
          indentStr: { writable: true, value: guessIndent(string2) }
        });
        this.byStart[0] = chunk;
        this.byEnd[string2.length] = chunk;
      }
      addSourcemapLocation(char) {
        this.sourcemapLocations.add(char);
      }
      append(content2) {
        if (typeof content2 !== "string")
          throw new TypeError("outro content must be a string");
        this.outro += content2;
        return this;
      }
      appendLeft(index2, content2) {
        if (typeof content2 !== "string")
          throw new TypeError("inserted content must be a string");
        this._split(index2);
        const chunk = this.byEnd[index2];
        if (chunk) {
          chunk.appendLeft(content2);
        } else {
          this.intro += content2;
        }
        return this;
      }
      appendRight(index2, content2) {
        if (typeof content2 !== "string")
          throw new TypeError("inserted content must be a string");
        this._split(index2);
        const chunk = this.byStart[index2];
        if (chunk) {
          chunk.appendRight(content2);
        } else {
          this.outro += content2;
        }
        return this;
      }
      clone() {
        const cloned = new MagicString(this.original, { filename: this.filename });
        let originalChunk = this.firstChunk;
        let clonedChunk = cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone();
        while (originalChunk) {
          cloned.byStart[clonedChunk.start] = clonedChunk;
          cloned.byEnd[clonedChunk.end] = clonedChunk;
          const nextOriginalChunk = originalChunk.next;
          const nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();
          if (nextClonedChunk) {
            clonedChunk.next = nextClonedChunk;
            nextClonedChunk.previous = clonedChunk;
            clonedChunk = nextClonedChunk;
          }
          originalChunk = nextOriginalChunk;
        }
        cloned.lastChunk = clonedChunk;
        if (this.indentExclusionRanges) {
          cloned.indentExclusionRanges = this.indentExclusionRanges.slice();
        }
        cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);
        cloned.intro = this.intro;
        cloned.outro = this.outro;
        return cloned;
      }
      generateDecodedMap(options2) {
        options2 = options2 || {};
        const sourceIndex = 0;
        const names = Object.keys(this.storedNames);
        const mappings = new Mappings(options2.hires);
        const locate = getLocator(this.original);
        if (this.intro) {
          mappings.advance(this.intro);
        }
        this.firstChunk.eachNext((chunk) => {
          const loc = locate(chunk.start);
          if (chunk.intro.length)
            mappings.advance(chunk.intro);
          if (chunk.edited) {
            mappings.addEdit(sourceIndex, chunk.content, loc, chunk.storeName ? names.indexOf(chunk.original) : -1);
          } else {
            mappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);
          }
          if (chunk.outro.length)
            mappings.advance(chunk.outro);
        });
        return {
          file: options2.file ? options2.file.split(/[/\\]/).pop() : null,
          sources: [options2.source ? getRelativePath(options2.file || "", options2.source) : null],
          sourcesContent: options2.includeContent ? [this.original] : [null],
          names,
          mappings: mappings.raw
        };
      }
      generateMap(options2) {
        return new SourceMap(this.generateDecodedMap(options2));
      }
      getIndentString() {
        return this.indentStr === null ? "	" : this.indentStr;
      }
      indent(indentStr, options2) {
        const pattern2 = /^[^\r\n]/gm;
        if (isObject$1(indentStr)) {
          options2 = indentStr;
          indentStr = void 0;
        }
        indentStr = indentStr !== void 0 ? indentStr : this.indentStr || "	";
        if (indentStr === "")
          return this;
        options2 = options2 || {};
        const isExcluded = {};
        if (options2.exclude) {
          const exclusions = typeof options2.exclude[0] === "number" ? [options2.exclude] : options2.exclude;
          exclusions.forEach((exclusion) => {
            for (let i2 = exclusion[0]; i2 < exclusion[1]; i2 += 1) {
              isExcluded[i2] = true;
            }
          });
        }
        let shouldIndentNextCharacter = options2.indentStart !== false;
        const replacer = (match2) => {
          if (shouldIndentNextCharacter)
            return `${indentStr}${match2}`;
          shouldIndentNextCharacter = true;
          return match2;
        };
        this.intro = this.intro.replace(pattern2, replacer);
        let charIndex = 0;
        let chunk = this.firstChunk;
        while (chunk) {
          const end = chunk.end;
          if (chunk.edited) {
            if (!isExcluded[charIndex]) {
              chunk.content = chunk.content.replace(pattern2, replacer);
              if (chunk.content.length) {
                shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === "\n";
              }
            }
          } else {
            charIndex = chunk.start;
            while (charIndex < end) {
              if (!isExcluded[charIndex]) {
                const char = this.original[charIndex];
                if (char === "\n") {
                  shouldIndentNextCharacter = true;
                } else if (char !== "\r" && shouldIndentNextCharacter) {
                  shouldIndentNextCharacter = false;
                  if (charIndex === chunk.start) {
                    chunk.prependRight(indentStr);
                  } else {
                    this._splitChunk(chunk, charIndex);
                    chunk = chunk.next;
                    chunk.prependRight(indentStr);
                  }
                }
              }
              charIndex += 1;
            }
          }
          charIndex = chunk.end;
          chunk = chunk.next;
        }
        this.outro = this.outro.replace(pattern2, replacer);
        return this;
      }
      insert() {
        throw new Error("magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)");
      }
      insertLeft(index2, content2) {
        if (!warned$1.insertLeft) {
          console.warn("magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead");
          warned$1.insertLeft = true;
        }
        return this.appendLeft(index2, content2);
      }
      insertRight(index2, content2) {
        if (!warned$1.insertRight) {
          console.warn("magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead");
          warned$1.insertRight = true;
        }
        return this.prependRight(index2, content2);
      }
      move(start, end, index2) {
        if (index2 >= start && index2 <= end)
          throw new Error("Cannot move a selection inside itself");
        this._split(start);
        this._split(end);
        this._split(index2);
        const first2 = this.byStart[start];
        const last = this.byEnd[end];
        const oldLeft = first2.previous;
        const oldRight = last.next;
        const newRight = this.byStart[index2];
        if (!newRight && last === this.lastChunk)
          return this;
        const newLeft = newRight ? newRight.previous : this.lastChunk;
        if (oldLeft)
          oldLeft.next = oldRight;
        if (oldRight)
          oldRight.previous = oldLeft;
        if (newLeft)
          newLeft.next = first2;
        if (newRight)
          newRight.previous = last;
        if (!first2.previous)
          this.firstChunk = last.next;
        if (!last.next) {
          this.lastChunk = first2.previous;
          this.lastChunk.next = null;
        }
        first2.previous = newLeft;
        last.next = newRight || null;
        if (!newLeft)
          this.firstChunk = first2;
        if (!newRight)
          this.lastChunk = last;
        return this;
      }
      overwrite(start, end, content2, options2) {
        if (typeof content2 !== "string")
          throw new TypeError("replacement content must be a string");
        while (start < 0)
          start += this.original.length;
        while (end < 0)
          end += this.original.length;
        if (end > this.original.length)
          throw new Error("end is out of bounds");
        if (start === end)
          throw new Error("Cannot overwrite a zero-length range \u2013 use appendLeft or prependRight instead");
        this._split(start);
        this._split(end);
        if (options2 === true) {
          if (!warned$1.storeName) {
            console.warn("The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string");
            warned$1.storeName = true;
          }
          options2 = { storeName: true };
        }
        const storeName = options2 !== void 0 ? options2.storeName : false;
        const contentOnly = options2 !== void 0 ? options2.contentOnly : false;
        if (storeName) {
          const original = this.original.slice(start, end);
          Object.defineProperty(this.storedNames, original, {
            writable: true,
            value: true,
            enumerable: true
          });
        }
        const first2 = this.byStart[start];
        const last = this.byEnd[end];
        if (first2) {
          let chunk = first2;
          while (chunk !== last) {
            if (chunk.next !== this.byStart[chunk.end]) {
              throw new Error("Cannot overwrite across a split point");
            }
            chunk = chunk.next;
            chunk.edit("", false);
          }
          first2.edit(content2, storeName, contentOnly);
        } else {
          const newChunk = new Chunk(start, end, "").edit(content2, storeName);
          last.next = newChunk;
          newChunk.previous = last;
        }
        return this;
      }
      prepend(content2) {
        if (typeof content2 !== "string")
          throw new TypeError("outro content must be a string");
        this.intro = content2 + this.intro;
        return this;
      }
      prependLeft(index2, content2) {
        if (typeof content2 !== "string")
          throw new TypeError("inserted content must be a string");
        this._split(index2);
        const chunk = this.byEnd[index2];
        if (chunk) {
          chunk.prependLeft(content2);
        } else {
          this.intro = content2 + this.intro;
        }
        return this;
      }
      prependRight(index2, content2) {
        if (typeof content2 !== "string")
          throw new TypeError("inserted content must be a string");
        this._split(index2);
        const chunk = this.byStart[index2];
        if (chunk) {
          chunk.prependRight(content2);
        } else {
          this.outro = content2 + this.outro;
        }
        return this;
      }
      remove(start, end) {
        while (start < 0)
          start += this.original.length;
        while (end < 0)
          end += this.original.length;
        if (start === end)
          return this;
        if (start < 0 || end > this.original.length)
          throw new Error("Character is out of bounds");
        if (start > end)
          throw new Error("end must be greater than start");
        this._split(start);
        this._split(end);
        let chunk = this.byStart[start];
        while (chunk) {
          chunk.intro = "";
          chunk.outro = "";
          chunk.edit("");
          chunk = end > chunk.end ? this.byStart[chunk.end] : null;
        }
        return this;
      }
      lastChar() {
        if (this.outro.length)
          return this.outro[this.outro.length - 1];
        let chunk = this.lastChunk;
        do {
          if (chunk.outro.length)
            return chunk.outro[chunk.outro.length - 1];
          if (chunk.content.length)
            return chunk.content[chunk.content.length - 1];
          if (chunk.intro.length)
            return chunk.intro[chunk.intro.length - 1];
        } while (chunk = chunk.previous);
        if (this.intro.length)
          return this.intro[this.intro.length - 1];
        return "";
      }
      lastLine() {
        let lineIndex = this.outro.lastIndexOf(n);
        if (lineIndex !== -1)
          return this.outro.substr(lineIndex + 1);
        let lineStr = this.outro;
        let chunk = this.lastChunk;
        do {
          if (chunk.outro.length > 0) {
            lineIndex = chunk.outro.lastIndexOf(n);
            if (lineIndex !== -1)
              return chunk.outro.substr(lineIndex + 1) + lineStr;
            lineStr = chunk.outro + lineStr;
          }
          if (chunk.content.length > 0) {
            lineIndex = chunk.content.lastIndexOf(n);
            if (lineIndex !== -1)
              return chunk.content.substr(lineIndex + 1) + lineStr;
            lineStr = chunk.content + lineStr;
          }
          if (chunk.intro.length > 0) {
            lineIndex = chunk.intro.lastIndexOf(n);
            if (lineIndex !== -1)
              return chunk.intro.substr(lineIndex + 1) + lineStr;
            lineStr = chunk.intro + lineStr;
          }
        } while (chunk = chunk.previous);
        lineIndex = this.intro.lastIndexOf(n);
        if (lineIndex !== -1)
          return this.intro.substr(lineIndex + 1) + lineStr;
        return this.intro + lineStr;
      }
      slice(start = 0, end = this.original.length) {
        while (start < 0)
          start += this.original.length;
        while (end < 0)
          end += this.original.length;
        let result2 = "";
        let chunk = this.firstChunk;
        while (chunk && (chunk.start > start || chunk.end <= start)) {
          if (chunk.start < end && chunk.end >= end) {
            return result2;
          }
          chunk = chunk.next;
        }
        if (chunk && chunk.edited && chunk.start !== start)
          throw new Error(`Cannot use replaced character ${start} as slice start anchor.`);
        const startChunk = chunk;
        while (chunk) {
          if (chunk.intro && (startChunk !== chunk || chunk.start === start)) {
            result2 += chunk.intro;
          }
          const containsEnd = chunk.start < end && chunk.end >= end;
          if (containsEnd && chunk.edited && chunk.end !== end)
            throw new Error(`Cannot use replaced character ${end} as slice end anchor.`);
          const sliceStart = startChunk === chunk ? start - chunk.start : 0;
          const sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;
          result2 += chunk.content.slice(sliceStart, sliceEnd);
          if (chunk.outro && (!containsEnd || chunk.end === end)) {
            result2 += chunk.outro;
          }
          if (containsEnd) {
            break;
          }
          chunk = chunk.next;
        }
        return result2;
      }
      snip(start, end) {
        const clone = this.clone();
        clone.remove(0, start);
        clone.remove(end, clone.original.length);
        return clone;
      }
      _split(index2) {
        if (this.byStart[index2] || this.byEnd[index2])
          return;
        let chunk = this.lastSearchedChunk;
        const searchForward = index2 > chunk.end;
        while (chunk) {
          if (chunk.contains(index2))
            return this._splitChunk(chunk, index2);
          chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];
        }
      }
      _splitChunk(chunk, index2) {
        if (chunk.edited && chunk.content.length) {
          const loc = getLocator(this.original)(index2);
          throw new Error(`Cannot split a chunk that has already been edited (${loc.line}:${loc.column} \u2013 "${chunk.original}")`);
        }
        const newChunk = chunk.split(index2);
        this.byEnd[index2] = chunk;
        this.byStart[index2] = newChunk;
        this.byEnd[newChunk.end] = newChunk;
        if (chunk === this.lastChunk)
          this.lastChunk = newChunk;
        this.lastSearchedChunk = chunk;
        return true;
      }
      toString() {
        let str = this.intro;
        let chunk = this.firstChunk;
        while (chunk) {
          str += chunk.toString();
          chunk = chunk.next;
        }
        return str + this.outro;
      }
      isEmpty() {
        let chunk = this.firstChunk;
        do {
          if (chunk.intro.length && chunk.intro.trim() || chunk.content.length && chunk.content.trim() || chunk.outro.length && chunk.outro.trim())
            return false;
        } while (chunk = chunk.next);
        return true;
      }
      length() {
        let chunk = this.firstChunk;
        let length = 0;
        do {
          length += chunk.intro.length + chunk.content.length + chunk.outro.length;
        } while (chunk = chunk.next);
        return length;
      }
      trimLines() {
        return this.trim("[\\r\\n]");
      }
      trim(charType) {
        return this.trimStart(charType).trimEnd(charType);
      }
      trimEndAborted(charType) {
        const rx = new RegExp((charType || "\\s") + "+$");
        this.outro = this.outro.replace(rx, "");
        if (this.outro.length)
          return true;
        let chunk = this.lastChunk;
        do {
          const end = chunk.end;
          const aborted = chunk.trimEnd(rx);
          if (chunk.end !== end) {
            if (this.lastChunk === chunk) {
              this.lastChunk = chunk.next;
            }
            this.byEnd[chunk.end] = chunk;
            this.byStart[chunk.next.start] = chunk.next;
            this.byEnd[chunk.next.end] = chunk.next;
          }
          if (aborted)
            return true;
          chunk = chunk.previous;
        } while (chunk);
        return false;
      }
      trimEnd(charType) {
        this.trimEndAborted(charType);
        return this;
      }
      trimStartAborted(charType) {
        const rx = new RegExp("^" + (charType || "\\s") + "+");
        this.intro = this.intro.replace(rx, "");
        if (this.intro.length)
          return true;
        let chunk = this.firstChunk;
        do {
          const end = chunk.end;
          const aborted = chunk.trimStart(rx);
          if (chunk.end !== end) {
            if (chunk === this.lastChunk)
              this.lastChunk = chunk.next;
            this.byEnd[chunk.end] = chunk;
            this.byStart[chunk.next.start] = chunk.next;
            this.byEnd[chunk.next.end] = chunk.next;
          }
          if (aborted)
            return true;
          chunk = chunk.next;
        } while (chunk);
        return false;
      }
      trimStart(charType) {
        this.trimStartAborted(charType);
        return this;
      }
      hasChanged() {
        return this.original !== this.toString();
      }
      replace(searchValue, replacement2) {
        function getReplacement(match2, str) {
          if (typeof replacement2 === "string") {
            return replacement2.replace(/\$(\$|&|\d+)/g, (_2, i2) => {
              if (i2 === "$")
                return "$";
              if (i2 === "&")
                return match2[0];
              const num = +i2;
              if (num < match2.length)
                return match2[+i2];
              return `$${i2}`;
            });
          } else {
            return replacement2(...match2, match2.index, str, match2.groups);
          }
        }
        function matchAll(re2, str) {
          let match2;
          const matches2 = [];
          while (match2 = re2.exec(str)) {
            matches2.push(match2);
          }
          return matches2;
        }
        if (typeof searchValue !== "string" && searchValue.global) {
          const matches2 = matchAll(searchValue, this.original);
          matches2.forEach((match2) => {
            if (match2.index != null)
              this.overwrite(match2.index, match2.index + match2[0].length, getReplacement(match2, this.original));
          });
        } else {
          const match2 = this.original.match(searchValue);
          if (match2 && match2.index != null)
            this.overwrite(match2.index, match2.index + match2[0].length, getReplacement(match2, this.original));
        }
        return this;
      }
    };
    var A = new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
    function parse$h(E3, g2 = "@") {
      if (!C)
        return init.then(() => parse$h(E3));
      const I2 = E3.length + 1, o2 = (C.__heap_base.value || C.__heap_base) + 4 * I2 - C.memory.buffer.byteLength;
      o2 > 0 && C.memory.grow(Math.ceil(o2 / 65536));
      const k2 = C.sa(I2 - 1);
      if ((A ? B : Q)(E3, new Uint16Array(C.memory.buffer, k2, I2)), !C.parse())
        throw Object.assign(new Error(`Parse error ${g2}:${E3.slice(0, C.e()).split("\n").length}:${C.e() - E3.lastIndexOf("\n", C.e() - 1)}`), { idx: C.e() });
      const J2 = [], i2 = [];
      for (; C.ri(); ) {
        const A3 = C.is(), Q3 = C.ie(), B3 = C.ai(), g3 = C.id(), I3 = C.ss(), o3 = C.se();
        let k3;
        C.ip() && (k3 = w3(E3.slice(g3 === -1 ? A3 - 1 : A3, g3 === -1 ? Q3 + 1 : Q3))), J2.push({ n: k3, s: A3, e: Q3, ss: I3, se: o3, d: g3, a: B3 });
      }
      for (; C.re(); ) {
        const A3 = E3.slice(C.es(), C.ee()), Q3 = A3[0];
        i2.push(Q3 === '"' || Q3 === "'" ? w3(A3) : A3);
      }
      function w3(A3) {
        try {
          return (0, eval)(A3);
        } catch (A4) {
        }
      }
      return [J2, i2, !!C.f()];
    }
    function Q(A3, Q3) {
      const B3 = A3.length;
      let C3 = 0;
      for (; C3 < B3; ) {
        const B4 = A3.charCodeAt(C3);
        Q3[C3++] = (255 & B4) << 8 | B4 >>> 8;
      }
    }
    function B(A3, Q3) {
      const B3 = A3.length;
      let C3 = 0;
      for (; C3 < B3; )
        Q3[C3] = A3.charCodeAt(C3++);
    }
    var C;
    var init = WebAssembly.compile((E = "AGFzbQEAAAABKghgAX8Bf2AEf39/fwBgAn9/AGAAAX9gAABgAX8AYAN/f38Bf2ACf38BfwMqKQABAgMDAwMDAwMDAwMDAwMAAAQEBAUEBQAAAAAEBAAGBwACAAAABwMGBAUBcAEBAQUDAQABBg8CfwFBkPIAC38AQZDyAAsHZBEGbWVtb3J5AgACc2EAAAFlAAMCaXMABAJpZQAFAnNzAAYCc2UABwJhaQAIAmlkAAkCaXAACgJlcwALAmVlAAwCcmkADQJyZQAOAWYADwVwYXJzZQAQC19faGVhcF9iYXNlAwEKhjQpaAEBf0EAIAA2AtQJQQAoArAJIgEgAEEBdGoiAEEAOwEAQQAgAEECaiIANgLYCUEAIAA2AtwJQQBBADYCtAlBAEEANgLECUEAQQA2ArwJQQBBADYCuAlBAEEANgLMCUEAQQA2AsAJIAELnwEBA39BACgCxAkhBEEAQQAoAtwJIgU2AsQJQQAgBDYCyAlBACAFQSBqNgLcCSAEQRxqQbQJIAQbIAU2AgBBACgCqAkhBEEAKAKkCSEGIAUgATYCACAFIAA2AgggBSACIAJBAmpBACAGIANGGyAEIANGGzYCDCAFIAM2AhQgBUEANgIQIAUgAjYCBCAFQQA2AhwgBUEAKAKkCSADRjoAGAtIAQF/QQAoAswJIgJBCGpBuAkgAhtBACgC3AkiAjYCAEEAIAI2AswJQQAgAkEMajYC3AkgAkEANgIIIAIgATYCBCACIAA2AgALCABBACgC4AkLFQBBACgCvAkoAgBBACgCsAlrQQF1Cx4BAX9BACgCvAkoAgQiAEEAKAKwCWtBAXVBfyAAGwsVAEEAKAK8CSgCCEEAKAKwCWtBAXULHgEBf0EAKAK8CSgCDCIAQQAoArAJa0EBdUF/IAAbCx4BAX9BACgCvAkoAhAiAEEAKAKwCWtBAXVBfyAAGws7AQF/AkBBACgCvAkoAhQiAEEAKAKkCUcNAEF/DwsCQCAAQQAoAqgJRw0AQX4PCyAAQQAoArAJa0EBdQsLAEEAKAK8CS0AGAsVAEEAKALACSgCAEEAKAKwCWtBAXULFQBBACgCwAkoAgRBACgCsAlrQQF1CyUBAX9BAEEAKAK8CSIAQRxqQbQJIAAbKAIAIgA2ArwJIABBAEcLJQEBf0EAQQAoAsAJIgBBCGpBuAkgABsoAgAiADYCwAkgAEEARwsIAEEALQDkCQvnCwEGfyMAQYDaAGsiASQAQQBBAToA5AlBAEH//wM7AewJQQBBACgCrAk2AvAJQQBBACgCsAlBfmoiAjYCiApBACACQQAoAtQJQQF0aiIDNgKMCkEAQQA7AeYJQQBBADsB6AlBAEEAOwHqCUEAQQA6APQJQQBBADYC4AlBAEEAOgDQCUEAIAFBgNIAajYC+AlBACABQYASajYC/AlBACABNgKACkEAQQA6AIQKAkACQAJAAkADQEEAIAJBAmoiBDYCiAogAiADTw0BAkAgBC8BACIDQXdqQQVJDQACQAJAAkACQAJAIANBm39qDgUBCAgIAgALIANBIEYNBCADQS9GDQMgA0E7Rg0CDAcLQQAvAeoJDQEgBBARRQ0BIAJBBGpBgghBChAoDQEQEkEALQDkCQ0BQQBBACgCiAoiAjYC8AkMBwsgBBARRQ0AIAJBBGpBjAhBChAoDQAQEwtBAEEAKAKICjYC8AkMAQsCQCACLwEEIgRBKkYNACAEQS9HDQQQFAwBC0EBEBULQQAoAowKIQNBACgCiAohAgwACwtBACEDIAQhAkEALQDQCQ0CDAELQQAgAjYCiApBAEEAOgDkCQsDQEEAIAJBAmoiBDYCiAoCQAJAAkACQAJAAkAgAkEAKAKMCk8NACAELwEAIgNBd2pBBUkNBQJAAkACQAJAAkACQAJAAkACQAJAIANBYGoOCg8OCA4ODg4HAQIACwJAAkACQAJAIANBoH9qDgoIEREDEQERERECAAsgA0GFf2oOAwUQBgsLQQAvAeoJDQ8gBBARRQ0PIAJBBGpBgghBChAoDQ8QEgwPCyAEEBFFDQ4gAkEEakGMCEEKECgNDhATDA4LIAQQEUUNDSACKQAEQuyAhIOwjsA5Ug0NIAIvAQwiBEF3aiICQRdLDQtBASACdEGfgIAEcUUNCwwMC0EAQQAvAeoJIgJBAWo7AeoJQQAoAvwJIAJBAnRqQQAoAvAJNgIADAwLQQAvAeoJIgNFDQhBACADQX9qIgU7AeoJQQAvAegJIgNFDQsgA0ECdEEAKAKACmpBfGooAgAiBigCFEEAKAL8CSAFQf//A3FBAnRqKAIARw0LAkAgBigCBA0AIAYgBDYCBAtBACADQX9qOwHoCSAGIAJBBGo2AgwMCwsCQEEAKALwCSIELwEAQSlHDQBBACgCxAkiAkUNACACKAIEIARHDQBBAEEAKALICSICNgLECQJAIAJFDQAgAkEANgIcDAELQQBBADYCtAkLIAFBgBBqQQAvAeoJIgJqQQAtAIQKOgAAQQAgAkEBajsB6glBACgC/AkgAkECdGogBDYCAEEAQQA6AIQKDAoLQQAvAeoJIgJFDQZBACACQX9qIgM7AeoJIAJBAC8B7AkiBEcNAUEAQQAvAeYJQX9qIgI7AeYJQQBBACgC+AkgAkH//wNxQQF0ai8BADsB7AkLEBYMCAsgBEH//wNGDQcgA0H//wNxIARJDQQMBwtBJxAXDAYLQSIQFwwFCyADQS9HDQQCQAJAIAIvAQQiAkEqRg0AIAJBL0cNARAUDAcLQQEQFQwGCwJAAkACQAJAQQAoAvAJIgQvAQAiAhAYRQ0AAkACQAJAIAJBVWoOBAEFAgAFCyAEQX5qLwEAQVBqQf//A3FBCkkNAwwECyAEQX5qLwEAQStGDQIMAwsgBEF+ai8BAEEtRg0BDAILAkAgAkH9AEYNACACQSlHDQFBACgC/AlBAC8B6glBAnRqKAIAEBlFDQEMAgtBACgC/AlBAC8B6gkiA0ECdGooAgAQGg0BIAFBgBBqIANqLQAADQELIAQQGw0AIAJFDQBBASEEIAJBL0ZBAC0A9AlBAEdxRQ0BCxAcQQAhBAtBACAEOgD0CQwEC0EALwHsCUH//wNGQQAvAeoJRXFBAC0A0AlFcUEALwHoCUVxIQMMBgsQHUEAIQMMBQsgBEGgAUcNAQtBAEEBOgCECgtBAEEAKAKICjYC8AkLQQAoAogKIQIMAAsLIAFBgNoAaiQAIAMLHQACQEEAKAKwCSAARw0AQQEPCyAAQX5qLwEAEB4LpgYBBH9BAEEAKAKICiIAQQxqIgE2AogKQQEQISECAkACQAJAAkACQEEAKAKICiIDIAFHDQAgAhAlRQ0BCwJAAkACQAJAAkAgAkGff2oODAYBAwgBBwEBAQEBBAALAkACQCACQSpGDQAgAkH2AEYNBSACQfsARw0CQQAgA0ECajYCiApBARAhIQNBACgCiAohAQNAAkACQCADQf//A3EiAkEiRg0AIAJBJ0YNACACECQaQQAoAogKIQIMAQsgAhAXQQBBACgCiApBAmoiAjYCiAoLQQEQIRoCQCABIAIQJiIDQSxHDQBBAEEAKAKICkECajYCiApBARAhIQMLQQAoAogKIQICQCADQf0ARg0AIAIgAUYNBSACIQEgAkEAKAKMCk0NAQwFCwtBACACQQJqNgKICgwBC0EAIANBAmo2AogKQQEQIRpBACgCiAoiAiACECYaC0EBECEhAgtBACgCiAohAwJAIAJB5gBHDQAgA0ECakGeCEEGECgNAEEAIANBCGo2AogKIABBARAhECIPC0EAIANBfmo2AogKDAMLEB0PCwJAIAMpAAJC7ICEg7COwDlSDQAgAy8BChAeRQ0AQQAgA0EKajYCiApBARAhIQJBACgCiAohAyACECQaIANBACgCiAoQAkEAQQAoAogKQX5qNgKICg8LQQAgA0EEaiIDNgKICgtBACADQQRqIgI2AogKQQBBADoA5AkDQEEAIAJBAmo2AogKQQEQISEDQQAoAogKIQICQCADECRBIHJB+wBHDQBBAEEAKAKICkF+ajYCiAoPC0EAKAKICiIDIAJGDQEgAiADEAICQEEBECEiAkEsRg0AAkAgAkE9Rw0AQQBBACgCiApBfmo2AogKDwtBAEEAKAKICkF+ajYCiAoPC0EAKAKICiECDAALCw8LQQAgA0EKajYCiApBARAhGkEAKAKICiEDC0EAIANBEGo2AogKAkBBARAhIgJBKkcNAEEAQQAoAogKQQJqNgKICkEBECEhAgtBACgCiAohAyACECQaIANBACgCiAoQAkEAQQAoAogKQX5qNgKICg8LIAMgA0EOahACC6sGAQR/QQBBACgCiAoiAEEMaiIBNgKICgJAAkACQAJAAkACQAJAAkACQAJAQQEQISICQVlqDggCCAECAQEBBwALIAJBIkYNASACQfsARg0CC0EAKAKICiABRg0HC0EALwHqCQ0BQQAoAogKIQJBACgCjAohAwNAIAIgA08NBAJAAkAgAi8BACIBQSdGDQAgAUEiRw0BCyAAIAEQIg8LQQAgAkECaiICNgKICgwACwtBACgCiAohAkEALwHqCQ0BAkADQAJAAkACQCACQQAoAowKTw0AQQEQISICQSJGDQEgAkEnRg0BIAJB/QBHDQJBAEEAKAKICkECajYCiAoLQQEQIRpBACgCiAoiAikAAELmgMiD8I3ANlINBkEAIAJBCGo2AogKQQEQISICQSJGDQMgAkEnRg0DDAYLIAIQFwtBAEEAKAKICkECaiICNgKICgwACwsgACACECIMBQtBAEEAKAKICkF+ajYCiAoPC0EAIAJBfmo2AogKDwsQHQ8LQQBBACgCiApBAmo2AogKQQEQIUHtAEcNAUEAKAKICiICQQJqQZYIQQYQKA0BQQAoAvAJLwEAQS5GDQEgACAAIAJBCGpBACgCqAkQAQ8LQQAoAvwJQQAvAeoJIgJBAnRqQQAoAogKNgIAQQAgAkEBajsB6glBACgC8AkvAQBBLkYNAEEAQQAoAogKIgFBAmo2AogKQQEQISECIABBACgCiApBACABEAFBAEEALwHoCSIBQQFqOwHoCUEAKAKACiABQQJ0akEAKALECTYCAAJAIAJBIkYNACACQSdGDQBBAEEAKAKICkF+ajYCiAoPCyACEBdBAEEAKAKICkECaiICNgKICgJAAkACQEEBECFBV2oOBAECAgACC0EAQQAoAogKQQJqNgKICkEBECEaQQAoAsQJIgEgAjYCBCABQQE6ABggAUEAKAKICiICNgIQQQAgAkF+ajYCiAoPC0EAKALECSIBIAI2AgQgAUEBOgAYQQBBAC8B6glBf2o7AeoJIAFBACgCiApBAmo2AgxBAEEALwHoCUF/ajsB6AkPC0EAQQAoAogKQX5qNgKICg8LC0cBA39BACgCiApBAmohAEEAKAKMCiEBAkADQCAAIgJBfmogAU8NASACQQJqIQAgAi8BAEF2ag4EAQAAAQALC0EAIAI2AogKC5gBAQN/QQBBACgCiAoiAUECajYCiAogAUEGaiEBQQAoAowKIQIDQAJAAkACQCABQXxqIAJPDQAgAUF+ai8BACEDAkACQCAADQAgA0EqRg0BIANBdmoOBAIEBAIECyADQSpHDQMLIAEvAQBBL0cNAkEAIAFBfmo2AogKDAELIAFBfmohAQtBACABNgKICg8LIAFBAmohAQwACwu/AQEEf0EAKAKICiEAQQAoAowKIQECQAJAA0AgACICQQJqIQAgAiABTw0BAkACQCAALwEAIgNBpH9qDgUBAgICBAALIANBJEcNASACLwEEQfsARw0BQQBBAC8B5gkiAEEBajsB5glBACgC+AkgAEEBdGpBAC8B7Ak7AQBBACACQQRqNgKICkEAQQAvAeoJQQFqIgA7AewJQQAgADsB6gkPCyACQQRqIQAMAAsLQQAgADYCiAoQHQ8LQQAgADYCiAoLiAEBBH9BACgCiAohAUEAKAKMCiECAkACQANAIAEiA0ECaiEBIAMgAk8NASABLwEAIgQgAEYNAgJAIARB3ABGDQAgBEF2ag4EAgEBAgELIANBBGohASADLwEEQQ1HDQAgA0EGaiABIAMvAQZBCkYbIQEMAAsLQQAgATYCiAoQHQ8LQQAgATYCiAoLbAEBfwJAAkAgAEFfaiIBQQVLDQBBASABdEExcQ0BCyAAQUZqQf//A3FBBkkNACAAQSlHIABBWGpB//8DcUEHSXENAAJAIABBpX9qDgQBAAABAAsgAEH9AEcgAEGFf2pB//8DcUEESXEPC0EBCy4BAX9BASEBAkAgAEH2CEEFEB8NACAAQYAJQQMQHw0AIABBhglBAhAfIQELIAELgwEBAn9BASEBAkACQAJAAkACQAJAIAAvAQAiAkFFag4EBQQEAQALAkAgAkGbf2oOBAMEBAIACyACQSlGDQQgAkH5AEcNAyAAQX5qQZIJQQYQHw8LIABBfmovAQBBPUYPCyAAQX5qQYoJQQQQHw8LIABBfmpBnglBAxAfDwtBACEBCyABC5MDAQJ/QQAhAQJAAkACQAJAAkACQAJAAkACQCAALwEAQZx/ag4UAAECCAgICAgICAMECAgFCAYICAcICwJAAkAgAEF+ai8BAEGXf2oOBAAJCQEJCyAAQXxqQa4IQQIQHw8LIABBfGpBsghBAxAfDwsCQAJAIABBfmovAQBBjX9qDgIAAQgLAkAgAEF8ai8BACICQeEARg0AIAJB7ABHDQggAEF6akHlABAgDwsgAEF6akHjABAgDwsgAEF8akG4CEEEEB8PCyAAQX5qLwEAQe8ARw0FIABBfGovAQBB5QBHDQUCQCAAQXpqLwEAIgJB8ABGDQAgAkHjAEcNBiAAQXhqQcAIQQYQHw8LIABBeGpBzAhBAhAfDwtBASEBIABBfmoiAEHpABAgDQQgAEHQCEEFEB8PCyAAQX5qQeQAECAPCyAAQX5qQdoIQQcQHw8LIABBfmpB6AhBBBAfDwsCQCAAQX5qLwEAIgJB7wBGDQAgAkHlAEcNASAAQXxqQe4AECAPCyAAQXxqQfAIQQMQHyEBCyABC3ABAn8CQAJAA0BBAEEAKAKICiIAQQJqIgE2AogKIABBACgCjApPDQECQAJAAkAgAS8BACIBQaV/ag4CAQIACwJAIAFBdmoOBAQDAwQACyABQS9HDQIMBAsQJxoMAQtBACAAQQRqNgKICgwACwsQHQsLNQEBf0EAQQE6ANAJQQAoAogKIQBBAEEAKAKMCkECajYCiApBACAAQQAoArAJa0EBdTYC4AkLNAEBf0EBIQECQCAAQXdqQf//A3FBBUkNACAAQYABckGgAUYNACAAQS5HIAAQJXEhAQsgAQtJAQN/QQAhAwJAIAAgAkEBdCICayIEQQJqIgBBACgCsAkiBUkNACAAIAEgAhAoDQACQCAAIAVHDQBBAQ8LIAQvAQAQHiEDCyADCz0BAn9BACECAkBBACgCsAkiAyAASw0AIAAvAQAgAUcNAAJAIAMgAEcNAEEBDwsgAEF+ai8BABAeIQILIAILnAEBA39BACgCiAohAQJAA0ACQAJAIAEvAQAiAkEvRw0AAkAgAS8BAiIBQSpGDQAgAUEvRw0EEBQMAgsgABAVDAELAkACQCAARQ0AIAJBd2oiAUEXSw0BQQEgAXRBn4CABHFFDQEMAgsgAhAjRQ0DDAELIAJBoAFHDQILQQBBACgCiAoiA0ECaiIBNgKICiADQQAoAowKSQ0ACwsgAgvCAwEBfwJAIAFBIkYNACABQSdGDQAQHQ8LQQAoAogKIQIgARAXIAAgAkECakEAKAKICkEAKAKkCRABQQBBACgCiApBAmo2AogKQQAQISEAQQAoAogKIQECQAJAIABB4QBHDQAgAUECakGkCEEKEChFDQELQQAgAUF+ajYCiAoPC0EAIAFBDGo2AogKAkBBARAhQfsARg0AQQAgATYCiAoPC0EAKAKICiICIQADQEEAIABBAmo2AogKAkACQAJAQQEQISIAQSJGDQAgAEEnRw0BQScQF0EAQQAoAogKQQJqNgKICkEBECEhAAwCC0EiEBdBAEEAKAKICkECajYCiApBARAhIQAMAQsgABAkIQALAkAgAEE6Rg0AQQAgATYCiAoPC0EAQQAoAogKQQJqNgKICgJAQQEQISIAQSJGDQAgAEEnRg0AQQAgATYCiAoPCyAAEBdBAEEAKAKICkECajYCiAoCQAJAQQEQISIAQSxGDQAgAEH9AEYNAUEAIAE2AogKDwtBAEEAKAKICkECajYCiApBARAhQf0ARg0AQQAoAogKIQAMAQsLQQAoAsQJIgEgAjYCECABQQAoAogKQQJqNgIMCzABAX8CQAJAIABBd2oiAUEXSw0AQQEgAXRBjYCABHENAQsgAEGgAUYNAEEADwtBAQttAQJ/AkACQANAAkAgAEH//wNxIgFBd2oiAkEXSw0AQQEgAnRBn4CABHENAgsgAUGgAUYNASAAIQIgARAlDQJBACECQQBBACgCiAoiAEECajYCiAogAC8BAiIADQAMAgsLIAAhAgsgAkH//wNxC2gBAn9BASEBAkACQCAAQV9qIgJBBUsNAEEBIAJ0QTFxDQELIABB+P8DcUEoRg0AIABBRmpB//8DcUEGSQ0AAkAgAEGlf2oiAkEDSw0AIAJBAUcNAQsgAEGFf2pB//8DcUEESSEBCyABC4sBAQJ/AkBBACgCiAoiAi8BACIDQeEARw0AQQAgAkEEajYCiApBARAhIQJBACgCiAohAAJAAkAgAkEiRg0AIAJBJ0YNACACECQaQQAoAogKIQEMAQsgAhAXQQBBACgCiApBAmoiATYCiAoLQQEQISEDQQAoAogKIQILAkAgAiAARg0AIAAgARACCyADC3IBBH9BACgCiAohAEEAKAKMCiEBAkACQANAIABBAmohAiAAIAFPDQECQAJAIAIvAQAiA0Gkf2oOAgEEAAsgAiEAIANBdmoOBAIBAQIBCyAAQQRqIQAMAAsLQQAgAjYCiAoQHUEADwtBACACNgKICkHdAAtJAQN/QQAhAwJAIAJFDQACQANAIAAtAAAiBCABLQAAIgVHDQEgAUEBaiEBIABBAWohACACQX9qIgINAAwCCwsgBCAFayEDCyADCwvCAQIAQYAIC6QBAAB4AHAAbwByAHQAbQBwAG8AcgB0AGUAdABhAGYAcgBvAG0AcwBzAGUAcgB0AHYAbwB5AGkAZQBkAGUAbABlAGkAbgBzAHQAYQBuAHQAeQByAGUAdAB1AHIAZABlAGIAdQBnAGcAZQBhAHcAYQBpAHQAaAByAHcAaABpAGwAZQBmAG8AcgBpAGYAYwBhAHQAYwBmAGkAbgBhAGwAbABlAGwAcwAAQaQJCxABAAAAAgAAAAAEAAAQOQAA", typeof Buffer != "undefined" ? Buffer.from(E, "base64") : Uint8Array.from(atob(E), (A3) => A3.charCodeAt(0)))).then(WebAssembly.instantiate).then(({ exports: A3 }) => {
      C = A3;
    });
    var E;
    var dist$1 = {};
    (function(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.lilconfigSync = exports.lilconfig = exports.defaultLoaders = void 0;
      const path = path__default;
      const fs = fs__default;
      const os = require$$1__default;
      const fsReadFileAsync = fs.promises.readFile;
      function getDefaultSearchPlaces(name) {
        return [
          "package.json",
          `.${name}rc.json`,
          `.${name}rc.js`,
          `${name}.config.js`,
          `.${name}rc.cjs`,
          `${name}.config.cjs`
        ];
      }
      function getSearchPaths(startDir, stopDir) {
        return startDir.split(path.sep).reduceRight((acc, _2, ind, arr) => {
          const currentPath = arr.slice(0, ind + 1).join(path.sep);
          if (!acc.passedStopDir)
            acc.searchPlaces.push(currentPath || path.sep);
          if (currentPath === stopDir)
            acc.passedStopDir = true;
          return acc;
        }, { searchPlaces: [], passedStopDir: false }).searchPlaces;
      }
      exports.defaultLoaders = Object.freeze({
        ".js": eval("require"),
        ".json": eval("require"),
        ".cjs": eval("require"),
        noExt(_2, content2) {
          return JSON.parse(content2);
        }
      });
      function getExtDesc(ext2) {
        return ext2 === "noExt" ? "files without extensions" : `extension "${ext2}"`;
      }
      function getOptions(name, options2 = {}) {
        const conf = __spreadProps2(__spreadValues2({
          stopDir: os.homedir(),
          searchPlaces: getDefaultSearchPlaces(name),
          ignoreEmptySearchPlaces: true,
          transform: (x2) => x2,
          packageProp: [name]
        }, options2), {
          loaders: __spreadValues2(__spreadValues2({}, exports.defaultLoaders), options2.loaders)
        });
        conf.searchPlaces.forEach((place) => {
          const key2 = path.extname(place) || "noExt";
          const loader = conf.loaders[key2];
          if (!loader) {
            throw new Error(`No loader specified for ${getExtDesc(key2)}, so searchPlaces item "${place}" is invalid`);
          }
          if (typeof loader !== "function") {
            throw new Error(`loader for ${getExtDesc(key2)} is not a function (type provided: "${typeof loader}"), so searchPlaces item "${place}" is invalid`);
          }
        });
        return conf;
      }
      function getPackageProp(props, obj) {
        if (typeof props === "string" && props in obj)
          return obj[props];
        return (Array.isArray(props) ? props : props.split(".")).reduce((acc, prop) => acc === void 0 ? acc : acc[prop], obj) || null;
      }
      function getSearchItems(searchPlaces, searchPaths) {
        return searchPaths.reduce((acc, searchPath) => {
          searchPlaces.forEach((fileName) => acc.push({
            fileName,
            filepath: path.join(searchPath, fileName),
            loaderKey: path.extname(fileName) || "noExt"
          }));
          return acc;
        }, []);
      }
      function validateFilePath(filepath) {
        if (!filepath)
          throw new Error("load must pass a non-empty string");
      }
      function validateLoader(loader, ext2) {
        if (!loader)
          throw new Error(`No loader specified for extension "${ext2}"`);
        if (typeof loader !== "function")
          throw new Error("loader is not a function");
      }
      function lilconfig(name, options2) {
        const { ignoreEmptySearchPlaces, loaders, packageProp, searchPlaces, stopDir, transform: transform2 } = getOptions(name, options2);
        return {
          async search(searchFrom = process.cwd()) {
            const searchPaths = getSearchPaths(searchFrom, stopDir);
            const result2 = {
              config: null,
              filepath: ""
            };
            const searchItems = getSearchItems(searchPlaces, searchPaths);
            for (const { fileName, filepath, loaderKey } of searchItems) {
              try {
                await fs.promises.access(filepath);
              } catch (_a2) {
                continue;
              }
              const content2 = String(await fsReadFileAsync(filepath));
              const loader = loaders[loaderKey];
              if (fileName === "package.json") {
                const pkg = loader(filepath, content2);
                const maybeConfig = getPackageProp(packageProp, pkg);
                if (maybeConfig != null) {
                  result2.config = maybeConfig;
                  result2.filepath = filepath;
                  break;
                }
                continue;
              }
              const isEmpty2 = content2.trim() === "";
              if (isEmpty2 && ignoreEmptySearchPlaces)
                continue;
              if (isEmpty2) {
                result2.isEmpty = true;
                result2.config = void 0;
              } else {
                validateLoader(loader, loaderKey);
                result2.config = loader(filepath, content2);
              }
              result2.filepath = filepath;
              break;
            }
            if (result2.filepath === "" && result2.config === null)
              return transform2(null);
            return transform2(result2);
          },
          async load(filepath) {
            validateFilePath(filepath);
            const absPath = path.resolve(process.cwd(), filepath);
            const { base: base2, ext: ext2 } = path.parse(absPath);
            const loaderKey = ext2 || "noExt";
            const loader = loaders[loaderKey];
            validateLoader(loader, loaderKey);
            const content2 = String(await fsReadFileAsync(absPath));
            if (base2 === "package.json") {
              const pkg = await loader(absPath, content2);
              return transform2({
                config: getPackageProp(packageProp, pkg),
                filepath: absPath
              });
            }
            const result2 = {
              config: null,
              filepath: absPath
            };
            const isEmpty2 = content2.trim() === "";
            if (isEmpty2 && ignoreEmptySearchPlaces)
              return transform2({
                config: void 0,
                filepath: absPath,
                isEmpty: true
              });
            result2.config = isEmpty2 ? void 0 : await loader(absPath, content2);
            return transform2(isEmpty2 ? __spreadProps2(__spreadValues2({}, result2), { isEmpty: isEmpty2, config: void 0 }) : result2);
          }
        };
      }
      exports.lilconfig = lilconfig;
      function lilconfigSync(name, options2) {
        const { ignoreEmptySearchPlaces, loaders, packageProp, searchPlaces, stopDir, transform: transform2 } = getOptions(name, options2);
        return {
          search(searchFrom = process.cwd()) {
            const searchPaths = getSearchPaths(searchFrom, stopDir);
            const result2 = {
              config: null,
              filepath: ""
            };
            const searchItems = getSearchItems(searchPlaces, searchPaths);
            for (const { fileName, filepath, loaderKey } of searchItems) {
              try {
                fs.accessSync(filepath);
              } catch (_a2) {
                continue;
              }
              const loader = loaders[loaderKey];
              const content2 = String(fs.readFileSync(filepath));
              if (fileName === "package.json") {
                const pkg = loader(filepath, content2);
                const maybeConfig = getPackageProp(packageProp, pkg);
                if (maybeConfig != null) {
                  result2.config = maybeConfig;
                  result2.filepath = filepath;
                  break;
                }
                continue;
              }
              const isEmpty2 = content2.trim() === "";
              if (isEmpty2 && ignoreEmptySearchPlaces)
                continue;
              if (isEmpty2) {
                result2.isEmpty = true;
                result2.config = void 0;
              } else {
                validateLoader(loader, loaderKey);
                result2.config = loader(filepath, content2);
              }
              result2.filepath = filepath;
              break;
            }
            if (result2.filepath === "" && result2.config === null)
              return transform2(null);
            return transform2(result2);
          },
          load(filepath) {
            validateFilePath(filepath);
            const absPath = path.resolve(process.cwd(), filepath);
            const { base: base2, ext: ext2 } = path.parse(absPath);
            const loaderKey = ext2 || "noExt";
            const loader = loaders[loaderKey];
            validateLoader(loader, loaderKey);
            const content2 = String(fs.readFileSync(absPath));
            if (base2 === "package.json") {
              const pkg = loader(absPath, content2);
              return transform2({
                config: getPackageProp(packageProp, pkg),
                filepath: absPath
              });
            }
            const result2 = {
              config: null,
              filepath: absPath
            };
            const isEmpty2 = content2.trim() === "";
            if (isEmpty2 && ignoreEmptySearchPlaces)
              return transform2({
                filepath: absPath,
                config: void 0,
                isEmpty: true
              });
            result2.config = isEmpty2 ? void 0 : loader(absPath, content2);
            return transform2(isEmpty2 ? __spreadProps2(__spreadValues2({}, result2), { isEmpty: isEmpty2, config: void 0 }) : result2);
          }
        };
      }
      exports.lilconfigSync = lilconfigSync;
    })(dist$1);
    var dist = {};
    var parseCst$1 = {};
    var PlainValueEc8e588e = {};
    var Char = {
      ANCHOR: "&",
      COMMENT: "#",
      TAG: "!",
      DIRECTIVES_END: "-",
      DOCUMENT_END: "."
    };
    var Type = {
      ALIAS: "ALIAS",
      BLANK_LINE: "BLANK_LINE",
      BLOCK_FOLDED: "BLOCK_FOLDED",
      BLOCK_LITERAL: "BLOCK_LITERAL",
      COMMENT: "COMMENT",
      DIRECTIVE: "DIRECTIVE",
      DOCUMENT: "DOCUMENT",
      FLOW_MAP: "FLOW_MAP",
      FLOW_SEQ: "FLOW_SEQ",
      MAP: "MAP",
      MAP_KEY: "MAP_KEY",
      MAP_VALUE: "MAP_VALUE",
      PLAIN: "PLAIN",
      QUOTE_DOUBLE: "QUOTE_DOUBLE",
      QUOTE_SINGLE: "QUOTE_SINGLE",
      SEQ: "SEQ",
      SEQ_ITEM: "SEQ_ITEM"
    };
    var defaultTagPrefix = "tag:yaml.org,2002:";
    var defaultTags = {
      MAP: "tag:yaml.org,2002:map",
      SEQ: "tag:yaml.org,2002:seq",
      STR: "tag:yaml.org,2002:str"
    };
    function findLineStarts(src2) {
      const ls2 = [0];
      let offset2 = src2.indexOf("\n");
      while (offset2 !== -1) {
        offset2 += 1;
        ls2.push(offset2);
        offset2 = src2.indexOf("\n", offset2);
      }
      return ls2;
    }
    function getSrcInfo(cst) {
      let lineStarts, src2;
      if (typeof cst === "string") {
        lineStarts = findLineStarts(cst);
        src2 = cst;
      } else {
        if (Array.isArray(cst))
          cst = cst[0];
        if (cst && cst.context) {
          if (!cst.lineStarts)
            cst.lineStarts = findLineStarts(cst.context.src);
          lineStarts = cst.lineStarts;
          src2 = cst.context.src;
        }
      }
      return {
        lineStarts,
        src: src2
      };
    }
    function getLinePos(offset2, cst) {
      if (typeof offset2 !== "number" || offset2 < 0)
        return null;
      const {
        lineStarts,
        src: src2
      } = getSrcInfo(cst);
      if (!lineStarts || !src2 || offset2 > src2.length)
        return null;
      for (let i2 = 0; i2 < lineStarts.length; ++i2) {
        const start = lineStarts[i2];
        if (offset2 < start) {
          return {
            line: i2,
            col: offset2 - lineStarts[i2 - 1] + 1
          };
        }
        if (offset2 === start)
          return {
            line: i2 + 1,
            col: 1
          };
      }
      const line2 = lineStarts.length;
      return {
        line: line2,
        col: offset2 - lineStarts[line2 - 1] + 1
      };
    }
    function getLine(line2, cst) {
      const {
        lineStarts,
        src: src2
      } = getSrcInfo(cst);
      if (!lineStarts || !(line2 >= 1) || line2 > lineStarts.length)
        return null;
      const start = lineStarts[line2 - 1];
      let end = lineStarts[line2];
      while (end && end > start && src2[end - 1] === "\n")
        --end;
      return src2.slice(start, end);
    }
    function getPrettyContext({
      start,
      end
    }, cst, maxWidth = 80) {
      let src2 = getLine(start.line, cst);
      if (!src2)
        return null;
      let {
        col
      } = start;
      if (src2.length > maxWidth) {
        if (col <= maxWidth - 10) {
          src2 = src2.substr(0, maxWidth - 1) + "\u2026";
        } else {
          const halfWidth = Math.round(maxWidth / 2);
          if (src2.length > col + halfWidth)
            src2 = src2.substr(0, col + halfWidth - 1) + "\u2026";
          col -= src2.length - maxWidth;
          src2 = "\u2026" + src2.substr(1 - maxWidth);
        }
      }
      let errLen = 1;
      let errEnd = "";
      if (end) {
        if (end.line === start.line && col + (end.col - start.col) <= maxWidth + 1) {
          errLen = end.col - start.col;
        } else {
          errLen = Math.min(src2.length + 1, maxWidth) - col;
          errEnd = "\u2026";
        }
      }
      const offset2 = col > 1 ? " ".repeat(col - 1) : "";
      const err = "^".repeat(errLen);
      return `${src2}
${offset2}${err}${errEnd}`;
    }
    var Range = class {
      static copy(orig) {
        return new Range(orig.start, orig.end);
      }
      constructor(start, end) {
        this.start = start;
        this.end = end || start;
      }
      isEmpty() {
        return typeof this.start !== "number" || !this.end || this.end <= this.start;
      }
      setOrigRange(cr2, offset2) {
        const {
          start,
          end
        } = this;
        if (cr2.length === 0 || end <= cr2[0]) {
          this.origStart = start;
          this.origEnd = end;
          return offset2;
        }
        let i2 = offset2;
        while (i2 < cr2.length) {
          if (cr2[i2] > start)
            break;
          else
            ++i2;
        }
        this.origStart = start + i2;
        const nextOffset = i2;
        while (i2 < cr2.length) {
          if (cr2[i2] >= end)
            break;
          else
            ++i2;
        }
        this.origEnd = end + i2;
        return nextOffset;
      }
    };
    var Node$2 = class {
      static addStringTerminator(src2, offset2, str) {
        if (str[str.length - 1] === "\n")
          return str;
        const next = Node$2.endOfWhiteSpace(src2, offset2);
        return next >= src2.length || src2[next] === "\n" ? str + "\n" : str;
      }
      static atDocumentBoundary(src2, offset2, sep) {
        const ch0 = src2[offset2];
        if (!ch0)
          return true;
        const prev = src2[offset2 - 1];
        if (prev && prev !== "\n")
          return false;
        if (sep) {
          if (ch0 !== sep)
            return false;
        } else {
          if (ch0 !== Char.DIRECTIVES_END && ch0 !== Char.DOCUMENT_END)
            return false;
        }
        const ch1 = src2[offset2 + 1];
        const ch2 = src2[offset2 + 2];
        if (ch1 !== ch0 || ch2 !== ch0)
          return false;
        const ch3 = src2[offset2 + 3];
        return !ch3 || ch3 === "\n" || ch3 === "	" || ch3 === " ";
      }
      static endOfIdentifier(src2, offset2) {
        let ch2 = src2[offset2];
        const isVerbatim = ch2 === "<";
        const notOk = isVerbatim ? ["\n", "	", " ", ">"] : ["\n", "	", " ", "[", "]", "{", "}", ","];
        while (ch2 && notOk.indexOf(ch2) === -1)
          ch2 = src2[offset2 += 1];
        if (isVerbatim && ch2 === ">")
          offset2 += 1;
        return offset2;
      }
      static endOfIndent(src2, offset2) {
        let ch2 = src2[offset2];
        while (ch2 === " ")
          ch2 = src2[offset2 += 1];
        return offset2;
      }
      static endOfLine(src2, offset2) {
        let ch2 = src2[offset2];
        while (ch2 && ch2 !== "\n")
          ch2 = src2[offset2 += 1];
        return offset2;
      }
      static endOfWhiteSpace(src2, offset2) {
        let ch2 = src2[offset2];
        while (ch2 === "	" || ch2 === " ")
          ch2 = src2[offset2 += 1];
        return offset2;
      }
      static startOfLine(src2, offset2) {
        let ch2 = src2[offset2 - 1];
        if (ch2 === "\n")
          return offset2;
        while (ch2 && ch2 !== "\n")
          ch2 = src2[offset2 -= 1];
        return offset2 + 1;
      }
      static endOfBlockIndent(src2, indent, lineStart) {
        const inEnd = Node$2.endOfIndent(src2, lineStart);
        if (inEnd > lineStart + indent) {
          return inEnd;
        } else {
          const wsEnd = Node$2.endOfWhiteSpace(src2, inEnd);
          const ch2 = src2[wsEnd];
          if (!ch2 || ch2 === "\n")
            return wsEnd;
        }
        return null;
      }
      static atBlank(src2, offset2, endAsBlank) {
        const ch2 = src2[offset2];
        return ch2 === "\n" || ch2 === "	" || ch2 === " " || endAsBlank && !ch2;
      }
      static nextNodeIsIndented(ch2, indentDiff, indicatorAsIndent) {
        if (!ch2 || indentDiff < 0)
          return false;
        if (indentDiff > 0)
          return true;
        return indicatorAsIndent && ch2 === "-";
      }
      static normalizeOffset(src2, offset2) {
        const ch2 = src2[offset2];
        return !ch2 ? offset2 : ch2 !== "\n" && src2[offset2 - 1] === "\n" ? offset2 - 1 : Node$2.endOfWhiteSpace(src2, offset2);
      }
      static foldNewline(src2, offset2, indent) {
        let inCount = 0;
        let error2 = false;
        let fold = "";
        let ch2 = src2[offset2 + 1];
        while (ch2 === " " || ch2 === "	" || ch2 === "\n") {
          switch (ch2) {
            case "\n":
              inCount = 0;
              offset2 += 1;
              fold += "\n";
              break;
            case "	":
              if (inCount <= indent)
                error2 = true;
              offset2 = Node$2.endOfWhiteSpace(src2, offset2 + 2) - 1;
              break;
            case " ":
              inCount += 1;
              offset2 += 1;
              break;
          }
          ch2 = src2[offset2 + 1];
        }
        if (!fold)
          fold = " ";
        if (ch2 && inCount <= indent)
          error2 = true;
        return {
          fold,
          offset: offset2,
          error: error2
        };
      }
      constructor(type, props, context2) {
        Object.defineProperty(this, "context", {
          value: context2 || null,
          writable: true
        });
        this.error = null;
        this.range = null;
        this.valueRange = null;
        this.props = props || [];
        this.type = type;
        this.value = null;
      }
      getPropValue(idx, key2, skipKey) {
        if (!this.context)
          return null;
        const {
          src: src2
        } = this.context;
        const prop = this.props[idx];
        return prop && src2[prop.start] === key2 ? src2.slice(prop.start + (skipKey ? 1 : 0), prop.end) : null;
      }
      get anchor() {
        for (let i2 = 0; i2 < this.props.length; ++i2) {
          const anchor = this.getPropValue(i2, Char.ANCHOR, true);
          if (anchor != null)
            return anchor;
        }
        return null;
      }
      get comment() {
        const comments = [];
        for (let i2 = 0; i2 < this.props.length; ++i2) {
          const comment = this.getPropValue(i2, Char.COMMENT, true);
          if (comment != null)
            comments.push(comment);
        }
        return comments.length > 0 ? comments.join("\n") : null;
      }
      commentHasRequiredWhitespace(start) {
        const {
          src: src2
        } = this.context;
        if (this.header && start === this.header.end)
          return false;
        if (!this.valueRange)
          return false;
        const {
          end
        } = this.valueRange;
        return start !== end || Node$2.atBlank(src2, end - 1);
      }
      get hasComment() {
        if (this.context) {
          const {
            src: src2
          } = this.context;
          for (let i2 = 0; i2 < this.props.length; ++i2) {
            if (src2[this.props[i2].start] === Char.COMMENT)
              return true;
          }
        }
        return false;
      }
      get hasProps() {
        if (this.context) {
          const {
            src: src2
          } = this.context;
          for (let i2 = 0; i2 < this.props.length; ++i2) {
            if (src2[this.props[i2].start] !== Char.COMMENT)
              return true;
          }
        }
        return false;
      }
      get includesTrailingLines() {
        return false;
      }
      get jsonLike() {
        const jsonLikeTypes = [Type.FLOW_MAP, Type.FLOW_SEQ, Type.QUOTE_DOUBLE, Type.QUOTE_SINGLE];
        return jsonLikeTypes.indexOf(this.type) !== -1;
      }
      get rangeAsLinePos() {
        if (!this.range || !this.context)
          return void 0;
        const start = getLinePos(this.range.start, this.context.root);
        if (!start)
          return void 0;
        const end = getLinePos(this.range.end, this.context.root);
        return {
          start,
          end
        };
      }
      get rawValue() {
        if (!this.valueRange || !this.context)
          return null;
        const {
          start,
          end
        } = this.valueRange;
        return this.context.src.slice(start, end);
      }
      get tag() {
        for (let i2 = 0; i2 < this.props.length; ++i2) {
          const tag = this.getPropValue(i2, Char.TAG, false);
          if (tag != null) {
            if (tag[1] === "<") {
              return {
                verbatim: tag.slice(2, -1)
              };
            } else {
              const [_2, handle, suffix] = tag.match(/^(.*!)([^!]*)$/);
              return {
                handle,
                suffix
              };
            }
          }
        }
        return null;
      }
      get valueRangeContainsNewline() {
        if (!this.valueRange || !this.context)
          return false;
        const {
          start,
          end
        } = this.valueRange;
        const {
          src: src2
        } = this.context;
        for (let i2 = start; i2 < end; ++i2) {
          if (src2[i2] === "\n")
            return true;
        }
        return false;
      }
      parseComment(start) {
        const {
          src: src2
        } = this.context;
        if (src2[start] === Char.COMMENT) {
          const end = Node$2.endOfLine(src2, start + 1);
          const commentRange = new Range(start, end);
          this.props.push(commentRange);
          return end;
        }
        return start;
      }
      setOrigRanges(cr2, offset2) {
        if (this.range)
          offset2 = this.range.setOrigRange(cr2, offset2);
        if (this.valueRange)
          this.valueRange.setOrigRange(cr2, offset2);
        this.props.forEach((prop) => prop.setOrigRange(cr2, offset2));
        return offset2;
      }
      toString() {
        const {
          context: {
            src: src2
          },
          range: range2,
          value
        } = this;
        if (value != null)
          return value;
        const str = src2.slice(range2.start, range2.end);
        return Node$2.addStringTerminator(src2, range2.end, str);
      }
    };
    var YAMLError = class extends Error {
      constructor(name, source2, message) {
        if (!message || !(source2 instanceof Node$2))
          throw new Error(`Invalid arguments for new ${name}`);
        super();
        this.name = name;
        this.message = message;
        this.source = source2;
      }
      makePretty() {
        if (!this.source)
          return;
        this.nodeType = this.source.type;
        const cst = this.source.context && this.source.context.root;
        if (typeof this.offset === "number") {
          this.range = new Range(this.offset, this.offset + 1);
          const start = cst && getLinePos(this.offset, cst);
          if (start) {
            const end = {
              line: start.line,
              col: start.col + 1
            };
            this.linePos = {
              start,
              end
            };
          }
          delete this.offset;
        } else {
          this.range = this.source.range;
          this.linePos = this.source.rangeAsLinePos;
        }
        if (this.linePos) {
          const {
            line: line2,
            col
          } = this.linePos.start;
          this.message += ` at line ${line2}, column ${col}`;
          const ctx = cst && getPrettyContext(this.linePos, cst);
          if (ctx)
            this.message += `:

${ctx}
`;
        }
        delete this.source;
      }
    };
    var YAMLReferenceError = class extends YAMLError {
      constructor(source2, message) {
        super("YAMLReferenceError", source2, message);
      }
    };
    var YAMLSemanticError = class extends YAMLError {
      constructor(source2, message) {
        super("YAMLSemanticError", source2, message);
      }
    };
    var YAMLSyntaxError = class extends YAMLError {
      constructor(source2, message) {
        super("YAMLSyntaxError", source2, message);
      }
    };
    var YAMLWarning = class extends YAMLError {
      constructor(source2, message) {
        super("YAMLWarning", source2, message);
      }
    };
    function _defineProperty(obj, key2, value) {
      if (key2 in obj) {
        Object.defineProperty(obj, key2, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key2] = value;
      }
      return obj;
    }
    var PlainValue$6 = class extends Node$2 {
      static endOfLine(src2, start, inFlow) {
        let ch2 = src2[start];
        let offset2 = start;
        while (ch2 && ch2 !== "\n") {
          if (inFlow && (ch2 === "[" || ch2 === "]" || ch2 === "{" || ch2 === "}" || ch2 === ","))
            break;
          const next = src2[offset2 + 1];
          if (ch2 === ":" && (!next || next === "\n" || next === "	" || next === " " || inFlow && next === ","))
            break;
          if ((ch2 === " " || ch2 === "	") && next === "#")
            break;
          offset2 += 1;
          ch2 = next;
        }
        return offset2;
      }
      get strValue() {
        if (!this.valueRange || !this.context)
          return null;
        let {
          start,
          end
        } = this.valueRange;
        const {
          src: src2
        } = this.context;
        let ch2 = src2[end - 1];
        while (start < end && (ch2 === "\n" || ch2 === "	" || ch2 === " "))
          ch2 = src2[--end - 1];
        let str = "";
        for (let i2 = start; i2 < end; ++i2) {
          const ch3 = src2[i2];
          if (ch3 === "\n") {
            const {
              fold,
              offset: offset2
            } = Node$2.foldNewline(src2, i2, -1);
            str += fold;
            i2 = offset2;
          } else if (ch3 === " " || ch3 === "	") {
            const wsStart = i2;
            let next = src2[i2 + 1];
            while (i2 < end && (next === " " || next === "	")) {
              i2 += 1;
              next = src2[i2 + 1];
            }
            if (next !== "\n")
              str += i2 > wsStart ? src2.slice(wsStart, i2 + 1) : ch3;
          } else {
            str += ch3;
          }
        }
        const ch0 = src2[start];
        switch (ch0) {
          case "	": {
            const msg = "Plain value cannot start with a tab character";
            const errors = [new YAMLSemanticError(this, msg)];
            return {
              errors,
              str
            };
          }
          case "@":
          case "`": {
            const msg = `Plain value cannot start with reserved character ${ch0}`;
            const errors = [new YAMLSemanticError(this, msg)];
            return {
              errors,
              str
            };
          }
          default:
            return str;
        }
      }
      parseBlockValue(start) {
        const {
          indent,
          inFlow,
          src: src2
        } = this.context;
        let offset2 = start;
        let valueEnd = start;
        for (let ch2 = src2[offset2]; ch2 === "\n"; ch2 = src2[offset2]) {
          if (Node$2.atDocumentBoundary(src2, offset2 + 1))
            break;
          const end = Node$2.endOfBlockIndent(src2, indent, offset2 + 1);
          if (end === null || src2[end] === "#")
            break;
          if (src2[end] === "\n") {
            offset2 = end;
          } else {
            valueEnd = PlainValue$6.endOfLine(src2, end, inFlow);
            offset2 = valueEnd;
          }
        }
        if (this.valueRange.isEmpty())
          this.valueRange.start = start;
        this.valueRange.end = valueEnd;
        return valueEnd;
      }
      parse(context2, start) {
        this.context = context2;
        const {
          inFlow,
          src: src2
        } = context2;
        let offset2 = start;
        const ch2 = src2[offset2];
        if (ch2 && ch2 !== "#" && ch2 !== "\n") {
          offset2 = PlainValue$6.endOfLine(src2, start, inFlow);
        }
        this.valueRange = new Range(start, offset2);
        offset2 = Node$2.endOfWhiteSpace(src2, offset2);
        offset2 = this.parseComment(offset2);
        if (!this.hasComment || this.valueRange.isEmpty()) {
          offset2 = this.parseBlockValue(offset2);
        }
        return offset2;
      }
    };
    PlainValueEc8e588e.Char = Char;
    PlainValueEc8e588e.Node = Node$2;
    PlainValueEc8e588e.PlainValue = PlainValue$6;
    PlainValueEc8e588e.Range = Range;
    PlainValueEc8e588e.Type = Type;
    PlainValueEc8e588e.YAMLError = YAMLError;
    PlainValueEc8e588e.YAMLReferenceError = YAMLReferenceError;
    PlainValueEc8e588e.YAMLSemanticError = YAMLSemanticError;
    PlainValueEc8e588e.YAMLSyntaxError = YAMLSyntaxError;
    PlainValueEc8e588e.YAMLWarning = YAMLWarning;
    PlainValueEc8e588e._defineProperty = _defineProperty;
    PlainValueEc8e588e.defaultTagPrefix = defaultTagPrefix;
    PlainValueEc8e588e.defaultTags = defaultTags;
    var PlainValue$5 = PlainValueEc8e588e;
    var BlankLine = class extends PlainValue$5.Node {
      constructor() {
        super(PlainValue$5.Type.BLANK_LINE);
      }
      get includesTrailingLines() {
        return true;
      }
      parse(context2, start) {
        this.context = context2;
        this.range = new PlainValue$5.Range(start, start + 1);
        return start + 1;
      }
    };
    var CollectionItem = class extends PlainValue$5.Node {
      constructor(type, props) {
        super(type, props);
        this.node = null;
      }
      get includesTrailingLines() {
        return !!this.node && this.node.includesTrailingLines;
      }
      parse(context2, start) {
        this.context = context2;
        const {
          parseNode,
          src: src2
        } = context2;
        let {
          atLineStart,
          lineStart
        } = context2;
        if (!atLineStart && this.type === PlainValue$5.Type.SEQ_ITEM)
          this.error = new PlainValue$5.YAMLSemanticError(this, "Sequence items must not have preceding content on the same line");
        const indent = atLineStart ? start - lineStart : context2.indent;
        let offset2 = PlainValue$5.Node.endOfWhiteSpace(src2, start + 1);
        let ch2 = src2[offset2];
        const inlineComment = ch2 === "#";
        const comments = [];
        let blankLine = null;
        while (ch2 === "\n" || ch2 === "#") {
          if (ch2 === "#") {
            const end2 = PlainValue$5.Node.endOfLine(src2, offset2 + 1);
            comments.push(new PlainValue$5.Range(offset2, end2));
            offset2 = end2;
          } else {
            atLineStart = true;
            lineStart = offset2 + 1;
            const wsEnd = PlainValue$5.Node.endOfWhiteSpace(src2, lineStart);
            if (src2[wsEnd] === "\n" && comments.length === 0) {
              blankLine = new BlankLine();
              lineStart = blankLine.parse({
                src: src2
              }, lineStart);
            }
            offset2 = PlainValue$5.Node.endOfIndent(src2, lineStart);
          }
          ch2 = src2[offset2];
        }
        if (PlainValue$5.Node.nextNodeIsIndented(ch2, offset2 - (lineStart + indent), this.type !== PlainValue$5.Type.SEQ_ITEM)) {
          this.node = parseNode({
            atLineStart,
            inCollection: false,
            indent,
            lineStart,
            parent: this
          }, offset2);
        } else if (ch2 && lineStart > start + 1) {
          offset2 = lineStart - 1;
        }
        if (this.node) {
          if (blankLine) {
            const items = context2.parent.items || context2.parent.contents;
            if (items)
              items.push(blankLine);
          }
          if (comments.length)
            Array.prototype.push.apply(this.props, comments);
          offset2 = this.node.range.end;
        } else {
          if (inlineComment) {
            const c3 = comments[0];
            this.props.push(c3);
            offset2 = c3.end;
          } else {
            offset2 = PlainValue$5.Node.endOfLine(src2, start + 1);
          }
        }
        const end = this.node ? this.node.valueRange.end : offset2;
        this.valueRange = new PlainValue$5.Range(start, end);
        return offset2;
      }
      setOrigRanges(cr2, offset2) {
        offset2 = super.setOrigRanges(cr2, offset2);
        return this.node ? this.node.setOrigRanges(cr2, offset2) : offset2;
      }
      toString() {
        const {
          context: {
            src: src2
          },
          node: node2,
          range: range2,
          value
        } = this;
        if (value != null)
          return value;
        const str = node2 ? src2.slice(range2.start, node2.range.start) + String(node2) : src2.slice(range2.start, range2.end);
        return PlainValue$5.Node.addStringTerminator(src2, range2.end, str);
      }
    };
    var Comment = class extends PlainValue$5.Node {
      constructor() {
        super(PlainValue$5.Type.COMMENT);
      }
      parse(context2, start) {
        this.context = context2;
        const offset2 = this.parseComment(start);
        this.range = new PlainValue$5.Range(start, offset2);
        return offset2;
      }
    };
    function grabCollectionEndComments(node2) {
      let cnode = node2;
      while (cnode instanceof CollectionItem)
        cnode = cnode.node;
      if (!(cnode instanceof Collection$1))
        return null;
      const len = cnode.items.length;
      let ci2 = -1;
      for (let i2 = len - 1; i2 >= 0; --i2) {
        const n3 = cnode.items[i2];
        if (n3.type === PlainValue$5.Type.COMMENT) {
          const {
            indent,
            lineStart
          } = n3.context;
          if (indent > 0 && n3.range.start >= lineStart + indent)
            break;
          ci2 = i2;
        } else if (n3.type === PlainValue$5.Type.BLANK_LINE)
          ci2 = i2;
        else
          break;
      }
      if (ci2 === -1)
        return null;
      const ca2 = cnode.items.splice(ci2, len - ci2);
      const prevEnd = ca2[0].range.start;
      while (true) {
        cnode.range.end = prevEnd;
        if (cnode.valueRange && cnode.valueRange.end > prevEnd)
          cnode.valueRange.end = prevEnd;
        if (cnode === node2)
          break;
        cnode = cnode.context.parent;
      }
      return ca2;
    }
    var Collection$1 = class extends PlainValue$5.Node {
      static nextContentHasIndent(src2, offset2, indent) {
        const lineStart = PlainValue$5.Node.endOfLine(src2, offset2) + 1;
        offset2 = PlainValue$5.Node.endOfWhiteSpace(src2, lineStart);
        const ch2 = src2[offset2];
        if (!ch2)
          return false;
        if (offset2 >= lineStart + indent)
          return true;
        if (ch2 !== "#" && ch2 !== "\n")
          return false;
        return Collection$1.nextContentHasIndent(src2, offset2, indent);
      }
      constructor(firstItem) {
        super(firstItem.type === PlainValue$5.Type.SEQ_ITEM ? PlainValue$5.Type.SEQ : PlainValue$5.Type.MAP);
        for (let i2 = firstItem.props.length - 1; i2 >= 0; --i2) {
          if (firstItem.props[i2].start < firstItem.context.lineStart) {
            this.props = firstItem.props.slice(0, i2 + 1);
            firstItem.props = firstItem.props.slice(i2 + 1);
            const itemRange = firstItem.props[0] || firstItem.valueRange;
            firstItem.range.start = itemRange.start;
            break;
          }
        }
        this.items = [firstItem];
        const ec = grabCollectionEndComments(firstItem);
        if (ec)
          Array.prototype.push.apply(this.items, ec);
      }
      get includesTrailingLines() {
        return this.items.length > 0;
      }
      parse(context2, start) {
        this.context = context2;
        const {
          parseNode,
          src: src2
        } = context2;
        let lineStart = PlainValue$5.Node.startOfLine(src2, start);
        const firstItem = this.items[0];
        firstItem.context.parent = this;
        this.valueRange = PlainValue$5.Range.copy(firstItem.valueRange);
        const indent = firstItem.range.start - firstItem.context.lineStart;
        let offset2 = start;
        offset2 = PlainValue$5.Node.normalizeOffset(src2, offset2);
        let ch2 = src2[offset2];
        let atLineStart = PlainValue$5.Node.endOfWhiteSpace(src2, lineStart) === offset2;
        let prevIncludesTrailingLines = false;
        while (ch2) {
          while (ch2 === "\n" || ch2 === "#") {
            if (atLineStart && ch2 === "\n" && !prevIncludesTrailingLines) {
              const blankLine = new BlankLine();
              offset2 = blankLine.parse({
                src: src2
              }, offset2);
              this.valueRange.end = offset2;
              if (offset2 >= src2.length) {
                ch2 = null;
                break;
              }
              this.items.push(blankLine);
              offset2 -= 1;
            } else if (ch2 === "#") {
              if (offset2 < lineStart + indent && !Collection$1.nextContentHasIndent(src2, offset2, indent)) {
                return offset2;
              }
              const comment = new Comment();
              offset2 = comment.parse({
                indent,
                lineStart,
                src: src2
              }, offset2);
              this.items.push(comment);
              this.valueRange.end = offset2;
              if (offset2 >= src2.length) {
                ch2 = null;
                break;
              }
            }
            lineStart = offset2 + 1;
            offset2 = PlainValue$5.Node.endOfIndent(src2, lineStart);
            if (PlainValue$5.Node.atBlank(src2, offset2)) {
              const wsEnd = PlainValue$5.Node.endOfWhiteSpace(src2, offset2);
              const next = src2[wsEnd];
              if (!next || next === "\n" || next === "#") {
                offset2 = wsEnd;
              }
            }
            ch2 = src2[offset2];
            atLineStart = true;
          }
          if (!ch2) {
            break;
          }
          if (offset2 !== lineStart + indent && (atLineStart || ch2 !== ":")) {
            if (offset2 < lineStart + indent) {
              if (lineStart > start)
                offset2 = lineStart;
              break;
            } else if (!this.error) {
              const msg = "All collection items must start at the same column";
              this.error = new PlainValue$5.YAMLSyntaxError(this, msg);
            }
          }
          if (firstItem.type === PlainValue$5.Type.SEQ_ITEM) {
            if (ch2 !== "-") {
              if (lineStart > start)
                offset2 = lineStart;
              break;
            }
          } else if (ch2 === "-" && !this.error) {
            const next = src2[offset2 + 1];
            if (!next || next === "\n" || next === "	" || next === " ") {
              const msg = "A collection cannot be both a mapping and a sequence";
              this.error = new PlainValue$5.YAMLSyntaxError(this, msg);
            }
          }
          const node2 = parseNode({
            atLineStart,
            inCollection: true,
            indent,
            lineStart,
            parent: this
          }, offset2);
          if (!node2)
            return offset2;
          this.items.push(node2);
          this.valueRange.end = node2.valueRange.end;
          offset2 = PlainValue$5.Node.normalizeOffset(src2, node2.range.end);
          ch2 = src2[offset2];
          atLineStart = false;
          prevIncludesTrailingLines = node2.includesTrailingLines;
          if (ch2) {
            let ls2 = offset2 - 1;
            let prev = src2[ls2];
            while (prev === " " || prev === "	")
              prev = src2[--ls2];
            if (prev === "\n") {
              lineStart = ls2 + 1;
              atLineStart = true;
            }
          }
          const ec = grabCollectionEndComments(node2);
          if (ec)
            Array.prototype.push.apply(this.items, ec);
        }
        return offset2;
      }
      setOrigRanges(cr2, offset2) {
        offset2 = super.setOrigRanges(cr2, offset2);
        this.items.forEach((node2) => {
          offset2 = node2.setOrigRanges(cr2, offset2);
        });
        return offset2;
      }
      toString() {
        const {
          context: {
            src: src2
          },
          items,
          range: range2,
          value
        } = this;
        if (value != null)
          return value;
        let str = src2.slice(range2.start, items[0].range.start) + String(items[0]);
        for (let i2 = 1; i2 < items.length; ++i2) {
          const item = items[i2];
          const {
            atLineStart,
            indent
          } = item.context;
          if (atLineStart)
            for (let i3 = 0; i3 < indent; ++i3)
              str += " ";
          str += String(item);
        }
        return PlainValue$5.Node.addStringTerminator(src2, range2.end, str);
      }
    };
    var Directive = class extends PlainValue$5.Node {
      constructor() {
        super(PlainValue$5.Type.DIRECTIVE);
        this.name = null;
      }
      get parameters() {
        const raw = this.rawValue;
        return raw ? raw.trim().split(/[ \t]+/) : [];
      }
      parseName(start) {
        const {
          src: src2
        } = this.context;
        let offset2 = start;
        let ch2 = src2[offset2];
        while (ch2 && ch2 !== "\n" && ch2 !== "	" && ch2 !== " ")
          ch2 = src2[offset2 += 1];
        this.name = src2.slice(start, offset2);
        return offset2;
      }
      parseParameters(start) {
        const {
          src: src2
        } = this.context;
        let offset2 = start;
        let ch2 = src2[offset2];
        while (ch2 && ch2 !== "\n" && ch2 !== "#")
          ch2 = src2[offset2 += 1];
        this.valueRange = new PlainValue$5.Range(start, offset2);
        return offset2;
      }
      parse(context2, start) {
        this.context = context2;
        let offset2 = this.parseName(start + 1);
        offset2 = this.parseParameters(offset2);
        offset2 = this.parseComment(offset2);
        this.range = new PlainValue$5.Range(start, offset2);
        return offset2;
      }
    };
    var Document$3 = class extends PlainValue$5.Node {
      static startCommentOrEndBlankLine(src2, start) {
        const offset2 = PlainValue$5.Node.endOfWhiteSpace(src2, start);
        const ch2 = src2[offset2];
        return ch2 === "#" || ch2 === "\n" ? offset2 : start;
      }
      constructor() {
        super(PlainValue$5.Type.DOCUMENT);
        this.directives = null;
        this.contents = null;
        this.directivesEndMarker = null;
        this.documentEndMarker = null;
      }
      parseDirectives(start) {
        const {
          src: src2
        } = this.context;
        this.directives = [];
        let atLineStart = true;
        let hasDirectives = false;
        let offset2 = start;
        while (!PlainValue$5.Node.atDocumentBoundary(src2, offset2, PlainValue$5.Char.DIRECTIVES_END)) {
          offset2 = Document$3.startCommentOrEndBlankLine(src2, offset2);
          switch (src2[offset2]) {
            case "\n":
              if (atLineStart) {
                const blankLine = new BlankLine();
                offset2 = blankLine.parse({
                  src: src2
                }, offset2);
                if (offset2 < src2.length) {
                  this.directives.push(blankLine);
                }
              } else {
                offset2 += 1;
                atLineStart = true;
              }
              break;
            case "#":
              {
                const comment = new Comment();
                offset2 = comment.parse({
                  src: src2
                }, offset2);
                this.directives.push(comment);
                atLineStart = false;
              }
              break;
            case "%":
              {
                const directive = new Directive();
                offset2 = directive.parse({
                  parent: this,
                  src: src2
                }, offset2);
                this.directives.push(directive);
                hasDirectives = true;
                atLineStart = false;
              }
              break;
            default:
              if (hasDirectives) {
                this.error = new PlainValue$5.YAMLSemanticError(this, "Missing directives-end indicator line");
              } else if (this.directives.length > 0) {
                this.contents = this.directives;
                this.directives = [];
              }
              return offset2;
          }
        }
        if (src2[offset2]) {
          this.directivesEndMarker = new PlainValue$5.Range(offset2, offset2 + 3);
          return offset2 + 3;
        }
        if (hasDirectives) {
          this.error = new PlainValue$5.YAMLSemanticError(this, "Missing directives-end indicator line");
        } else if (this.directives.length > 0) {
          this.contents = this.directives;
          this.directives = [];
        }
        return offset2;
      }
      parseContents(start) {
        const {
          parseNode,
          src: src2
        } = this.context;
        if (!this.contents)
          this.contents = [];
        let lineStart = start;
        while (src2[lineStart - 1] === "-")
          lineStart -= 1;
        let offset2 = PlainValue$5.Node.endOfWhiteSpace(src2, start);
        let atLineStart = lineStart === start;
        this.valueRange = new PlainValue$5.Range(offset2);
        while (!PlainValue$5.Node.atDocumentBoundary(src2, offset2, PlainValue$5.Char.DOCUMENT_END)) {
          switch (src2[offset2]) {
            case "\n":
              if (atLineStart) {
                const blankLine = new BlankLine();
                offset2 = blankLine.parse({
                  src: src2
                }, offset2);
                if (offset2 < src2.length) {
                  this.contents.push(blankLine);
                }
              } else {
                offset2 += 1;
                atLineStart = true;
              }
              lineStart = offset2;
              break;
            case "#":
              {
                const comment = new Comment();
                offset2 = comment.parse({
                  src: src2
                }, offset2);
                this.contents.push(comment);
                atLineStart = false;
              }
              break;
            default: {
              const iEnd = PlainValue$5.Node.endOfIndent(src2, offset2);
              const context2 = {
                atLineStart,
                indent: -1,
                inFlow: false,
                inCollection: false,
                lineStart,
                parent: this
              };
              const node2 = parseNode(context2, iEnd);
              if (!node2)
                return this.valueRange.end = iEnd;
              this.contents.push(node2);
              offset2 = node2.range.end;
              atLineStart = false;
              const ec = grabCollectionEndComments(node2);
              if (ec)
                Array.prototype.push.apply(this.contents, ec);
            }
          }
          offset2 = Document$3.startCommentOrEndBlankLine(src2, offset2);
        }
        this.valueRange.end = offset2;
        if (src2[offset2]) {
          this.documentEndMarker = new PlainValue$5.Range(offset2, offset2 + 3);
          offset2 += 3;
          if (src2[offset2]) {
            offset2 = PlainValue$5.Node.endOfWhiteSpace(src2, offset2);
            if (src2[offset2] === "#") {
              const comment = new Comment();
              offset2 = comment.parse({
                src: src2
              }, offset2);
              this.contents.push(comment);
            }
            switch (src2[offset2]) {
              case "\n":
                offset2 += 1;
                break;
              case void 0:
                break;
              default:
                this.error = new PlainValue$5.YAMLSyntaxError(this, "Document end marker line cannot have a non-comment suffix");
            }
          }
        }
        return offset2;
      }
      parse(context2, start) {
        context2.root = this;
        this.context = context2;
        const {
          src: src2
        } = context2;
        let offset2 = src2.charCodeAt(start) === 65279 ? start + 1 : start;
        offset2 = this.parseDirectives(offset2);
        offset2 = this.parseContents(offset2);
        return offset2;
      }
      setOrigRanges(cr2, offset2) {
        offset2 = super.setOrigRanges(cr2, offset2);
        this.directives.forEach((node2) => {
          offset2 = node2.setOrigRanges(cr2, offset2);
        });
        if (this.directivesEndMarker)
          offset2 = this.directivesEndMarker.setOrigRange(cr2, offset2);
        this.contents.forEach((node2) => {
          offset2 = node2.setOrigRanges(cr2, offset2);
        });
        if (this.documentEndMarker)
          offset2 = this.documentEndMarker.setOrigRange(cr2, offset2);
        return offset2;
      }
      toString() {
        const {
          contents,
          directives,
          value
        } = this;
        if (value != null)
          return value;
        let str = directives.join("");
        if (contents.length > 0) {
          if (directives.length > 0 || contents[0].type === PlainValue$5.Type.COMMENT)
            str += "---\n";
          str += contents.join("");
        }
        if (str[str.length - 1] !== "\n")
          str += "\n";
        return str;
      }
    };
    var Alias$1 = class extends PlainValue$5.Node {
      parse(context2, start) {
        this.context = context2;
        const {
          src: src2
        } = context2;
        let offset2 = PlainValue$5.Node.endOfIdentifier(src2, start + 1);
        this.valueRange = new PlainValue$5.Range(start + 1, offset2);
        offset2 = PlainValue$5.Node.endOfWhiteSpace(src2, offset2);
        offset2 = this.parseComment(offset2);
        return offset2;
      }
    };
    var Chomp = {
      CLIP: "CLIP",
      KEEP: "KEEP",
      STRIP: "STRIP"
    };
    var BlockValue = class extends PlainValue$5.Node {
      constructor(type, props) {
        super(type, props);
        this.blockIndent = null;
        this.chomping = Chomp.CLIP;
        this.header = null;
      }
      get includesTrailingLines() {
        return this.chomping === Chomp.KEEP;
      }
      get strValue() {
        if (!this.valueRange || !this.context)
          return null;
        let {
          start,
          end
        } = this.valueRange;
        const {
          indent,
          src: src2
        } = this.context;
        if (this.valueRange.isEmpty())
          return "";
        let lastNewLine = null;
        let ch2 = src2[end - 1];
        while (ch2 === "\n" || ch2 === "	" || ch2 === " ") {
          end -= 1;
          if (end <= start) {
            if (this.chomping === Chomp.KEEP)
              break;
            else
              return "";
          }
          if (ch2 === "\n")
            lastNewLine = end;
          ch2 = src2[end - 1];
        }
        let keepStart = end + 1;
        if (lastNewLine) {
          if (this.chomping === Chomp.KEEP) {
            keepStart = lastNewLine;
            end = this.valueRange.end;
          } else {
            end = lastNewLine;
          }
        }
        const bi2 = indent + this.blockIndent;
        const folded = this.type === PlainValue$5.Type.BLOCK_FOLDED;
        let atStart = true;
        let str = "";
        let sep = "";
        let prevMoreIndented = false;
        for (let i2 = start; i2 < end; ++i2) {
          for (let j2 = 0; j2 < bi2; ++j2) {
            if (src2[i2] !== " ")
              break;
            i2 += 1;
          }
          const ch3 = src2[i2];
          if (ch3 === "\n") {
            if (sep === "\n")
              str += "\n";
            else
              sep = "\n";
          } else {
            const lineEnd = PlainValue$5.Node.endOfLine(src2, i2);
            const line2 = src2.slice(i2, lineEnd);
            i2 = lineEnd;
            if (folded && (ch3 === " " || ch3 === "	") && i2 < keepStart) {
              if (sep === " ")
                sep = "\n";
              else if (!prevMoreIndented && !atStart && sep === "\n")
                sep = "\n\n";
              str += sep + line2;
              sep = lineEnd < end && src2[lineEnd] || "";
              prevMoreIndented = true;
            } else {
              str += sep + line2;
              sep = folded && i2 < keepStart ? " " : "\n";
              prevMoreIndented = false;
            }
            if (atStart && line2 !== "")
              atStart = false;
          }
        }
        return this.chomping === Chomp.STRIP ? str : str + "\n";
      }
      parseBlockHeader(start) {
        const {
          src: src2
        } = this.context;
        let offset2 = start + 1;
        let bi2 = "";
        while (true) {
          const ch2 = src2[offset2];
          switch (ch2) {
            case "-":
              this.chomping = Chomp.STRIP;
              break;
            case "+":
              this.chomping = Chomp.KEEP;
              break;
            case "0":
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
              bi2 += ch2;
              break;
            default:
              this.blockIndent = Number(bi2) || null;
              this.header = new PlainValue$5.Range(start, offset2);
              return offset2;
          }
          offset2 += 1;
        }
      }
      parseBlockValue(start) {
        const {
          indent,
          src: src2
        } = this.context;
        const explicit = !!this.blockIndent;
        let offset2 = start;
        let valueEnd = start;
        let minBlockIndent = 1;
        for (let ch2 = src2[offset2]; ch2 === "\n"; ch2 = src2[offset2]) {
          offset2 += 1;
          if (PlainValue$5.Node.atDocumentBoundary(src2, offset2))
            break;
          const end = PlainValue$5.Node.endOfBlockIndent(src2, indent, offset2);
          if (end === null)
            break;
          const ch3 = src2[end];
          const lineIndent = end - (offset2 + indent);
          if (!this.blockIndent) {
            if (src2[end] !== "\n") {
              if (lineIndent < minBlockIndent) {
                const msg = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
                this.error = new PlainValue$5.YAMLSemanticError(this, msg);
              }
              this.blockIndent = lineIndent;
            } else if (lineIndent > minBlockIndent) {
              minBlockIndent = lineIndent;
            }
          } else if (ch3 && ch3 !== "\n" && lineIndent < this.blockIndent) {
            if (src2[end] === "#")
              break;
            if (!this.error) {
              const src3 = explicit ? "explicit indentation indicator" : "first line";
              const msg = `Block scalars must not be less indented than their ${src3}`;
              this.error = new PlainValue$5.YAMLSemanticError(this, msg);
            }
          }
          if (src2[end] === "\n") {
            offset2 = end;
          } else {
            offset2 = valueEnd = PlainValue$5.Node.endOfLine(src2, end);
          }
        }
        if (this.chomping !== Chomp.KEEP) {
          offset2 = src2[valueEnd] ? valueEnd + 1 : valueEnd;
        }
        this.valueRange = new PlainValue$5.Range(start + 1, offset2);
        return offset2;
      }
      parse(context2, start) {
        this.context = context2;
        const {
          src: src2
        } = context2;
        let offset2 = this.parseBlockHeader(start);
        offset2 = PlainValue$5.Node.endOfWhiteSpace(src2, offset2);
        offset2 = this.parseComment(offset2);
        offset2 = this.parseBlockValue(offset2);
        return offset2;
      }
      setOrigRanges(cr2, offset2) {
        offset2 = super.setOrigRanges(cr2, offset2);
        return this.header ? this.header.setOrigRange(cr2, offset2) : offset2;
      }
    };
    var FlowCollection = class extends PlainValue$5.Node {
      constructor(type, props) {
        super(type, props);
        this.items = null;
      }
      prevNodeIsJsonLike(idx = this.items.length) {
        const node2 = this.items[idx - 1];
        return !!node2 && (node2.jsonLike || node2.type === PlainValue$5.Type.COMMENT && this.prevNodeIsJsonLike(idx - 1));
      }
      parse(context2, start) {
        this.context = context2;
        const {
          parseNode,
          src: src2
        } = context2;
        let {
          indent,
          lineStart
        } = context2;
        let char = src2[start];
        this.items = [{
          char,
          offset: start
        }];
        let offset2 = PlainValue$5.Node.endOfWhiteSpace(src2, start + 1);
        char = src2[offset2];
        while (char && char !== "]" && char !== "}") {
          switch (char) {
            case "\n":
              {
                lineStart = offset2 + 1;
                const wsEnd = PlainValue$5.Node.endOfWhiteSpace(src2, lineStart);
                if (src2[wsEnd] === "\n") {
                  const blankLine = new BlankLine();
                  lineStart = blankLine.parse({
                    src: src2
                  }, lineStart);
                  this.items.push(blankLine);
                }
                offset2 = PlainValue$5.Node.endOfIndent(src2, lineStart);
                if (offset2 <= lineStart + indent) {
                  char = src2[offset2];
                  if (offset2 < lineStart + indent || char !== "]" && char !== "}") {
                    const msg = "Insufficient indentation in flow collection";
                    this.error = new PlainValue$5.YAMLSemanticError(this, msg);
                  }
                }
              }
              break;
            case ",":
              {
                this.items.push({
                  char,
                  offset: offset2
                });
                offset2 += 1;
              }
              break;
            case "#":
              {
                const comment = new Comment();
                offset2 = comment.parse({
                  src: src2
                }, offset2);
                this.items.push(comment);
              }
              break;
            case "?":
            case ":": {
              const next = src2[offset2 + 1];
              if (next === "\n" || next === "	" || next === " " || next === "," || char === ":" && this.prevNodeIsJsonLike()) {
                this.items.push({
                  char,
                  offset: offset2
                });
                offset2 += 1;
                break;
              }
            }
            default: {
              const node2 = parseNode({
                atLineStart: false,
                inCollection: false,
                inFlow: true,
                indent: -1,
                lineStart,
                parent: this
              }, offset2);
              if (!node2) {
                this.valueRange = new PlainValue$5.Range(start, offset2);
                return offset2;
              }
              this.items.push(node2);
              offset2 = PlainValue$5.Node.normalizeOffset(src2, node2.range.end);
            }
          }
          offset2 = PlainValue$5.Node.endOfWhiteSpace(src2, offset2);
          char = src2[offset2];
        }
        this.valueRange = new PlainValue$5.Range(start, offset2 + 1);
        if (char) {
          this.items.push({
            char,
            offset: offset2
          });
          offset2 = PlainValue$5.Node.endOfWhiteSpace(src2, offset2 + 1);
          offset2 = this.parseComment(offset2);
        }
        return offset2;
      }
      setOrigRanges(cr2, offset2) {
        offset2 = super.setOrigRanges(cr2, offset2);
        this.items.forEach((node2) => {
          if (node2 instanceof PlainValue$5.Node) {
            offset2 = node2.setOrigRanges(cr2, offset2);
          } else if (cr2.length === 0) {
            node2.origOffset = node2.offset;
          } else {
            let i2 = offset2;
            while (i2 < cr2.length) {
              if (cr2[i2] > node2.offset)
                break;
              else
                ++i2;
            }
            node2.origOffset = node2.offset + i2;
            offset2 = i2;
          }
        });
        return offset2;
      }
      toString() {
        const {
          context: {
            src: src2
          },
          items,
          range: range2,
          value
        } = this;
        if (value != null)
          return value;
        const nodes = items.filter((item) => item instanceof PlainValue$5.Node);
        let str = "";
        let prevEnd = range2.start;
        nodes.forEach((node2) => {
          const prefix = src2.slice(prevEnd, node2.range.start);
          prevEnd = node2.range.end;
          str += prefix + String(node2);
          if (str[str.length - 1] === "\n" && src2[prevEnd - 1] !== "\n" && src2[prevEnd] === "\n") {
            prevEnd += 1;
          }
        });
        str += src2.slice(prevEnd, range2.end);
        return PlainValue$5.Node.addStringTerminator(src2, range2.end, str);
      }
    };
    var QuoteDouble = class extends PlainValue$5.Node {
      static endOfQuote(src2, offset2) {
        let ch2 = src2[offset2];
        while (ch2 && ch2 !== '"') {
          offset2 += ch2 === "\\" ? 2 : 1;
          ch2 = src2[offset2];
        }
        return offset2 + 1;
      }
      get strValue() {
        if (!this.valueRange || !this.context)
          return null;
        const errors = [];
        const {
          start,
          end
        } = this.valueRange;
        const {
          indent,
          src: src2
        } = this.context;
        if (src2[end - 1] !== '"')
          errors.push(new PlainValue$5.YAMLSyntaxError(this, 'Missing closing "quote'));
        let str = "";
        for (let i2 = start + 1; i2 < end - 1; ++i2) {
          const ch2 = src2[i2];
          if (ch2 === "\n") {
            if (PlainValue$5.Node.atDocumentBoundary(src2, i2 + 1))
              errors.push(new PlainValue$5.YAMLSemanticError(this, "Document boundary indicators are not allowed within string values"));
            const {
              fold,
              offset: offset2,
              error: error2
            } = PlainValue$5.Node.foldNewline(src2, i2, indent);
            str += fold;
            i2 = offset2;
            if (error2)
              errors.push(new PlainValue$5.YAMLSemanticError(this, "Multi-line double-quoted string needs to be sufficiently indented"));
          } else if (ch2 === "\\") {
            i2 += 1;
            switch (src2[i2]) {
              case "0":
                str += "\0";
                break;
              case "a":
                str += "\x07";
                break;
              case "b":
                str += "\b";
                break;
              case "e":
                str += "\x1B";
                break;
              case "f":
                str += "\f";
                break;
              case "n":
                str += "\n";
                break;
              case "r":
                str += "\r";
                break;
              case "t":
                str += "	";
                break;
              case "v":
                str += "\v";
                break;
              case "N":
                str += "\x85";
                break;
              case "_":
                str += "\xA0";
                break;
              case "L":
                str += "\u2028";
                break;
              case "P":
                str += "\u2029";
                break;
              case " ":
                str += " ";
                break;
              case '"':
                str += '"';
                break;
              case "/":
                str += "/";
                break;
              case "\\":
                str += "\\";
                break;
              case "	":
                str += "	";
                break;
              case "x":
                str += this.parseCharCode(i2 + 1, 2, errors);
                i2 += 2;
                break;
              case "u":
                str += this.parseCharCode(i2 + 1, 4, errors);
                i2 += 4;
                break;
              case "U":
                str += this.parseCharCode(i2 + 1, 8, errors);
                i2 += 8;
                break;
              case "\n":
                while (src2[i2 + 1] === " " || src2[i2 + 1] === "	")
                  i2 += 1;
                break;
              default:
                errors.push(new PlainValue$5.YAMLSyntaxError(this, `Invalid escape sequence ${src2.substr(i2 - 1, 2)}`));
                str += "\\" + src2[i2];
            }
          } else if (ch2 === " " || ch2 === "	") {
            const wsStart = i2;
            let next = src2[i2 + 1];
            while (next === " " || next === "	") {
              i2 += 1;
              next = src2[i2 + 1];
            }
            if (next !== "\n")
              str += i2 > wsStart ? src2.slice(wsStart, i2 + 1) : ch2;
          } else {
            str += ch2;
          }
        }
        return errors.length > 0 ? {
          errors,
          str
        } : str;
      }
      parseCharCode(offset2, length, errors) {
        const {
          src: src2
        } = this.context;
        const cc = src2.substr(offset2, length);
        const ok2 = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
        const code = ok2 ? parseInt(cc, 16) : NaN;
        if (isNaN(code)) {
          errors.push(new PlainValue$5.YAMLSyntaxError(this, `Invalid escape sequence ${src2.substr(offset2 - 2, length + 2)}`));
          return src2.substr(offset2 - 2, length + 2);
        }
        return String.fromCodePoint(code);
      }
      parse(context2, start) {
        this.context = context2;
        const {
          src: src2
        } = context2;
        let offset2 = QuoteDouble.endOfQuote(src2, start + 1);
        this.valueRange = new PlainValue$5.Range(start, offset2);
        offset2 = PlainValue$5.Node.endOfWhiteSpace(src2, offset2);
        offset2 = this.parseComment(offset2);
        return offset2;
      }
    };
    var QuoteSingle = class extends PlainValue$5.Node {
      static endOfQuote(src2, offset2) {
        let ch2 = src2[offset2];
        while (ch2) {
          if (ch2 === "'") {
            if (src2[offset2 + 1] !== "'")
              break;
            ch2 = src2[offset2 += 2];
          } else {
            ch2 = src2[offset2 += 1];
          }
        }
        return offset2 + 1;
      }
      get strValue() {
        if (!this.valueRange || !this.context)
          return null;
        const errors = [];
        const {
          start,
          end
        } = this.valueRange;
        const {
          indent,
          src: src2
        } = this.context;
        if (src2[end - 1] !== "'")
          errors.push(new PlainValue$5.YAMLSyntaxError(this, "Missing closing 'quote"));
        let str = "";
        for (let i2 = start + 1; i2 < end - 1; ++i2) {
          const ch2 = src2[i2];
          if (ch2 === "\n") {
            if (PlainValue$5.Node.atDocumentBoundary(src2, i2 + 1))
              errors.push(new PlainValue$5.YAMLSemanticError(this, "Document boundary indicators are not allowed within string values"));
            const {
              fold,
              offset: offset2,
              error: error2
            } = PlainValue$5.Node.foldNewline(src2, i2, indent);
            str += fold;
            i2 = offset2;
            if (error2)
              errors.push(new PlainValue$5.YAMLSemanticError(this, "Multi-line single-quoted string needs to be sufficiently indented"));
          } else if (ch2 === "'") {
            str += ch2;
            i2 += 1;
            if (src2[i2] !== "'")
              errors.push(new PlainValue$5.YAMLSyntaxError(this, "Unescaped single quote? This should not happen."));
          } else if (ch2 === " " || ch2 === "	") {
            const wsStart = i2;
            let next = src2[i2 + 1];
            while (next === " " || next === "	") {
              i2 += 1;
              next = src2[i2 + 1];
            }
            if (next !== "\n")
              str += i2 > wsStart ? src2.slice(wsStart, i2 + 1) : ch2;
          } else {
            str += ch2;
          }
        }
        return errors.length > 0 ? {
          errors,
          str
        } : str;
      }
      parse(context2, start) {
        this.context = context2;
        const {
          src: src2
        } = context2;
        let offset2 = QuoteSingle.endOfQuote(src2, start + 1);
        this.valueRange = new PlainValue$5.Range(start, offset2);
        offset2 = PlainValue$5.Node.endOfWhiteSpace(src2, offset2);
        offset2 = this.parseComment(offset2);
        return offset2;
      }
    };
    function createNewNode(type, props) {
      switch (type) {
        case PlainValue$5.Type.ALIAS:
          return new Alias$1(type, props);
        case PlainValue$5.Type.BLOCK_FOLDED:
        case PlainValue$5.Type.BLOCK_LITERAL:
          return new BlockValue(type, props);
        case PlainValue$5.Type.FLOW_MAP:
        case PlainValue$5.Type.FLOW_SEQ:
          return new FlowCollection(type, props);
        case PlainValue$5.Type.MAP_KEY:
        case PlainValue$5.Type.MAP_VALUE:
        case PlainValue$5.Type.SEQ_ITEM:
          return new CollectionItem(type, props);
        case PlainValue$5.Type.COMMENT:
        case PlainValue$5.Type.PLAIN:
          return new PlainValue$5.PlainValue(type, props);
        case PlainValue$5.Type.QUOTE_DOUBLE:
          return new QuoteDouble(type, props);
        case PlainValue$5.Type.QUOTE_SINGLE:
          return new QuoteSingle(type, props);
        default:
          return null;
      }
    }
    var ParseContext = class {
      static parseType(src2, offset2, inFlow) {
        switch (src2[offset2]) {
          case "*":
            return PlainValue$5.Type.ALIAS;
          case ">":
            return PlainValue$5.Type.BLOCK_FOLDED;
          case "|":
            return PlainValue$5.Type.BLOCK_LITERAL;
          case "{":
            return PlainValue$5.Type.FLOW_MAP;
          case "[":
            return PlainValue$5.Type.FLOW_SEQ;
          case "?":
            return !inFlow && PlainValue$5.Node.atBlank(src2, offset2 + 1, true) ? PlainValue$5.Type.MAP_KEY : PlainValue$5.Type.PLAIN;
          case ":":
            return !inFlow && PlainValue$5.Node.atBlank(src2, offset2 + 1, true) ? PlainValue$5.Type.MAP_VALUE : PlainValue$5.Type.PLAIN;
          case "-":
            return !inFlow && PlainValue$5.Node.atBlank(src2, offset2 + 1, true) ? PlainValue$5.Type.SEQ_ITEM : PlainValue$5.Type.PLAIN;
          case '"':
            return PlainValue$5.Type.QUOTE_DOUBLE;
          case "'":
            return PlainValue$5.Type.QUOTE_SINGLE;
          default:
            return PlainValue$5.Type.PLAIN;
        }
      }
      constructor(orig = {}, {
        atLineStart,
        inCollection,
        inFlow,
        indent,
        lineStart,
        parent
      } = {}) {
        PlainValue$5._defineProperty(this, "parseNode", (overlay, start) => {
          if (PlainValue$5.Node.atDocumentBoundary(this.src, start))
            return null;
          const context2 = new ParseContext(this, overlay);
          const {
            props,
            type,
            valueStart
          } = context2.parseProps(start);
          const node2 = createNewNode(type, props);
          let offset2 = node2.parse(context2, valueStart);
          node2.range = new PlainValue$5.Range(start, offset2);
          if (offset2 <= start) {
            node2.error = new Error(`Node#parse consumed no characters`);
            node2.error.parseEnd = offset2;
            node2.error.source = node2;
            node2.range.end = start + 1;
          }
          if (context2.nodeStartsCollection(node2)) {
            if (!node2.error && !context2.atLineStart && context2.parent.type === PlainValue$5.Type.DOCUMENT) {
              node2.error = new PlainValue$5.YAMLSyntaxError(node2, "Block collection must not have preceding content here (e.g. directives-end indicator)");
            }
            const collection = new Collection$1(node2);
            offset2 = collection.parse(new ParseContext(context2), offset2);
            collection.range = new PlainValue$5.Range(start, offset2);
            return collection;
          }
          return node2;
        });
        this.atLineStart = atLineStart != null ? atLineStart : orig.atLineStart || false;
        this.inCollection = inCollection != null ? inCollection : orig.inCollection || false;
        this.inFlow = inFlow != null ? inFlow : orig.inFlow || false;
        this.indent = indent != null ? indent : orig.indent;
        this.lineStart = lineStart != null ? lineStart : orig.lineStart;
        this.parent = parent != null ? parent : orig.parent || {};
        this.root = orig.root;
        this.src = orig.src;
      }
      nodeStartsCollection(node2) {
        const {
          inCollection,
          inFlow,
          src: src2
        } = this;
        if (inCollection || inFlow)
          return false;
        if (node2 instanceof CollectionItem)
          return true;
        let offset2 = node2.range.end;
        if (src2[offset2] === "\n" || src2[offset2 - 1] === "\n")
          return false;
        offset2 = PlainValue$5.Node.endOfWhiteSpace(src2, offset2);
        return src2[offset2] === ":";
      }
      parseProps(offset2) {
        const {
          inFlow,
          parent,
          src: src2
        } = this;
        const props = [];
        let lineHasProps = false;
        offset2 = this.atLineStart ? PlainValue$5.Node.endOfIndent(src2, offset2) : PlainValue$5.Node.endOfWhiteSpace(src2, offset2);
        let ch2 = src2[offset2];
        while (ch2 === PlainValue$5.Char.ANCHOR || ch2 === PlainValue$5.Char.COMMENT || ch2 === PlainValue$5.Char.TAG || ch2 === "\n") {
          if (ch2 === "\n") {
            let inEnd = offset2;
            let lineStart;
            do {
              lineStart = inEnd + 1;
              inEnd = PlainValue$5.Node.endOfIndent(src2, lineStart);
            } while (src2[inEnd] === "\n");
            const indentDiff = inEnd - (lineStart + this.indent);
            const noIndicatorAsIndent = parent.type === PlainValue$5.Type.SEQ_ITEM && parent.context.atLineStart;
            if (src2[inEnd] !== "#" && !PlainValue$5.Node.nextNodeIsIndented(src2[inEnd], indentDiff, !noIndicatorAsIndent))
              break;
            this.atLineStart = true;
            this.lineStart = lineStart;
            lineHasProps = false;
            offset2 = inEnd;
          } else if (ch2 === PlainValue$5.Char.COMMENT) {
            const end = PlainValue$5.Node.endOfLine(src2, offset2 + 1);
            props.push(new PlainValue$5.Range(offset2, end));
            offset2 = end;
          } else {
            let end = PlainValue$5.Node.endOfIdentifier(src2, offset2 + 1);
            if (ch2 === PlainValue$5.Char.TAG && src2[end] === "," && /^[a-zA-Z0-9-]+\.[a-zA-Z0-9-]+,\d\d\d\d(-\d\d){0,2}\/\S/.test(src2.slice(offset2 + 1, end + 13))) {
              end = PlainValue$5.Node.endOfIdentifier(src2, end + 5);
            }
            props.push(new PlainValue$5.Range(offset2, end));
            lineHasProps = true;
            offset2 = PlainValue$5.Node.endOfWhiteSpace(src2, end);
          }
          ch2 = src2[offset2];
        }
        if (lineHasProps && ch2 === ":" && PlainValue$5.Node.atBlank(src2, offset2 + 1, true))
          offset2 -= 1;
        const type = ParseContext.parseType(src2, offset2, inFlow);
        return {
          props,
          type,
          valueStart: offset2
        };
      }
    };
    function parse$g(src2) {
      const cr2 = [];
      if (src2.indexOf("\r") !== -1) {
        src2 = src2.replace(/\r\n?/g, (match2, offset3) => {
          if (match2.length > 1)
            cr2.push(offset3);
          return "\n";
        });
      }
      const documents = [];
      let offset2 = 0;
      do {
        const doc = new Document$3();
        const context2 = new ParseContext({
          src: src2
        });
        offset2 = doc.parse(context2, offset2);
        documents.push(doc);
      } while (offset2 < src2.length);
      documents.setOrigRanges = () => {
        if (cr2.length === 0)
          return false;
        for (let i2 = 1; i2 < cr2.length; ++i2)
          cr2[i2] -= i2;
        let crOffset = 0;
        for (let i2 = 0; i2 < documents.length; ++i2) {
          crOffset = documents[i2].setOrigRanges(cr2, crOffset);
        }
        cr2.splice(0, cr2.length);
        return true;
      };
      documents.toString = () => documents.join("...\n");
      return documents;
    }
    parseCst$1.parse = parse$g;
    var Document9b4560a1 = {};
    var resolveSeqD03cb037 = {};
    var PlainValue$4 = PlainValueEc8e588e;
    function addCommentBefore(str, indent, comment) {
      if (!comment)
        return str;
      const cc = comment.replace(/[\s\S]^/gm, `$&${indent}#`);
      return `#${cc}
${indent}${str}`;
    }
    function addComment(str, indent, comment) {
      return !comment ? str : comment.indexOf("\n") === -1 ? `${str} #${comment}` : `${str}
` + comment.replace(/^/gm, `${indent || ""}#`);
    }
    var Node$1 = class {
    };
    function toJSON(value, arg, ctx) {
      if (Array.isArray(value))
        return value.map((v2, i2) => toJSON(v2, String(i2), ctx));
      if (value && typeof value.toJSON === "function") {
        const anchor = ctx && ctx.anchors && ctx.anchors.get(value);
        if (anchor)
          ctx.onCreate = (res2) => {
            anchor.res = res2;
            delete ctx.onCreate;
          };
        const res = value.toJSON(arg, ctx);
        if (anchor && ctx.onCreate)
          ctx.onCreate(res);
        return res;
      }
      if ((!ctx || !ctx.keep) && typeof value === "bigint")
        return Number(value);
      return value;
    }
    var Scalar = class extends Node$1 {
      constructor(value) {
        super();
        this.value = value;
      }
      toJSON(arg, ctx) {
        return ctx && ctx.keep ? this.value : toJSON(this.value, arg, ctx);
      }
      toString() {
        return String(this.value);
      }
    };
    function collectionFromPath(schema, path2, value) {
      let v2 = value;
      for (let i2 = path2.length - 1; i2 >= 0; --i2) {
        const k2 = path2[i2];
        if (Number.isInteger(k2) && k2 >= 0) {
          const a2 = [];
          a2[k2] = v2;
          v2 = a2;
        } else {
          const o2 = {};
          Object.defineProperty(o2, k2, {
            value: v2,
            writable: true,
            enumerable: true,
            configurable: true
          });
          v2 = o2;
        }
      }
      return schema.createNode(v2, false);
    }
    var isEmptyPath = (path2) => path2 == null || typeof path2 === "object" && path2[Symbol.iterator]().next().done;
    var Collection = class extends Node$1 {
      constructor(schema) {
        super();
        PlainValue$4._defineProperty(this, "items", []);
        this.schema = schema;
      }
      addIn(path2, value) {
        if (isEmptyPath(path2))
          this.add(value);
        else {
          const [key2, ...rest] = path2;
          const node2 = this.get(key2, true);
          if (node2 instanceof Collection)
            node2.addIn(rest, value);
          else if (node2 === void 0 && this.schema)
            this.set(key2, collectionFromPath(this.schema, rest, value));
          else
            throw new Error(`Expected YAML collection at ${key2}. Remaining path: ${rest}`);
        }
      }
      deleteIn([key2, ...rest]) {
        if (rest.length === 0)
          return this.delete(key2);
        const node2 = this.get(key2, true);
        if (node2 instanceof Collection)
          return node2.deleteIn(rest);
        else
          throw new Error(`Expected YAML collection at ${key2}. Remaining path: ${rest}`);
      }
      getIn([key2, ...rest], keepScalar) {
        const node2 = this.get(key2, true);
        if (rest.length === 0)
          return !keepScalar && node2 instanceof Scalar ? node2.value : node2;
        else
          return node2 instanceof Collection ? node2.getIn(rest, keepScalar) : void 0;
      }
      hasAllNullValues() {
        return this.items.every((node2) => {
          if (!node2 || node2.type !== "PAIR")
            return false;
          const n3 = node2.value;
          return n3 == null || n3 instanceof Scalar && n3.value == null && !n3.commentBefore && !n3.comment && !n3.tag;
        });
      }
      hasIn([key2, ...rest]) {
        if (rest.length === 0)
          return this.has(key2);
        const node2 = this.get(key2, true);
        return node2 instanceof Collection ? node2.hasIn(rest) : false;
      }
      setIn([key2, ...rest], value) {
        if (rest.length === 0) {
          this.set(key2, value);
        } else {
          const node2 = this.get(key2, true);
          if (node2 instanceof Collection)
            node2.setIn(rest, value);
          else if (node2 === void 0 && this.schema)
            this.set(key2, collectionFromPath(this.schema, rest, value));
          else
            throw new Error(`Expected YAML collection at ${key2}. Remaining path: ${rest}`);
        }
      }
      toJSON() {
        return null;
      }
      toString(ctx, {
        blockItem,
        flowChars,
        isMap,
        itemIndent
      }, onComment, onChompKeep) {
        const {
          indent,
          indentStep,
          stringify: stringify2
        } = ctx;
        const inFlow = this.type === PlainValue$4.Type.FLOW_MAP || this.type === PlainValue$4.Type.FLOW_SEQ || ctx.inFlow;
        if (inFlow)
          itemIndent += indentStep;
        const allNullValues = isMap && this.hasAllNullValues();
        ctx = Object.assign({}, ctx, {
          allNullValues,
          indent: itemIndent,
          inFlow,
          type: null
        });
        let chompKeep = false;
        let hasItemWithNewLine = false;
        const nodes = this.items.reduce((nodes2, item, i2) => {
          let comment;
          if (item) {
            if (!chompKeep && item.spaceBefore)
              nodes2.push({
                type: "comment",
                str: ""
              });
            if (item.commentBefore)
              item.commentBefore.match(/^.*$/gm).forEach((line2) => {
                nodes2.push({
                  type: "comment",
                  str: `#${line2}`
                });
              });
            if (item.comment)
              comment = item.comment;
            if (inFlow && (!chompKeep && item.spaceBefore || item.commentBefore || item.comment || item.key && (item.key.commentBefore || item.key.comment) || item.value && (item.value.commentBefore || item.value.comment)))
              hasItemWithNewLine = true;
          }
          chompKeep = false;
          let str2 = stringify2(item, ctx, () => comment = null, () => chompKeep = true);
          if (inFlow && !hasItemWithNewLine && str2.includes("\n"))
            hasItemWithNewLine = true;
          if (inFlow && i2 < this.items.length - 1)
            str2 += ",";
          str2 = addComment(str2, itemIndent, comment);
          if (chompKeep && (comment || inFlow))
            chompKeep = false;
          nodes2.push({
            type: "item",
            str: str2
          });
          return nodes2;
        }, []);
        let str;
        if (nodes.length === 0) {
          str = flowChars.start + flowChars.end;
        } else if (inFlow) {
          const {
            start,
            end
          } = flowChars;
          const strings = nodes.map((n3) => n3.str);
          if (hasItemWithNewLine || strings.reduce((sum, str2) => sum + str2.length + 2, 2) > Collection.maxFlowStringSingleLineLength) {
            str = start;
            for (const s2 of strings) {
              str += s2 ? `
${indentStep}${indent}${s2}` : "\n";
            }
            str += `
${indent}${end}`;
          } else {
            str = `${start} ${strings.join(" ")} ${end}`;
          }
        } else {
          const strings = nodes.map(blockItem);
          str = strings.shift();
          for (const s2 of strings)
            str += s2 ? `
${indent}${s2}` : "\n";
        }
        if (this.comment) {
          str += "\n" + this.comment.replace(/^/gm, `${indent}#`);
          if (onComment)
            onComment();
        } else if (chompKeep && onChompKeep)
          onChompKeep();
        return str;
      }
    };
    PlainValue$4._defineProperty(Collection, "maxFlowStringSingleLineLength", 60);
    function asItemIndex(key2) {
      let idx = key2 instanceof Scalar ? key2.value : key2;
      if (idx && typeof idx === "string")
        idx = Number(idx);
      return Number.isInteger(idx) && idx >= 0 ? idx : null;
    }
    var YAMLSeq = class extends Collection {
      add(value) {
        this.items.push(value);
      }
      delete(key2) {
        const idx = asItemIndex(key2);
        if (typeof idx !== "number")
          return false;
        const del = this.items.splice(idx, 1);
        return del.length > 0;
      }
      get(key2, keepScalar) {
        const idx = asItemIndex(key2);
        if (typeof idx !== "number")
          return void 0;
        const it2 = this.items[idx];
        return !keepScalar && it2 instanceof Scalar ? it2.value : it2;
      }
      has(key2) {
        const idx = asItemIndex(key2);
        return typeof idx === "number" && idx < this.items.length;
      }
      set(key2, value) {
        const idx = asItemIndex(key2);
        if (typeof idx !== "number")
          throw new Error(`Expected a valid index, not ${key2}.`);
        this.items[idx] = value;
      }
      toJSON(_2, ctx) {
        const seq2 = [];
        if (ctx && ctx.onCreate)
          ctx.onCreate(seq2);
        let i2 = 0;
        for (const item of this.items)
          seq2.push(toJSON(item, String(i2++), ctx));
        return seq2;
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        return super.toString(ctx, {
          blockItem: (n3) => n3.type === "comment" ? n3.str : `- ${n3.str}`,
          flowChars: {
            start: "[",
            end: "]"
          },
          isMap: false,
          itemIndent: (ctx.indent || "") + "  "
        }, onComment, onChompKeep);
      }
    };
    var stringifyKey = (key2, jsKey, ctx) => {
      if (jsKey === null)
        return "";
      if (typeof jsKey !== "object")
        return String(jsKey);
      if (key2 instanceof Node$1 && ctx && ctx.doc)
        return key2.toString({
          anchors: /* @__PURE__ */ Object.create(null),
          doc: ctx.doc,
          indent: "",
          indentStep: ctx.indentStep,
          inFlow: true,
          inStringifyKey: true,
          stringify: ctx.stringify
        });
      return JSON.stringify(jsKey);
    };
    var Pair = class extends Node$1 {
      constructor(key2, value = null) {
        super();
        this.key = key2;
        this.value = value;
        this.type = Pair.Type.PAIR;
      }
      get commentBefore() {
        return this.key instanceof Node$1 ? this.key.commentBefore : void 0;
      }
      set commentBefore(cb) {
        if (this.key == null)
          this.key = new Scalar(null);
        if (this.key instanceof Node$1)
          this.key.commentBefore = cb;
        else {
          const msg = "Pair.commentBefore is an alias for Pair.key.commentBefore. To set it, the key must be a Node.";
          throw new Error(msg);
        }
      }
      addToJSMap(ctx, map2) {
        const key2 = toJSON(this.key, "", ctx);
        if (map2 instanceof Map) {
          const value = toJSON(this.value, key2, ctx);
          map2.set(key2, value);
        } else if (map2 instanceof Set) {
          map2.add(key2);
        } else {
          const stringKey = stringifyKey(this.key, key2, ctx);
          const value = toJSON(this.value, stringKey, ctx);
          if (stringKey in map2)
            Object.defineProperty(map2, stringKey, {
              value,
              writable: true,
              enumerable: true,
              configurable: true
            });
          else
            map2[stringKey] = value;
        }
        return map2;
      }
      toJSON(_2, ctx) {
        const pair = ctx && ctx.mapAsMap ? /* @__PURE__ */ new Map() : {};
        return this.addToJSMap(ctx, pair);
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx || !ctx.doc)
          return JSON.stringify(this);
        const {
          indent: indentSize,
          indentSeq,
          simpleKeys
        } = ctx.doc.options;
        let {
          key: key2,
          value
        } = this;
        let keyComment = key2 instanceof Node$1 && key2.comment;
        if (simpleKeys) {
          if (keyComment) {
            throw new Error("With simple keys, key nodes cannot have comments");
          }
          if (key2 instanceof Collection) {
            const msg = "With simple keys, collection cannot be used as a key value";
            throw new Error(msg);
          }
        }
        let explicitKey = !simpleKeys && (!key2 || keyComment || (key2 instanceof Node$1 ? key2 instanceof Collection || key2.type === PlainValue$4.Type.BLOCK_FOLDED || key2.type === PlainValue$4.Type.BLOCK_LITERAL : typeof key2 === "object"));
        const {
          doc,
          indent,
          indentStep,
          stringify: stringify2
        } = ctx;
        ctx = Object.assign({}, ctx, {
          implicitKey: !explicitKey,
          indent: indent + indentStep
        });
        let chompKeep = false;
        let str = stringify2(key2, ctx, () => keyComment = null, () => chompKeep = true);
        str = addComment(str, ctx.indent, keyComment);
        if (!explicitKey && str.length > 1024) {
          if (simpleKeys)
            throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
          explicitKey = true;
        }
        if (ctx.allNullValues && !simpleKeys) {
          if (this.comment) {
            str = addComment(str, ctx.indent, this.comment);
            if (onComment)
              onComment();
          } else if (chompKeep && !keyComment && onChompKeep)
            onChompKeep();
          return ctx.inFlow && !explicitKey ? str : `? ${str}`;
        }
        str = explicitKey ? `? ${str}
${indent}:` : `${str}:`;
        if (this.comment) {
          str = addComment(str, ctx.indent, this.comment);
          if (onComment)
            onComment();
        }
        let vcb = "";
        let valueComment = null;
        if (value instanceof Node$1) {
          if (value.spaceBefore)
            vcb = "\n";
          if (value.commentBefore) {
            const cs2 = value.commentBefore.replace(/^/gm, `${ctx.indent}#`);
            vcb += `
${cs2}`;
          }
          valueComment = value.comment;
        } else if (value && typeof value === "object") {
          value = doc.schema.createNode(value, true);
        }
        ctx.implicitKey = false;
        if (!explicitKey && !this.comment && value instanceof Scalar)
          ctx.indentAtStart = str.length + 1;
        chompKeep = false;
        if (!indentSeq && indentSize >= 2 && !ctx.inFlow && !explicitKey && value instanceof YAMLSeq && value.type !== PlainValue$4.Type.FLOW_SEQ && !value.tag && !doc.anchors.getName(value)) {
          ctx.indent = ctx.indent.substr(2);
        }
        const valueStr = stringify2(value, ctx, () => valueComment = null, () => chompKeep = true);
        let ws2 = " ";
        if (vcb || this.comment) {
          ws2 = `${vcb}
${ctx.indent}`;
        } else if (!explicitKey && value instanceof Collection) {
          const flow = valueStr[0] === "[" || valueStr[0] === "{";
          if (!flow || valueStr.includes("\n"))
            ws2 = `
${ctx.indent}`;
        } else if (valueStr[0] === "\n")
          ws2 = "";
        if (chompKeep && !valueComment && onChompKeep)
          onChompKeep();
        return addComment(str + ws2 + valueStr, ctx.indent, valueComment);
      }
    };
    PlainValue$4._defineProperty(Pair, "Type", {
      PAIR: "PAIR",
      MERGE_PAIR: "MERGE_PAIR"
    });
    var getAliasCount = (node2, anchors) => {
      if (node2 instanceof Alias) {
        const anchor = anchors.get(node2.source);
        return anchor.count * anchor.aliasCount;
      } else if (node2 instanceof Collection) {
        let count = 0;
        for (const item of node2.items) {
          const c3 = getAliasCount(item, anchors);
          if (c3 > count)
            count = c3;
        }
        return count;
      } else if (node2 instanceof Pair) {
        const kc = getAliasCount(node2.key, anchors);
        const vc = getAliasCount(node2.value, anchors);
        return Math.max(kc, vc);
      }
      return 1;
    };
    var Alias = class extends Node$1 {
      static stringify({
        range: range2,
        source: source2
      }, {
        anchors,
        doc,
        implicitKey,
        inStringifyKey
      }) {
        let anchor = Object.keys(anchors).find((a2) => anchors[a2] === source2);
        if (!anchor && inStringifyKey)
          anchor = doc.anchors.getName(source2) || doc.anchors.newName();
        if (anchor)
          return `*${anchor}${implicitKey ? " " : ""}`;
        const msg = doc.anchors.getName(source2) ? "Alias node must be after source node" : "Source node not found for alias node";
        throw new Error(`${msg} [${range2}]`);
      }
      constructor(source2) {
        super();
        this.source = source2;
        this.type = PlainValue$4.Type.ALIAS;
      }
      set tag(t) {
        throw new Error("Alias nodes cannot have tags");
      }
      toJSON(arg, ctx) {
        if (!ctx)
          return toJSON(this.source, arg, ctx);
        const {
          anchors,
          maxAliasCount
        } = ctx;
        const anchor = anchors.get(this.source);
        if (!anchor || anchor.res === void 0) {
          const msg = "This should not happen: Alias anchor was not resolved?";
          if (this.cstNode)
            throw new PlainValue$4.YAMLReferenceError(this.cstNode, msg);
          else
            throw new ReferenceError(msg);
        }
        if (maxAliasCount >= 0) {
          anchor.count += 1;
          if (anchor.aliasCount === 0)
            anchor.aliasCount = getAliasCount(this.source, anchors);
          if (anchor.count * anchor.aliasCount > maxAliasCount) {
            const msg = "Excessive alias count indicates a resource exhaustion attack";
            if (this.cstNode)
              throw new PlainValue$4.YAMLReferenceError(this.cstNode, msg);
            else
              throw new ReferenceError(msg);
          }
        }
        return anchor.res;
      }
      toString(ctx) {
        return Alias.stringify(this, ctx);
      }
    };
    PlainValue$4._defineProperty(Alias, "default", true);
    function findPair(items, key2) {
      const k2 = key2 instanceof Scalar ? key2.value : key2;
      for (const it2 of items) {
        if (it2 instanceof Pair) {
          if (it2.key === key2 || it2.key === k2)
            return it2;
          if (it2.key && it2.key.value === k2)
            return it2;
        }
      }
      return void 0;
    }
    var YAMLMap = class extends Collection {
      add(pair, overwrite) {
        if (!pair)
          pair = new Pair(pair);
        else if (!(pair instanceof Pair))
          pair = new Pair(pair.key || pair, pair.value);
        const prev = findPair(this.items, pair.key);
        const sortEntries = this.schema && this.schema.sortMapEntries;
        if (prev) {
          if (overwrite)
            prev.value = pair.value;
          else
            throw new Error(`Key ${pair.key} already set`);
        } else if (sortEntries) {
          const i2 = this.items.findIndex((item) => sortEntries(pair, item) < 0);
          if (i2 === -1)
            this.items.push(pair);
          else
            this.items.splice(i2, 0, pair);
        } else {
          this.items.push(pair);
        }
      }
      delete(key2) {
        const it2 = findPair(this.items, key2);
        if (!it2)
          return false;
        const del = this.items.splice(this.items.indexOf(it2), 1);
        return del.length > 0;
      }
      get(key2, keepScalar) {
        const it2 = findPair(this.items, key2);
        const node2 = it2 && it2.value;
        return !keepScalar && node2 instanceof Scalar ? node2.value : node2;
      }
      has(key2) {
        return !!findPair(this.items, key2);
      }
      set(key2, value) {
        this.add(new Pair(key2, value), true);
      }
      toJSON(_2, ctx, Type2) {
        const map2 = Type2 ? new Type2() : ctx && ctx.mapAsMap ? /* @__PURE__ */ new Map() : {};
        if (ctx && ctx.onCreate)
          ctx.onCreate(map2);
        for (const item of this.items)
          item.addToJSMap(ctx, map2);
        return map2;
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        for (const item of this.items) {
          if (!(item instanceof Pair))
            throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
        }
        return super.toString(ctx, {
          blockItem: (n3) => n3.str,
          flowChars: {
            start: "{",
            end: "}"
          },
          isMap: true,
          itemIndent: ctx.indent || ""
        }, onComment, onChompKeep);
      }
    };
    var MERGE_KEY = "<<";
    var Merge = class extends Pair {
      constructor(pair) {
        if (pair instanceof Pair) {
          let seq2 = pair.value;
          if (!(seq2 instanceof YAMLSeq)) {
            seq2 = new YAMLSeq();
            seq2.items.push(pair.value);
            seq2.range = pair.value.range;
          }
          super(pair.key, seq2);
          this.range = pair.range;
        } else {
          super(new Scalar(MERGE_KEY), new YAMLSeq());
        }
        this.type = Pair.Type.MERGE_PAIR;
      }
      addToJSMap(ctx, map2) {
        for (const {
          source: source2
        } of this.value.items) {
          if (!(source2 instanceof YAMLMap))
            throw new Error("Merge sources must be maps");
          const srcMap = source2.toJSON(null, ctx, Map);
          for (const [key2, value] of srcMap) {
            if (map2 instanceof Map) {
              if (!map2.has(key2))
                map2.set(key2, value);
            } else if (map2 instanceof Set) {
              map2.add(key2);
            } else if (!Object.prototype.hasOwnProperty.call(map2, key2)) {
              Object.defineProperty(map2, key2, {
                value,
                writable: true,
                enumerable: true,
                configurable: true
              });
            }
          }
        }
        return map2;
      }
      toString(ctx, onComment) {
        const seq2 = this.value;
        if (seq2.items.length > 1)
          return super.toString(ctx, onComment);
        this.value = seq2.items[0];
        const str = super.toString(ctx, onComment);
        this.value = seq2;
        return str;
      }
    };
    var binaryOptions = {
      defaultType: PlainValue$4.Type.BLOCK_LITERAL,
      lineWidth: 76
    };
    var boolOptions = {
      trueStr: "true",
      falseStr: "false"
    };
    var intOptions = {
      asBigInt: false
    };
    var nullOptions = {
      nullStr: "null"
    };
    var strOptions = {
      defaultType: PlainValue$4.Type.PLAIN,
      doubleQuoted: {
        jsonEncoding: false,
        minMultiLineLength: 40
      },
      fold: {
        lineWidth: 80,
        minContentWidth: 20
      }
    };
    function resolveScalar(str, tags2, scalarFallback) {
      for (const {
        format: format2,
        test,
        resolve: resolve2
      } of tags2) {
        if (test) {
          const match2 = str.match(test);
          if (match2) {
            let res = resolve2.apply(null, match2);
            if (!(res instanceof Scalar))
              res = new Scalar(res);
            if (format2)
              res.format = format2;
            return res;
          }
        }
      }
      if (scalarFallback)
        str = scalarFallback(str);
      return new Scalar(str);
    }
    var FOLD_FLOW = "flow";
    var FOLD_BLOCK = "block";
    var FOLD_QUOTED = "quoted";
    var consumeMoreIndentedLines = (text, i2) => {
      let ch2 = text[i2 + 1];
      while (ch2 === " " || ch2 === "	") {
        do {
          ch2 = text[i2 += 1];
        } while (ch2 && ch2 !== "\n");
        ch2 = text[i2 + 1];
      }
      return i2;
    };
    function foldFlowLines(text, indent, mode2, {
      indentAtStart,
      lineWidth = 80,
      minContentWidth = 20,
      onFold,
      onOverflow
    }) {
      if (!lineWidth || lineWidth < 0)
        return text;
      const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
      if (text.length <= endStep)
        return text;
      const folds = [];
      const escapedFolds = {};
      let end = lineWidth - indent.length;
      if (typeof indentAtStart === "number") {
        if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
          folds.push(0);
        else
          end = lineWidth - indentAtStart;
      }
      let split2 = void 0;
      let prev = void 0;
      let overflow = false;
      let i2 = -1;
      let escStart = -1;
      let escEnd = -1;
      if (mode2 === FOLD_BLOCK) {
        i2 = consumeMoreIndentedLines(text, i2);
        if (i2 !== -1)
          end = i2 + endStep;
      }
      for (let ch2; ch2 = text[i2 += 1]; ) {
        if (mode2 === FOLD_QUOTED && ch2 === "\\") {
          escStart = i2;
          switch (text[i2 + 1]) {
            case "x":
              i2 += 3;
              break;
            case "u":
              i2 += 5;
              break;
            case "U":
              i2 += 9;
              break;
            default:
              i2 += 1;
          }
          escEnd = i2;
        }
        if (ch2 === "\n") {
          if (mode2 === FOLD_BLOCK)
            i2 = consumeMoreIndentedLines(text, i2);
          end = i2 + endStep;
          split2 = void 0;
        } else {
          if (ch2 === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
            const next = text[i2 + 1];
            if (next && next !== " " && next !== "\n" && next !== "	")
              split2 = i2;
          }
          if (i2 >= end) {
            if (split2) {
              folds.push(split2);
              end = split2 + endStep;
              split2 = void 0;
            } else if (mode2 === FOLD_QUOTED) {
              while (prev === " " || prev === "	") {
                prev = ch2;
                ch2 = text[i2 += 1];
                overflow = true;
              }
              const j2 = i2 > escEnd + 1 ? i2 - 2 : escStart - 1;
              if (escapedFolds[j2])
                return text;
              folds.push(j2);
              escapedFolds[j2] = true;
              end = j2 + endStep;
              split2 = void 0;
            } else {
              overflow = true;
            }
          }
        }
        prev = ch2;
      }
      if (overflow && onOverflow)
        onOverflow();
      if (folds.length === 0)
        return text;
      if (onFold)
        onFold();
      let res = text.slice(0, folds[0]);
      for (let i3 = 0; i3 < folds.length; ++i3) {
        const fold = folds[i3];
        const end2 = folds[i3 + 1] || text.length;
        if (fold === 0)
          res = `
${indent}${text.slice(0, end2)}`;
        else {
          if (mode2 === FOLD_QUOTED && escapedFolds[fold])
            res += `${text[fold]}\\`;
          res += `
${indent}${text.slice(fold + 1, end2)}`;
        }
      }
      return res;
    }
    var getFoldOptions = ({
      indentAtStart
    }) => indentAtStart ? Object.assign({
      indentAtStart
    }, strOptions.fold) : strOptions.fold;
    var containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
    function lineLengthOverLimit(str, lineWidth, indentLength) {
      if (!lineWidth || lineWidth < 0)
        return false;
      const limit = lineWidth - indentLength;
      const strLen = str.length;
      if (strLen <= limit)
        return false;
      for (let i2 = 0, start = 0; i2 < strLen; ++i2) {
        if (str[i2] === "\n") {
          if (i2 - start > limit)
            return true;
          start = i2 + 1;
          if (strLen - start <= limit)
            return false;
        }
      }
      return true;
    }
    function doubleQuotedString(value, ctx) {
      const {
        implicitKey
      } = ctx;
      const {
        jsonEncoding,
        minMultiLineLength
      } = strOptions.doubleQuoted;
      const json2 = JSON.stringify(value);
      if (jsonEncoding)
        return json2;
      const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
      let str = "";
      let start = 0;
      for (let i2 = 0, ch2 = json2[i2]; ch2; ch2 = json2[++i2]) {
        if (ch2 === " " && json2[i2 + 1] === "\\" && json2[i2 + 2] === "n") {
          str += json2.slice(start, i2) + "\\ ";
          i2 += 1;
          start = i2;
          ch2 = "\\";
        }
        if (ch2 === "\\")
          switch (json2[i2 + 1]) {
            case "u":
              {
                str += json2.slice(start, i2);
                const code = json2.substr(i2 + 2, 4);
                switch (code) {
                  case "0000":
                    str += "\\0";
                    break;
                  case "0007":
                    str += "\\a";
                    break;
                  case "000b":
                    str += "\\v";
                    break;
                  case "001b":
                    str += "\\e";
                    break;
                  case "0085":
                    str += "\\N";
                    break;
                  case "00a0":
                    str += "\\_";
                    break;
                  case "2028":
                    str += "\\L";
                    break;
                  case "2029":
                    str += "\\P";
                    break;
                  default:
                    if (code.substr(0, 2) === "00")
                      str += "\\x" + code.substr(2);
                    else
                      str += json2.substr(i2, 6);
                }
                i2 += 5;
                start = i2 + 1;
              }
              break;
            case "n":
              if (implicitKey || json2[i2 + 2] === '"' || json2.length < minMultiLineLength) {
                i2 += 1;
              } else {
                str += json2.slice(start, i2) + "\n\n";
                while (json2[i2 + 2] === "\\" && json2[i2 + 3] === "n" && json2[i2 + 4] !== '"') {
                  str += "\n";
                  i2 += 2;
                }
                str += indent;
                if (json2[i2 + 2] === " ")
                  str += "\\";
                i2 += 1;
                start = i2 + 1;
              }
              break;
            default:
              i2 += 1;
          }
      }
      str = start ? str + json2.slice(start) : json2;
      return implicitKey ? str : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx));
    }
    function singleQuotedString(value, ctx) {
      if (ctx.implicitKey) {
        if (/\n/.test(value))
          return doubleQuotedString(value, ctx);
      } else {
        if (/[ \t]\n|\n[ \t]/.test(value))
          return doubleQuotedString(value, ctx);
      }
      const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
      const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&
${indent}`) + "'";
      return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx));
    }
    function blockString({
      comment,
      type,
      value
    }, ctx, onComment, onChompKeep) {
      if (/\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
        return doubleQuotedString(value, ctx);
      }
      const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : "");
      const indentSize = indent ? "2" : "1";
      const literal2 = type === PlainValue$4.Type.BLOCK_FOLDED ? false : type === PlainValue$4.Type.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, strOptions.fold.lineWidth, indent.length);
      let header = literal2 ? "|" : ">";
      if (!value)
        return header + "\n";
      let wsStart = "";
      let wsEnd = "";
      value = value.replace(/[\n\t ]*$/, (ws2) => {
        const n3 = ws2.indexOf("\n");
        if (n3 === -1) {
          header += "-";
        } else if (value === ws2 || n3 !== ws2.length - 1) {
          header += "+";
          if (onChompKeep)
            onChompKeep();
        }
        wsEnd = ws2.replace(/\n$/, "");
        return "";
      }).replace(/^[\n ]*/, (ws2) => {
        if (ws2.indexOf(" ") !== -1)
          header += indentSize;
        const m3 = ws2.match(/ +$/);
        if (m3) {
          wsStart = ws2.slice(0, -m3[0].length);
          return m3[0];
        } else {
          wsStart = ws2;
          return "";
        }
      });
      if (wsEnd)
        wsEnd = wsEnd.replace(/\n+(?!\n|$)/g, `$&${indent}`);
      if (wsStart)
        wsStart = wsStart.replace(/\n+/g, `$&${indent}`);
      if (comment) {
        header += " #" + comment.replace(/ ?[\r\n]+/g, " ");
        if (onComment)
          onComment();
      }
      if (!value)
        return `${header}${indentSize}
${indent}${wsEnd}`;
      if (literal2) {
        value = value.replace(/\n+/g, `$&${indent}`);
        return `${header}
${indent}${wsStart}${value}${wsEnd}`;
      }
      value = value.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
      const body = foldFlowLines(`${wsStart}${value}${wsEnd}`, indent, FOLD_BLOCK, strOptions.fold);
      return `${header}
${indent}${body}`;
    }
    function plainString(item, ctx, onComment, onChompKeep) {
      const {
        comment,
        type,
        value
      } = item;
      const {
        actualString,
        implicitKey,
        indent,
        inFlow
      } = ctx;
      if (implicitKey && /[\n[\]{},]/.test(value) || inFlow && /[[\]{},]/.test(value)) {
        return doubleQuotedString(value, ctx);
      }
      if (!value || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
        return implicitKey || inFlow || value.indexOf("\n") === -1 ? value.indexOf('"') !== -1 && value.indexOf("'") === -1 ? singleQuotedString(value, ctx) : doubleQuotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
      }
      if (!implicitKey && !inFlow && type !== PlainValue$4.Type.PLAIN && value.indexOf("\n") !== -1) {
        return blockString(item, ctx, onComment, onChompKeep);
      }
      if (indent === "" && containsDocumentMarker(value)) {
        ctx.forceBlockIndent = true;
        return blockString(item, ctx, onComment, onChompKeep);
      }
      const str = value.replace(/\n+/g, `$&
${indent}`);
      if (actualString) {
        const {
          tags: tags2
        } = ctx.doc.schema;
        const resolved = resolveScalar(str, tags2, tags2.scalarFallback).value;
        if (typeof resolved !== "string")
          return doubleQuotedString(value, ctx);
      }
      const body = implicitKey ? str : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx));
      if (comment && !inFlow && (body.indexOf("\n") !== -1 || comment.indexOf("\n") !== -1)) {
        if (onComment)
          onComment();
        return addCommentBefore(body, indent, comment);
      }
      return body;
    }
    function stringifyString(item, ctx, onComment, onChompKeep) {
      const {
        defaultType
      } = strOptions;
      const {
        implicitKey,
        inFlow
      } = ctx;
      let {
        type,
        value
      } = item;
      if (typeof value !== "string") {
        value = String(value);
        item = Object.assign({}, item, {
          value
        });
      }
      const _stringify = (_type) => {
        switch (_type) {
          case PlainValue$4.Type.BLOCK_FOLDED:
          case PlainValue$4.Type.BLOCK_LITERAL:
            return blockString(item, ctx, onComment, onChompKeep);
          case PlainValue$4.Type.QUOTE_DOUBLE:
            return doubleQuotedString(value, ctx);
          case PlainValue$4.Type.QUOTE_SINGLE:
            return singleQuotedString(value, ctx);
          case PlainValue$4.Type.PLAIN:
            return plainString(item, ctx, onComment, onChompKeep);
          default:
            return null;
        }
      };
      if (type !== PlainValue$4.Type.QUOTE_DOUBLE && /[\x00-\x08\x0b-\x1f\x7f-\x9f]/.test(value)) {
        type = PlainValue$4.Type.QUOTE_DOUBLE;
      } else if ((implicitKey || inFlow) && (type === PlainValue$4.Type.BLOCK_FOLDED || type === PlainValue$4.Type.BLOCK_LITERAL)) {
        type = PlainValue$4.Type.QUOTE_DOUBLE;
      }
      let res = _stringify(type);
      if (res === null) {
        res = _stringify(defaultType);
        if (res === null)
          throw new Error(`Unsupported default string type ${defaultType}`);
      }
      return res;
    }
    function stringifyNumber({
      format: format2,
      minFractionDigits,
      tag,
      value
    }) {
      if (typeof value === "bigint")
        return String(value);
      if (!isFinite(value))
        return isNaN(value) ? ".nan" : value < 0 ? "-.inf" : ".inf";
      let n3 = JSON.stringify(value);
      if (!format2 && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n3)) {
        let i2 = n3.indexOf(".");
        if (i2 < 0) {
          i2 = n3.length;
          n3 += ".";
        }
        let d3 = minFractionDigits - (n3.length - i2 - 1);
        while (d3-- > 0)
          n3 += "0";
      }
      return n3;
    }
    function checkFlowCollectionEnd(errors, cst) {
      let char, name;
      switch (cst.type) {
        case PlainValue$4.Type.FLOW_MAP:
          char = "}";
          name = "flow map";
          break;
        case PlainValue$4.Type.FLOW_SEQ:
          char = "]";
          name = "flow sequence";
          break;
        default:
          errors.push(new PlainValue$4.YAMLSemanticError(cst, "Not a flow collection!?"));
          return;
      }
      let lastItem;
      for (let i2 = cst.items.length - 1; i2 >= 0; --i2) {
        const item = cst.items[i2];
        if (!item || item.type !== PlainValue$4.Type.COMMENT) {
          lastItem = item;
          break;
        }
      }
      if (lastItem && lastItem.char !== char) {
        const msg = `Expected ${name} to end with ${char}`;
        let err;
        if (typeof lastItem.offset === "number") {
          err = new PlainValue$4.YAMLSemanticError(cst, msg);
          err.offset = lastItem.offset + 1;
        } else {
          err = new PlainValue$4.YAMLSemanticError(lastItem, msg);
          if (lastItem.range && lastItem.range.end)
            err.offset = lastItem.range.end - lastItem.range.start;
        }
        errors.push(err);
      }
    }
    function checkFlowCommentSpace(errors, comment) {
      const prev = comment.context.src[comment.range.start - 1];
      if (prev !== "\n" && prev !== "	" && prev !== " ") {
        const msg = "Comments must be separated from other tokens by white space characters";
        errors.push(new PlainValue$4.YAMLSemanticError(comment, msg));
      }
    }
    function getLongKeyError(source2, key2) {
      const sk = String(key2);
      const k2 = sk.substr(0, 8) + "..." + sk.substr(-8);
      return new PlainValue$4.YAMLSemanticError(source2, `The "${k2}" key is too long`);
    }
    function resolveComments(collection, comments) {
      for (const {
        afterKey,
        before,
        comment
      } of comments) {
        let item = collection.items[before];
        if (!item) {
          if (comment !== void 0) {
            if (collection.comment)
              collection.comment += "\n" + comment;
            else
              collection.comment = comment;
          }
        } else {
          if (afterKey && item.value)
            item = item.value;
          if (comment === void 0) {
            if (afterKey || !item.commentBefore)
              item.spaceBefore = true;
          } else {
            if (item.commentBefore)
              item.commentBefore += "\n" + comment;
            else
              item.commentBefore = comment;
          }
        }
      }
    }
    function resolveString(doc, node2) {
      const res = node2.strValue;
      if (!res)
        return "";
      if (typeof res === "string")
        return res;
      res.errors.forEach((error2) => {
        if (!error2.source)
          error2.source = node2;
        doc.errors.push(error2);
      });
      return res.str;
    }
    function resolveTagHandle(doc, node2) {
      const {
        handle,
        suffix
      } = node2.tag;
      let prefix = doc.tagPrefixes.find((p2) => p2.handle === handle);
      if (!prefix) {
        const dtp = doc.getDefaults().tagPrefixes;
        if (dtp)
          prefix = dtp.find((p2) => p2.handle === handle);
        if (!prefix)
          throw new PlainValue$4.YAMLSemanticError(node2, `The ${handle} tag handle is non-default and was not declared.`);
      }
      if (!suffix)
        throw new PlainValue$4.YAMLSemanticError(node2, `The ${handle} tag has no suffix.`);
      if (handle === "!" && (doc.version || doc.options.version) === "1.0") {
        if (suffix[0] === "^") {
          doc.warnings.push(new PlainValue$4.YAMLWarning(node2, "YAML 1.0 ^ tag expansion is not supported"));
          return suffix;
        }
        if (/[:/]/.test(suffix)) {
          const vocab = suffix.match(/^([a-z0-9-]+)\/(.*)/i);
          return vocab ? `tag:${vocab[1]}.yaml.org,2002:${vocab[2]}` : `tag:${suffix}`;
        }
      }
      return prefix.prefix + decodeURIComponent(suffix);
    }
    function resolveTagName(doc, node2) {
      const {
        tag,
        type
      } = node2;
      let nonSpecific = false;
      if (tag) {
        const {
          handle,
          suffix,
          verbatim
        } = tag;
        if (verbatim) {
          if (verbatim !== "!" && verbatim !== "!!")
            return verbatim;
          const msg = `Verbatim tags aren't resolved, so ${verbatim} is invalid.`;
          doc.errors.push(new PlainValue$4.YAMLSemanticError(node2, msg));
        } else if (handle === "!" && !suffix) {
          nonSpecific = true;
        } else {
          try {
            return resolveTagHandle(doc, node2);
          } catch (error2) {
            doc.errors.push(error2);
          }
        }
      }
      switch (type) {
        case PlainValue$4.Type.BLOCK_FOLDED:
        case PlainValue$4.Type.BLOCK_LITERAL:
        case PlainValue$4.Type.QUOTE_DOUBLE:
        case PlainValue$4.Type.QUOTE_SINGLE:
          return PlainValue$4.defaultTags.STR;
        case PlainValue$4.Type.FLOW_MAP:
        case PlainValue$4.Type.MAP:
          return PlainValue$4.defaultTags.MAP;
        case PlainValue$4.Type.FLOW_SEQ:
        case PlainValue$4.Type.SEQ:
          return PlainValue$4.defaultTags.SEQ;
        case PlainValue$4.Type.PLAIN:
          return nonSpecific ? PlainValue$4.defaultTags.STR : null;
        default:
          return null;
      }
    }
    function resolveByTagName(doc, node2, tagName) {
      const {
        tags: tags2
      } = doc.schema;
      const matchWithTest = [];
      for (const tag of tags2) {
        if (tag.tag === tagName) {
          if (tag.test)
            matchWithTest.push(tag);
          else {
            const res = tag.resolve(doc, node2);
            return res instanceof Collection ? res : new Scalar(res);
          }
        }
      }
      const str = resolveString(doc, node2);
      if (typeof str === "string" && matchWithTest.length > 0)
        return resolveScalar(str, matchWithTest, tags2.scalarFallback);
      return null;
    }
    function getFallbackTagName({
      type
    }) {
      switch (type) {
        case PlainValue$4.Type.FLOW_MAP:
        case PlainValue$4.Type.MAP:
          return PlainValue$4.defaultTags.MAP;
        case PlainValue$4.Type.FLOW_SEQ:
        case PlainValue$4.Type.SEQ:
          return PlainValue$4.defaultTags.SEQ;
        default:
          return PlainValue$4.defaultTags.STR;
      }
    }
    function resolveTag(doc, node2, tagName) {
      try {
        const res = resolveByTagName(doc, node2, tagName);
        if (res) {
          if (tagName && node2.tag)
            res.tag = tagName;
          return res;
        }
      } catch (error2) {
        if (!error2.source)
          error2.source = node2;
        doc.errors.push(error2);
        return null;
      }
      try {
        const fallback = getFallbackTagName(node2);
        if (!fallback)
          throw new Error(`The tag ${tagName} is unavailable`);
        const msg = `The tag ${tagName} is unavailable, falling back to ${fallback}`;
        doc.warnings.push(new PlainValue$4.YAMLWarning(node2, msg));
        const res = resolveByTagName(doc, node2, fallback);
        res.tag = tagName;
        return res;
      } catch (error2) {
        const refError = new PlainValue$4.YAMLReferenceError(node2, error2.message);
        refError.stack = error2.stack;
        doc.errors.push(refError);
        return null;
      }
    }
    var isCollectionItem = (node2) => {
      if (!node2)
        return false;
      const {
        type
      } = node2;
      return type === PlainValue$4.Type.MAP_KEY || type === PlainValue$4.Type.MAP_VALUE || type === PlainValue$4.Type.SEQ_ITEM;
    };
    function resolveNodeProps(errors, node2) {
      const comments = {
        before: [],
        after: []
      };
      let hasAnchor = false;
      let hasTag = false;
      const props = isCollectionItem(node2.context.parent) ? node2.context.parent.props.concat(node2.props) : node2.props;
      for (const {
        start,
        end
      } of props) {
        switch (node2.context.src[start]) {
          case PlainValue$4.Char.COMMENT: {
            if (!node2.commentHasRequiredWhitespace(start)) {
              const msg = "Comments must be separated from other tokens by white space characters";
              errors.push(new PlainValue$4.YAMLSemanticError(node2, msg));
            }
            const {
              header,
              valueRange
            } = node2;
            const cc = valueRange && (start > valueRange.start || header && start > header.start) ? comments.after : comments.before;
            cc.push(node2.context.src.slice(start + 1, end));
            break;
          }
          case PlainValue$4.Char.ANCHOR:
            if (hasAnchor) {
              const msg = "A node can have at most one anchor";
              errors.push(new PlainValue$4.YAMLSemanticError(node2, msg));
            }
            hasAnchor = true;
            break;
          case PlainValue$4.Char.TAG:
            if (hasTag) {
              const msg = "A node can have at most one tag";
              errors.push(new PlainValue$4.YAMLSemanticError(node2, msg));
            }
            hasTag = true;
            break;
        }
      }
      return {
        comments,
        hasAnchor,
        hasTag
      };
    }
    function resolveNodeValue(doc, node2) {
      const {
        anchors,
        errors,
        schema
      } = doc;
      if (node2.type === PlainValue$4.Type.ALIAS) {
        const name = node2.rawValue;
        const src2 = anchors.getNode(name);
        if (!src2) {
          const msg = `Aliased anchor not found: ${name}`;
          errors.push(new PlainValue$4.YAMLReferenceError(node2, msg));
          return null;
        }
        const res = new Alias(src2);
        anchors._cstAliases.push(res);
        return res;
      }
      const tagName = resolveTagName(doc, node2);
      if (tagName)
        return resolveTag(doc, node2, tagName);
      if (node2.type !== PlainValue$4.Type.PLAIN) {
        const msg = `Failed to resolve ${node2.type} node here`;
        errors.push(new PlainValue$4.YAMLSyntaxError(node2, msg));
        return null;
      }
      try {
        const str = resolveString(doc, node2);
        return resolveScalar(str, schema.tags, schema.tags.scalarFallback);
      } catch (error2) {
        if (!error2.source)
          error2.source = node2;
        errors.push(error2);
        return null;
      }
    }
    function resolveNode(doc, node2) {
      if (!node2)
        return null;
      if (node2.error)
        doc.errors.push(node2.error);
      const {
        comments,
        hasAnchor,
        hasTag
      } = resolveNodeProps(doc.errors, node2);
      if (hasAnchor) {
        const {
          anchors
        } = doc;
        const name = node2.anchor;
        const prev = anchors.getNode(name);
        if (prev)
          anchors.map[anchors.newName(name)] = prev;
        anchors.map[name] = node2;
      }
      if (node2.type === PlainValue$4.Type.ALIAS && (hasAnchor || hasTag)) {
        const msg = "An alias node must not specify any properties";
        doc.errors.push(new PlainValue$4.YAMLSemanticError(node2, msg));
      }
      const res = resolveNodeValue(doc, node2);
      if (res) {
        res.range = [node2.range.start, node2.range.end];
        if (doc.options.keepCstNodes)
          res.cstNode = node2;
        if (doc.options.keepNodeTypes)
          res.type = node2.type;
        const cb = comments.before.join("\n");
        if (cb) {
          res.commentBefore = res.commentBefore ? `${res.commentBefore}
${cb}` : cb;
        }
        const ca2 = comments.after.join("\n");
        if (ca2)
          res.comment = res.comment ? `${res.comment}
${ca2}` : ca2;
      }
      return node2.resolved = res;
    }
    function resolveMap(doc, cst) {
      if (cst.type !== PlainValue$4.Type.MAP && cst.type !== PlainValue$4.Type.FLOW_MAP) {
        const msg = `A ${cst.type} node cannot be resolved as a mapping`;
        doc.errors.push(new PlainValue$4.YAMLSyntaxError(cst, msg));
        return null;
      }
      const {
        comments,
        items
      } = cst.type === PlainValue$4.Type.FLOW_MAP ? resolveFlowMapItems(doc, cst) : resolveBlockMapItems(doc, cst);
      const map2 = new YAMLMap();
      map2.items = items;
      resolveComments(map2, comments);
      let hasCollectionKey = false;
      for (let i2 = 0; i2 < items.length; ++i2) {
        const {
          key: iKey
        } = items[i2];
        if (iKey instanceof Collection)
          hasCollectionKey = true;
        if (doc.schema.merge && iKey && iKey.value === MERGE_KEY) {
          items[i2] = new Merge(items[i2]);
          const sources = items[i2].value.items;
          let error2 = null;
          sources.some((node2) => {
            if (node2 instanceof Alias) {
              const {
                type
              } = node2.source;
              if (type === PlainValue$4.Type.MAP || type === PlainValue$4.Type.FLOW_MAP)
                return false;
              return error2 = "Merge nodes aliases can only point to maps";
            }
            return error2 = "Merge nodes can only have Alias nodes as values";
          });
          if (error2)
            doc.errors.push(new PlainValue$4.YAMLSemanticError(cst, error2));
        } else {
          for (let j2 = i2 + 1; j2 < items.length; ++j2) {
            const {
              key: jKey
            } = items[j2];
            if (iKey === jKey || iKey && jKey && Object.prototype.hasOwnProperty.call(iKey, "value") && iKey.value === jKey.value) {
              const msg = `Map keys must be unique; "${iKey}" is repeated`;
              doc.errors.push(new PlainValue$4.YAMLSemanticError(cst, msg));
              break;
            }
          }
        }
      }
      if (hasCollectionKey && !doc.options.mapAsMap) {
        const warn2 = "Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.";
        doc.warnings.push(new PlainValue$4.YAMLWarning(cst, warn2));
      }
      cst.resolved = map2;
      return map2;
    }
    var valueHasPairComment = ({
      context: {
        lineStart,
        node: node2,
        src: src2
      },
      props
    }) => {
      if (props.length === 0)
        return false;
      const {
        start
      } = props[0];
      if (node2 && start > node2.valueRange.start)
        return false;
      if (src2[start] !== PlainValue$4.Char.COMMENT)
        return false;
      for (let i2 = lineStart; i2 < start; ++i2)
        if (src2[i2] === "\n")
          return false;
      return true;
    };
    function resolvePairComment(item, pair) {
      if (!valueHasPairComment(item))
        return;
      const comment = item.getPropValue(0, PlainValue$4.Char.COMMENT, true);
      let found = false;
      const cb = pair.value.commentBefore;
      if (cb && cb.startsWith(comment)) {
        pair.value.commentBefore = cb.substr(comment.length + 1);
        found = true;
      } else {
        const cc = pair.value.comment;
        if (!item.node && cc && cc.startsWith(comment)) {
          pair.value.comment = cc.substr(comment.length + 1);
          found = true;
        }
      }
      if (found)
        pair.comment = comment;
    }
    function resolveBlockMapItems(doc, cst) {
      const comments = [];
      const items = [];
      let key2 = void 0;
      let keyStart = null;
      for (let i2 = 0; i2 < cst.items.length; ++i2) {
        const item = cst.items[i2];
        switch (item.type) {
          case PlainValue$4.Type.BLANK_LINE:
            comments.push({
              afterKey: !!key2,
              before: items.length
            });
            break;
          case PlainValue$4.Type.COMMENT:
            comments.push({
              afterKey: !!key2,
              before: items.length,
              comment: item.comment
            });
            break;
          case PlainValue$4.Type.MAP_KEY:
            if (key2 !== void 0)
              items.push(new Pair(key2));
            if (item.error)
              doc.errors.push(item.error);
            key2 = resolveNode(doc, item.node);
            keyStart = null;
            break;
          case PlainValue$4.Type.MAP_VALUE:
            {
              if (key2 === void 0)
                key2 = null;
              if (item.error)
                doc.errors.push(item.error);
              if (!item.context.atLineStart && item.node && item.node.type === PlainValue$4.Type.MAP && !item.node.context.atLineStart) {
                const msg = "Nested mappings are not allowed in compact mappings";
                doc.errors.push(new PlainValue$4.YAMLSemanticError(item.node, msg));
              }
              let valueNode = item.node;
              if (!valueNode && item.props.length > 0) {
                valueNode = new PlainValue$4.PlainValue(PlainValue$4.Type.PLAIN, []);
                valueNode.context = {
                  parent: item,
                  src: item.context.src
                };
                const pos2 = item.range.start + 1;
                valueNode.range = {
                  start: pos2,
                  end: pos2
                };
                valueNode.valueRange = {
                  start: pos2,
                  end: pos2
                };
                if (typeof item.range.origStart === "number") {
                  const origPos = item.range.origStart + 1;
                  valueNode.range.origStart = valueNode.range.origEnd = origPos;
                  valueNode.valueRange.origStart = valueNode.valueRange.origEnd = origPos;
                }
              }
              const pair = new Pair(key2, resolveNode(doc, valueNode));
              resolvePairComment(item, pair);
              items.push(pair);
              if (key2 && typeof keyStart === "number") {
                if (item.range.start > keyStart + 1024)
                  doc.errors.push(getLongKeyError(cst, key2));
              }
              key2 = void 0;
              keyStart = null;
            }
            break;
          default:
            if (key2 !== void 0)
              items.push(new Pair(key2));
            key2 = resolveNode(doc, item);
            keyStart = item.range.start;
            if (item.error)
              doc.errors.push(item.error);
            next:
              for (let j2 = i2 + 1; ; ++j2) {
                const nextItem = cst.items[j2];
                switch (nextItem && nextItem.type) {
                  case PlainValue$4.Type.BLANK_LINE:
                  case PlainValue$4.Type.COMMENT:
                    continue next;
                  case PlainValue$4.Type.MAP_VALUE:
                    break next;
                  default: {
                    const msg = "Implicit map keys need to be followed by map values";
                    doc.errors.push(new PlainValue$4.YAMLSemanticError(item, msg));
                    break next;
                  }
                }
              }
            if (item.valueRangeContainsNewline) {
              const msg = "Implicit map keys need to be on a single line";
              doc.errors.push(new PlainValue$4.YAMLSemanticError(item, msg));
            }
        }
      }
      if (key2 !== void 0)
        items.push(new Pair(key2));
      return {
        comments,
        items
      };
    }
    function resolveFlowMapItems(doc, cst) {
      const comments = [];
      const items = [];
      let key2 = void 0;
      let explicitKey = false;
      let next = "{";
      for (let i2 = 0; i2 < cst.items.length; ++i2) {
        const item = cst.items[i2];
        if (typeof item.char === "string") {
          const {
            char,
            offset: offset2
          } = item;
          if (char === "?" && key2 === void 0 && !explicitKey) {
            explicitKey = true;
            next = ":";
            continue;
          }
          if (char === ":") {
            if (key2 === void 0)
              key2 = null;
            if (next === ":") {
              next = ",";
              continue;
            }
          } else {
            if (explicitKey) {
              if (key2 === void 0 && char !== ",")
                key2 = null;
              explicitKey = false;
            }
            if (key2 !== void 0) {
              items.push(new Pair(key2));
              key2 = void 0;
              if (char === ",") {
                next = ":";
                continue;
              }
            }
          }
          if (char === "}") {
            if (i2 === cst.items.length - 1)
              continue;
          } else if (char === next) {
            next = ":";
            continue;
          }
          const msg = `Flow map contains an unexpected ${char}`;
          const err = new PlainValue$4.YAMLSyntaxError(cst, msg);
          err.offset = offset2;
          doc.errors.push(err);
        } else if (item.type === PlainValue$4.Type.BLANK_LINE) {
          comments.push({
            afterKey: !!key2,
            before: items.length
          });
        } else if (item.type === PlainValue$4.Type.COMMENT) {
          checkFlowCommentSpace(doc.errors, item);
          comments.push({
            afterKey: !!key2,
            before: items.length,
            comment: item.comment
          });
        } else if (key2 === void 0) {
          if (next === ",")
            doc.errors.push(new PlainValue$4.YAMLSemanticError(item, "Separator , missing in flow map"));
          key2 = resolveNode(doc, item);
        } else {
          if (next !== ",")
            doc.errors.push(new PlainValue$4.YAMLSemanticError(item, "Indicator : missing in flow map entry"));
          items.push(new Pair(key2, resolveNode(doc, item)));
          key2 = void 0;
          explicitKey = false;
        }
      }
      checkFlowCollectionEnd(doc.errors, cst);
      if (key2 !== void 0)
        items.push(new Pair(key2));
      return {
        comments,
        items
      };
    }
    function resolveSeq$3(doc, cst) {
      if (cst.type !== PlainValue$4.Type.SEQ && cst.type !== PlainValue$4.Type.FLOW_SEQ) {
        const msg = `A ${cst.type} node cannot be resolved as a sequence`;
        doc.errors.push(new PlainValue$4.YAMLSyntaxError(cst, msg));
        return null;
      }
      const {
        comments,
        items
      } = cst.type === PlainValue$4.Type.FLOW_SEQ ? resolveFlowSeqItems(doc, cst) : resolveBlockSeqItems(doc, cst);
      const seq2 = new YAMLSeq();
      seq2.items = items;
      resolveComments(seq2, comments);
      if (!doc.options.mapAsMap && items.some((it2) => it2 instanceof Pair && it2.key instanceof Collection)) {
        const warn2 = "Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.";
        doc.warnings.push(new PlainValue$4.YAMLWarning(cst, warn2));
      }
      cst.resolved = seq2;
      return seq2;
    }
    function resolveBlockSeqItems(doc, cst) {
      const comments = [];
      const items = [];
      for (let i2 = 0; i2 < cst.items.length; ++i2) {
        const item = cst.items[i2];
        switch (item.type) {
          case PlainValue$4.Type.BLANK_LINE:
            comments.push({
              before: items.length
            });
            break;
          case PlainValue$4.Type.COMMENT:
            comments.push({
              comment: item.comment,
              before: items.length
            });
            break;
          case PlainValue$4.Type.SEQ_ITEM:
            if (item.error)
              doc.errors.push(item.error);
            items.push(resolveNode(doc, item.node));
            if (item.hasProps) {
              const msg = "Sequence items cannot have tags or anchors before the - indicator";
              doc.errors.push(new PlainValue$4.YAMLSemanticError(item, msg));
            }
            break;
          default:
            if (item.error)
              doc.errors.push(item.error);
            doc.errors.push(new PlainValue$4.YAMLSyntaxError(item, `Unexpected ${item.type} node in sequence`));
        }
      }
      return {
        comments,
        items
      };
    }
    function resolveFlowSeqItems(doc, cst) {
      const comments = [];
      const items = [];
      let explicitKey = false;
      let key2 = void 0;
      let keyStart = null;
      let next = "[";
      let prevItem = null;
      for (let i2 = 0; i2 < cst.items.length; ++i2) {
        const item = cst.items[i2];
        if (typeof item.char === "string") {
          const {
            char,
            offset: offset2
          } = item;
          if (char !== ":" && (explicitKey || key2 !== void 0)) {
            if (explicitKey && key2 === void 0)
              key2 = next ? items.pop() : null;
            items.push(new Pair(key2));
            explicitKey = false;
            key2 = void 0;
            keyStart = null;
          }
          if (char === next) {
            next = null;
          } else if (!next && char === "?") {
            explicitKey = true;
          } else if (next !== "[" && char === ":" && key2 === void 0) {
            if (next === ",") {
              key2 = items.pop();
              if (key2 instanceof Pair) {
                const msg = "Chaining flow sequence pairs is invalid";
                const err = new PlainValue$4.YAMLSemanticError(cst, msg);
                err.offset = offset2;
                doc.errors.push(err);
              }
              if (!explicitKey && typeof keyStart === "number") {
                const keyEnd = item.range ? item.range.start : item.offset;
                if (keyEnd > keyStart + 1024)
                  doc.errors.push(getLongKeyError(cst, key2));
                const {
                  src: src2
                } = prevItem.context;
                for (let i3 = keyStart; i3 < keyEnd; ++i3)
                  if (src2[i3] === "\n") {
                    const msg = "Implicit keys of flow sequence pairs need to be on a single line";
                    doc.errors.push(new PlainValue$4.YAMLSemanticError(prevItem, msg));
                    break;
                  }
              }
            } else {
              key2 = null;
            }
            keyStart = null;
            explicitKey = false;
            next = null;
          } else if (next === "[" || char !== "]" || i2 < cst.items.length - 1) {
            const msg = `Flow sequence contains an unexpected ${char}`;
            const err = new PlainValue$4.YAMLSyntaxError(cst, msg);
            err.offset = offset2;
            doc.errors.push(err);
          }
        } else if (item.type === PlainValue$4.Type.BLANK_LINE) {
          comments.push({
            before: items.length
          });
        } else if (item.type === PlainValue$4.Type.COMMENT) {
          checkFlowCommentSpace(doc.errors, item);
          comments.push({
            comment: item.comment,
            before: items.length
          });
        } else {
          if (next) {
            const msg = `Expected a ${next} in flow sequence`;
            doc.errors.push(new PlainValue$4.YAMLSemanticError(item, msg));
          }
          const value = resolveNode(doc, item);
          if (key2 === void 0) {
            items.push(value);
            prevItem = item;
          } else {
            items.push(new Pair(key2, value));
            key2 = void 0;
          }
          keyStart = item.range.start;
          next = ",";
        }
      }
      checkFlowCollectionEnd(doc.errors, cst);
      if (key2 !== void 0)
        items.push(new Pair(key2));
      return {
        comments,
        items
      };
    }
    resolveSeqD03cb037.Alias = Alias;
    resolveSeqD03cb037.Collection = Collection;
    resolveSeqD03cb037.Merge = Merge;
    resolveSeqD03cb037.Node = Node$1;
    resolveSeqD03cb037.Pair = Pair;
    resolveSeqD03cb037.Scalar = Scalar;
    resolveSeqD03cb037.YAMLMap = YAMLMap;
    resolveSeqD03cb037.YAMLSeq = YAMLSeq;
    resolveSeqD03cb037.addComment = addComment;
    resolveSeqD03cb037.binaryOptions = binaryOptions;
    resolveSeqD03cb037.boolOptions = boolOptions;
    resolveSeqD03cb037.findPair = findPair;
    resolveSeqD03cb037.intOptions = intOptions;
    resolveSeqD03cb037.isEmptyPath = isEmptyPath;
    resolveSeqD03cb037.nullOptions = nullOptions;
    resolveSeqD03cb037.resolveMap = resolveMap;
    resolveSeqD03cb037.resolveNode = resolveNode;
    resolveSeqD03cb037.resolveSeq = resolveSeq$3;
    resolveSeqD03cb037.resolveString = resolveString;
    resolveSeqD03cb037.strOptions = strOptions;
    resolveSeqD03cb037.stringifyNumber = stringifyNumber;
    resolveSeqD03cb037.stringifyString = stringifyString;
    resolveSeqD03cb037.toJSON = toJSON;
    var Schema88e323a7 = {};
    var warnings1000a372 = {};
    var PlainValue$3 = PlainValueEc8e588e;
    var resolveSeq$2 = resolveSeqD03cb037;
    var binary = {
      identify: (value) => value instanceof Uint8Array,
      default: false,
      tag: "tag:yaml.org,2002:binary",
      resolve: (doc, node2) => {
        const src2 = resolveSeq$2.resolveString(doc, node2);
        if (typeof Buffer === "function") {
          return Buffer.from(src2, "base64");
        } else if (typeof atob === "function") {
          const str = atob(src2.replace(/[\n\r]/g, ""));
          const buffer2 = new Uint8Array(str.length);
          for (let i2 = 0; i2 < str.length; ++i2)
            buffer2[i2] = str.charCodeAt(i2);
          return buffer2;
        } else {
          const msg = "This environment does not support reading binary tags; either Buffer or atob is required";
          doc.errors.push(new PlainValue$3.YAMLReferenceError(node2, msg));
          return null;
        }
      },
      options: resolveSeq$2.binaryOptions,
      stringify: ({
        comment,
        type,
        value
      }, ctx, onComment, onChompKeep) => {
        let src2;
        if (typeof Buffer === "function") {
          src2 = value instanceof Buffer ? value.toString("base64") : Buffer.from(value.buffer).toString("base64");
        } else if (typeof btoa === "function") {
          let s2 = "";
          for (let i2 = 0; i2 < value.length; ++i2)
            s2 += String.fromCharCode(value[i2]);
          src2 = btoa(s2);
        } else {
          throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
        }
        if (!type)
          type = resolveSeq$2.binaryOptions.defaultType;
        if (type === PlainValue$3.Type.QUOTE_DOUBLE) {
          value = src2;
        } else {
          const {
            lineWidth
          } = resolveSeq$2.binaryOptions;
          const n3 = Math.ceil(src2.length / lineWidth);
          const lines = new Array(n3);
          for (let i2 = 0, o2 = 0; i2 < n3; ++i2, o2 += lineWidth) {
            lines[i2] = src2.substr(o2, lineWidth);
          }
          value = lines.join(type === PlainValue$3.Type.BLOCK_LITERAL ? "\n" : " ");
        }
        return resolveSeq$2.stringifyString({
          comment,
          type,
          value
        }, ctx, onComment, onChompKeep);
      }
    };
    function parsePairs(doc, cst) {
      const seq2 = resolveSeq$2.resolveSeq(doc, cst);
      for (let i2 = 0; i2 < seq2.items.length; ++i2) {
        let item = seq2.items[i2];
        if (item instanceof resolveSeq$2.Pair)
          continue;
        else if (item instanceof resolveSeq$2.YAMLMap) {
          if (item.items.length > 1) {
            const msg = "Each pair must have its own sequence indicator";
            throw new PlainValue$3.YAMLSemanticError(cst, msg);
          }
          const pair = item.items[0] || new resolveSeq$2.Pair();
          if (item.commentBefore)
            pair.commentBefore = pair.commentBefore ? `${item.commentBefore}
${pair.commentBefore}` : item.commentBefore;
          if (item.comment)
            pair.comment = pair.comment ? `${item.comment}
${pair.comment}` : item.comment;
          item = pair;
        }
        seq2.items[i2] = item instanceof resolveSeq$2.Pair ? item : new resolveSeq$2.Pair(item);
      }
      return seq2;
    }
    function createPairs(schema, iterable, ctx) {
      const pairs2 = new resolveSeq$2.YAMLSeq(schema);
      pairs2.tag = "tag:yaml.org,2002:pairs";
      for (const it2 of iterable) {
        let key2, value;
        if (Array.isArray(it2)) {
          if (it2.length === 2) {
            key2 = it2[0];
            value = it2[1];
          } else
            throw new TypeError(`Expected [key, value] tuple: ${it2}`);
        } else if (it2 && it2 instanceof Object) {
          const keys = Object.keys(it2);
          if (keys.length === 1) {
            key2 = keys[0];
            value = it2[key2];
          } else
            throw new TypeError(`Expected { key: value } tuple: ${it2}`);
        } else {
          key2 = it2;
        }
        const pair = schema.createPair(key2, value, ctx);
        pairs2.items.push(pair);
      }
      return pairs2;
    }
    var pairs = {
      default: false,
      tag: "tag:yaml.org,2002:pairs",
      resolve: parsePairs,
      createNode: createPairs
    };
    var YAMLOMap = class extends resolveSeq$2.YAMLSeq {
      constructor() {
        super();
        PlainValue$3._defineProperty(this, "add", resolveSeq$2.YAMLMap.prototype.add.bind(this));
        PlainValue$3._defineProperty(this, "delete", resolveSeq$2.YAMLMap.prototype.delete.bind(this));
        PlainValue$3._defineProperty(this, "get", resolveSeq$2.YAMLMap.prototype.get.bind(this));
        PlainValue$3._defineProperty(this, "has", resolveSeq$2.YAMLMap.prototype.has.bind(this));
        PlainValue$3._defineProperty(this, "set", resolveSeq$2.YAMLMap.prototype.set.bind(this));
        this.tag = YAMLOMap.tag;
      }
      toJSON(_2, ctx) {
        const map2 = /* @__PURE__ */ new Map();
        if (ctx && ctx.onCreate)
          ctx.onCreate(map2);
        for (const pair of this.items) {
          let key2, value;
          if (pair instanceof resolveSeq$2.Pair) {
            key2 = resolveSeq$2.toJSON(pair.key, "", ctx);
            value = resolveSeq$2.toJSON(pair.value, key2, ctx);
          } else {
            key2 = resolveSeq$2.toJSON(pair, "", ctx);
          }
          if (map2.has(key2))
            throw new Error("Ordered maps must not include duplicate keys");
          map2.set(key2, value);
        }
        return map2;
      }
    };
    PlainValue$3._defineProperty(YAMLOMap, "tag", "tag:yaml.org,2002:omap");
    function parseOMap(doc, cst) {
      const pairs2 = parsePairs(doc, cst);
      const seenKeys = [];
      for (const {
        key: key2
      } of pairs2.items) {
        if (key2 instanceof resolveSeq$2.Scalar) {
          if (seenKeys.includes(key2.value)) {
            const msg = "Ordered maps must not include duplicate keys";
            throw new PlainValue$3.YAMLSemanticError(cst, msg);
          } else {
            seenKeys.push(key2.value);
          }
        }
      }
      return Object.assign(new YAMLOMap(), pairs2);
    }
    function createOMap(schema, iterable, ctx) {
      const pairs2 = createPairs(schema, iterable, ctx);
      const omap2 = new YAMLOMap();
      omap2.items = pairs2.items;
      return omap2;
    }
    var omap = {
      identify: (value) => value instanceof Map,
      nodeClass: YAMLOMap,
      default: false,
      tag: "tag:yaml.org,2002:omap",
      resolve: parseOMap,
      createNode: createOMap
    };
    var YAMLSet = class extends resolveSeq$2.YAMLMap {
      constructor() {
        super();
        this.tag = YAMLSet.tag;
      }
      add(key2) {
        const pair = key2 instanceof resolveSeq$2.Pair ? key2 : new resolveSeq$2.Pair(key2);
        const prev = resolveSeq$2.findPair(this.items, pair.key);
        if (!prev)
          this.items.push(pair);
      }
      get(key2, keepPair) {
        const pair = resolveSeq$2.findPair(this.items, key2);
        return !keepPair && pair instanceof resolveSeq$2.Pair ? pair.key instanceof resolveSeq$2.Scalar ? pair.key.value : pair.key : pair;
      }
      set(key2, value) {
        if (typeof value !== "boolean")
          throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
        const prev = resolveSeq$2.findPair(this.items, key2);
        if (prev && !value) {
          this.items.splice(this.items.indexOf(prev), 1);
        } else if (!prev && value) {
          this.items.push(new resolveSeq$2.Pair(key2));
        }
      }
      toJSON(_2, ctx) {
        return super.toJSON(_2, ctx, Set);
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        if (this.hasAllNullValues())
          return super.toString(ctx, onComment, onChompKeep);
        else
          throw new Error("Set items must all have null values");
      }
    };
    PlainValue$3._defineProperty(YAMLSet, "tag", "tag:yaml.org,2002:set");
    function parseSet(doc, cst) {
      const map2 = resolveSeq$2.resolveMap(doc, cst);
      if (!map2.hasAllNullValues())
        throw new PlainValue$3.YAMLSemanticError(cst, "Set items must all have null values");
      return Object.assign(new YAMLSet(), map2);
    }
    function createSet(schema, iterable, ctx) {
      const set2 = new YAMLSet();
      for (const value of iterable)
        set2.items.push(schema.createPair(value, null, ctx));
      return set2;
    }
    var set = {
      identify: (value) => value instanceof Set,
      nodeClass: YAMLSet,
      default: false,
      tag: "tag:yaml.org,2002:set",
      resolve: parseSet,
      createNode: createSet
    };
    var parseSexagesimal = (sign2, parts) => {
      const n3 = parts.split(":").reduce((n4, p2) => n4 * 60 + Number(p2), 0);
      return sign2 === "-" ? -n3 : n3;
    };
    var stringifySexagesimal = ({
      value
    }) => {
      if (isNaN(value) || !isFinite(value))
        return resolveSeq$2.stringifyNumber(value);
      let sign2 = "";
      if (value < 0) {
        sign2 = "-";
        value = Math.abs(value);
      }
      const parts = [value % 60];
      if (value < 60) {
        parts.unshift(0);
      } else {
        value = Math.round((value - parts[0]) / 60);
        parts.unshift(value % 60);
        if (value >= 60) {
          value = Math.round((value - parts[0]) / 60);
          parts.unshift(value);
        }
      }
      return sign2 + parts.map((n3) => n3 < 10 ? "0" + String(n3) : String(n3)).join(":").replace(/000000\d*$/, "");
    };
    var intTime = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "TIME",
      test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+)$/,
      resolve: (str, sign2, parts) => parseSexagesimal(sign2, parts.replace(/_/g, "")),
      stringify: stringifySexagesimal
    };
    var floatTime = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "TIME",
      test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*)$/,
      resolve: (str, sign2, parts) => parseSexagesimal(sign2, parts.replace(/_/g, "")),
      stringify: stringifySexagesimal
    };
    var timestamp = {
      identify: (value) => value instanceof Date,
      default: true,
      tag: "tag:yaml.org,2002:timestamp",
      test: RegExp("^(?:([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?)$"),
      resolve: (str, year, month, day, hour, minute, second, millisec, tz) => {
        if (millisec)
          millisec = (millisec + "00").substr(1, 3);
        let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec || 0);
        if (tz && tz !== "Z") {
          let d3 = parseSexagesimal(tz[0], tz.slice(1));
          if (Math.abs(d3) < 30)
            d3 *= 60;
          date -= 6e4 * d3;
        }
        return new Date(date);
      },
      stringify: ({
        value
      }) => value.toISOString().replace(/((T00:00)?:00)?\.000Z$/, "")
    };
    function shouldWarn(deprecation) {
      const env2 = typeof process !== "undefined" && process.env || {};
      if (deprecation) {
        if (typeof YAML_SILENCE_DEPRECATION_WARNINGS !== "undefined")
          return !YAML_SILENCE_DEPRECATION_WARNINGS;
        return !env2.YAML_SILENCE_DEPRECATION_WARNINGS;
      }
      if (typeof YAML_SILENCE_WARNINGS !== "undefined")
        return !YAML_SILENCE_WARNINGS;
      return !env2.YAML_SILENCE_WARNINGS;
    }
    function warn(warning, type) {
      if (shouldWarn(false)) {
        const emit = typeof process !== "undefined" && process.emitWarning;
        if (emit)
          emit(warning, type);
        else {
          console.warn(type ? `${type}: ${warning}` : warning);
        }
      }
    }
    function warnFileDeprecation(filename2) {
      if (shouldWarn(true)) {
        const path2 = filename2.replace(/.*yaml[/\\]/i, "").replace(/\.js$/, "").replace(/\\/g, "/");
        warn(`The endpoint 'yaml/${path2}' will be removed in a future release.`, "DeprecationWarning");
      }
    }
    var warned = {};
    function warnOptionDeprecation(name, alternative) {
      if (!warned[name] && shouldWarn(true)) {
        warned[name] = true;
        let msg = `The option '${name}' will be removed in a future release`;
        msg += alternative ? `, use '${alternative}' instead.` : ".";
        warn(msg, "DeprecationWarning");
      }
    }
    warnings1000a372.binary = binary;
    warnings1000a372.floatTime = floatTime;
    warnings1000a372.intTime = intTime;
    warnings1000a372.omap = omap;
    warnings1000a372.pairs = pairs;
    warnings1000a372.set = set;
    warnings1000a372.timestamp = timestamp;
    warnings1000a372.warn = warn;
    warnings1000a372.warnFileDeprecation = warnFileDeprecation;
    warnings1000a372.warnOptionDeprecation = warnOptionDeprecation;
    var PlainValue$2 = PlainValueEc8e588e;
    var resolveSeq$1 = resolveSeqD03cb037;
    var warnings$1 = warnings1000a372;
    function createMap(schema, obj, ctx) {
      const map2 = new resolveSeq$1.YAMLMap(schema);
      if (obj instanceof Map) {
        for (const [key2, value] of obj)
          map2.items.push(schema.createPair(key2, value, ctx));
      } else if (obj && typeof obj === "object") {
        for (const key2 of Object.keys(obj))
          map2.items.push(schema.createPair(key2, obj[key2], ctx));
      }
      if (typeof schema.sortMapEntries === "function") {
        map2.items.sort(schema.sortMapEntries);
      }
      return map2;
    }
    var map = {
      createNode: createMap,
      default: true,
      nodeClass: resolveSeq$1.YAMLMap,
      tag: "tag:yaml.org,2002:map",
      resolve: resolveSeq$1.resolveMap
    };
    function createSeq(schema, obj, ctx) {
      const seq2 = new resolveSeq$1.YAMLSeq(schema);
      if (obj && obj[Symbol.iterator]) {
        for (const it2 of obj) {
          const v2 = schema.createNode(it2, ctx.wrapScalars, null, ctx);
          seq2.items.push(v2);
        }
      }
      return seq2;
    }
    var seq = {
      createNode: createSeq,
      default: true,
      nodeClass: resolveSeq$1.YAMLSeq,
      tag: "tag:yaml.org,2002:seq",
      resolve: resolveSeq$1.resolveSeq
    };
    var string = {
      identify: (value) => typeof value === "string",
      default: true,
      tag: "tag:yaml.org,2002:str",
      resolve: resolveSeq$1.resolveString,
      stringify(item, ctx, onComment, onChompKeep) {
        ctx = Object.assign({
          actualString: true
        }, ctx);
        return resolveSeq$1.stringifyString(item, ctx, onComment, onChompKeep);
      },
      options: resolveSeq$1.strOptions
    };
    var failsafe = [map, seq, string];
    var intIdentify$2 = (value) => typeof value === "bigint" || Number.isInteger(value);
    var intResolve$1 = (src2, part, radix) => resolveSeq$1.intOptions.asBigInt ? BigInt(src2) : parseInt(part, radix);
    function intStringify$1(node2, radix, prefix) {
      const {
        value
      } = node2;
      if (intIdentify$2(value) && value >= 0)
        return prefix + value.toString(radix);
      return resolveSeq$1.stringifyNumber(node2);
    }
    var nullObj = {
      identify: (value) => value == null,
      createNode: (schema, value, ctx) => ctx.wrapScalars ? new resolveSeq$1.Scalar(null) : null,
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^(?:~|[Nn]ull|NULL)?$/,
      resolve: () => null,
      options: resolveSeq$1.nullOptions,
      stringify: () => resolveSeq$1.nullOptions.nullStr
    };
    var boolObj = {
      identify: (value) => typeof value === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
      resolve: (str) => str[0] === "t" || str[0] === "T",
      options: resolveSeq$1.boolOptions,
      stringify: ({
        value
      }) => value ? resolveSeq$1.boolOptions.trueStr : resolveSeq$1.boolOptions.falseStr
    };
    var octObj = {
      identify: (value) => intIdentify$2(value) && value >= 0,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^0o([0-7]+)$/,
      resolve: (str, oct) => intResolve$1(str, oct, 8),
      options: resolveSeq$1.intOptions,
      stringify: (node2) => intStringify$1(node2, 8, "0o")
    };
    var intObj = {
      identify: intIdentify$2,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^[-+]?[0-9]+$/,
      resolve: (str) => intResolve$1(str, str, 10),
      options: resolveSeq$1.intOptions,
      stringify: resolveSeq$1.stringifyNumber
    };
    var hexObj = {
      identify: (value) => intIdentify$2(value) && value >= 0,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^0x([0-9a-fA-F]+)$/,
      resolve: (str, hex) => intResolve$1(str, hex, 16),
      options: resolveSeq$1.intOptions,
      stringify: (node2) => intStringify$1(node2, 16, "0x")
    };
    var nanObj = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^(?:[-+]?\.inf|(\.nan))$/i,
      resolve: (str, nan) => nan ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      stringify: resolveSeq$1.stringifyNumber
    };
    var expObj = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
      resolve: (str) => parseFloat(str),
      stringify: ({
        value
      }) => Number(value).toExponential()
    };
    var floatObj = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:\.([0-9]+)|[0-9]+\.([0-9]*))$/,
      resolve(str, frac1, frac2) {
        const frac = frac1 || frac2;
        const node2 = new resolveSeq$1.Scalar(parseFloat(str));
        if (frac && frac[frac.length - 1] === "0")
          node2.minFractionDigits = frac.length;
        return node2;
      },
      stringify: resolveSeq$1.stringifyNumber
    };
    var core$1 = failsafe.concat([nullObj, boolObj, octObj, intObj, hexObj, nanObj, expObj, floatObj]);
    var intIdentify$1 = (value) => typeof value === "bigint" || Number.isInteger(value);
    var stringifyJSON = ({
      value
    }) => JSON.stringify(value);
    var json = [map, seq, {
      identify: (value) => typeof value === "string",
      default: true,
      tag: "tag:yaml.org,2002:str",
      resolve: resolveSeq$1.resolveString,
      stringify: stringifyJSON
    }, {
      identify: (value) => value == null,
      createNode: (schema, value, ctx) => ctx.wrapScalars ? new resolveSeq$1.Scalar(null) : null,
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^null$/,
      resolve: () => null,
      stringify: stringifyJSON
    }, {
      identify: (value) => typeof value === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^true|false$/,
      resolve: (str) => str === "true",
      stringify: stringifyJSON
    }, {
      identify: intIdentify$1,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^-?(?:0|[1-9][0-9]*)$/,
      resolve: (str) => resolveSeq$1.intOptions.asBigInt ? BigInt(str) : parseInt(str, 10),
      stringify: ({
        value
      }) => intIdentify$1(value) ? value.toString() : JSON.stringify(value)
    }, {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
      resolve: (str) => parseFloat(str),
      stringify: stringifyJSON
    }];
    json.scalarFallback = (str) => {
      throw new SyntaxError(`Unresolved plain scalar ${JSON.stringify(str)}`);
    };
    var boolStringify = ({
      value
    }) => value ? resolveSeq$1.boolOptions.trueStr : resolveSeq$1.boolOptions.falseStr;
    var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
    function intResolve(sign2, src2, radix) {
      let str = src2.replace(/_/g, "");
      if (resolveSeq$1.intOptions.asBigInt) {
        switch (radix) {
          case 2:
            str = `0b${str}`;
            break;
          case 8:
            str = `0o${str}`;
            break;
          case 16:
            str = `0x${str}`;
            break;
        }
        const n4 = BigInt(str);
        return sign2 === "-" ? BigInt(-1) * n4 : n4;
      }
      const n3 = parseInt(str, radix);
      return sign2 === "-" ? -1 * n3 : n3;
    }
    function intStringify(node2, radix, prefix) {
      const {
        value
      } = node2;
      if (intIdentify(value)) {
        const str = value.toString(radix);
        return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
      }
      return resolveSeq$1.stringifyNumber(node2);
    }
    var yaml11 = failsafe.concat([{
      identify: (value) => value == null,
      createNode: (schema, value, ctx) => ctx.wrapScalars ? new resolveSeq$1.Scalar(null) : null,
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^(?:~|[Nn]ull|NULL)?$/,
      resolve: () => null,
      options: resolveSeq$1.nullOptions,
      stringify: () => resolveSeq$1.nullOptions.nullStr
    }, {
      identify: (value) => typeof value === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
      resolve: () => true,
      options: resolveSeq$1.boolOptions,
      stringify: boolStringify
    }, {
      identify: (value) => typeof value === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,
      resolve: () => false,
      options: resolveSeq$1.boolOptions,
      stringify: boolStringify
    }, {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "BIN",
      test: /^([-+]?)0b([0-1_]+)$/,
      resolve: (str, sign2, bin) => intResolve(sign2, bin, 2),
      stringify: (node2) => intStringify(node2, 2, "0b")
    }, {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^([-+]?)0([0-7_]+)$/,
      resolve: (str, sign2, oct) => intResolve(sign2, oct, 8),
      stringify: (node2) => intStringify(node2, 8, "0")
    }, {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^([-+]?)([0-9][0-9_]*)$/,
      resolve: (str, sign2, abs) => intResolve(sign2, abs, 10),
      stringify: resolveSeq$1.stringifyNumber
    }, {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^([-+]?)0x([0-9a-fA-F_]+)$/,
      resolve: (str, sign2, hex) => intResolve(sign2, hex, 16),
      stringify: (node2) => intStringify(node2, 16, "0x")
    }, {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^(?:[-+]?\.inf|(\.nan))$/i,
      resolve: (str, nan) => nan ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      stringify: resolveSeq$1.stringifyNumber
    }, {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?([0-9][0-9_]*)?(\.[0-9_]*)?[eE][-+]?[0-9]+$/,
      resolve: (str) => parseFloat(str.replace(/_/g, "")),
      stringify: ({
        value
      }) => Number(value).toExponential()
    }, {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:[0-9][0-9_]*)?\.([0-9_]*)$/,
      resolve(str, frac) {
        const node2 = new resolveSeq$1.Scalar(parseFloat(str.replace(/_/g, "")));
        if (frac) {
          const f2 = frac.replace(/_/g, "");
          if (f2[f2.length - 1] === "0")
            node2.minFractionDigits = f2.length;
        }
        return node2;
      },
      stringify: resolveSeq$1.stringifyNumber
    }], warnings$1.binary, warnings$1.omap, warnings$1.pairs, warnings$1.set, warnings$1.intTime, warnings$1.floatTime, warnings$1.timestamp);
    var schemas = {
      core: core$1,
      failsafe,
      json,
      yaml11
    };
    var tags = {
      binary: warnings$1.binary,
      bool: boolObj,
      float: floatObj,
      floatExp: expObj,
      floatNaN: nanObj,
      floatTime: warnings$1.floatTime,
      int: intObj,
      intHex: hexObj,
      intOct: octObj,
      intTime: warnings$1.intTime,
      map,
      null: nullObj,
      omap: warnings$1.omap,
      pairs: warnings$1.pairs,
      seq,
      set: warnings$1.set,
      timestamp: warnings$1.timestamp
    };
    function findTagObject(value, tagName, tags2) {
      if (tagName) {
        const match2 = tags2.filter((t) => t.tag === tagName);
        const tagObj = match2.find((t) => !t.format) || match2[0];
        if (!tagObj)
          throw new Error(`Tag ${tagName} not found`);
        return tagObj;
      }
      return tags2.find((t) => (t.identify && t.identify(value) || t.class && value instanceof t.class) && !t.format);
    }
    function createNode$1(value, tagName, ctx) {
      if (value instanceof resolveSeq$1.Node)
        return value;
      const {
        defaultPrefix,
        onTagObj,
        prevObjects,
        schema,
        wrapScalars
      } = ctx;
      if (tagName && tagName.startsWith("!!"))
        tagName = defaultPrefix + tagName.slice(2);
      let tagObj = findTagObject(value, tagName, schema.tags);
      if (!tagObj) {
        if (typeof value.toJSON === "function")
          value = value.toJSON();
        if (!value || typeof value !== "object")
          return wrapScalars ? new resolveSeq$1.Scalar(value) : value;
        tagObj = value instanceof Map ? map : value[Symbol.iterator] ? seq : map;
      }
      if (onTagObj) {
        onTagObj(tagObj);
        delete ctx.onTagObj;
      }
      const obj = {
        value: void 0,
        node: void 0
      };
      if (value && typeof value === "object" && prevObjects) {
        const prev = prevObjects.get(value);
        if (prev) {
          const alias2 = new resolveSeq$1.Alias(prev);
          ctx.aliasNodes.push(alias2);
          return alias2;
        }
        obj.value = value;
        prevObjects.set(value, obj);
      }
      obj.node = tagObj.createNode ? tagObj.createNode(ctx.schema, value, ctx) : wrapScalars ? new resolveSeq$1.Scalar(value) : value;
      if (tagName && obj.node instanceof resolveSeq$1.Node)
        obj.node.tag = tagName;
      return obj.node;
    }
    function getSchemaTags(schemas2, knownTags, customTags, schemaId) {
      let tags2 = schemas2[schemaId.replace(/\W/g, "")];
      if (!tags2) {
        const keys = Object.keys(schemas2).map((key2) => JSON.stringify(key2)).join(", ");
        throw new Error(`Unknown schema "${schemaId}"; use one of ${keys}`);
      }
      if (Array.isArray(customTags)) {
        for (const tag of customTags)
          tags2 = tags2.concat(tag);
      } else if (typeof customTags === "function") {
        tags2 = customTags(tags2.slice());
      }
      for (let i2 = 0; i2 < tags2.length; ++i2) {
        const tag = tags2[i2];
        if (typeof tag === "string") {
          const tagObj = knownTags[tag];
          if (!tagObj) {
            const keys = Object.keys(knownTags).map((key2) => JSON.stringify(key2)).join(", ");
            throw new Error(`Unknown custom tag "${tag}"; use one of ${keys}`);
          }
          tags2[i2] = tagObj;
        }
      }
      return tags2;
    }
    var sortMapEntriesByKey = (a2, b2) => a2.key < b2.key ? -1 : a2.key > b2.key ? 1 : 0;
    var Schema$2 = class {
      constructor({
        customTags,
        merge: merge3,
        schema,
        sortMapEntries,
        tags: deprecatedCustomTags
      }) {
        this.merge = !!merge3;
        this.name = schema;
        this.sortMapEntries = sortMapEntries === true ? sortMapEntriesByKey : sortMapEntries || null;
        if (!customTags && deprecatedCustomTags)
          warnings$1.warnOptionDeprecation("tags", "customTags");
        this.tags = getSchemaTags(schemas, tags, customTags || deprecatedCustomTags, schema);
      }
      createNode(value, wrapScalars, tagName, ctx) {
        const baseCtx = {
          defaultPrefix: Schema$2.defaultPrefix,
          schema: this,
          wrapScalars
        };
        const createCtx = ctx ? Object.assign(ctx, baseCtx) : baseCtx;
        return createNode$1(value, tagName, createCtx);
      }
      createPair(key2, value, ctx) {
        if (!ctx)
          ctx = {
            wrapScalars: true
          };
        const k2 = this.createNode(key2, ctx.wrapScalars, null, ctx);
        const v2 = this.createNode(value, ctx.wrapScalars, null, ctx);
        return new resolveSeq$1.Pair(k2, v2);
      }
    };
    PlainValue$2._defineProperty(Schema$2, "defaultPrefix", PlainValue$2.defaultTagPrefix);
    PlainValue$2._defineProperty(Schema$2, "defaultTags", PlainValue$2.defaultTags);
    Schema88e323a7.Schema = Schema$2;
    var PlainValue$1 = PlainValueEc8e588e;
    var resolveSeq = resolveSeqD03cb037;
    var Schema$1 = Schema88e323a7;
    var defaultOptions$1 = {
      anchorPrefix: "a",
      customTags: null,
      indent: 2,
      indentSeq: true,
      keepCstNodes: false,
      keepNodeTypes: true,
      keepBlobsInJSON: true,
      mapAsMap: false,
      maxAliasCount: 100,
      prettyErrors: false,
      simpleKeys: false,
      version: "1.2"
    };
    var scalarOptions = {
      get binary() {
        return resolveSeq.binaryOptions;
      },
      set binary(opt) {
        Object.assign(resolveSeq.binaryOptions, opt);
      },
      get bool() {
        return resolveSeq.boolOptions;
      },
      set bool(opt) {
        Object.assign(resolveSeq.boolOptions, opt);
      },
      get int() {
        return resolveSeq.intOptions;
      },
      set int(opt) {
        Object.assign(resolveSeq.intOptions, opt);
      },
      get null() {
        return resolveSeq.nullOptions;
      },
      set null(opt) {
        Object.assign(resolveSeq.nullOptions, opt);
      },
      get str() {
        return resolveSeq.strOptions;
      },
      set str(opt) {
        Object.assign(resolveSeq.strOptions, opt);
      }
    };
    var documentOptions = {
      "1.0": {
        schema: "yaml-1.1",
        merge: true,
        tagPrefixes: [{
          handle: "!",
          prefix: PlainValue$1.defaultTagPrefix
        }, {
          handle: "!!",
          prefix: "tag:private.yaml.org,2002:"
        }]
      },
      1.1: {
        schema: "yaml-1.1",
        merge: true,
        tagPrefixes: [{
          handle: "!",
          prefix: "!"
        }, {
          handle: "!!",
          prefix: PlainValue$1.defaultTagPrefix
        }]
      },
      1.2: {
        schema: "core",
        merge: false,
        tagPrefixes: [{
          handle: "!",
          prefix: "!"
        }, {
          handle: "!!",
          prefix: PlainValue$1.defaultTagPrefix
        }]
      }
    };
    function stringifyTag(doc, tag) {
      if ((doc.version || doc.options.version) === "1.0") {
        const priv = tag.match(/^tag:private\.yaml\.org,2002:([^:/]+)$/);
        if (priv)
          return "!" + priv[1];
        const vocab = tag.match(/^tag:([a-zA-Z0-9-]+)\.yaml\.org,2002:(.*)/);
        return vocab ? `!${vocab[1]}/${vocab[2]}` : `!${tag.replace(/^tag:/, "")}`;
      }
      let p2 = doc.tagPrefixes.find((p3) => tag.indexOf(p3.prefix) === 0);
      if (!p2) {
        const dtp = doc.getDefaults().tagPrefixes;
        p2 = dtp && dtp.find((p3) => tag.indexOf(p3.prefix) === 0);
      }
      if (!p2)
        return tag[0] === "!" ? tag : `!<${tag}>`;
      const suffix = tag.substr(p2.prefix.length).replace(/[!,[\]{}]/g, (ch2) => ({
        "!": "%21",
        ",": "%2C",
        "[": "%5B",
        "]": "%5D",
        "{": "%7B",
        "}": "%7D"
      })[ch2]);
      return p2.handle + suffix;
    }
    function getTagObject(tags2, item) {
      if (item instanceof resolveSeq.Alias)
        return resolveSeq.Alias;
      if (item.tag) {
        const match2 = tags2.filter((t) => t.tag === item.tag);
        if (match2.length > 0)
          return match2.find((t) => t.format === item.format) || match2[0];
      }
      let tagObj, obj;
      if (item instanceof resolveSeq.Scalar) {
        obj = item.value;
        const match2 = tags2.filter((t) => t.identify && t.identify(obj) || t.class && obj instanceof t.class);
        tagObj = match2.find((t) => t.format === item.format) || match2.find((t) => !t.format);
      } else {
        obj = item;
        tagObj = tags2.find((t) => t.nodeClass && obj instanceof t.nodeClass);
      }
      if (!tagObj) {
        const name = obj && obj.constructor ? obj.constructor.name : typeof obj;
        throw new Error(`Tag not resolved for ${name} value`);
      }
      return tagObj;
    }
    function stringifyProps(node2, tagObj, {
      anchors,
      doc
    }) {
      const props = [];
      const anchor = doc.anchors.getName(node2);
      if (anchor) {
        anchors[anchor] = node2;
        props.push(`&${anchor}`);
      }
      if (node2.tag) {
        props.push(stringifyTag(doc, node2.tag));
      } else if (!tagObj.default) {
        props.push(stringifyTag(doc, tagObj.tag));
      }
      return props.join(" ");
    }
    function stringify$2(item, ctx, onComment, onChompKeep) {
      const {
        anchors,
        schema
      } = ctx.doc;
      let tagObj;
      if (!(item instanceof resolveSeq.Node)) {
        const createCtx = {
          aliasNodes: [],
          onTagObj: (o2) => tagObj = o2,
          prevObjects: /* @__PURE__ */ new Map()
        };
        item = schema.createNode(item, true, null, createCtx);
        for (const alias2 of createCtx.aliasNodes) {
          alias2.source = alias2.source.node;
          let name = anchors.getName(alias2.source);
          if (!name) {
            name = anchors.newName();
            anchors.map[name] = alias2.source;
          }
        }
      }
      if (item instanceof resolveSeq.Pair)
        return item.toString(ctx, onComment, onChompKeep);
      if (!tagObj)
        tagObj = getTagObject(schema.tags, item);
      const props = stringifyProps(item, tagObj, ctx);
      if (props.length > 0)
        ctx.indentAtStart = (ctx.indentAtStart || 0) + props.length + 1;
      const str = typeof tagObj.stringify === "function" ? tagObj.stringify(item, ctx, onComment, onChompKeep) : item instanceof resolveSeq.Scalar ? resolveSeq.stringifyString(item, ctx, onComment, onChompKeep) : item.toString(ctx, onComment, onChompKeep);
      if (!props)
        return str;
      return item instanceof resolveSeq.Scalar || str[0] === "{" || str[0] === "[" ? `${props} ${str}` : `${props}
${ctx.indent}${str}`;
    }
    var Anchors = class {
      static validAnchorNode(node2) {
        return node2 instanceof resolveSeq.Scalar || node2 instanceof resolveSeq.YAMLSeq || node2 instanceof resolveSeq.YAMLMap;
      }
      constructor(prefix) {
        PlainValue$1._defineProperty(this, "map", /* @__PURE__ */ Object.create(null));
        this.prefix = prefix;
      }
      createAlias(node2, name) {
        this.setAnchor(node2, name);
        return new resolveSeq.Alias(node2);
      }
      createMergePair(...sources) {
        const merge3 = new resolveSeq.Merge();
        merge3.value.items = sources.map((s2) => {
          if (s2 instanceof resolveSeq.Alias) {
            if (s2.source instanceof resolveSeq.YAMLMap)
              return s2;
          } else if (s2 instanceof resolveSeq.YAMLMap) {
            return this.createAlias(s2);
          }
          throw new Error("Merge sources must be Map nodes or their Aliases");
        });
        return merge3;
      }
      getName(node2) {
        const {
          map: map2
        } = this;
        return Object.keys(map2).find((a2) => map2[a2] === node2);
      }
      getNames() {
        return Object.keys(this.map);
      }
      getNode(name) {
        return this.map[name];
      }
      newName(prefix) {
        if (!prefix)
          prefix = this.prefix;
        const names = Object.keys(this.map);
        for (let i2 = 1; true; ++i2) {
          const name = `${prefix}${i2}`;
          if (!names.includes(name))
            return name;
        }
      }
      resolveNodes() {
        const {
          map: map2,
          _cstAliases
        } = this;
        Object.keys(map2).forEach((a2) => {
          map2[a2] = map2[a2].resolved;
        });
        _cstAliases.forEach((a2) => {
          a2.source = a2.source.resolved;
        });
        delete this._cstAliases;
      }
      setAnchor(node2, name) {
        if (node2 != null && !Anchors.validAnchorNode(node2)) {
          throw new Error("Anchors may only be set for Scalar, Seq and Map nodes");
        }
        if (name && /[\x00-\x19\s,[\]{}]/.test(name)) {
          throw new Error("Anchor names must not contain whitespace or control characters");
        }
        const {
          map: map2
        } = this;
        const prev = node2 && Object.keys(map2).find((a2) => map2[a2] === node2);
        if (prev) {
          if (!name) {
            return prev;
          } else if (prev !== name) {
            delete map2[prev];
            map2[name] = node2;
          }
        } else {
          if (!name) {
            if (!node2)
              return null;
            name = this.newName();
          }
          map2[name] = node2;
        }
        return name;
      }
    };
    var visit = (node2, tags2) => {
      if (node2 && typeof node2 === "object") {
        const {
          tag
        } = node2;
        if (node2 instanceof resolveSeq.Collection) {
          if (tag)
            tags2[tag] = true;
          node2.items.forEach((n3) => visit(n3, tags2));
        } else if (node2 instanceof resolveSeq.Pair) {
          visit(node2.key, tags2);
          visit(node2.value, tags2);
        } else if (node2 instanceof resolveSeq.Scalar) {
          if (tag)
            tags2[tag] = true;
        }
      }
      return tags2;
    };
    var listTagNames = (node2) => Object.keys(visit(node2, {}));
    function parseContents(doc, contents) {
      const comments = {
        before: [],
        after: []
      };
      let body = void 0;
      let spaceBefore = false;
      for (const node2 of contents) {
        if (node2.valueRange) {
          if (body !== void 0) {
            const msg = "Document contains trailing content not separated by a ... or --- line";
            doc.errors.push(new PlainValue$1.YAMLSyntaxError(node2, msg));
            break;
          }
          const res = resolveSeq.resolveNode(doc, node2);
          if (spaceBefore) {
            res.spaceBefore = true;
            spaceBefore = false;
          }
          body = res;
        } else if (node2.comment !== null) {
          const cc = body === void 0 ? comments.before : comments.after;
          cc.push(node2.comment);
        } else if (node2.type === PlainValue$1.Type.BLANK_LINE) {
          spaceBefore = true;
          if (body === void 0 && comments.before.length > 0 && !doc.commentBefore) {
            doc.commentBefore = comments.before.join("\n");
            comments.before = [];
          }
        }
      }
      doc.contents = body || null;
      if (!body) {
        doc.comment = comments.before.concat(comments.after).join("\n") || null;
      } else {
        const cb = comments.before.join("\n");
        if (cb) {
          const cbNode = body instanceof resolveSeq.Collection && body.items[0] ? body.items[0] : body;
          cbNode.commentBefore = cbNode.commentBefore ? `${cb}
${cbNode.commentBefore}` : cb;
        }
        doc.comment = comments.after.join("\n") || null;
      }
    }
    function resolveTagDirective({
      tagPrefixes
    }, directive) {
      const [handle, prefix] = directive.parameters;
      if (!handle || !prefix) {
        const msg = "Insufficient parameters given for %TAG directive";
        throw new PlainValue$1.YAMLSemanticError(directive, msg);
      }
      if (tagPrefixes.some((p2) => p2.handle === handle)) {
        const msg = "The %TAG directive must only be given at most once per handle in the same document.";
        throw new PlainValue$1.YAMLSemanticError(directive, msg);
      }
      return {
        handle,
        prefix
      };
    }
    function resolveYamlDirective(doc, directive) {
      let [version2] = directive.parameters;
      if (directive.name === "YAML:1.0")
        version2 = "1.0";
      if (!version2) {
        const msg = "Insufficient parameters given for %YAML directive";
        throw new PlainValue$1.YAMLSemanticError(directive, msg);
      }
      if (!documentOptions[version2]) {
        const v0 = doc.version || doc.options.version;
        const msg = `Document will be parsed as YAML ${v0} rather than YAML ${version2}`;
        doc.warnings.push(new PlainValue$1.YAMLWarning(directive, msg));
      }
      return version2;
    }
    function parseDirectives(doc, directives, prevDoc) {
      const directiveComments = [];
      let hasDirectives = false;
      for (const directive of directives) {
        const {
          comment,
          name
        } = directive;
        switch (name) {
          case "TAG":
            try {
              doc.tagPrefixes.push(resolveTagDirective(doc, directive));
            } catch (error2) {
              doc.errors.push(error2);
            }
            hasDirectives = true;
            break;
          case "YAML":
          case "YAML:1.0":
            if (doc.version) {
              const msg = "The %YAML directive must only be given at most once per document.";
              doc.errors.push(new PlainValue$1.YAMLSemanticError(directive, msg));
            }
            try {
              doc.version = resolveYamlDirective(doc, directive);
            } catch (error2) {
              doc.errors.push(error2);
            }
            hasDirectives = true;
            break;
          default:
            if (name) {
              const msg = `YAML only supports %TAG and %YAML directives, and not %${name}`;
              doc.warnings.push(new PlainValue$1.YAMLWarning(directive, msg));
            }
        }
        if (comment)
          directiveComments.push(comment);
      }
      if (prevDoc && !hasDirectives && (doc.version || prevDoc.version || doc.options.version) === "1.1") {
        const copyTagPrefix = ({
          handle,
          prefix
        }) => ({
          handle,
          prefix
        });
        doc.tagPrefixes = prevDoc.tagPrefixes.map(copyTagPrefix);
        doc.version = prevDoc.version;
      }
      doc.commentBefore = directiveComments.join("\n") || null;
    }
    function assertCollection(contents) {
      if (contents instanceof resolveSeq.Collection)
        return true;
      throw new Error("Expected a YAML collection as document contents");
    }
    var Document$2 = class {
      constructor(options2) {
        this.anchors = new Anchors(options2.anchorPrefix);
        this.commentBefore = null;
        this.comment = null;
        this.contents = null;
        this.directivesEndMarker = null;
        this.errors = [];
        this.options = options2;
        this.schema = null;
        this.tagPrefixes = [];
        this.version = null;
        this.warnings = [];
      }
      add(value) {
        assertCollection(this.contents);
        return this.contents.add(value);
      }
      addIn(path2, value) {
        assertCollection(this.contents);
        this.contents.addIn(path2, value);
      }
      delete(key2) {
        assertCollection(this.contents);
        return this.contents.delete(key2);
      }
      deleteIn(path2) {
        if (resolveSeq.isEmptyPath(path2)) {
          if (this.contents == null)
            return false;
          this.contents = null;
          return true;
        }
        assertCollection(this.contents);
        return this.contents.deleteIn(path2);
      }
      getDefaults() {
        return Document$2.defaults[this.version] || Document$2.defaults[this.options.version] || {};
      }
      get(key2, keepScalar) {
        return this.contents instanceof resolveSeq.Collection ? this.contents.get(key2, keepScalar) : void 0;
      }
      getIn(path2, keepScalar) {
        if (resolveSeq.isEmptyPath(path2))
          return !keepScalar && this.contents instanceof resolveSeq.Scalar ? this.contents.value : this.contents;
        return this.contents instanceof resolveSeq.Collection ? this.contents.getIn(path2, keepScalar) : void 0;
      }
      has(key2) {
        return this.contents instanceof resolveSeq.Collection ? this.contents.has(key2) : false;
      }
      hasIn(path2) {
        if (resolveSeq.isEmptyPath(path2))
          return this.contents !== void 0;
        return this.contents instanceof resolveSeq.Collection ? this.contents.hasIn(path2) : false;
      }
      set(key2, value) {
        assertCollection(this.contents);
        this.contents.set(key2, value);
      }
      setIn(path2, value) {
        if (resolveSeq.isEmptyPath(path2))
          this.contents = value;
        else {
          assertCollection(this.contents);
          this.contents.setIn(path2, value);
        }
      }
      setSchema(id, customTags) {
        if (!id && !customTags && this.schema)
          return;
        if (typeof id === "number")
          id = id.toFixed(1);
        if (id === "1.0" || id === "1.1" || id === "1.2") {
          if (this.version)
            this.version = id;
          else
            this.options.version = id;
          delete this.options.schema;
        } else if (id && typeof id === "string") {
          this.options.schema = id;
        }
        if (Array.isArray(customTags))
          this.options.customTags = customTags;
        const opt = Object.assign({}, this.getDefaults(), this.options);
        this.schema = new Schema$1.Schema(opt);
      }
      parse(node2, prevDoc) {
        if (this.options.keepCstNodes)
          this.cstNode = node2;
        if (this.options.keepNodeTypes)
          this.type = "DOCUMENT";
        const {
          directives = [],
          contents = [],
          directivesEndMarker,
          error: error2,
          valueRange
        } = node2;
        if (error2) {
          if (!error2.source)
            error2.source = this;
          this.errors.push(error2);
        }
        parseDirectives(this, directives, prevDoc);
        if (directivesEndMarker)
          this.directivesEndMarker = true;
        this.range = valueRange ? [valueRange.start, valueRange.end] : null;
        this.setSchema();
        this.anchors._cstAliases = [];
        parseContents(this, contents);
        this.anchors.resolveNodes();
        if (this.options.prettyErrors) {
          for (const error3 of this.errors)
            if (error3 instanceof PlainValue$1.YAMLError)
              error3.makePretty();
          for (const warn2 of this.warnings)
            if (warn2 instanceof PlainValue$1.YAMLError)
              warn2.makePretty();
        }
        return this;
      }
      listNonDefaultTags() {
        return listTagNames(this.contents).filter((t) => t.indexOf(Schema$1.Schema.defaultPrefix) !== 0);
      }
      setTagPrefix(handle, prefix) {
        if (handle[0] !== "!" || handle[handle.length - 1] !== "!")
          throw new Error("Handle must start and end with !");
        if (prefix) {
          const prev = this.tagPrefixes.find((p2) => p2.handle === handle);
          if (prev)
            prev.prefix = prefix;
          else
            this.tagPrefixes.push({
              handle,
              prefix
            });
        } else {
          this.tagPrefixes = this.tagPrefixes.filter((p2) => p2.handle !== handle);
        }
      }
      toJSON(arg, onAnchor) {
        const {
          keepBlobsInJSON,
          mapAsMap,
          maxAliasCount
        } = this.options;
        const keep = keepBlobsInJSON && (typeof arg !== "string" || !(this.contents instanceof resolveSeq.Scalar));
        const ctx = {
          doc: this,
          indentStep: "  ",
          keep,
          mapAsMap: keep && !!mapAsMap,
          maxAliasCount,
          stringify: stringify$2
        };
        const anchorNames = Object.keys(this.anchors.map);
        if (anchorNames.length > 0)
          ctx.anchors = new Map(anchorNames.map((name) => [this.anchors.map[name], {
            alias: [],
            aliasCount: 0,
            count: 1
          }]));
        const res = resolveSeq.toJSON(this.contents, arg, ctx);
        if (typeof onAnchor === "function" && ctx.anchors)
          for (const {
            count,
            res: res2
          } of ctx.anchors.values())
            onAnchor(res2, count);
        return res;
      }
      toString() {
        if (this.errors.length > 0)
          throw new Error("Document with errors cannot be stringified");
        const indentSize = this.options.indent;
        if (!Number.isInteger(indentSize) || indentSize <= 0) {
          const s2 = JSON.stringify(indentSize);
          throw new Error(`"indent" option must be a positive integer, not ${s2}`);
        }
        this.setSchema();
        const lines = [];
        let hasDirectives = false;
        if (this.version) {
          let vd = "%YAML 1.2";
          if (this.schema.name === "yaml-1.1") {
            if (this.version === "1.0")
              vd = "%YAML:1.0";
            else if (this.version === "1.1")
              vd = "%YAML 1.1";
          }
          lines.push(vd);
          hasDirectives = true;
        }
        const tagNames = this.listNonDefaultTags();
        this.tagPrefixes.forEach(({
          handle,
          prefix
        }) => {
          if (tagNames.some((t) => t.indexOf(prefix) === 0)) {
            lines.push(`%TAG ${handle} ${prefix}`);
            hasDirectives = true;
          }
        });
        if (hasDirectives || this.directivesEndMarker)
          lines.push("---");
        if (this.commentBefore) {
          if (hasDirectives || !this.directivesEndMarker)
            lines.unshift("");
          lines.unshift(this.commentBefore.replace(/^/gm, "#"));
        }
        const ctx = {
          anchors: /* @__PURE__ */ Object.create(null),
          doc: this,
          indent: "",
          indentStep: " ".repeat(indentSize),
          stringify: stringify$2
        };
        let chompKeep = false;
        let contentComment = null;
        if (this.contents) {
          if (this.contents instanceof resolveSeq.Node) {
            if (this.contents.spaceBefore && (hasDirectives || this.directivesEndMarker))
              lines.push("");
            if (this.contents.commentBefore)
              lines.push(this.contents.commentBefore.replace(/^/gm, "#"));
            ctx.forceBlockIndent = !!this.comment;
            contentComment = this.contents.comment;
          }
          const onChompKeep = contentComment ? null : () => chompKeep = true;
          const body = stringify$2(this.contents, ctx, () => contentComment = null, onChompKeep);
          lines.push(resolveSeq.addComment(body, "", contentComment));
        } else if (this.contents !== void 0) {
          lines.push(stringify$2(this.contents, ctx));
        }
        if (this.comment) {
          if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
            lines.push("");
          lines.push(this.comment.replace(/^/gm, "#"));
        }
        return lines.join("\n") + "\n";
      }
    };
    PlainValue$1._defineProperty(Document$2, "defaults", documentOptions);
    Document9b4560a1.Document = Document$2;
    Document9b4560a1.defaultOptions = defaultOptions$1;
    Document9b4560a1.scalarOptions = scalarOptions;
    var parseCst = parseCst$1;
    var Document$1 = Document9b4560a1;
    var Schema = Schema88e323a7;
    var PlainValue = PlainValueEc8e588e;
    var warnings = warnings1000a372;
    function createNode(value, wrapScalars = true, tag) {
      if (tag === void 0 && typeof wrapScalars === "string") {
        tag = wrapScalars;
        wrapScalars = true;
      }
      const options2 = Object.assign({}, Document$1.Document.defaults[Document$1.defaultOptions.version], Document$1.defaultOptions);
      const schema = new Schema.Schema(options2);
      return schema.createNode(value, wrapScalars, tag);
    }
    var Document = class extends Document$1.Document {
      constructor(options2) {
        super(Object.assign({}, Document$1.defaultOptions, options2));
      }
    };
    function parseAllDocuments(src2, options2) {
      const stream2 = [];
      let prev;
      for (const cstDoc of parseCst.parse(src2)) {
        const doc = new Document(options2);
        doc.parse(cstDoc, prev);
        stream2.push(doc);
        prev = doc;
      }
      return stream2;
    }
    function parseDocument(src2, options2) {
      const cst = parseCst.parse(src2);
      const doc = new Document(options2).parse(cst[0]);
      if (cst.length > 1) {
        const errMsg = "Source contains multiple documents; please use YAML.parseAllDocuments()";
        doc.errors.unshift(new PlainValue.YAMLSemanticError(cst[1], errMsg));
      }
      return doc;
    }
    function parse$f(src2, options2) {
      const doc = parseDocument(src2, options2);
      doc.warnings.forEach((warning) => warnings.warn(warning));
      if (doc.errors.length > 0)
        throw doc.errors[0];
      return doc.toJSON();
    }
    function stringify$1(value, options2) {
      const doc = new Document(options2);
      doc.contents = value;
      return String(doc);
    }
    var YAML = {
      createNode,
      defaultOptions: Document$1.defaultOptions,
      Document,
      parse: parse$f,
      parseAllDocuments,
      parseCST: parseCst.parse,
      parseDocument,
      scalarOptions: Document$1.scalarOptions,
      stringify: stringify$1
    };
    dist.YAML = YAML;
    var yaml$1 = dist.YAML;
    var { createRequire, createRequireFromPath } = require$$0__default$4;
    function req$2(name, rootFile) {
      const create = createRequire || createRequireFromPath;
      const require2 = create(rootFile);
      return require2(name);
    }
    var req_1 = req$2;
    var req$1 = req_1;
    var options = (config2, file) => {
      if (config2.parser && typeof config2.parser === "string") {
        try {
          config2.parser = req$1(config2.parser, file);
        } catch (err) {
          throw new Error(`Loading PostCSS Parser failed: ${err.message}

(@${file})`);
        }
      }
      if (config2.syntax && typeof config2.syntax === "string") {
        try {
          config2.syntax = req$1(config2.syntax, file);
        } catch (err) {
          throw new Error(`Loading PostCSS Syntax failed: ${err.message}

(@${file})`);
        }
      }
      if (config2.stringifier && typeof config2.stringifier === "string") {
        try {
          config2.stringifier = req$1(config2.stringifier, file);
        } catch (err) {
          throw new Error(`Loading PostCSS Stringifier failed: ${err.message}

(@${file})`);
        }
      }
      if (config2.plugins) {
        delete config2.plugins;
      }
      return config2;
    };
    var options_1 = options;
    var req = req_1;
    var load = (plugin, options2, file) => {
      try {
        if (options2 === null || options2 === void 0 || Object.keys(options2).length === 0) {
          return req(plugin, file);
        } else {
          return req(plugin, file)(options2);
        }
      } catch (err) {
        throw new Error(`Loading PostCSS Plugin failed: ${err.message}

(@${file})`);
      }
    };
    var plugins = (config2, file) => {
      let plugins2 = [];
      if (Array.isArray(config2.plugins)) {
        plugins2 = config2.plugins.filter(Boolean);
      } else {
        plugins2 = Object.keys(config2.plugins).filter((plugin) => {
          return config2.plugins[plugin] !== false ? plugin : "";
        }).map((plugin) => {
          return load(plugin, config2.plugins[plugin], file);
        });
      }
      if (plugins2.length && plugins2.length > 0) {
        plugins2.forEach((plugin, i2) => {
          if (plugin.default) {
            plugin = plugin.default;
          }
          if (plugin.postcss === true) {
            plugin = plugin();
          } else if (plugin.postcss) {
            plugin = plugin.postcss;
          }
          if (!(typeof plugin === "object" && Array.isArray(plugin.plugins) || typeof plugin === "object" && plugin.postcssPlugin || typeof plugin === "function")) {
            throw new TypeError(`Invalid PostCSS Plugin found at: plugins[${i2}]

(@${file})`);
          }
        });
      }
      return plugins2;
    };
    var plugins_1 = plugins;
    var resolve$1 = path__default.resolve;
    var config$1 = dist$1;
    var yaml = yaml$1;
    var loadOptions = options_1;
    var loadPlugins = plugins_1;
    var interopRequireDefault = (obj) => obj && obj.__esModule ? obj : { default: obj };
    var processResult = (ctx, result2) => {
      const file = result2.filepath || "";
      let config2 = interopRequireDefault(result2.config).default || {};
      if (typeof config2 === "function") {
        config2 = config2(ctx);
      } else {
        config2 = Object.assign({}, config2, ctx);
      }
      if (!config2.plugins) {
        config2.plugins = [];
      }
      return {
        plugins: loadPlugins(config2, file),
        options: loadOptions(config2, file),
        file
      };
    };
    var createContext = (ctx) => {
      ctx = Object.assign({
        cwd: process.cwd(),
        env: "development"
      }, ctx);
      if (!ctx.env) {
        "development" = "development";
      }
      return ctx;
    };
    var addTypeScriptLoader = (options2 = {}, loader) => {
      const moduleName = "postcss";
      return __spreadProps2(__spreadValues2({}, options2), {
        searchPlaces: [
          ...options2.searchPlaces || [],
          "package.json",
          `.${moduleName}rc`,
          `.${moduleName}rc.json`,
          `.${moduleName}rc.yaml`,
          `.${moduleName}rc.yml`,
          `.${moduleName}rc.ts`,
          `.${moduleName}rc.js`,
          `.${moduleName}rc.cjs`,
          `${moduleName}.config.ts`,
          `${moduleName}.config.js`,
          `${moduleName}.config.cjs`
        ],
        loaders: __spreadProps2(__spreadValues2({}, options2.loaders), {
          ".yaml": (filepath, content2) => yaml.parse(content2),
          ".yml": (filepath, content2) => yaml.parse(content2),
          ".ts": loader
        })
      });
    };
    var withTypeScriptLoader = (rcFunc) => {
      return (ctx, path2, options2) => {
        return rcFunc(ctx, path2, addTypeScriptLoader(options2, (configFile) => {
          let registerer = { enabled() {
          } };
          try {
            registerer = __require("ts-node").register();
            return commonjsRequire(configFile);
          } catch (err) {
            if (err.code === "MODULE_NOT_FOUND") {
              throw new Error(`'ts-node' is required for the TypeScript configuration files. Make sure it is installed
Error: ${err.message}`);
            }
            throw err;
          } finally {
            registerer.enabled(false);
          }
        }));
      };
    };
    var rc = withTypeScriptLoader((ctx, path2, options2) => {
      ctx = createContext(ctx);
      path2 = path2 ? resolve$1(path2) : process.cwd();
      return config$1.lilconfig("postcss", options2).search(path2).then((result2) => {
        if (!result2) {
          throw new Error(`No PostCSS Config found in: ${path2}`);
        }
        return processResult(ctx, result2);
      });
    });
    rc.sync = withTypeScriptLoader((ctx, path2, options2) => {
      ctx = createContext(ctx);
      path2 = path2 ? resolve$1(path2) : process.cwd();
      const result2 = config$1.lilconfigSync("postcss", options2).search(path2);
      if (!result2) {
        throw new Error(`No PostCSS Config found in: ${path2}`);
      }
      return processResult(ctx, result2);
    });
    var src$1 = rc;
    var mimes$1 = {
      "ez": "application/andrew-inset",
      "aw": "application/applixware",
      "atom": "application/atom+xml",
      "atomcat": "application/atomcat+xml",
      "atomdeleted": "application/atomdeleted+xml",
      "atomsvc": "application/atomsvc+xml",
      "dwd": "application/atsc-dwd+xml",
      "held": "application/atsc-held+xml",
      "rsat": "application/atsc-rsat+xml",
      "bdoc": "application/bdoc",
      "xcs": "application/calendar+xml",
      "ccxml": "application/ccxml+xml",
      "cdfx": "application/cdfx+xml",
      "cdmia": "application/cdmi-capability",
      "cdmic": "application/cdmi-container",
      "cdmid": "application/cdmi-domain",
      "cdmio": "application/cdmi-object",
      "cdmiq": "application/cdmi-queue",
      "cu": "application/cu-seeme",
      "mpd": "application/dash+xml",
      "davmount": "application/davmount+xml",
      "dbk": "application/docbook+xml",
      "dssc": "application/dssc+der",
      "xdssc": "application/dssc+xml",
      "es": "application/ecmascript",
      "ecma": "application/ecmascript",
      "emma": "application/emma+xml",
      "emotionml": "application/emotionml+xml",
      "epub": "application/epub+zip",
      "exi": "application/exi",
      "fdt": "application/fdt+xml",
      "pfr": "application/font-tdpfr",
      "geojson": "application/geo+json",
      "gml": "application/gml+xml",
      "gpx": "application/gpx+xml",
      "gxf": "application/gxf",
      "gz": "application/gzip",
      "hjson": "application/hjson",
      "stk": "application/hyperstudio",
      "ink": "application/inkml+xml",
      "inkml": "application/inkml+xml",
      "ipfix": "application/ipfix",
      "its": "application/its+xml",
      "jar": "application/java-archive",
      "war": "application/java-archive",
      "ear": "application/java-archive",
      "ser": "application/java-serialized-object",
      "class": "application/java-vm",
      "js": "application/javascript",
      "mjs": "application/javascript",
      "json": "application/json",
      "map": "application/json",
      "json5": "application/json5",
      "jsonml": "application/jsonml+json",
      "jsonld": "application/ld+json",
      "lgr": "application/lgr+xml",
      "lostxml": "application/lost+xml",
      "hqx": "application/mac-binhex40",
      "cpt": "application/mac-compactpro",
      "mads": "application/mads+xml",
      "webmanifest": "application/manifest+json",
      "mrc": "application/marc",
      "mrcx": "application/marcxml+xml",
      "ma": "application/mathematica",
      "nb": "application/mathematica",
      "mb": "application/mathematica",
      "mathml": "application/mathml+xml",
      "mbox": "application/mbox",
      "mscml": "application/mediaservercontrol+xml",
      "metalink": "application/metalink+xml",
      "meta4": "application/metalink4+xml",
      "mets": "application/mets+xml",
      "maei": "application/mmt-aei+xml",
      "musd": "application/mmt-usd+xml",
      "mods": "application/mods+xml",
      "m21": "application/mp21",
      "mp21": "application/mp21",
      "mp4s": "application/mp4",
      "m4p": "application/mp4",
      "doc": "application/msword",
      "dot": "application/msword",
      "mxf": "application/mxf",
      "nq": "application/n-quads",
      "nt": "application/n-triples",
      "cjs": "application/node",
      "bin": "application/octet-stream",
      "dms": "application/octet-stream",
      "lrf": "application/octet-stream",
      "mar": "application/octet-stream",
      "so": "application/octet-stream",
      "dist": "application/octet-stream",
      "distz": "application/octet-stream",
      "pkg": "application/octet-stream",
      "bpk": "application/octet-stream",
      "dump": "application/octet-stream",
      "elc": "application/octet-stream",
      "deploy": "application/octet-stream",
      "exe": "application/octet-stream",
      "dll": "application/octet-stream",
      "deb": "application/octet-stream",
      "dmg": "application/octet-stream",
      "iso": "application/octet-stream",
      "img": "application/octet-stream",
      "msi": "application/octet-stream",
      "msp": "application/octet-stream",
      "msm": "application/octet-stream",
      "buffer": "application/octet-stream",
      "oda": "application/oda",
      "opf": "application/oebps-package+xml",
      "ogx": "application/ogg",
      "omdoc": "application/omdoc+xml",
      "onetoc": "application/onenote",
      "onetoc2": "application/onenote",
      "onetmp": "application/onenote",
      "onepkg": "application/onenote",
      "oxps": "application/oxps",
      "relo": "application/p2p-overlay+xml",
      "xer": "application/patch-ops-error+xml",
      "pdf": "application/pdf",
      "pgp": "application/pgp-encrypted",
      "asc": "application/pgp-signature",
      "sig": "application/pgp-signature",
      "prf": "application/pics-rules",
      "p10": "application/pkcs10",
      "p7m": "application/pkcs7-mime",
      "p7c": "application/pkcs7-mime",
      "p7s": "application/pkcs7-signature",
      "p8": "application/pkcs8",
      "ac": "application/pkix-attr-cert",
      "cer": "application/pkix-cert",
      "crl": "application/pkix-crl",
      "pkipath": "application/pkix-pkipath",
      "pki": "application/pkixcmp",
      "pls": "application/pls+xml",
      "ai": "application/postscript",
      "eps": "application/postscript",
      "ps": "application/postscript",
      "provx": "application/provenance+xml",
      "cww": "application/prs.cww",
      "pskcxml": "application/pskc+xml",
      "raml": "application/raml+yaml",
      "rdf": "application/rdf+xml",
      "owl": "application/rdf+xml",
      "rif": "application/reginfo+xml",
      "rnc": "application/relax-ng-compact-syntax",
      "rl": "application/resource-lists+xml",
      "rld": "application/resource-lists-diff+xml",
      "rs": "application/rls-services+xml",
      "rapd": "application/route-apd+xml",
      "sls": "application/route-s-tsid+xml",
      "rusd": "application/route-usd+xml",
      "gbr": "application/rpki-ghostbusters",
      "mft": "application/rpki-manifest",
      "roa": "application/rpki-roa",
      "rsd": "application/rsd+xml",
      "rss": "application/rss+xml",
      "rtf": "application/rtf",
      "sbml": "application/sbml+xml",
      "scq": "application/scvp-cv-request",
      "scs": "application/scvp-cv-response",
      "spq": "application/scvp-vp-request",
      "spp": "application/scvp-vp-response",
      "sdp": "application/sdp",
      "senmlx": "application/senml+xml",
      "sensmlx": "application/sensml+xml",
      "setpay": "application/set-payment-initiation",
      "setreg": "application/set-registration-initiation",
      "shf": "application/shf+xml",
      "siv": "application/sieve",
      "sieve": "application/sieve",
      "smi": "application/smil+xml",
      "smil": "application/smil+xml",
      "rq": "application/sparql-query",
      "srx": "application/sparql-results+xml",
      "gram": "application/srgs",
      "grxml": "application/srgs+xml",
      "sru": "application/sru+xml",
      "ssdl": "application/ssdl+xml",
      "ssml": "application/ssml+xml",
      "swidtag": "application/swid+xml",
      "tei": "application/tei+xml",
      "teicorpus": "application/tei+xml",
      "tfi": "application/thraud+xml",
      "tsd": "application/timestamped-data",
      "toml": "application/toml",
      "trig": "application/trig",
      "ttml": "application/ttml+xml",
      "ubj": "application/ubjson",
      "rsheet": "application/urc-ressheet+xml",
      "td": "application/urc-targetdesc+xml",
      "vxml": "application/voicexml+xml",
      "wasm": "application/wasm",
      "wgt": "application/widget",
      "hlp": "application/winhlp",
      "wsdl": "application/wsdl+xml",
      "wspolicy": "application/wspolicy+xml",
      "xaml": "application/xaml+xml",
      "xav": "application/xcap-att+xml",
      "xca": "application/xcap-caps+xml",
      "xdf": "application/xcap-diff+xml",
      "xel": "application/xcap-el+xml",
      "xns": "application/xcap-ns+xml",
      "xenc": "application/xenc+xml",
      "xhtml": "application/xhtml+xml",
      "xht": "application/xhtml+xml",
      "xlf": "application/xliff+xml",
      "xml": "application/xml",
      "xsl": "application/xml",
      "xsd": "application/xml",
      "rng": "application/xml",
      "dtd": "application/xml-dtd",
      "xop": "application/xop+xml",
      "xpl": "application/xproc+xml",
      "xslt": "application/xml",
      "xspf": "application/xspf+xml",
      "mxml": "application/xv+xml",
      "xhvml": "application/xv+xml",
      "xvml": "application/xv+xml",
      "xvm": "application/xv+xml",
      "yang": "application/yang",
      "yin": "application/yin+xml",
      "zip": "application/zip",
      "3gpp": "video/3gpp",
      "adp": "audio/adpcm",
      "amr": "audio/amr",
      "au": "audio/basic",
      "snd": "audio/basic",
      "mid": "audio/midi",
      "midi": "audio/midi",
      "kar": "audio/midi",
      "rmi": "audio/midi",
      "mxmf": "audio/mobile-xmf",
      "mp3": "audio/mpeg",
      "m4a": "audio/mp4",
      "mp4a": "audio/mp4",
      "mpga": "audio/mpeg",
      "mp2": "audio/mpeg",
      "mp2a": "audio/mpeg",
      "m2a": "audio/mpeg",
      "m3a": "audio/mpeg",
      "oga": "audio/ogg",
      "ogg": "audio/ogg",
      "spx": "audio/ogg",
      "opus": "audio/ogg",
      "s3m": "audio/s3m",
      "sil": "audio/silk",
      "wav": "audio/wav",
      "weba": "audio/webm",
      "xm": "audio/xm",
      "ttc": "font/collection",
      "otf": "font/otf",
      "ttf": "font/ttf",
      "woff": "font/woff",
      "woff2": "font/woff2",
      "exr": "image/aces",
      "apng": "image/apng",
      "avif": "image/avif",
      "bmp": "image/bmp",
      "cgm": "image/cgm",
      "drle": "image/dicom-rle",
      "emf": "image/emf",
      "fits": "image/fits",
      "g3": "image/g3fax",
      "gif": "image/gif",
      "heic": "image/heic",
      "heics": "image/heic-sequence",
      "heif": "image/heif",
      "heifs": "image/heif-sequence",
      "hej2": "image/hej2k",
      "hsj2": "image/hsj2",
      "ief": "image/ief",
      "jls": "image/jls",
      "jp2": "image/jp2",
      "jpg2": "image/jp2",
      "jpeg": "image/jpeg",
      "jpg": "image/jpeg",
      "jpe": "image/jpeg",
      "jph": "image/jph",
      "jhc": "image/jphc",
      "jpm": "image/jpm",
      "jpx": "image/jpx",
      "jpf": "image/jpx",
      "jxr": "image/jxr",
      "jxra": "image/jxra",
      "jxrs": "image/jxrs",
      "jxs": "image/jxs",
      "jxsc": "image/jxsc",
      "jxsi": "image/jxsi",
      "jxss": "image/jxss",
      "ktx": "image/ktx",
      "ktx2": "image/ktx2",
      "png": "image/png",
      "btif": "image/prs.btif",
      "pti": "image/prs.pti",
      "sgi": "image/sgi",
      "svg": "image/svg+xml",
      "svgz": "image/svg+xml",
      "t38": "image/t38",
      "tif": "image/tiff",
      "tiff": "image/tiff",
      "tfx": "image/tiff-fx",
      "webp": "image/webp",
      "wmf": "image/wmf",
      "disposition-notification": "message/disposition-notification",
      "u8msg": "message/global",
      "u8dsn": "message/global-delivery-status",
      "u8mdn": "message/global-disposition-notification",
      "u8hdr": "message/global-headers",
      "eml": "message/rfc822",
      "mime": "message/rfc822",
      "3mf": "model/3mf",
      "gltf": "model/gltf+json",
      "glb": "model/gltf-binary",
      "igs": "model/iges",
      "iges": "model/iges",
      "msh": "model/mesh",
      "mesh": "model/mesh",
      "silo": "model/mesh",
      "mtl": "model/mtl",
      "obj": "model/obj",
      "stpz": "model/step+zip",
      "stpxz": "model/step-xml+zip",
      "stl": "model/stl",
      "wrl": "model/vrml",
      "vrml": "model/vrml",
      "x3db": "model/x3d+fastinfoset",
      "x3dbz": "model/x3d+binary",
      "x3dv": "model/x3d-vrml",
      "x3dvz": "model/x3d+vrml",
      "x3d": "model/x3d+xml",
      "x3dz": "model/x3d+xml",
      "appcache": "text/cache-manifest",
      "manifest": "text/cache-manifest",
      "ics": "text/calendar",
      "ifb": "text/calendar",
      "coffee": "text/coffeescript",
      "litcoffee": "text/coffeescript",
      "css": "text/css",
      "csv": "text/csv",
      "html": "text/html",
      "htm": "text/html",
      "shtml": "text/html",
      "jade": "text/jade",
      "jsx": "text/jsx",
      "less": "text/less",
      "markdown": "text/markdown",
      "md": "text/markdown",
      "mml": "text/mathml",
      "mdx": "text/mdx",
      "n3": "text/n3",
      "txt": "text/plain",
      "text": "text/plain",
      "conf": "text/plain",
      "def": "text/plain",
      "list": "text/plain",
      "log": "text/plain",
      "in": "text/plain",
      "ini": "text/plain",
      "dsc": "text/prs.lines.tag",
      "rtx": "text/richtext",
      "sgml": "text/sgml",
      "sgm": "text/sgml",
      "shex": "text/shex",
      "slim": "text/slim",
      "slm": "text/slim",
      "spdx": "text/spdx",
      "stylus": "text/stylus",
      "styl": "text/stylus",
      "tsv": "text/tab-separated-values",
      "t": "text/troff",
      "tr": "text/troff",
      "roff": "text/troff",
      "man": "text/troff",
      "me": "text/troff",
      "ms": "text/troff",
      "ttl": "text/turtle",
      "uri": "text/uri-list",
      "uris": "text/uri-list",
      "urls": "text/uri-list",
      "vcard": "text/vcard",
      "vtt": "text/vtt",
      "yaml": "text/yaml",
      "yml": "text/yaml",
      "3gp": "video/3gpp",
      "3g2": "video/3gpp2",
      "h261": "video/h261",
      "h263": "video/h263",
      "h264": "video/h264",
      "m4s": "video/iso.segment",
      "jpgv": "video/jpeg",
      "jpgm": "image/jpm",
      "mj2": "video/mj2",
      "mjp2": "video/mj2",
      "ts": "video/mp2t",
      "mp4": "video/mp4",
      "mp4v": "video/mp4",
      "mpg4": "video/mp4",
      "mpeg": "video/mpeg",
      "mpg": "video/mpeg",
      "mpe": "video/mpeg",
      "m1v": "video/mpeg",
      "m2v": "video/mpeg",
      "ogv": "video/ogg",
      "qt": "video/quicktime",
      "mov": "video/quicktime",
      "webm": "video/webm"
    };
    function lookup(extn) {
      let tmp = ("" + extn).trim().toLowerCase();
      let idx = tmp.lastIndexOf(".");
      return mimes$1[!~idx ? tmp : tmp.substring(++idx)];
    }
    var assetUrlRE = /__VITE_ASSET__([a-z\d]{8})__(?:\$_(.*?)__)?/g;
    var rawRE = /(\?|&)raw(?:&|$)/;
    var urlRE = /(\?|&)url(?:&|$)/;
    var assetCache = /* @__PURE__ */ new WeakMap();
    var assetHashToFilenameMap = /* @__PURE__ */ new WeakMap();
    var emittedHashMap = /* @__PURE__ */ new WeakMap();
    function assetPlugin(config2) {
      assetHashToFilenameMap.set(config2, /* @__PURE__ */ new Map());
      mimes$1["ico"] = "image/x-icon";
      return {
        name: "vite:asset",
        buildStart() {
          assetCache.set(config2, /* @__PURE__ */ new Map());
          emittedHashMap.set(config2, /* @__PURE__ */ new Set());
        },
        resolveId(id) {
          if (!config2.assetsInclude(cleanUrl(id))) {
            return;
          }
          const publicFile = checkPublicFile(id, config2);
          if (publicFile) {
            return id;
          }
        },
        async load(id) {
          if (id.startsWith("\0")) {
            return;
          }
          if (rawRE.test(id)) {
            const file = checkPublicFile(id, config2) || cleanUrl(id);
            return `export default ${JSON.stringify(await fs$n.promises.readFile(file, "utf-8"))}`;
          }
          if (!config2.assetsInclude(cleanUrl(id)) && !urlRE.test(id)) {
            return;
          }
          id = id.replace(urlRE, "$1").replace(/[\?&]$/, "");
          const url2 = await fileToUrl(id, config2, this);
          return `export default ${JSON.stringify(url2)}`;
        },
        renderChunk(code, chunk) {
          let match2;
          let s2;
          while (match2 = assetUrlRE.exec(code)) {
            s2 = s2 || (s2 = new MagicString(code));
            const [full, hash, postfix = ""] = match2;
            const file = getAssetFilename(hash, config2) || this.getFileName(hash);
            chunk.viteMetadata.importedAssets.add(cleanUrl(file));
            const outputFilepath = config2.base + file + postfix;
            s2.overwrite(match2.index, match2.index + full.length, outputFilepath, {
              contentOnly: true
            });
          }
          if (s2) {
            return {
              code: s2.toString(),
              map: config2.build.sourcemap ? s2.generateMap({ hires: true }) : null
            };
          } else {
            return null;
          }
        },
        generateBundle(_2, bundle) {
          if (config2.command === "build" && config2.build.ssr) {
            for (const file in bundle) {
              if (bundle[file].type === "asset" && !file.includes("ssr-manifest.json")) {
                delete bundle[file];
              }
            }
          }
        }
      };
    }
    function checkPublicFile(url2, { publicDir }) {
      if (!publicDir || !url2.startsWith("/")) {
        return;
      }
      const publicFile = path__default.join(publicDir, cleanUrl(url2));
      if (fs__default.existsSync(publicFile)) {
        return publicFile;
      } else {
        return;
      }
    }
    async function fileToUrl(id, config2, ctx) {
      if (config2.command === "serve") {
        return fileToDevUrl(id, config2);
      } else {
        return fileToBuiltUrl(id, config2, ctx);
      }
    }
    function fileToDevUrl(id, config2) {
      var _a2, _b;
      let rtn;
      if (checkPublicFile(id, config2)) {
        rtn = id;
      } else if (id.startsWith(config2.root)) {
        rtn = "/" + path__default.posix.relative(config2.root, id);
      } else {
        rtn = path__default.posix.join(FS_PREFIX + id);
      }
      const origin = (_b = (_a2 = config2.server) === null || _a2 === void 0 ? void 0 : _a2.origin) !== null && _b !== void 0 ? _b : "";
      return origin + config2.base + rtn.replace(/^\//, "");
    }
    function getAssetFilename(hash, config2) {
      var _a2;
      return (_a2 = assetHashToFilenameMap.get(config2)) === null || _a2 === void 0 ? void 0 : _a2.get(hash);
    }
    function assetFileNamesToFileName(assetFileNames, file, contentHash, content2) {
      const basename = path__default.basename(file);
      const extname = path__default.extname(basename);
      const ext2 = extname.substring(1);
      const name = basename.slice(0, -extname.length);
      const hash = contentHash;
      if (typeof assetFileNames === "function") {
        assetFileNames = assetFileNames({
          name: file,
          source: content2,
          type: "asset"
        });
        if (typeof assetFileNames !== "string") {
          throw new TypeError("assetFileNames must return a string");
        }
      } else if (typeof assetFileNames !== "string") {
        throw new TypeError("assetFileNames must be a string or a function");
      }
      const fileName = assetFileNames.replace(/\[\w+\]/g, (placeholder) => {
        switch (placeholder) {
          case "[ext]":
            return ext2;
          case "[extname]":
            return extname;
          case "[hash]":
            return hash;
          case "[name]":
            return name;
        }
        throw new Error(`invalid placeholder ${placeholder} in assetFileNames "${assetFileNames}"`);
      });
      return fileName;
    }
    async function fileToBuiltUrl(id, config2, pluginContext, skipPublicCheck = false) {
      var _a2, _b, _c;
      if (!skipPublicCheck && checkPublicFile(id, config2)) {
        return config2.base + id.slice(1);
      }
      const cache2 = assetCache.get(config2);
      const cached = cache2.get(id);
      if (cached) {
        return cached;
      }
      const file = cleanUrl(id);
      const content2 = await fs$n.promises.readFile(file);
      let url2;
      if (config2.build.lib || !file.endsWith(".svg") && content2.length < Number(config2.build.assetsInlineLimit)) {
        url2 = `data:${lookup(file)};base64,${content2.toString("base64")}`;
      } else {
        const map2 = assetHashToFilenameMap.get(config2);
        const contentHash = getAssetHash(content2);
        const { search, hash } = require$$0$4.parse(id);
        const postfix = (search || "") + (hash || "");
        const output = (_b = (_a2 = config2.build) === null || _a2 === void 0 ? void 0 : _a2.rollupOptions) === null || _b === void 0 ? void 0 : _b.output;
        const assetFileNames = (_c = output && !Array.isArray(output) ? output.assetFileNames : void 0) !== null && _c !== void 0 ? _c : path__default.posix.join(config2.build.assetsDir, "[name].[hash][extname]");
        const fileName = assetFileNamesToFileName(assetFileNames, file, contentHash, content2);
        if (!map2.has(contentHash)) {
          map2.set(contentHash, fileName);
        }
        const emittedSet = emittedHashMap.get(config2);
        if (!emittedSet.has(contentHash)) {
          const name = normalizePath$4(path__default.relative(config2.root, file));
          pluginContext.emitFile({
            name,
            fileName,
            type: "asset",
            source: content2
          });
          emittedSet.add(contentHash);
        }
        url2 = `__VITE_ASSET__${contentHash}__${postfix ? `$_${postfix}__` : ``}`;
      }
      cache2.set(id, url2);
      return url2;
    }
    function getAssetHash(content2) {
      return require$$1$2.createHash("sha256").update(content2).digest("hex").slice(0, 8);
    }
    async function urlToBuiltUrl(url2, importer, config2, pluginContext) {
      if (checkPublicFile(url2, config2)) {
        return config2.base + url2.slice(1);
      }
      const file = url2.startsWith("/") ? path__default.join(config2.root, url2) : path__default.join(path__default.dirname(importer), url2);
      return fileToBuiltUrl(file, config2, pluginContext, true);
    }
    var modulePreloadPolyfillId = "vite/modulepreload-polyfill";
    function modulePreloadPolyfillPlugin(config2) {
      const skip = config2.build.ssr;
      let polyfillString;
      return {
        name: "vite:modulepreload-polyfill",
        resolveId(id) {
          if (id === modulePreloadPolyfillId) {
            return id;
          }
        },
        load(id) {
          if (id === modulePreloadPolyfillId) {
            if (skip) {
              return "";
            }
            if (!polyfillString) {
              polyfillString = `const p = ${polyfill.toString()};${isModernFlag}&&p();`;
            }
            return polyfillString;
          }
        }
      };
    }
    function polyfill() {
      const relList = document.createElement("link").relList;
      if (relList && relList.supports && relList.supports("modulepreload")) {
        return;
      }
      for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
        processPreload(link);
      }
      new MutationObserver((mutations) => {
        for (const mutation of mutations) {
          if (mutation.type !== "childList") {
            continue;
          }
          for (const node2 of mutation.addedNodes) {
            if (node2.tagName === "LINK" && node2.rel === "modulepreload")
              processPreload(node2);
          }
        }
      }).observe(document, { childList: true, subtree: true });
      function getFetchOpts(script) {
        const fetchOpts = {};
        if (script.integrity)
          fetchOpts.integrity = script.integrity;
        if (script.referrerpolicy)
          fetchOpts.referrerPolicy = script.referrerpolicy;
        if (script.crossorigin === "use-credentials")
          fetchOpts.credentials = "include";
        else if (script.crossorigin === "anonymous")
          fetchOpts.credentials = "omit";
        else
          fetchOpts.credentials = "same-origin";
        return fetchOpts;
      }
      function processPreload(link) {
        if (link.ep)
          return;
        link.ep = true;
        const fetchOpts = getFetchOpts(link);
        fetch(link.href, fetchOpts);
      }
    }
    var htmlProxyRE$1 = /\?html-proxy=?[&inline\-css]*&index=(\d+)\.(js|css)$/;
    var inlineCSSRE$1 = /__VITE_INLINE_CSS__([^_]+_\d+)__/g;
    var htmlLangRE = /\.(html|htm)$/;
    var inlineImportRE = /\bimport\s*\(("[^"]*"|'[^']*')\)/g;
    var isHTMLProxy = (id) => htmlProxyRE$1.test(id);
    var isHTMLRequest = (request) => htmlLangRE.test(request);
    var htmlProxyMap = /* @__PURE__ */ new WeakMap();
    var htmlProxyResult = /* @__PURE__ */ new Map();
    function htmlInlineProxyPlugin(config2) {
      htmlProxyMap.set(config2, /* @__PURE__ */ new Map());
      return {
        name: "vite:html-inline-proxy",
        resolveId(id) {
          if (htmlProxyRE$1.test(id)) {
            return id;
          }
        },
        load(id) {
          const proxyMatch = id.match(htmlProxyRE$1);
          if (proxyMatch) {
            const index2 = Number(proxyMatch[1]);
            const file = cleanUrl(id);
            const url2 = file.replace(normalizePath$4(config2.root), "");
            const result2 = htmlProxyMap.get(config2).get(url2)[index2];
            if (result2) {
              return result2;
            } else {
              throw new Error(`No matching HTML proxy module found from ${id}`);
            }
          }
        }
      };
    }
    function addToHTMLProxyCache(config2, filePath, index2, result2) {
      if (!htmlProxyMap.get(config2)) {
        htmlProxyMap.set(config2, /* @__PURE__ */ new Map());
      }
      if (!htmlProxyMap.get(config2).get(filePath)) {
        htmlProxyMap.get(config2).set(filePath, []);
      }
      htmlProxyMap.get(config2).get(filePath)[index2] = result2;
    }
    function addToHTMLProxyTransformResult(hash, code) {
      htmlProxyResult.set(hash, code);
    }
    var assetAttrsConfig = {
      link: ["href"],
      video: ["src", "poster"],
      source: ["src", "srcset"],
      img: ["src", "srcset"],
      image: ["xlink:href", "href"],
      use: ["xlink:href", "href"]
    };
    var isAsyncScriptMap = /* @__PURE__ */ new WeakMap();
    async function traverseHtml(html, filePath, visitor) {
      const { parse: parse2, transform: transform2 } = await Promise.resolve().then(function() {
        return require_dep_86378e0d();
      }).then(function(n3) {
        return n3.compilerDom_cjs;
      });
      html = html.replace(/<!doctype\s/i, "<!DOCTYPE ");
      try {
        const ast = parse2(html, { comments: true });
        transform2(ast, {
          nodeTransforms: [visitor]
        });
      } catch (e2) {
        handleParseError(e2, html, filePath);
      }
    }
    function getScriptInfo(node2) {
      let src2;
      let isModule = false;
      let isAsync = false;
      for (let i2 = 0; i2 < node2.props.length; i2++) {
        const p2 = node2.props[i2];
        if (p2.type === 6) {
          if (p2.name === "src") {
            src2 = p2;
          } else if (p2.name === "type" && p2.value && p2.value.content === "module") {
            isModule = true;
          } else if (p2.name === "async") {
            isAsync = true;
          }
        }
      }
      return { src: src2, isModule, isAsync };
    }
    function formatParseError(compilerError, id, html) {
      const formattedError = __spreadValues2({}, compilerError);
      if (compilerError.loc) {
        formattedError.frame = generateCodeFrame(html, compilerError.loc.start.offset);
        formattedError.loc = {
          file: id,
          line: compilerError.loc.start.line,
          column: compilerError.loc.start.column
        };
      }
      return formattedError;
    }
    function handleParseError(compilerError, html, filePath) {
      const parseError = __spreadValues2({
        loc: filePath,
        frame: ""
      }, formatParseError(compilerError, filePath, html));
      throw new Error(`Unable to parse HTML; ${compilerError.message}
 at ${JSON.stringify(parseError.loc)}
${parseError.frame}`);
    }
    function buildHtmlPlugin(config2) {
      const [preHooks, postHooks] = resolveHtmlTransforms(config2.plugins);
      const processedHtml = /* @__PURE__ */ new Map();
      const isExcludedUrl = (url2) => url2.startsWith("#") || isExternalUrl(url2) || isDataUrl(url2) || checkPublicFile(url2, config2);
      isAsyncScriptMap.set(config2, /* @__PURE__ */ new Map());
      return {
        name: "vite:build-html",
        async transform(html, id) {
          var _a2, _b;
          if (id.endsWith(".html")) {
            const publicPath = `/${slash$1(path__default.relative(config2.root, id))}`;
            html = await applyHtmlTransforms(html, preHooks, {
              path: publicPath,
              filename: id
            });
            let js2 = "";
            const s2 = new MagicString(html);
            const assetUrls = [];
            const scriptUrls = [];
            let inlineModuleIndex = -1;
            let everyScriptIsAsync = true;
            let someScriptsAreAsync = false;
            let someScriptsAreDefer = false;
            await traverseHtml(html, id, (node2) => {
              if (node2.type !== 1) {
                return;
              }
              let shouldRemove = false;
              if (node2.tag === "script") {
                const { src: src2, isModule, isAsync } = getScriptInfo(node2);
                const url2 = src2 && src2.value && src2.value.content;
                const isPublicFile = !!(url2 && checkPublicFile(url2, config2));
                if (isPublicFile) {
                  s2.overwrite(src2.value.loc.start.offset, src2.value.loc.end.offset, `"${config2.base + url2.slice(1)}"`, { contentOnly: true });
                }
                if (isModule) {
                  inlineModuleIndex++;
                  if (url2 && !isExcludedUrl(url2)) {
                    js2 += `
import ${JSON.stringify(url2)}`;
                    shouldRemove = true;
                  } else if (node2.children.length) {
                    const contents = node2.children.map((child) => child.content || "").join("");
                    const filePath = id.replace(normalizePath$4(config2.root), "");
                    addToHTMLProxyCache(config2, filePath, inlineModuleIndex, {
                      code: contents
                    });
                    js2 += `
import "${id}?html-proxy&index=${inlineModuleIndex}.js"`;
                    shouldRemove = true;
                  }
                  everyScriptIsAsync && (everyScriptIsAsync = isAsync);
                  someScriptsAreAsync || (someScriptsAreAsync = isAsync);
                  someScriptsAreDefer || (someScriptsAreDefer = !isAsync);
                } else if (url2 && !isPublicFile) {
                  if (!isExcludedUrl(url2)) {
                    config2.logger.warn(`<script src="${url2}"> in "${publicPath}" can't be bundled without type="module" attribute`);
                  }
                } else if (node2.children.length) {
                  const scriptNode = node2.children.pop();
                  const code = scriptNode.content;
                  let match2;
                  while (match2 = inlineImportRE.exec(code)) {
                    const { 0: full, 1: url3, index: index2 } = match2;
                    const startUrl = full.indexOf(url3);
                    const start = scriptNode.loc.start.offset + index2 + startUrl + 1;
                    const end = start + url3.length - 2;
                    scriptUrls.push({ start, end, url: url3.slice(1, -1) });
                  }
                }
              }
              const assetAttrs = assetAttrsConfig[node2.tag];
              if (assetAttrs) {
                for (const p2 of node2.props) {
                  if (p2.type === 6 && p2.value && assetAttrs.includes(p2.name)) {
                    const url2 = decodeURI(p2.value.content);
                    if (!isExcludedUrl(url2)) {
                      if (node2.tag === "link" && isCSSRequest(url2)) {
                        js2 += `
import ${JSON.stringify(url2)}`;
                        shouldRemove = true;
                      } else {
                        assetUrls.push(p2);
                      }
                    } else if (checkPublicFile(url2, config2)) {
                      s2.overwrite(p2.value.loc.start.offset, p2.value.loc.end.offset, `"${config2.base + url2.slice(1)}"`, { contentOnly: true });
                    }
                  }
                }
              }
              const inlineStyle = node2.props.find((prop) => prop.name === "style" && prop.type === 6 && prop.value && prop.value.content.includes("url("));
              if (inlineStyle) {
                inlineModuleIndex++;
                const styleNode = inlineStyle.value;
                const code = styleNode.content;
                const filePath = id.replace(normalizePath$4(config2.root), "");
                addToHTMLProxyCache(config2, filePath, inlineModuleIndex, { code });
                js2 += `
import "${id}?html-proxy&inline-css&index=${inlineModuleIndex}.css"`;
                s2.overwrite(styleNode.loc.start.offset, styleNode.loc.end.offset, `"__VITE_INLINE_CSS__${cleanUrl(id)}_${inlineModuleIndex}__"`, { contentOnly: true });
              }
              if (node2.tag === "style" && node2.children.length) {
                const styleNode = node2.children.pop();
                const filePath = id.replace(normalizePath$4(config2.root), "");
                inlineModuleIndex++;
                addToHTMLProxyCache(config2, filePath, inlineModuleIndex, {
                  code: styleNode.content
                });
                js2 += `
import "${id}?html-proxy&index=${inlineModuleIndex}.css"`;
                shouldRemove = true;
              }
              if (shouldRemove) {
                s2.remove(node2.loc.start.offset, node2.loc.end.offset);
              }
            });
            isAsyncScriptMap.get(config2).set(id, everyScriptIsAsync);
            if (someScriptsAreAsync && someScriptsAreDefer) {
              config2.logger.warn(`
Mixed async and defer script modules in ${id}, output script will fallback to defer. Every script, including inline ones, need to be marked as async for your output script to be async.`);
            }
            const namedOutput = Object.keys(((_b = (_a2 = config2 === null || config2 === void 0 ? void 0 : config2.build) === null || _a2 === void 0 ? void 0 : _a2.rollupOptions) === null || _b === void 0 ? void 0 : _b.input) || {});
            for (const attr of assetUrls) {
              const value = attr.value;
              const content2 = decodeURI(value.content);
              if (content2 !== "" && !namedOutput.includes(content2) && !namedOutput.includes(content2.replace(/^\//, ""))) {
                try {
                  const url2 = attr.name === "srcset" ? await processSrcSet(content2, ({ url: url3 }) => urlToBuiltUrl(url3, id, config2, this)) : await urlToBuiltUrl(content2, id, config2, this);
                  s2.overwrite(value.loc.start.offset, value.loc.end.offset, `"${url2}"`, { contentOnly: true });
                } catch (e2) {
                  if (e2.code !== "ENOENT") {
                    throw e2;
                  }
                }
              }
            }
            for (const { start, end, url: url2 } of scriptUrls) {
              if (!isExcludedUrl(url2)) {
                s2.overwrite(start, end, await urlToBuiltUrl(url2, id, config2, this), { contentOnly: true });
              } else if (checkPublicFile(url2, config2)) {
                s2.overwrite(start, end, config2.base + url2.slice(1), {
                  contentOnly: true
                });
              }
            }
            processedHtml.set(id, s2.toString());
            if (config2.build.polyfillModulePreload && (someScriptsAreAsync || someScriptsAreDefer)) {
              js2 = `import "${modulePreloadPolyfillId}";
${js2}`;
            }
            return js2;
          }
        },
        async generateBundle(options2, bundle) {
          const analyzedChunk = /* @__PURE__ */ new Map();
          const getImportedChunks = (chunk, seen2 = /* @__PURE__ */ new Set()) => {
            const chunks = [];
            chunk.imports.forEach((file) => {
              const importee = bundle[file];
              if ((importee === null || importee === void 0 ? void 0 : importee.type) === "chunk" && !seen2.has(file)) {
                seen2.add(file);
                chunks.push(...getImportedChunks(importee, seen2));
                chunks.push(importee);
              }
            });
            return chunks;
          };
          const toScriptTag = (chunk, isAsync) => ({
            tag: "script",
            attrs: __spreadProps2(__spreadValues2({}, isAsync ? { async: true } : {}), {
              type: "module",
              crossorigin: true,
              src: toPublicPath(chunk.fileName, config2)
            })
          });
          const toPreloadTag = (chunk) => ({
            tag: "link",
            attrs: {
              rel: "modulepreload",
              href: toPublicPath(chunk.fileName, config2)
            }
          });
          const getCssTagsForChunk = (chunk, seen2 = /* @__PURE__ */ new Set()) => {
            const tags2 = [];
            if (!analyzedChunk.has(chunk)) {
              analyzedChunk.set(chunk, 1);
              chunk.imports.forEach((file) => {
                const importee = bundle[file];
                if ((importee === null || importee === void 0 ? void 0 : importee.type) === "chunk") {
                  tags2.push(...getCssTagsForChunk(importee, seen2));
                }
              });
            }
            chunk.viteMetadata.importedCss.forEach((file) => {
              if (!seen2.has(file)) {
                seen2.add(file);
                tags2.push({
                  tag: "link",
                  attrs: {
                    rel: "stylesheet",
                    href: toPublicPath(file, config2)
                  }
                });
              }
            });
            return tags2;
          };
          for (const [id, html] of processedHtml) {
            const isAsync = isAsyncScriptMap.get(config2).get(id);
            let result2 = html;
            const chunk = Object.values(bundle).find((chunk2) => chunk2.type === "chunk" && chunk2.isEntry && chunk2.facadeModuleId === id);
            let canInlineEntry = false;
            if (chunk) {
              if (options2.format === "es" && isEntirelyImport(chunk.code)) {
                canInlineEntry = true;
              }
              const imports = getImportedChunks(chunk);
              const assetTags = canInlineEntry ? imports.map((chunk2) => toScriptTag(chunk2, isAsync)) : [toScriptTag(chunk, isAsync), ...imports.map(toPreloadTag)];
              assetTags.push(...getCssTagsForChunk(chunk));
              result2 = injectToHead(result2, assetTags);
            }
            if (!config2.build.cssCodeSplit) {
              const cssChunk = Object.values(bundle).find((chunk2) => chunk2.type === "asset" && chunk2.name === "style.css");
              if (cssChunk) {
                result2 = injectToHead(result2, [
                  {
                    tag: "link",
                    attrs: {
                      rel: "stylesheet",
                      href: toPublicPath(cssChunk.fileName, config2)
                    }
                  }
                ]);
              }
            }
            let match2;
            let s2;
            while (match2 = inlineCSSRE$1.exec(result2)) {
              s2 || (s2 = new MagicString(result2));
              const { 0: full, 1: scopedName } = match2;
              const cssTransformedCode = htmlProxyResult.get(scopedName);
              s2.overwrite(match2.index, match2.index + full.length, cssTransformedCode, { contentOnly: true });
            }
            if (s2) {
              result2 = s2.toString();
            }
            const relativeUrlPath = path__default.posix.relative(config2.root, id);
            result2 = await applyHtmlTransforms(result2, postHooks, {
              path: "/" + relativeUrlPath,
              filename: id,
              bundle,
              chunk
            });
            result2 = result2.replace(assetUrlRE, (_2, fileHash, postfix = "") => {
              return config2.base + getAssetFilename(fileHash, config2) + postfix;
            });
            if (chunk && canInlineEntry) {
              delete bundle[chunk.fileName];
            }
            const shortEmitName = path__default.relative(config2.root, id);
            this.emitFile({
              type: "asset",
              fileName: shortEmitName,
              source: result2
            });
          }
        }
      };
    }
    function resolveHtmlTransforms(plugins2) {
      const preHooks = [];
      const postHooks = [];
      for (const plugin of plugins2) {
        const hook = plugin.transformIndexHtml;
        if (hook) {
          if (typeof hook === "function") {
            postHooks.push(hook);
          } else if (hook.enforce === "pre") {
            preHooks.push(hook.transform);
          } else {
            postHooks.push(hook.transform);
          }
        }
      }
      return [preHooks, postHooks];
    }
    var maybeVirtualHtmlSet = /* @__PURE__ */ new Set();
    async function applyHtmlTransforms(html, hooks, ctx) {
      const headTags = [];
      const headPrependTags = [];
      const bodyTags = [];
      const bodyPrependTags = [];
      maybeVirtualHtmlSet.add(ctx.filename);
      for (const hook of hooks) {
        const res = await hook(html, ctx);
        if (!res) {
          continue;
        }
        if (typeof res === "string") {
          html = res;
        } else {
          let tags2;
          if (Array.isArray(res)) {
            tags2 = res;
          } else {
            html = res.html || html;
            tags2 = res.tags;
          }
          for (const tag of tags2) {
            if (tag.injectTo === "body") {
              bodyTags.push(tag);
            } else if (tag.injectTo === "body-prepend") {
              bodyPrependTags.push(tag);
            } else if (tag.injectTo === "head") {
              headTags.push(tag);
            } else {
              headPrependTags.push(tag);
            }
          }
        }
      }
      if (headPrependTags.length) {
        html = injectToHead(html, headPrependTags, true);
      }
      if (headTags.length) {
        html = injectToHead(html, headTags);
      }
      if (bodyPrependTags.length) {
        html = injectToBody(html, bodyPrependTags, true);
      }
      if (bodyTags.length) {
        html = injectToBody(html, bodyTags);
      }
      return html;
    }
    var importRE = /\bimport\s*("[^"]*[^\\]"|'[^']*[^\\]');*/g;
    var commentRE$1 = /\/\*[\s\S]*?\*\/|\/\/.*$/gm;
    function isEntirelyImport(code) {
      return !code.replace(importRE, "").replace(commentRE$1, "").trim().length;
    }
    function toPublicPath(filename2, config2) {
      return isExternalUrl(filename2) ? filename2 : config2.base + filename2;
    }
    var headInjectRE = /([ \t]*)<\/head>/i;
    var headPrependInjectRE = /([ \t]*)<head[^>]*>/i;
    var htmlInjectRE = /<\/html>/i;
    var htmlPrependInjectRE = /([ \t]*)<html[^>]*>/i;
    var bodyInjectRE = /([ \t]*)<\/body>/i;
    var bodyPrependInjectRE = /([ \t]*)<body[^>]*>/i;
    var doctypePrependInjectRE = /<!doctype html>/i;
    function injectToHead(html, tags2, prepend = false) {
      if (prepend) {
        if (headPrependInjectRE.test(html)) {
          return html.replace(headPrependInjectRE, (match2, p1) => `${match2}
${serializeTags(tags2, incrementIndent(p1))}`);
        }
      } else {
        if (headInjectRE.test(html)) {
          return html.replace(headInjectRE, (match2, p1) => `${serializeTags(tags2, incrementIndent(p1))}${match2}`);
        }
        if (bodyPrependInjectRE.test(html)) {
          return html.replace(bodyPrependInjectRE, (match2, p1) => `${serializeTags(tags2, p1)}
${match2}`);
        }
      }
      return prependInjectFallback(html, tags2);
    }
    function injectToBody(html, tags2, prepend = false) {
      if (prepend) {
        if (bodyPrependInjectRE.test(html)) {
          return html.replace(bodyPrependInjectRE, (match2, p1) => `${match2}
${serializeTags(tags2, incrementIndent(p1))}`);
        }
        if (headInjectRE.test(html)) {
          return html.replace(headInjectRE, (match2, p1) => `${match2}
${serializeTags(tags2, p1)}`);
        }
        return prependInjectFallback(html, tags2);
      } else {
        if (bodyInjectRE.test(html)) {
          return html.replace(bodyInjectRE, (match2, p1) => `${serializeTags(tags2, incrementIndent(p1))}${match2}`);
        }
        if (htmlInjectRE.test(html)) {
          return html.replace(htmlInjectRE, `${serializeTags(tags2)}
$&`);
        }
        return html + `
` + serializeTags(tags2);
      }
    }
    function prependInjectFallback(html, tags2) {
      if (htmlPrependInjectRE.test(html)) {
        return html.replace(htmlPrependInjectRE, `$&
${serializeTags(tags2)}`);
      }
      if (doctypePrependInjectRE.test(html)) {
        return html.replace(doctypePrependInjectRE, `$&
${serializeTags(tags2)}`);
      }
      return serializeTags(tags2) + html;
    }
    var unaryTags = /* @__PURE__ */ new Set(["link", "meta", "base"]);
    function serializeTag({ tag, attrs, children }, indent = "") {
      if (unaryTags.has(tag)) {
        return `<${tag}${serializeAttrs(attrs)}>`;
      } else {
        return `<${tag}${serializeAttrs(attrs)}>${serializeTags(children, incrementIndent(indent))}</${tag}>`;
      }
    }
    function serializeTags(tags2, indent = "") {
      if (typeof tags2 === "string") {
        return tags2;
      } else if (tags2 && tags2.length) {
        return tags2.map((tag) => `${indent}${serializeTag(tag, indent)}
`).join("");
      }
      return "";
    }
    function serializeAttrs(attrs) {
      let res = "";
      for (const key2 in attrs) {
        if (typeof attrs[key2] === "boolean") {
          res += attrs[key2] ? ` ${key2}` : ``;
        } else {
          res += ` ${key2}=${JSON.stringify(attrs[key2])}`;
        }
      }
      return res;
    }
    function incrementIndent(indent = "") {
      return `${indent}${indent[0] === "	" ? "	" : "  "}`;
    }
    var isDebug$6 = !!process.env.DEBUG;
    var debug$e = createDebugger("vite:sourcemap", {
      onlyWhenFocused: true
    });
    var virtualSourceRE = /^(\0|dep:|browser-external:)/;
    async function injectSourcesContent(map2, file, logger) {
      let sourceRoot;
      try {
        sourceRoot = await fs$n.promises.realpath(path__default.resolve(path__default.dirname(file), map2.sourceRoot || ""));
      } catch {
      }
      const missingSources = [];
      map2.sourcesContent = await Promise.all(map2.sources.map((sourcePath) => {
        if (sourcePath && !virtualSourceRE.test(sourcePath)) {
          sourcePath = decodeURI(sourcePath);
          if (sourceRoot) {
            sourcePath = path__default.resolve(sourceRoot, sourcePath);
          }
          return fs$n.promises.readFile(sourcePath, "utf-8").catch(() => {
            if (maybeVirtualHtmlSet.has(normalizePath$4(sourcePath)))
              return null;
            missingSources.push(sourcePath);
            return null;
          });
        }
        return null;
      }));
      if (missingSources.length) {
        logger.warnOnce(`Sourcemap for "${file}" points to missing source files`);
        isDebug$6 && debug$e(`Missing sources:
  ` + missingSources.join(`
  `));
      }
    }
    function genSourceMapUrl(map2) {
      if (typeof map2 !== "string") {
        map2 = JSON.stringify(map2);
      }
      return `data:application/json;base64,${Buffer.from(map2).toString("base64")}`;
    }
    function getCodeWithSourcemap(type, code, map2) {
      if (isDebug$6) {
        code += `
/*${JSON.stringify(map2, null, 2).replace(/\*\//g, "*\\/")}*/
`;
      }
      if (type === "js") {
        code += `
//# sourceMappingURL=${genSourceMapUrl(map2 !== null && map2 !== void 0 ? map2 : void 0)}`;
      } else if (type === "css") {
        code += `
/*# sourceMappingURL=${genSourceMapUrl(map2 !== null && map2 !== void 0 ? map2 : void 0)} */`;
      }
      return code;
    }
    var cssLangs = `\\.(css|less|sass|scss|styl|stylus|pcss|postcss)($|\\?)`;
    var cssLangRE = new RegExp(cssLangs);
    var cssModuleRE = new RegExp(`\\.module${cssLangs}`);
    var directRequestRE = /(\?|&)direct\b/;
    var htmlProxyRE = /(\?|&)html-proxy\b/;
    var commonjsProxyRE = /\?commonjs-proxy/;
    var inlineRE = /(\?|&)inline\b/;
    var inlineCSSRE = /(\?|&)inline-css\b/;
    var usedRE = /(\?|&)used\b/;
    var isCSSRequest = (request) => cssLangRE.test(request);
    var isDirectCSSRequest = (request) => cssLangRE.test(request) && directRequestRE.test(request);
    var isDirectRequest = (request) => directRequestRE.test(request);
    var cssModulesCache = /* @__PURE__ */ new WeakMap();
    var removedPureCssFilesCache = /* @__PURE__ */ new WeakMap();
    var postcssConfigCache = /* @__PURE__ */ new WeakMap();
    function cssPlugin(config2) {
      let server2;
      let moduleCache;
      const resolveUrl = config2.createResolver({
        preferRelative: true,
        tryIndex: false,
        extensions: []
      });
      const atImportResolvers = createCSSResolvers(config2);
      return {
        name: "vite:css",
        configureServer(_server) {
          server2 = _server;
        },
        buildStart() {
          moduleCache = /* @__PURE__ */ new Map();
          cssModulesCache.set(config2, moduleCache);
          removedPureCssFilesCache.set(config2, /* @__PURE__ */ new Map());
        },
        async transform(raw, id, options2) {
          var _a2, _b;
          if (!isCSSRequest(id) || commonjsProxyRE.test(id) || SPECIAL_QUERY_RE.test(id)) {
            return;
          }
          const ssr = (options2 === null || options2 === void 0 ? void 0 : options2.ssr) === true;
          const urlReplacer = async (url2, importer) => {
            if (checkPublicFile(url2, config2)) {
              return config2.base + url2.slice(1);
            }
            const resolved = await resolveUrl(url2, importer);
            if (resolved) {
              return fileToUrl(resolved, config2, this);
            }
            return url2;
          };
          const { code: css, modules, deps, map: map2 } = await compileCSS(id, raw, config2, urlReplacer, atImportResolvers, server2);
          if (modules) {
            moduleCache.set(id, modules);
          }
          if (config2.command === "build" && config2.build.watch && deps) {
            for (const file of deps) {
              this.addWatchFile(file);
            }
          }
          if (server2) {
            const { moduleGraph } = server2;
            const thisModule = moduleGraph.getModuleById(id);
            if (thisModule) {
              const isSelfAccepting = !modules && !inlineRE.test(id);
              if (deps) {
                const depModules = /* @__PURE__ */ new Set();
                for (const file of deps) {
                  depModules.add(isCSSRequest(file) ? moduleGraph.createFileOnlyEntry(file) : await moduleGraph.ensureEntryFromUrl((await fileToUrl(file, config2, this)).replace(((_b = (_a2 = config2.server) === null || _a2 === void 0 ? void 0 : _a2.origin) !== null && _b !== void 0 ? _b : "") + config2.base, "/"), ssr));
                }
                moduleGraph.updateModuleInfo(thisModule, depModules, /* @__PURE__ */ new Set(), isSelfAccepting, ssr);
                for (const file of deps) {
                  this.addWatchFile(file);
                }
              } else {
                thisModule.isSelfAccepting = isSelfAccepting;
              }
            }
          }
          return {
            code: css,
            map: map2
          };
        }
      };
    }
    function cssPostPlugin(config2) {
      const styles = /* @__PURE__ */ new Map();
      let pureCssChunks;
      let outputToExtractedCSSMap;
      let hasEmitted = false;
      return {
        name: "vite:css-post",
        buildStart() {
          pureCssChunks = /* @__PURE__ */ new Set();
          outputToExtractedCSSMap = /* @__PURE__ */ new Map();
          hasEmitted = false;
        },
        async transform(css, id, options2) {
          var _a2;
          if (!isCSSRequest(id) || commonjsProxyRE.test(id) || SPECIAL_QUERY_RE.test(id)) {
            return;
          }
          const inlined = inlineRE.test(id);
          const modules = cssModulesCache.get(config2).get(id);
          const modulesCode = modules && dataToEsm(modules, { namedExports: true, preferConst: true });
          if (config2.command === "serve") {
            if (isDirectCSSRequest(id)) {
              return css;
            } else {
              if (options2 === null || options2 === void 0 ? void 0 : options2.ssr) {
                return modulesCode || `export default ${JSON.stringify(css)}`;
              }
              if (inlined) {
                return `export default ${JSON.stringify(css)}`;
              }
              let cssContent = css;
              if ((_a2 = config2.css) === null || _a2 === void 0 ? void 0 : _a2.devSourcemap) {
                const sourcemap = this.getCombinedSourcemap();
                await injectSourcesContent(sourcemap, cleanUrl(id), config2.logger);
                cssContent = getCodeWithSourcemap("css", css, sourcemap);
              }
              return [
                `import { updateStyle as __vite__updateStyle, removeStyle as __vite__removeStyle } from ${JSON.stringify(path__default.posix.join(config2.base, CLIENT_PUBLIC_PATH))}`,
                `const __vite__id = ${JSON.stringify(id)}`,
                `const __vite__css = ${JSON.stringify(cssContent)}`,
                `__vite__updateStyle(__vite__id, __vite__css)`,
                `${modulesCode || `import.meta.hot.accept()
export default __vite__css`}`,
                `import.meta.hot.prune(() => __vite__removeStyle(__vite__id))`
              ].join("\n");
            }
          }
          const inlineCSS = inlineCSSRE.test(id);
          const query = parseRequest(id);
          const isHTMLProxy2 = htmlProxyRE.test(id);
          if (inlineCSS && isHTMLProxy2) {
            addToHTMLProxyTransformResult(`${cleanUrl(id)}_${Number.parseInt(query.index)}`, css);
            return `export default ''`;
          }
          if (!inlined) {
            styles.set(id, css);
          }
          return {
            code: modulesCode || (usedRE.test(id) ? `export default ${JSON.stringify(inlined ? await minifyCSS(css, config2) : css)}` : `export default ''`),
            map: { mappings: "" },
            moduleSideEffects: inlined ? false : "no-treeshake"
          };
        },
        async renderChunk(code, chunk, opts) {
          let chunkCSS = "";
          let isPureCssChunk = true;
          const ids = Object.keys(chunk.modules);
          for (const id of ids) {
            if (!isCSSRequest(id) || cssModuleRE.test(id) || commonjsProxyRE.test(id)) {
              isPureCssChunk = false;
            }
            if (styles.has(id)) {
              chunkCSS += styles.get(id);
            }
          }
          if (!chunkCSS) {
            return null;
          }
          const processChunkCSS = async (css, { inlined, minify }) => {
            const isRelativeBase = config2.base === "" || config2.base.startsWith(".");
            css = css.replace(assetUrlRE, (_2, fileHash, postfix = "") => {
              const filename2 = getAssetFilename(fileHash, config2) + postfix;
              chunk.viteMetadata.importedAssets.add(cleanUrl(filename2));
              if (!isRelativeBase || inlined) {
                return config2.base + filename2;
              } else {
                return `./${path__default.posix.basename(filename2)}`;
              }
            });
            if (css.includes("@import")) {
              css = await hoistAtImports(css);
            }
            if (minify && config2.build.minify) {
              css = await minifyCSS(css, config2);
            }
            return css;
          };
          if (config2.build.cssCodeSplit) {
            if (isPureCssChunk) {
              pureCssChunks.add(chunk.fileName);
            }
            if (opts.format === "es" || opts.format === "cjs") {
              chunkCSS = await processChunkCSS(chunkCSS, {
                inlined: false,
                minify: true
              });
              const fileHandle = this.emitFile({
                name: chunk.name + ".css",
                type: "asset",
                source: chunkCSS
              });
              chunk.viteMetadata.importedCss.add(this.getFileName(fileHandle));
            } else if (!config2.build.ssr) {
              chunkCSS = await processChunkCSS(chunkCSS, {
                inlined: true,
                minify: true
              });
              const style = `__vite_style__`;
              const injectCode = `var ${style} = document.createElement('style');${style}.innerHTML = ${JSON.stringify(chunkCSS)};document.head.appendChild(${style});`;
              if (config2.build.sourcemap) {
                const s2 = new MagicString(code);
                s2.prepend(injectCode);
                return {
                  code: s2.toString(),
                  map: s2.generateMap({ hires: true })
                };
              } else {
                return { code: injectCode + code };
              }
            }
          } else {
            chunkCSS = await processChunkCSS(chunkCSS, {
              inlined: false,
              minify: false
            });
            outputToExtractedCSSMap.set(opts, (outputToExtractedCSSMap.get(opts) || "") + chunkCSS);
          }
          return null;
        },
        async generateBundle(opts, bundle) {
          if (opts.__vite_skip_asset_emit__) {
            return;
          }
          if (pureCssChunks.size) {
            const emptyChunkFiles = [...pureCssChunks].map((file) => path__default.basename(file)).join("|").replace(/\./g, "\\.");
            const emptyChunkRE = new RegExp(opts.format === "es" ? `\\bimport\\s*"[^"]*(?:${emptyChunkFiles})";
?` : `\\brequire\\(\\s*"[^"]*(?:${emptyChunkFiles})"\\);
?`, "g");
            for (const file in bundle) {
              const chunk = bundle[file];
              if (chunk.type === "chunk") {
                chunk.imports = chunk.imports.filter((file2) => {
                  if (pureCssChunks.has(file2)) {
                    const { viteMetadata: { importedCss } } = bundle[file2];
                    importedCss.forEach((file3) => chunk.viteMetadata.importedCss.add(file3));
                    return false;
                  }
                  return true;
                });
                chunk.code = chunk.code.replace(emptyChunkRE, (m3) => `/* empty css ${"".padEnd(m3.length - 15)}*/`);
              }
            }
            const removedPureCssFiles = removedPureCssFilesCache.get(config2);
            pureCssChunks.forEach((fileName) => {
              removedPureCssFiles.set(fileName, bundle[fileName]);
              delete bundle[fileName];
            });
          }
          let extractedCss = outputToExtractedCSSMap.get(opts);
          if (extractedCss && !hasEmitted) {
            hasEmitted = true;
            if (config2.build.minify) {
              extractedCss = await minifyCSS(extractedCss, config2);
            }
            this.emitFile({
              name: "style.css",
              type: "asset",
              source: extractedCss
            });
          }
        }
      };
    }
    function createCSSResolvers(config2) {
      let cssResolve;
      let sassResolve;
      let lessResolve;
      return {
        get css() {
          return cssResolve || (cssResolve = config2.createResolver({
            extensions: [".css"],
            mainFields: ["style"],
            tryIndex: false,
            preferRelative: true
          }));
        },
        get sass() {
          return sassResolve || (sassResolve = config2.createResolver({
            extensions: [".scss", ".sass", ".css"],
            mainFields: ["sass", "style"],
            tryIndex: true,
            tryPrefix: "_",
            preferRelative: true
          }));
        },
        get less() {
          return lessResolve || (lessResolve = config2.createResolver({
            extensions: [".less", ".css"],
            mainFields: ["less", "style"],
            tryIndex: false,
            preferRelative: true
          }));
        }
      };
    }
    function getCssResolversKeys(resolvers) {
      return Object.keys(resolvers);
    }
    async function compileCSS(id, code, config2, urlReplacer, atImportResolvers, server2) {
      var _a2;
      const { modules: modulesOptions, preprocessorOptions, devSourcemap } = config2.css || {};
      const isModule = modulesOptions !== false && cssModuleRE.test(id);
      const needInlineImport = code.includes("@import");
      const hasUrl = cssUrlRE.test(code) || cssImageSetRE.test(code);
      const postcssConfig = await resolvePostcssConfig(config2);
      const lang = (_a2 = id.match(cssLangRE)) === null || _a2 === void 0 ? void 0 : _a2[1];
      if (lang === "css" && !postcssConfig && !isModule && !needInlineImport && !hasUrl) {
        return { code, map: null };
      }
      let preprocessorMap;
      let modules;
      const deps = /* @__PURE__ */ new Set();
      if (isPreProcessor(lang)) {
        const preProcessor = preProcessors[lang];
        let opts = preprocessorOptions && preprocessorOptions[lang] || {};
        switch (lang) {
          case "scss":
          case "sass":
            opts = __spreadValues2({
              includePaths: ["node_modules"],
              alias: config2.resolve.alias
            }, opts);
            break;
          case "less":
          case "styl":
          case "stylus":
            opts = __spreadValues2({
              paths: ["node_modules"],
              alias: config2.resolve.alias
            }, opts);
        }
        opts.filename = cleanUrl(id);
        opts.enableSourcemap = devSourcemap !== null && devSourcemap !== void 0 ? devSourcemap : false;
        const preprocessResult = await preProcessor(code, config2.root, opts, atImportResolvers);
        if (preprocessResult.errors.length) {
          throw preprocessResult.errors[0];
        }
        code = preprocessResult.code;
        preprocessorMap = combineSourcemapsIfExists(opts.filename, preprocessResult.map, preprocessResult.additionalMap);
        if (preprocessResult.deps) {
          preprocessResult.deps.forEach((dep) => {
            if (normalizePath$4(dep) !== normalizePath$4(opts.filename)) {
              deps.add(dep);
            }
          });
        }
      }
      const postcssOptions = postcssConfig && postcssConfig.options || {};
      const postcssPlugins = postcssConfig && postcssConfig.plugins ? postcssConfig.plugins.slice() : [];
      if (needInlineImport) {
        const isHTMLProxy2 = htmlProxyRE.test(id);
        postcssPlugins.unshift((await Promise.resolve().then(function() {
          return require_dep_bcc0af00();
        }).then(function(n3) {
          return n3.index;
        })).default({
          async resolve(id2, basedir) {
            const publicFile = checkPublicFile(id2, config2);
            if (isHTMLProxy2 && publicFile) {
              return publicFile;
            }
            const resolved = await atImportResolvers.css(id2, path__default.join(basedir, "*"));
            if (resolved) {
              return path__default.resolve(resolved);
            }
            return id2;
          }
        }));
      }
      postcssPlugins.push(UrlRewritePostcssPlugin({
        replacer: urlReplacer
      }));
      if (isModule) {
        postcssPlugins.unshift((await Promise.resolve().then(function() {
          return require_dep_ab7432fd();
        }).then(function(n3) {
          return n3.index;
        })).default(__spreadProps2(__spreadValues2({}, modulesOptions), {
          getJSON(cssFileName, _modules, outputFileName) {
            modules = _modules;
            if (modulesOptions && typeof modulesOptions.getJSON === "function") {
              modulesOptions.getJSON(cssFileName, _modules, outputFileName);
            }
          },
          async resolve(id2) {
            for (const key2 of getCssResolversKeys(atImportResolvers)) {
              const resolved = await atImportResolvers[key2](id2);
              if (resolved) {
                return path__default.resolve(resolved);
              }
            }
            return id2;
          }
        })));
      }
      if (!postcssPlugins.length) {
        return {
          code,
          map: preprocessorMap
        };
      }
      const postcssResult = await (await Promise.resolve().then(function() {
        return _interopNamespace(require_postcss());
      })).default(postcssPlugins).process(code, __spreadProps2(__spreadValues2({}, postcssOptions), {
        to: cleanUrl(id),
        from: cleanUrl(id),
        map: {
          inline: false,
          annotation: false,
          sourcesContent: true
        }
      }));
      for (const message of postcssResult.messages) {
        if (message.type === "dependency") {
          deps.add(normalizePath$4(message.file));
        } else if (message.type === "dir-dependency") {
          const { dir, glob: globPattern = "**" } = message;
          const pattern2 = normalizePath$4(path__default.resolve(path__default.dirname(id), dir)) + `/` + globPattern;
          const files = out.sync(pattern2, {
            ignore: ["**/node_modules/**"]
          });
          for (let i2 = 0; i2 < files.length; i2++) {
            deps.add(files[i2]);
          }
          if (server2) {
            if (!(id in server2._globImporters)) {
              server2._globImporters[id] = {
                module: server2.moduleGraph.getModuleById(id),
                importGlobs: []
              };
            }
            server2._globImporters[id].importGlobs.push({
              base: config2.root,
              pattern: pattern2
            });
          }
        } else if (message.type === "warning") {
          let msg = `[vite:css] ${message.text}`;
          if (message.line && message.column) {
            msg += `
${generateCodeFrame(code, {
              line: message.line,
              column: message.column
            })}`;
          }
          config2.logger.warn(colors$1.yellow(msg));
        }
      }
      if (!devSourcemap) {
        return {
          ast: postcssResult,
          code: postcssResult.css,
          map: { mappings: "" },
          modules,
          deps
        };
      }
      const rawPostcssMap = postcssResult.map.toJSON();
      const postcssMap = formatPostcssSourceMap(rawPostcssMap, cleanUrl(id));
      return {
        ast: postcssResult,
        code: postcssResult.css,
        map: combineSourcemapsIfExists(cleanUrl(id), postcssMap, preprocessorMap),
        modules,
        deps
      };
    }
    function formatPostcssSourceMap(rawMap, file) {
      const inputFileDir = path__default.dirname(file);
      const sources = [];
      const sourcesContent = [];
      for (const [i2, source2] of rawMap.sources.entries()) {
        if (source2 === "<no source>")
          continue;
        const cleanSource = cleanUrl(decodeURIComponent(source2));
        if (/^<.+>$/.test(cleanSource)) {
          sources.push(`\0${cleanSource}`);
        } else {
          sources.push(normalizePath$4(path__default.resolve(inputFileDir, cleanSource)));
        }
        if (rawMap.sourcesContent) {
          sourcesContent.push(rawMap.sourcesContent[i2]);
        }
      }
      return {
        file,
        mappings: rawMap.mappings,
        names: rawMap.names,
        sources,
        sourcesContent,
        version: rawMap.version
      };
    }
    function combineSourcemapsIfExists(filename2, map1, map2) {
      return map1 && map2 ? combineSourcemaps(filename2, [
        map1,
        map2
      ]) : map1;
    }
    async function resolvePostcssConfig(config2) {
      var _a2;
      let result2 = postcssConfigCache.get(config2);
      if (result2 !== void 0) {
        return result2;
      }
      const inlineOptions = (_a2 = config2.css) === null || _a2 === void 0 ? void 0 : _a2.postcss;
      if (isObject$5(inlineOptions)) {
        const options2 = __spreadValues2({}, inlineOptions);
        delete options2.plugins;
        result2 = {
          options: options2,
          plugins: inlineOptions.plugins || []
        };
      } else {
        try {
          const searchPath = typeof inlineOptions === "string" ? inlineOptions : config2.root;
          result2 = await src$1({}, searchPath);
        } catch (e2) {
          if (!/No PostCSS Config found/.test(e2.message)) {
            throw e2;
          }
          result2 = null;
        }
      }
      postcssConfigCache.set(config2, result2);
      return result2;
    }
    var cssUrlRE = /(?<=^|[^\w\-\u0080-\uffff])url\(\s*('[^']+'|"[^"]+"|[^'")]+)\s*\)/;
    var importCssRE = /@import ('[^']+\.css'|"[^"]+\.css"|[^'")]+\.css)/;
    var cssImageSetRE = /image-set\(([^)]+)\)/;
    var UrlRewritePostcssPlugin = (opts) => {
      if (!opts) {
        throw new Error("base or replace is required");
      }
      return {
        postcssPlugin: "vite-url-rewrite",
        Once(root2) {
          const promises = [];
          root2.walkDecls((declaration) => {
            const isCssUrl = cssUrlRE.test(declaration.value);
            const isCssImageSet = cssImageSetRE.test(declaration.value);
            if (isCssUrl || isCssImageSet) {
              const replacerForDeclaration = (rawUrl) => {
                var _a2;
                const importer = (_a2 = declaration.source) === null || _a2 === void 0 ? void 0 : _a2.input.file;
                return opts.replacer(rawUrl, importer);
              };
              const rewriterToUse = isCssUrl ? rewriteCssUrls : rewriteCssImageSet;
              promises.push(rewriterToUse(declaration.value, replacerForDeclaration).then((url2) => {
                declaration.value = url2;
              }));
            }
          });
          if (promises.length) {
            return Promise.all(promises);
          }
        }
      };
    };
    UrlRewritePostcssPlugin.postcss = true;
    function rewriteCssUrls(css, replacer) {
      return asyncReplace(css, cssUrlRE, async (match2) => {
        const [matched, rawUrl] = match2;
        return await doUrlReplace(rawUrl, matched, replacer);
      });
    }
    function rewriteImportCss(css, replacer) {
      return asyncReplace(css, importCssRE, async (match2) => {
        const [matched, rawUrl] = match2;
        return await doImportCSSReplace(rawUrl, matched, replacer);
      });
    }
    function rewriteCssImageSet(css, replacer) {
      return asyncReplace(css, cssImageSetRE, async (match2) => {
        const [matched, rawUrl] = match2;
        const url2 = await processSrcSet(rawUrl, ({ url: url3 }) => doUrlReplace(url3, matched, replacer));
        return `image-set(${url2})`;
      });
    }
    async function doUrlReplace(rawUrl, matched, replacer) {
      let wrap2 = "";
      const first2 = rawUrl[0];
      if (first2 === `"` || first2 === `'`) {
        wrap2 = first2;
        rawUrl = rawUrl.slice(1, -1);
      }
      if (isExternalUrl(rawUrl) || isDataUrl(rawUrl) || rawUrl.startsWith("#")) {
        return matched;
      }
      const newUrl = await replacer(rawUrl);
      if (wrap2 === "" && newUrl !== encodeURI(newUrl)) {
        wrap2 = "'";
      }
      return `url(${wrap2}${newUrl}${wrap2})`;
    }
    async function doImportCSSReplace(rawUrl, matched, replacer) {
      let wrap2 = "";
      const first2 = rawUrl[0];
      if (first2 === `"` || first2 === `'`) {
        wrap2 = first2;
        rawUrl = rawUrl.slice(1, -1);
      }
      if (isExternalUrl(rawUrl) || isDataUrl(rawUrl) || rawUrl.startsWith("#")) {
        return matched;
      }
      return `@import ${wrap2}${await replacer(rawUrl)}${wrap2}`;
    }
    async function minifyCSS(css, config2) {
      const { code, warnings: warnings2 } = await esbuild.transform(css, {
        loader: "css",
        minify: true,
        target: config2.build.cssTarget || void 0
      });
      if (warnings2.length) {
        const msgs = await esbuild.formatMessages(warnings2, { kind: "warning" });
        config2.logger.warn(colors$1.yellow(`warnings when minifying css:
${msgs.join("\n")}`));
      }
      return code;
    }
    async function hoistAtImports(css) {
      const postcss2 = await Promise.resolve().then(function() {
        return _interopNamespace(require_postcss());
      });
      return (await postcss2.default([AtImportHoistPlugin]).process(css)).css;
    }
    var AtImportHoistPlugin = () => {
      return {
        postcssPlugin: "vite-hoist-at-imports",
        Once(root2) {
          const imports = [];
          root2.walkAtRules((rule) => {
            if (rule.name === "import") {
              imports.unshift(rule);
            }
          });
          imports.forEach((i2) => root2.prepend(i2));
        }
      };
    };
    AtImportHoistPlugin.postcss = true;
    var loadedPreprocessors = {};
    function loadPreprocessor(lang, root2) {
      var _a2, _b;
      if (lang in loadedPreprocessors) {
        return loadedPreprocessors[lang];
      }
      try {
        const fallbackPaths = ((_b = (_a2 = __require.resolve).paths) === null || _b === void 0 ? void 0 : _b.call(_a2, lang)) || [];
        const resolved = __require.resolve(lang, { paths: [root2, ...fallbackPaths] });
        return loadedPreprocessors[lang] = __require(resolved);
      } catch (e2) {
        if (e2.code === "MODULE_NOT_FOUND") {
          throw new Error(`Preprocessor dependency "${lang}" not found. Did you install it?`);
        } else {
          const message = new Error(`Preprocessor dependency "${lang}" failed to load:
${e2.message}`);
          message.stack = e2.stack + "\n" + message.stack;
          throw message;
        }
      }
    }
    var scss = async (source2, root2, options2, resolvers) => {
      const render = loadPreprocessor("sass", root2).render;
      const internalImporter = (url2, importer2, done) => {
        resolvers.sass(url2, importer2).then((resolved) => {
          if (resolved) {
            rebaseUrls(resolved, options2.filename, options2.alias).then((data3) => done === null || done === void 0 ? void 0 : done(data3)).catch((data3) => done === null || done === void 0 ? void 0 : done(data3));
          } else {
            done === null || done === void 0 ? void 0 : done(null);
          }
        });
      };
      const importer = [internalImporter];
      if (options2.importer) {
        Array.isArray(options2.importer) ? importer.push(...options2.importer) : importer.push(options2.importer);
      }
      const { content: data2, map: additionalMap } = await getSource(source2, options2.filename, options2.additionalData, options2.enableSourcemap);
      const finalOptions = __spreadValues2(__spreadProps2(__spreadValues2({}, options2), {
        data: data2,
        file: options2.filename,
        outFile: options2.filename,
        importer
      }), options2.enableSourcemap ? {
        sourceMap: true,
        omitSourceMapUrl: true,
        sourceMapRoot: path__default.dirname(options2.filename)
      } : {});
      try {
        const result2 = await new Promise((resolve2, reject) => {
          render(finalOptions, (err, res) => {
            if (err) {
              reject(err);
            } else {
              resolve2(res);
            }
          });
        });
        const deps = result2.stats.includedFiles;
        const map2 = result2.map ? JSON.parse(result2.map.toString()) : void 0;
        return {
          code: result2.css.toString(),
          map: map2,
          additionalMap,
          errors: [],
          deps
        };
      } catch (e2) {
        e2.id = e2.file;
        e2.frame = e2.formatted;
        return { code: "", errors: [e2], deps: [] };
      }
    };
    var sass = (source2, root2, options2, aliasResolver) => scss(source2, root2, __spreadProps2(__spreadValues2({}, options2), {
      indentedSyntax: true
    }), aliasResolver);
    async function rebaseUrls(file, rootFile, alias2) {
      file = path__default.resolve(file);
      const fileDir = path__default.dirname(file);
      const rootDir = path__default.dirname(rootFile);
      if (fileDir === rootDir) {
        return { file };
      }
      const content2 = fs__default.readFileSync(file, "utf-8");
      const hasUrls = cssUrlRE.test(content2);
      const hasImportCss = importCssRE.test(content2);
      if (!hasUrls && !hasImportCss) {
        return { file };
      }
      let rebased;
      const rebaseFn = (url2) => {
        if (url2.startsWith("/"))
          return url2;
        for (const { find: find2 } of alias2) {
          const matches2 = typeof find2 === "string" ? url2.startsWith(find2) : find2.test(url2);
          if (matches2) {
            return url2;
          }
        }
        const absolute = path__default.resolve(fileDir, url2);
        const relative = path__default.relative(rootDir, absolute);
        return normalizePath$4(relative);
      };
      if (hasImportCss) {
        rebased = await rewriteImportCss(content2, rebaseFn);
      }
      if (hasUrls) {
        rebased = await rewriteCssUrls(rebased || content2, rebaseFn);
      }
      return {
        file,
        contents: rebased
      };
    }
    var less = async (source2, root2, options2, resolvers) => {
      const nodeLess = loadPreprocessor("less", root2);
      const viteResolverPlugin = createViteLessPlugin(nodeLess, options2.filename, options2.alias, resolvers);
      const { content: content2, map: additionalMap } = await getSource(source2, options2.filename, options2.additionalData, options2.enableSourcemap);
      let result2;
      try {
        result2 = await nodeLess.render(content2, __spreadValues2(__spreadProps2(__spreadValues2({}, options2), {
          plugins: [viteResolverPlugin, ...options2.plugins || []]
        }), options2.enableSourcemap ? {
          sourceMap: {
            outputSourceFiles: true,
            sourceMapFileInline: false
          }
        } : {}));
      } catch (e2) {
        const error2 = e2;
        const normalizedError = new Error(error2.message || error2.type);
        normalizedError.loc = {
          file: error2.filename || options2.filename,
          line: error2.line,
          column: error2.column
        };
        return { code: "", errors: [normalizedError], deps: [] };
      }
      const map2 = result2.map && JSON.parse(result2.map);
      if (map2) {
        delete map2.sourcesContent;
      }
      return {
        code: result2.css.toString(),
        map: map2,
        additionalMap,
        deps: result2.imports,
        errors: []
      };
    };
    var ViteLessManager;
    function createViteLessPlugin(less2, rootFile, alias2, resolvers) {
      if (!ViteLessManager) {
        ViteLessManager = class ViteManager extends less2.FileManager {
          constructor(rootFile2, resolvers2, alias3) {
            super();
            this.rootFile = rootFile2;
            this.resolvers = resolvers2;
            this.alias = alias3;
          }
          supports() {
            return true;
          }
          supportsSync() {
            return false;
          }
          async loadFile(filename2, dir, opts, env2) {
            const resolved = await this.resolvers.less(filename2, path__default.join(dir, "*"));
            if (resolved) {
              const result2 = await rebaseUrls(resolved, this.rootFile, this.alias);
              let contents;
              if (result2 && "contents" in result2) {
                contents = result2.contents;
              } else {
                contents = fs__default.readFileSync(resolved, "utf-8");
              }
              return {
                filename: path__default.resolve(resolved),
                contents
              };
            } else {
              return super.loadFile(filename2, dir, opts, env2);
            }
          }
        };
      }
      return {
        install(_2, pluginManager) {
          pluginManager.addFileManager(new ViteLessManager(rootFile, resolvers, alias2));
        },
        minVersion: [3, 0, 0]
      };
    }
    var styl = async (source2, root2, options2) => {
      var _a2;
      const nodeStylus = loadPreprocessor("stylus", root2);
      const { content: content2, map: additionalMap } = await getSource(source2, options2.filename, options2.additionalData, options2.enableSourcemap, "\n");
      const importsDeps = ((_a2 = options2.imports) !== null && _a2 !== void 0 ? _a2 : []).map((dep) => path__default.resolve(dep));
      try {
        const ref2 = nodeStylus(content2, options2);
        if (options2.enableSourcemap) {
          ref2.set("sourcemap", {
            comment: false,
            inline: false,
            basePath: root2
          });
        }
        const result2 = ref2.render();
        const deps = [...ref2.deps(), ...importsDeps];
        const map2 = ref2.sourcemap;
        return {
          code: result2,
          map: formatStylusSourceMap(map2, root2),
          additionalMap,
          errors: [],
          deps
        };
      } catch (e2) {
        return { code: "", errors: [e2], deps: [] };
      }
    };
    function formatStylusSourceMap(mapBefore, root2) {
      if (!mapBefore)
        return void 0;
      const map2 = __spreadValues2({}, mapBefore);
      const resolveFromRoot = (p2) => normalizePath$4(path__default.resolve(root2, p2));
      if (map2.file) {
        map2.file = resolveFromRoot(map2.file);
      }
      map2.sources = map2.sources.map(resolveFromRoot);
      return map2;
    }
    async function getSource(source2, filename2, additionalData, enableSourcemap, sep = "") {
      if (!additionalData)
        return { content: source2 };
      if (typeof additionalData === "function") {
        const newContent = await additionalData(source2, filename2);
        if (typeof newContent === "string") {
          return { content: newContent };
        }
        return newContent;
      }
      if (!enableSourcemap) {
        return { content: additionalData + sep + source2 };
      }
      const ms3 = new MagicString(source2);
      ms3.appendLeft(0, sep);
      ms3.appendLeft(0, additionalData);
      const map2 = ms3.generateMap({ hires: true });
      map2.file = filename2;
      map2.sources = [filename2];
      return {
        content: ms3.toString(),
        map: map2
      };
    }
    var preProcessors = Object.freeze({
      ["less"]: less,
      ["sass"]: sass,
      ["scss"]: scss,
      ["styl"]: styl,
      ["stylus"]: styl
    });
    function isPreProcessor(lang) {
      return lang && lang in preProcessors;
    }
    var Space_Separator = /[\u1680\u2000-\u200A\u202F\u205F\u3000]/;
    var ID_Start = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/;
    var ID_Continue = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/;
    var unicode = {
      Space_Separator,
      ID_Start,
      ID_Continue
    };
    var util$1 = {
      isSpaceSeparator(c3) {
        return typeof c3 === "string" && unicode.Space_Separator.test(c3);
      },
      isIdStartChar(c3) {
        return typeof c3 === "string" && (c3 >= "a" && c3 <= "z" || c3 >= "A" && c3 <= "Z" || c3 === "$" || c3 === "_" || unicode.ID_Start.test(c3));
      },
      isIdContinueChar(c3) {
        return typeof c3 === "string" && (c3 >= "a" && c3 <= "z" || c3 >= "A" && c3 <= "Z" || c3 >= "0" && c3 <= "9" || c3 === "$" || c3 === "_" || c3 === "\u200C" || c3 === "\u200D" || unicode.ID_Continue.test(c3));
      },
      isDigit(c3) {
        return typeof c3 === "string" && /[0-9]/.test(c3);
      },
      isHexDigit(c3) {
        return typeof c3 === "string" && /[0-9A-Fa-f]/.test(c3);
      }
    };
    var source;
    var parseState;
    var stack;
    var pos;
    var line;
    var column;
    var token;
    var key;
    var root;
    var parse$e = function parse2(text, reviver) {
      source = String(text);
      parseState = "start";
      stack = [];
      pos = 0;
      line = 1;
      column = 0;
      token = void 0;
      key = void 0;
      root = void 0;
      do {
        token = lex();
        parseStates[parseState]();
      } while (token.type !== "eof");
      if (typeof reviver === "function") {
        return internalize({ "": root }, "", reviver);
      }
      return root;
    };
    function internalize(holder, name, reviver) {
      const value = holder[name];
      if (value != null && typeof value === "object") {
        for (const key2 in value) {
          const replacement2 = internalize(value, key2, reviver);
          if (replacement2 === void 0) {
            delete value[key2];
          } else {
            value[key2] = replacement2;
          }
        }
      }
      return reviver.call(holder, name, value);
    }
    var lexState;
    var buffer;
    var doubleQuote;
    var sign;
    var c;
    function lex() {
      lexState = "default";
      buffer = "";
      doubleQuote = false;
      sign = 1;
      for (; ; ) {
        c = peek();
        const token2 = lexStates[lexState]();
        if (token2) {
          return token2;
        }
      }
    }
    function peek() {
      if (source[pos]) {
        return String.fromCodePoint(source.codePointAt(pos));
      }
    }
    function read() {
      const c3 = peek();
      if (c3 === "\n") {
        line++;
        column = 0;
      } else if (c3) {
        column += c3.length;
      } else {
        column++;
      }
      if (c3) {
        pos += c3.length;
      }
      return c3;
    }
    var lexStates = {
      default() {
        switch (c) {
          case "	":
          case "\v":
          case "\f":
          case " ":
          case "\xA0":
          case "\uFEFF":
          case "\n":
          case "\r":
          case "\u2028":
          case "\u2029":
            read();
            return;
          case "/":
            read();
            lexState = "comment";
            return;
          case void 0:
            read();
            return newToken("eof");
        }
        if (util$1.isSpaceSeparator(c)) {
          read();
          return;
        }
        return lexStates[parseState]();
      },
      comment() {
        switch (c) {
          case "*":
            read();
            lexState = "multiLineComment";
            return;
          case "/":
            read();
            lexState = "singleLineComment";
            return;
        }
        throw invalidChar(read());
      },
      multiLineComment() {
        switch (c) {
          case "*":
            read();
            lexState = "multiLineCommentAsterisk";
            return;
          case void 0:
            throw invalidChar(read());
        }
        read();
      },
      multiLineCommentAsterisk() {
        switch (c) {
          case "*":
            read();
            return;
          case "/":
            read();
            lexState = "default";
            return;
          case void 0:
            throw invalidChar(read());
        }
        read();
        lexState = "multiLineComment";
      },
      singleLineComment() {
        switch (c) {
          case "\n":
          case "\r":
          case "\u2028":
          case "\u2029":
            read();
            lexState = "default";
            return;
          case void 0:
            read();
            return newToken("eof");
        }
        read();
      },
      value() {
        switch (c) {
          case "{":
          case "[":
            return newToken("punctuator", read());
          case "n":
            read();
            literal$1("ull");
            return newToken("null", null);
          case "t":
            read();
            literal$1("rue");
            return newToken("boolean", true);
          case "f":
            read();
            literal$1("alse");
            return newToken("boolean", false);
          case "-":
          case "+":
            if (read() === "-") {
              sign = -1;
            }
            lexState = "sign";
            return;
          case ".":
            buffer = read();
            lexState = "decimalPointLeading";
            return;
          case "0":
            buffer = read();
            lexState = "zero";
            return;
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
            buffer = read();
            lexState = "decimalInteger";
            return;
          case "I":
            read();
            literal$1("nfinity");
            return newToken("numeric", Infinity);
          case "N":
            read();
            literal$1("aN");
            return newToken("numeric", NaN);
          case '"':
          case "'":
            doubleQuote = read() === '"';
            buffer = "";
            lexState = "string";
            return;
        }
        throw invalidChar(read());
      },
      identifierNameStartEscape() {
        if (c !== "u") {
          throw invalidChar(read());
        }
        read();
        const u2 = unicodeEscape();
        switch (u2) {
          case "$":
          case "_":
            break;
          default:
            if (!util$1.isIdStartChar(u2)) {
              throw invalidIdentifier();
            }
            break;
        }
        buffer += u2;
        lexState = "identifierName";
      },
      identifierName() {
        switch (c) {
          case "$":
          case "_":
          case "\u200C":
          case "\u200D":
            buffer += read();
            return;
          case "\\":
            read();
            lexState = "identifierNameEscape";
            return;
        }
        if (util$1.isIdContinueChar(c)) {
          buffer += read();
          return;
        }
        return newToken("identifier", buffer);
      },
      identifierNameEscape() {
        if (c !== "u") {
          throw invalidChar(read());
        }
        read();
        const u2 = unicodeEscape();
        switch (u2) {
          case "$":
          case "_":
          case "\u200C":
          case "\u200D":
            break;
          default:
            if (!util$1.isIdContinueChar(u2)) {
              throw invalidIdentifier();
            }
            break;
        }
        buffer += u2;
        lexState = "identifierName";
      },
      sign() {
        switch (c) {
          case ".":
            buffer = read();
            lexState = "decimalPointLeading";
            return;
          case "0":
            buffer = read();
            lexState = "zero";
            return;
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
            buffer = read();
            lexState = "decimalInteger";
            return;
          case "I":
            read();
            literal$1("nfinity");
            return newToken("numeric", sign * Infinity);
          case "N":
            read();
            literal$1("aN");
            return newToken("numeric", NaN);
        }
        throw invalidChar(read());
      },
      zero() {
        switch (c) {
          case ".":
            buffer += read();
            lexState = "decimalPoint";
            return;
          case "e":
          case "E":
            buffer += read();
            lexState = "decimalExponent";
            return;
          case "x":
          case "X":
            buffer += read();
            lexState = "hexadecimal";
            return;
        }
        return newToken("numeric", sign * 0);
      },
      decimalInteger() {
        switch (c) {
          case ".":
            buffer += read();
            lexState = "decimalPoint";
            return;
          case "e":
          case "E":
            buffer += read();
            lexState = "decimalExponent";
            return;
        }
        if (util$1.isDigit(c)) {
          buffer += read();
          return;
        }
        return newToken("numeric", sign * Number(buffer));
      },
      decimalPointLeading() {
        if (util$1.isDigit(c)) {
          buffer += read();
          lexState = "decimalFraction";
          return;
        }
        throw invalidChar(read());
      },
      decimalPoint() {
        switch (c) {
          case "e":
          case "E":
            buffer += read();
            lexState = "decimalExponent";
            return;
        }
        if (util$1.isDigit(c)) {
          buffer += read();
          lexState = "decimalFraction";
          return;
        }
        return newToken("numeric", sign * Number(buffer));
      },
      decimalFraction() {
        switch (c) {
          case "e":
          case "E":
            buffer += read();
            lexState = "decimalExponent";
            return;
        }
        if (util$1.isDigit(c)) {
          buffer += read();
          return;
        }
        return newToken("numeric", sign * Number(buffer));
      },
      decimalExponent() {
        switch (c) {
          case "+":
          case "-":
            buffer += read();
            lexState = "decimalExponentSign";
            return;
        }
        if (util$1.isDigit(c)) {
          buffer += read();
          lexState = "decimalExponentInteger";
          return;
        }
        throw invalidChar(read());
      },
      decimalExponentSign() {
        if (util$1.isDigit(c)) {
          buffer += read();
          lexState = "decimalExponentInteger";
          return;
        }
        throw invalidChar(read());
      },
      decimalExponentInteger() {
        if (util$1.isDigit(c)) {
          buffer += read();
          return;
        }
        return newToken("numeric", sign * Number(buffer));
      },
      hexadecimal() {
        if (util$1.isHexDigit(c)) {
          buffer += read();
          lexState = "hexadecimalInteger";
          return;
        }
        throw invalidChar(read());
      },
      hexadecimalInteger() {
        if (util$1.isHexDigit(c)) {
          buffer += read();
          return;
        }
        return newToken("numeric", sign * Number(buffer));
      },
      string() {
        switch (c) {
          case "\\":
            read();
            buffer += escape$1();
            return;
          case '"':
            if (doubleQuote) {
              read();
              return newToken("string", buffer);
            }
            buffer += read();
            return;
          case "'":
            if (!doubleQuote) {
              read();
              return newToken("string", buffer);
            }
            buffer += read();
            return;
          case "\n":
          case "\r":
            throw invalidChar(read());
          case "\u2028":
          case "\u2029":
            separatorChar(c);
            break;
          case void 0:
            throw invalidChar(read());
        }
        buffer += read();
      },
      start() {
        switch (c) {
          case "{":
          case "[":
            return newToken("punctuator", read());
        }
        lexState = "value";
      },
      beforePropertyName() {
        switch (c) {
          case "$":
          case "_":
            buffer = read();
            lexState = "identifierName";
            return;
          case "\\":
            read();
            lexState = "identifierNameStartEscape";
            return;
          case "}":
            return newToken("punctuator", read());
          case '"':
          case "'":
            doubleQuote = read() === '"';
            lexState = "string";
            return;
        }
        if (util$1.isIdStartChar(c)) {
          buffer += read();
          lexState = "identifierName";
          return;
        }
        throw invalidChar(read());
      },
      afterPropertyName() {
        if (c === ":") {
          return newToken("punctuator", read());
        }
        throw invalidChar(read());
      },
      beforePropertyValue() {
        lexState = "value";
      },
      afterPropertyValue() {
        switch (c) {
          case ",":
          case "}":
            return newToken("punctuator", read());
        }
        throw invalidChar(read());
      },
      beforeArrayValue() {
        if (c === "]") {
          return newToken("punctuator", read());
        }
        lexState = "value";
      },
      afterArrayValue() {
        switch (c) {
          case ",":
          case "]":
            return newToken("punctuator", read());
        }
        throw invalidChar(read());
      },
      end() {
        throw invalidChar(read());
      }
    };
    function newToken(type, value) {
      return {
        type,
        value,
        line,
        column
      };
    }
    function literal$1(s2) {
      for (const c3 of s2) {
        const p2 = peek();
        if (p2 !== c3) {
          throw invalidChar(read());
        }
        read();
      }
    }
    function escape$1() {
      const c3 = peek();
      switch (c3) {
        case "b":
          read();
          return "\b";
        case "f":
          read();
          return "\f";
        case "n":
          read();
          return "\n";
        case "r":
          read();
          return "\r";
        case "t":
          read();
          return "	";
        case "v":
          read();
          return "\v";
        case "0":
          read();
          if (util$1.isDigit(peek())) {
            throw invalidChar(read());
          }
          return "\0";
        case "x":
          read();
          return hexEscape();
        case "u":
          read();
          return unicodeEscape();
        case "\n":
        case "\u2028":
        case "\u2029":
          read();
          return "";
        case "\r":
          read();
          if (peek() === "\n") {
            read();
          }
          return "";
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
          throw invalidChar(read());
        case void 0:
          throw invalidChar(read());
      }
      return read();
    }
    function hexEscape() {
      let buffer2 = "";
      let c3 = peek();
      if (!util$1.isHexDigit(c3)) {
        throw invalidChar(read());
      }
      buffer2 += read();
      c3 = peek();
      if (!util$1.isHexDigit(c3)) {
        throw invalidChar(read());
      }
      buffer2 += read();
      return String.fromCodePoint(parseInt(buffer2, 16));
    }
    function unicodeEscape() {
      let buffer2 = "";
      let count = 4;
      while (count-- > 0) {
        const c3 = peek();
        if (!util$1.isHexDigit(c3)) {
          throw invalidChar(read());
        }
        buffer2 += read();
      }
      return String.fromCodePoint(parseInt(buffer2, 16));
    }
    var parseStates = {
      start() {
        if (token.type === "eof") {
          throw invalidEOF();
        }
        push$1();
      },
      beforePropertyName() {
        switch (token.type) {
          case "identifier":
          case "string":
            key = token.value;
            parseState = "afterPropertyName";
            return;
          case "punctuator":
            pop();
            return;
          case "eof":
            throw invalidEOF();
        }
      },
      afterPropertyName() {
        if (token.type === "eof") {
          throw invalidEOF();
        }
        parseState = "beforePropertyValue";
      },
      beforePropertyValue() {
        if (token.type === "eof") {
          throw invalidEOF();
        }
        push$1();
      },
      beforeArrayValue() {
        if (token.type === "eof") {
          throw invalidEOF();
        }
        if (token.type === "punctuator" && token.value === "]") {
          pop();
          return;
        }
        push$1();
      },
      afterPropertyValue() {
        if (token.type === "eof") {
          throw invalidEOF();
        }
        switch (token.value) {
          case ",":
            parseState = "beforePropertyName";
            return;
          case "}":
            pop();
        }
      },
      afterArrayValue() {
        if (token.type === "eof") {
          throw invalidEOF();
        }
        switch (token.value) {
          case ",":
            parseState = "beforeArrayValue";
            return;
          case "]":
            pop();
        }
      },
      end() {
      }
    };
    function push$1() {
      let value;
      switch (token.type) {
        case "punctuator":
          switch (token.value) {
            case "{":
              value = {};
              break;
            case "[":
              value = [];
              break;
          }
          break;
        case "null":
        case "boolean":
        case "numeric":
        case "string":
          value = token.value;
          break;
      }
      if (root === void 0) {
        root = value;
      } else {
        const parent = stack[stack.length - 1];
        if (Array.isArray(parent)) {
          parent.push(value);
        } else {
          parent[key] = value;
        }
      }
      if (value !== null && typeof value === "object") {
        stack.push(value);
        if (Array.isArray(value)) {
          parseState = "beforeArrayValue";
        } else {
          parseState = "beforePropertyName";
        }
      } else {
        const current = stack[stack.length - 1];
        if (current == null) {
          parseState = "end";
        } else if (Array.isArray(current)) {
          parseState = "afterArrayValue";
        } else {
          parseState = "afterPropertyValue";
        }
      }
    }
    function pop() {
      stack.pop();
      const current = stack[stack.length - 1];
      if (current == null) {
        parseState = "end";
      } else if (Array.isArray(current)) {
        parseState = "afterArrayValue";
      } else {
        parseState = "afterPropertyValue";
      }
    }
    function invalidChar(c3) {
      if (c3 === void 0) {
        return syntaxError$1(`JSON5: invalid end of input at ${line}:${column}`);
      }
      return syntaxError$1(`JSON5: invalid character '${formatChar(c3)}' at ${line}:${column}`);
    }
    function invalidEOF() {
      return syntaxError$1(`JSON5: invalid end of input at ${line}:${column}`);
    }
    function invalidIdentifier() {
      column -= 5;
      return syntaxError$1(`JSON5: invalid identifier character at ${line}:${column}`);
    }
    function separatorChar(c3) {
      console.warn(`JSON5: '${formatChar(c3)}' in strings is not valid ECMAScript; consider escaping`);
    }
    function formatChar(c3) {
      const replacements = {
        "'": "\\'",
        '"': '\\"',
        "\\": "\\\\",
        "\b": "\\b",
        "\f": "\\f",
        "\n": "\\n",
        "\r": "\\r",
        "	": "\\t",
        "\v": "\\v",
        "\0": "\\0",
        "\u2028": "\\u2028",
        "\u2029": "\\u2029"
      };
      if (replacements[c3]) {
        return replacements[c3];
      }
      if (c3 < " ") {
        const hexString = c3.charCodeAt(0).toString(16);
        return "\\x" + ("00" + hexString).substring(hexString.length);
      }
      return c3;
    }
    function syntaxError$1(message) {
      const err = new SyntaxError(message);
      err.lineNumber = line;
      err.columnNumber = column;
      return err;
    }
    var stringify = function stringify2(value, replacer, space) {
      const stack2 = [];
      let indent = "";
      let propertyList;
      let replacerFunc;
      let gap = "";
      let quote;
      if (replacer != null && typeof replacer === "object" && !Array.isArray(replacer)) {
        space = replacer.space;
        quote = replacer.quote;
        replacer = replacer.replacer;
      }
      if (typeof replacer === "function") {
        replacerFunc = replacer;
      } else if (Array.isArray(replacer)) {
        propertyList = [];
        for (const v2 of replacer) {
          let item;
          if (typeof v2 === "string") {
            item = v2;
          } else if (typeof v2 === "number" || v2 instanceof String || v2 instanceof Number) {
            item = String(v2);
          }
          if (item !== void 0 && propertyList.indexOf(item) < 0) {
            propertyList.push(item);
          }
        }
      }
      if (space instanceof Number) {
        space = Number(space);
      } else if (space instanceof String) {
        space = String(space);
      }
      if (typeof space === "number") {
        if (space > 0) {
          space = Math.min(10, Math.floor(space));
          gap = "          ".substr(0, space);
        }
      } else if (typeof space === "string") {
        gap = space.substr(0, 10);
      }
      return serializeProperty("", { "": value });
      function serializeProperty(key2, holder) {
        let value2 = holder[key2];
        if (value2 != null) {
          if (typeof value2.toJSON5 === "function") {
            value2 = value2.toJSON5(key2);
          } else if (typeof value2.toJSON === "function") {
            value2 = value2.toJSON(key2);
          }
        }
        if (replacerFunc) {
          value2 = replacerFunc.call(holder, key2, value2);
        }
        if (value2 instanceof Number) {
          value2 = Number(value2);
        } else if (value2 instanceof String) {
          value2 = String(value2);
        } else if (value2 instanceof Boolean) {
          value2 = value2.valueOf();
        }
        switch (value2) {
          case null:
            return "null";
          case true:
            return "true";
          case false:
            return "false";
        }
        if (typeof value2 === "string") {
          return quoteString(value2);
        }
        if (typeof value2 === "number") {
          return String(value2);
        }
        if (typeof value2 === "object") {
          return Array.isArray(value2) ? serializeArray2(value2) : serializeObject2(value2);
        }
        return void 0;
      }
      function quoteString(value2) {
        const quotes = {
          "'": 0.1,
          '"': 0.2
        };
        const replacements = {
          "'": "\\'",
          '"': '\\"',
          "\\": "\\\\",
          "\b": "\\b",
          "\f": "\\f",
          "\n": "\\n",
          "\r": "\\r",
          "	": "\\t",
          "\v": "\\v",
          "\0": "\\0",
          "\u2028": "\\u2028",
          "\u2029": "\\u2029"
        };
        let product = "";
        for (let i2 = 0; i2 < value2.length; i2++) {
          const c3 = value2[i2];
          switch (c3) {
            case "'":
            case '"':
              quotes[c3]++;
              product += c3;
              continue;
            case "\0":
              if (util$1.isDigit(value2[i2 + 1])) {
                product += "\\x00";
                continue;
              }
          }
          if (replacements[c3]) {
            product += replacements[c3];
            continue;
          }
          if (c3 < " ") {
            let hexString = c3.charCodeAt(0).toString(16);
            product += "\\x" + ("00" + hexString).substring(hexString.length);
            continue;
          }
          product += c3;
        }
        const quoteChar = quote || Object.keys(quotes).reduce((a2, b2) => quotes[a2] < quotes[b2] ? a2 : b2);
        product = product.replace(new RegExp(quoteChar, "g"), replacements[quoteChar]);
        return quoteChar + product + quoteChar;
      }
      function serializeObject2(value2) {
        if (stack2.indexOf(value2) >= 0) {
          throw TypeError("Converting circular structure to JSON5");
        }
        stack2.push(value2);
        let stepback = indent;
        indent = indent + gap;
        let keys = propertyList || Object.keys(value2);
        let partial2 = [];
        for (const key2 of keys) {
          const propertyString = serializeProperty(key2, value2);
          if (propertyString !== void 0) {
            let member = serializeKey(key2) + ":";
            if (gap !== "") {
              member += " ";
            }
            member += propertyString;
            partial2.push(member);
          }
        }
        let final;
        if (partial2.length === 0) {
          final = "{}";
        } else {
          let properties;
          if (gap === "") {
            properties = partial2.join(",");
            final = "{" + properties + "}";
          } else {
            let separator = ",\n" + indent;
            properties = partial2.join(separator);
            final = "{\n" + indent + properties + ",\n" + stepback + "}";
          }
        }
        stack2.pop();
        indent = stepback;
        return final;
      }
      function serializeKey(key2) {
        if (key2.length === 0) {
          return quoteString(key2);
        }
        const firstChar = String.fromCodePoint(key2.codePointAt(0));
        if (!util$1.isIdStartChar(firstChar)) {
          return quoteString(key2);
        }
        for (let i2 = firstChar.length; i2 < key2.length; i2++) {
          if (!util$1.isIdContinueChar(String.fromCodePoint(key2.codePointAt(i2)))) {
            return quoteString(key2);
          }
        }
        return key2;
      }
      function serializeArray2(value2) {
        if (stack2.indexOf(value2) >= 0) {
          throw TypeError("Converting circular structure to JSON5");
        }
        stack2.push(value2);
        let stepback = indent;
        indent = indent + gap;
        let partial2 = [];
        for (let i2 = 0; i2 < value2.length; i2++) {
          const propertyString = serializeProperty(String(i2), value2);
          partial2.push(propertyString !== void 0 ? propertyString : "null");
        }
        let final;
        if (partial2.length === 0) {
          final = "[]";
        } else {
          if (gap === "") {
            let properties = partial2.join(",");
            final = "[" + properties + "]";
          } else {
            let separator = ",\n" + indent;
            let properties = partial2.join(separator);
            final = "[\n" + indent + properties + ",\n" + stepback + "]";
          }
        }
        stack2.pop();
        indent = stepback;
        return final;
      }
    };
    var JSON5 = {
      parse: parse$e,
      stringify
    };
    var lib$2 = JSON5;
    function formatGlobRelativePattern(base2, pattern2) {
      let parentDepth = 0;
      while (pattern2.startsWith("../")) {
        pattern2 = pattern2.slice(3);
        base2 = path__default.resolve(base2, "../");
        parentDepth++;
      }
      if (pattern2.startsWith("./")) {
        pattern2 = pattern2.slice(2);
      }
      return { base: base2, pattern: pattern2, parentDepth, isAbsolute: false };
    }
    async function transformImportGlob(source2, pos2, importer, importIndex, root2, logger, normalizeUrl, resolve2, preload2 = true) {
      var _a2;
      const isEager = source2.slice(pos2, pos2 + 21) === "import.meta.globEager";
      const isEagerDefault = isEager && source2.slice(pos2 + 21, pos2 + 28) === "Default";
      const err = (msg) => {
        const e2 = new Error(`Invalid glob import syntax: ${msg}`);
        e2.pos = pos2;
        return e2;
      };
      importer = cleanUrl(importer);
      const importerBasename = path__default.basename(importer);
      const [userPattern, options2, endIndex] = lexGlobPattern(source2, pos2);
      let globParams = null;
      if (userPattern.startsWith("/")) {
        globParams = {
          isAbsolute: true,
          base: path__default.resolve(root2),
          pattern: userPattern.slice(1),
          parentDepth: 0
        };
      } else if (userPattern.startsWith(".")) {
        globParams = formatGlobRelativePattern(path__default.dirname(importer), userPattern);
      } else if (resolve2) {
        const resolvedId = await resolve2(userPattern, importer);
        if (resolvedId) {
          const importerDirname = path__default.dirname(importer);
          globParams = formatGlobRelativePattern(importerDirname, normalizePath$4(path__default.relative(importerDirname, resolvedId)));
        }
      }
      if (!globParams) {
        throw err(`pattern must start with "." or "/" (relative to project root) or alias path`);
      }
      const { base: base2, parentDepth, isAbsolute: isAbsolute2, pattern: pattern2 } = globParams;
      const files = out.sync(pattern2, {
        cwd: base2,
        ignore: /(^|\/)node_modules\//.test(pattern2) ? [] : ["**/node_modules/**"]
      });
      const imports = [];
      let importsString = ``;
      let entries = ``;
      for (let i2 = 0; i2 < files.length; i2++) {
        if (files[i2] === importerBasename)
          continue;
        const file = isAbsolute2 ? `/${files[i2]}` : parentDepth ? `${"../".repeat(parentDepth)}${files[i2]}` : `./${files[i2]}`;
        let importee = file;
        if (normalizeUrl) {
          [importee] = await normalizeUrl(file, pos2);
        }
        imports.push(importee);
        const isRawAssert = ((_a2 = options2 === null || options2 === void 0 ? void 0 : options2.assert) === null || _a2 === void 0 ? void 0 : _a2.type) === "raw";
        const isRawType = (options2 === null || options2 === void 0 ? void 0 : options2.as) === "raw";
        if (isRawType || isRawAssert) {
          if (isRawAssert) {
            logger.warn(colors$1.yellow(colors$1.bold("(!) import.meta.glob('...', { assert: { type: 'raw' }}) is deprecated. Use import.meta.glob('...', { as: 'raw' }) instead.")));
          }
          entries += ` ${JSON.stringify(file)}: ${JSON.stringify(await fs$n.promises.readFile(path__default.join(base2, files[i2]), "utf-8"))},`;
        } else {
          const importeeUrl = isCSSRequest(importee) ? `${importee}?used` : importee;
          if (isEager) {
            const identifier = `__glob_${importIndex}_${i2}`;
            importsString += `import ${isEagerDefault ? `` : `* as `}${identifier} from ${JSON.stringify(importeeUrl)};`;
            entries += ` ${JSON.stringify(file)}: ${identifier},`;
          } else {
            let imp = `import(${JSON.stringify(importeeUrl)})`;
            if (!normalizeUrl && preload2) {
              imp = `(${isModernFlag}? ${preloadMethod}(()=>${imp},"${preloadMarker}"): ${imp})`;
            }
            entries += ` ${JSON.stringify(file)}: () => ${imp},`;
          }
        }
      }
      return {
        imports,
        importsString,
        exp: `{${entries}}`,
        endIndex,
        isEager,
        pattern: pattern2,
        base: base2
      };
    }
    function lexGlobPattern(code, pos2) {
      let state = 0;
      let pattern2 = "";
      let i2 = code.indexOf(`(`, pos2) + 1;
      outer:
        for (; i2 < code.length; i2++) {
          const char = code.charAt(i2);
          switch (state) {
            case 0:
              if (char === `'`) {
                state = 1;
              } else if (char === `"`) {
                state = 2;
              } else if (char === "`") {
                state = 3;
              } else if (/\s/.test(char)) {
                continue;
              } else {
                error$2(i2);
              }
              break;
            case 1:
              if (char === `'`) {
                break outer;
              } else {
                pattern2 += char;
              }
              break;
            case 2:
              if (char === `"`) {
                break outer;
              } else {
                pattern2 += char;
              }
              break;
            case 3:
              if (char === "`") {
                break outer;
              } else {
                pattern2 += char;
              }
              break;
            default:
              throw new Error("unknown import.meta.glob lexer state");
          }
        }
      const noCommentCode = code.slice(i2 + 1).replace(singlelineCommentsRE, blankReplacer).replace(multilineCommentsRE, blankReplacer);
      const endIndex = noCommentCode.indexOf(")");
      const optionString = noCommentCode.substring(0, endIndex);
      const commaIndex = optionString.indexOf(",");
      let options2 = {};
      if (commaIndex > -1) {
        options2 = lib$2.parse(optionString.substring(commaIndex + 1));
      }
      return [pattern2, options2, endIndex + i2 + 2];
    }
    function error$2(pos2) {
      const err = new Error(`import.meta.glob() can only accept string literals.`);
      err.pos = pos2;
      throw err;
    }
    var isModernFlag = `__VITE_IS_MODERN__`;
    var preloadMethod = `__vitePreload`;
    var preloadMarker = `__VITE_PRELOAD__`;
    var preloadBaseMarker = `__VITE_PRELOAD_BASE__`;
    var preloadHelperId = "vite/preload-helper";
    var preloadMarkerRE = new RegExp(`"${preloadMarker}"`, "g");
    function detectScriptRel() {
      const relList = document.createElement("link").relList;
      return relList && relList.supports && relList.supports("modulepreload") ? "modulepreload" : "preload";
    }
    function preload(baseModule, deps) {
      if (!__VITE_IS_MODERN__ || !deps || deps.length === 0) {
        return baseModule();
      }
      return Promise.all(deps.map((dep) => {
        dep = `${base}${dep}`;
        if (dep in seen)
          return;
        seen[dep] = true;
        const isCss = dep.endsWith(".css");
        const cssSelector = isCss ? '[rel="stylesheet"]' : "";
        if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
          return;
        }
        const link = document.createElement("link");
        link.rel = isCss ? "stylesheet" : scriptRel;
        if (!isCss) {
          link.as = "script";
          link.crossOrigin = "";
        }
        link.href = dep;
        document.head.appendChild(link);
        if (isCss) {
          return new Promise((res, rej) => {
            link.addEventListener("load", res);
            link.addEventListener("error", () => rej(new Error(`Unable to preload CSS for ${dep}`)));
          });
        }
      })).then(() => baseModule());
    }
    function buildImportAnalysisPlugin(config2) {
      const ssr = !!config2.build.ssr;
      const insertPreload = !(ssr || !!config2.build.lib);
      const isWorker = config2.isWorker;
      const scriptRel2 = config2.build.polyfillModulePreload ? `'modulepreload'` : `(${detectScriptRel.toString()})()`;
      const preloadCode = `const scriptRel = ${scriptRel2};const seen = {};const base = '${preloadBaseMarker}';export const ${preloadMethod} = ${preload.toString()}`;
      const resolve2 = config2.createResolver({
        preferRelative: true,
        tryIndex: false,
        extensions: []
      });
      return {
        name: "vite:build-import-analysis",
        resolveId(id) {
          if (id === preloadHelperId) {
            return id;
          }
        },
        load(id) {
          if (id === preloadHelperId) {
            return preloadCode.replace(preloadBaseMarker, config2.base);
          }
        },
        async transform(source2, importer) {
          if (importer.includes("node_modules") && !source2.includes("import.meta.glob")) {
            return;
          }
          if (isWorker) {
            return;
          }
          await init;
          let imports = [];
          try {
            imports = parse$h(source2)[0];
          } catch (e2) {
            this.error(e2, e2.idx);
          }
          if (!imports.length) {
            return null;
          }
          let s2;
          const str = () => s2 || (s2 = new MagicString(source2));
          let needPreloadHelper = false;
          for (let index2 = 0; index2 < imports.length; index2++) {
            const { s: start, e: end, ss: expStart, se: expEnd, n: specifier, d: dynamicIndex } = imports[index2];
            if (source2.slice(start, end) === "import.meta" && source2.slice(end, end + 5) === ".glob") {
              const { importsString, exp, endIndex, isEager } = await transformImportGlob(source2, start, importer, index2, config2.root, config2.logger, void 0, resolve2, insertPreload);
              str().prepend(importsString);
              str().overwrite(expStart, endIndex, exp, { contentOnly: true });
              if (!isEager) {
                needPreloadHelper = true;
              }
              continue;
            }
            if (dynamicIndex > -1 && insertPreload) {
              needPreloadHelper = true;
              const original = source2.slice(expStart, expEnd);
              const replacement2 = `${preloadMethod}(() => ${original},${isModernFlag}?"${preloadMarker}":void 0)`;
              str().overwrite(expStart, expEnd, replacement2, { contentOnly: true });
            }
            if (specifier && isCSSRequest(specifier) && source2.slice(expStart, start).includes("from") && !(bareImportRE.test(specifier) && !specifier.includes("/"))) {
              const url2 = specifier.replace(/\?|$/, (m3) => `?used${m3 ? "&" : ""}`);
              str().overwrite(start, end, dynamicIndex > -1 ? `'${url2}'` : url2, {
                contentOnly: true
              });
            }
          }
          if (needPreloadHelper && insertPreload && !source2.includes(`const ${preloadMethod} =`)) {
            str().prepend(`import { ${preloadMethod} } from "${preloadHelperId}";`);
          }
          if (s2) {
            return {
              code: s2.toString(),
              map: config2.build.sourcemap ? s2.generateMap({ hires: true }) : null
            };
          }
        },
        renderChunk(code, _2, { format: format2 }) {
          if (code.indexOf(isModernFlag) > -1) {
            const re2 = new RegExp(isModernFlag, "g");
            const isModern = String(format2 === "es");
            if (config2.build.sourcemap) {
              const s2 = new MagicString(code);
              let match2;
              while (match2 = re2.exec(code)) {
                s2.overwrite(match2.index, match2.index + isModernFlag.length, isModern, { contentOnly: true });
              }
              return {
                code: s2.toString(),
                map: s2.generateMap({ hires: true })
              };
            } else {
              return code.replace(re2, isModern);
            }
          }
          return null;
        },
        generateBundle({ format: format2 }, bundle) {
          if (format2 !== "es" || ssr || isWorker) {
            return;
          }
          for (const file in bundle) {
            const chunk = bundle[file];
            if (chunk.type === "chunk" && chunk.code.indexOf(preloadMarker) > -1) {
              const code = chunk.code;
              let imports;
              try {
                imports = parse$h(code)[0].filter((i2) => i2.d > -1);
              } catch (e2) {
                this.error(e2, e2.idx);
              }
              if (imports.length) {
                const s2 = new MagicString(code);
                for (let index2 = 0; index2 < imports.length; index2++) {
                  const { n: name, s: start, e: end, ss: expStart, se: expEnd } = imports[index2];
                  let url2 = name;
                  if (!url2) {
                    const rawUrl = code.slice(start, end);
                    if (rawUrl[0] === `"` && rawUrl[rawUrl.length - 1] === `"`)
                      url2 = rawUrl.slice(1, -1);
                  }
                  const deps = /* @__PURE__ */ new Set();
                  let hasRemovedPureCssChunk = false;
                  if (url2) {
                    const ownerFilename = chunk.fileName;
                    const analyzed = /* @__PURE__ */ new Set();
                    const addDeps = (filename2) => {
                      if (filename2 === ownerFilename)
                        return;
                      if (analyzed.has(filename2))
                        return;
                      analyzed.add(filename2);
                      const chunk2 = bundle[filename2];
                      if (chunk2) {
                        deps.add(chunk2.fileName);
                        chunk2.viteMetadata.importedCss.forEach((file2) => {
                          deps.add(file2);
                        });
                        chunk2.imports.forEach(addDeps);
                      } else {
                        const removedPureCssFiles = removedPureCssFilesCache.get(config2);
                        const chunk3 = removedPureCssFiles.get(filename2);
                        if (chunk3) {
                          if (chunk3.viteMetadata.importedCss.size) {
                            chunk3.viteMetadata.importedCss.forEach((file2) => {
                              deps.add(file2);
                            });
                            hasRemovedPureCssChunk = true;
                          }
                          s2.overwrite(expStart, expEnd, "Promise.resolve({})", {
                            contentOnly: true
                          });
                        }
                      }
                    };
                    const normalizedFile = path__default.posix.join(path__default.posix.dirname(chunk.fileName), url2);
                    addDeps(normalizedFile);
                  }
                  let markPos = code.indexOf(preloadMarker, end);
                  if (markPos === -1 && imports.length === 1) {
                    markPos = code.indexOf(preloadMarker);
                  }
                  if (markPos > 0) {
                    s2.overwrite(markPos - 1, markPos + preloadMarker.length + 1, deps.size > 1 || hasRemovedPureCssChunk && deps.size > 0 ? `[${[...deps].map((d3) => JSON.stringify(d3)).join(",")}]` : `[]`, { contentOnly: true });
                  }
                }
                chunk.code = s2.toString();
              }
              chunk.code = chunk.code.replace(preloadMarkerRE, "void 0");
            }
          }
        }
      };
    }
    var externalTypes = [
      "css",
      "less",
      "sass",
      "scss",
      "styl",
      "stylus",
      "pcss",
      "postcss",
      "vue",
      "svelte",
      "marko",
      "astro",
      "jsx",
      "tsx",
      ...KNOWN_ASSET_TYPES
    ];
    function esbuildDepPlugin(qualified, exportsData, config2) {
      const allExternalTypes = config2.optimizeDeps.extensions ? externalTypes.filter((type) => {
        var _a2;
        return !((_a2 = config2.optimizeDeps.extensions) === null || _a2 === void 0 ? void 0 : _a2.includes("." + type));
      }) : externalTypes;
      const _resolve = config2.createResolver({ asSrc: false, scan: true });
      const _resolveRequire = config2.createResolver({
        asSrc: false,
        isRequire: true,
        scan: true
      });
      const resolve2 = (id, importer, kind, resolveDir) => {
        let _importer;
        if (resolveDir) {
          _importer = normalizePath$4(path__default.join(resolveDir, "*"));
        } else {
          _importer = importer in qualified ? qualified[importer] : importer;
        }
        const resolver = kind.startsWith("require") ? _resolveRequire : _resolve;
        return resolver(id, _importer, void 0);
      };
      return {
        name: "vite:dep-pre-bundle",
        setup(build2) {
          build2.onResolve({
            filter: new RegExp(`\\.(` + allExternalTypes.join("|") + `)(\\?.*)?$`)
          }, async ({ path: id, importer, kind }) => {
            const resolved = await resolve2(id, importer, kind);
            if (resolved) {
              return {
                path: resolved,
                external: true
              };
            }
          });
          function resolveEntry(id) {
            const flatId = flattenId(id);
            if (flatId in qualified) {
              return {
                path: flatId,
                namespace: "dep"
              };
            }
          }
          build2.onResolve({ filter: /^[\w@][^:]/ }, async ({ path: id, importer, kind }) => {
            var _a2;
            if (moduleListContains((_a2 = config2.optimizeDeps) === null || _a2 === void 0 ? void 0 : _a2.exclude, id)) {
              return {
                path: id,
                external: true
              };
            }
            let entry2;
            if (!importer) {
              if (entry2 = resolveEntry(id))
                return entry2;
              const aliased = await _resolve(id, void 0, true);
              if (aliased && (entry2 = resolveEntry(aliased))) {
                return entry2;
              }
            }
            const resolved = await resolve2(id, importer, kind);
            if (resolved) {
              if (resolved.startsWith(browserExternalId)) {
                return {
                  path: id,
                  namespace: "browser-external"
                };
              }
              if (isExternalUrl(resolved)) {
                return {
                  path: resolved,
                  external: true
                };
              }
              return {
                path: path__default.resolve(resolved)
              };
            }
          });
          const root2 = path__default.resolve(config2.root);
          build2.onLoad({ filter: /.*/, namespace: "dep" }, ({ path: id }) => {
            const entryFile = qualified[id];
            let relativePath = normalizePath$4(path__default.relative(root2, entryFile));
            if (!relativePath.startsWith("./") && !relativePath.startsWith("../") && relativePath !== ".") {
              relativePath = `./${relativePath}`;
            }
            let contents = "";
            const data2 = exportsData[id];
            const [imports, exports2] = data2;
            if (!imports.length && !exports2.length) {
              contents += `export default require("${relativePath}");`;
            } else {
              if (exports2.includes("default")) {
                contents += `import d from "${relativePath}";export default d;`;
              }
              if (data2.hasReExports || exports2.length > 1 || exports2[0] !== "default") {
                contents += `
export * from "${relativePath}"`;
              }
            }
            return {
              loader: "js",
              contents,
              resolveDir: root2
            };
          });
          build2.onLoad({ filter: /.*/, namespace: "browser-external" }, ({ path: id }) => {
            return {
              contents: `export default new Proxy({}, {
  get() {
    throw new Error('Module "${id}" has been externalized for browser compatibility and cannot be accessed in client code.')
  }
})`
            };
          });
          if (isRunningWithYarnPnp) {
            build2.onResolve({ filter: /.*/ }, async ({ path: path2, importer, kind, resolveDir }) => ({
              path: await resolve2(path2, importer, kind, resolveDir)
            }));
            build2.onLoad({ filter: /.*/ }, async (args) => ({
              contents: await (init_fs(), __toCommonJS(fs_exports)).promises.readFile(args.path),
              loader: "default"
            }));
          }
        }
      };
    }
    var reservedWords = {
      3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
      5: "class enum extends super const export import",
      6: "enum",
      strict: "implements interface let package private protected public static yield",
      strictBind: "eval arguments"
    };
    var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
    var keywords$1 = {
      5: ecma5AndLessKeywords,
      "5module": ecma5AndLessKeywords + " export import",
      6: ecma5AndLessKeywords + " const class extends export import super"
    };
    var keywordRelationalOperator = /^in(stanceof)?$/;
    var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
    var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
    var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
    var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
    nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
    var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1070, 4050, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 46, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 482, 44, 11, 6, 17, 0, 322, 29, 19, 43, 1269, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4152, 8, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938];
    var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 357, 0, 62, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
    function isInAstralSet(code, set2) {
      var pos2 = 65536;
      for (var i2 = 0; i2 < set2.length; i2 += 2) {
        pos2 += set2[i2];
        if (pos2 > code) {
          return false;
        }
        pos2 += set2[i2 + 1];
        if (pos2 >= code) {
          return true;
        }
      }
    }
    function isIdentifierStart(code, astral) {
      if (code < 65) {
        return code === 36;
      }
      if (code < 91) {
        return true;
      }
      if (code < 97) {
        return code === 95;
      }
      if (code < 123) {
        return true;
      }
      if (code <= 65535) {
        return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
      }
      if (astral === false) {
        return false;
      }
      return isInAstralSet(code, astralIdentifierStartCodes);
    }
    function isIdentifierChar(code, astral) {
      if (code < 48) {
        return code === 36;
      }
      if (code < 58) {
        return true;
      }
      if (code < 65) {
        return false;
      }
      if (code < 91) {
        return true;
      }
      if (code < 97) {
        return code === 95;
      }
      if (code < 123) {
        return true;
      }
      if (code <= 65535) {
        return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
      }
      if (astral === false) {
        return false;
      }
      return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
    }
    var TokenType = function TokenType2(label, conf) {
      if (conf === void 0)
        conf = {};
      this.label = label;
      this.keyword = conf.keyword;
      this.beforeExpr = !!conf.beforeExpr;
      this.startsExpr = !!conf.startsExpr;
      this.isLoop = !!conf.isLoop;
      this.isAssign = !!conf.isAssign;
      this.prefix = !!conf.prefix;
      this.postfix = !!conf.postfix;
      this.binop = conf.binop || null;
      this.updateContext = null;
    };
    function binop(name, prec) {
      return new TokenType(name, { beforeExpr: true, binop: prec });
    }
    var beforeExpr = { beforeExpr: true };
    var startsExpr = { startsExpr: true };
    var keywords = {};
    function kw(name, options2) {
      if (options2 === void 0)
        options2 = {};
      options2.keyword = name;
      return keywords[name] = new TokenType(name, options2);
    }
    var types$1 = {
      num: new TokenType("num", startsExpr),
      regexp: new TokenType("regexp", startsExpr),
      string: new TokenType("string", startsExpr),
      name: new TokenType("name", startsExpr),
      privateId: new TokenType("privateId", startsExpr),
      eof: new TokenType("eof"),
      bracketL: new TokenType("[", { beforeExpr: true, startsExpr: true }),
      bracketR: new TokenType("]"),
      braceL: new TokenType("{", { beforeExpr: true, startsExpr: true }),
      braceR: new TokenType("}"),
      parenL: new TokenType("(", { beforeExpr: true, startsExpr: true }),
      parenR: new TokenType(")"),
      comma: new TokenType(",", beforeExpr),
      semi: new TokenType(";", beforeExpr),
      colon: new TokenType(":", beforeExpr),
      dot: new TokenType("."),
      question: new TokenType("?", beforeExpr),
      questionDot: new TokenType("?."),
      arrow: new TokenType("=>", beforeExpr),
      template: new TokenType("template"),
      invalidTemplate: new TokenType("invalidTemplate"),
      ellipsis: new TokenType("...", beforeExpr),
      backQuote: new TokenType("`", startsExpr),
      dollarBraceL: new TokenType("${", { beforeExpr: true, startsExpr: true }),
      eq: new TokenType("=", { beforeExpr: true, isAssign: true }),
      assign: new TokenType("_=", { beforeExpr: true, isAssign: true }),
      incDec: new TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
      prefix: new TokenType("!/~", { beforeExpr: true, prefix: true, startsExpr: true }),
      logicalOR: binop("||", 1),
      logicalAND: binop("&&", 2),
      bitwiseOR: binop("|", 3),
      bitwiseXOR: binop("^", 4),
      bitwiseAND: binop("&", 5),
      equality: binop("==/!=/===/!==", 6),
      relational: binop("</>/<=/>=", 7),
      bitShift: binop("<</>>/>>>", 8),
      plusMin: new TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
      modulo: binop("%", 10),
      star: binop("*", 10),
      slash: binop("/", 10),
      starstar: new TokenType("**", { beforeExpr: true }),
      coalesce: binop("??", 1),
      _break: kw("break"),
      _case: kw("case", beforeExpr),
      _catch: kw("catch"),
      _continue: kw("continue"),
      _debugger: kw("debugger"),
      _default: kw("default", beforeExpr),
      _do: kw("do", { isLoop: true, beforeExpr: true }),
      _else: kw("else", beforeExpr),
      _finally: kw("finally"),
      _for: kw("for", { isLoop: true }),
      _function: kw("function", startsExpr),
      _if: kw("if"),
      _return: kw("return", beforeExpr),
      _switch: kw("switch"),
      _throw: kw("throw", beforeExpr),
      _try: kw("try"),
      _var: kw("var"),
      _const: kw("const"),
      _while: kw("while", { isLoop: true }),
      _with: kw("with"),
      _new: kw("new", { beforeExpr: true, startsExpr: true }),
      _this: kw("this", startsExpr),
      _super: kw("super", startsExpr),
      _class: kw("class", startsExpr),
      _extends: kw("extends", beforeExpr),
      _export: kw("export"),
      _import: kw("import", startsExpr),
      _null: kw("null", startsExpr),
      _true: kw("true", startsExpr),
      _false: kw("false", startsExpr),
      _in: kw("in", { beforeExpr: true, binop: 7 }),
      _instanceof: kw("instanceof", { beforeExpr: true, binop: 7 }),
      _typeof: kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true }),
      _void: kw("void", { beforeExpr: true, prefix: true, startsExpr: true }),
      _delete: kw("delete", { beforeExpr: true, prefix: true, startsExpr: true })
    };
    var lineBreak = /\r\n?|\n|\u2028|\u2029/;
    var lineBreakG = new RegExp(lineBreak.source, "g");
    function isNewLine(code) {
      return code === 10 || code === 13 || code === 8232 || code === 8233;
    }
    function nextLineBreak(code, from, end) {
      if (end === void 0)
        end = code.length;
      for (var i2 = from; i2 < end; i2++) {
        var next = code.charCodeAt(i2);
        if (isNewLine(next)) {
          return i2 < end - 1 && next === 13 && code.charCodeAt(i2 + 1) === 10 ? i2 + 2 : i2 + 1;
        }
      }
      return -1;
    }
    var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
    var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
    var ref = Object.prototype;
    var hasOwnProperty$1 = ref.hasOwnProperty;
    var toString$1 = ref.toString;
    var hasOwn = Object.hasOwn || function(obj, propName) {
      return hasOwnProperty$1.call(obj, propName);
    };
    var isArray = Array.isArray || function(obj) {
      return toString$1.call(obj) === "[object Array]";
    };
    function wordsRegexp(words) {
      return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$");
    }
    var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
    var Position = function Position2(line2, col) {
      this.line = line2;
      this.column = col;
    };
    Position.prototype.offset = function offset2(n3) {
      return new Position(this.line, this.column + n3);
    };
    var SourceLocation = function SourceLocation2(p2, start, end) {
      this.start = start;
      this.end = end;
      if (p2.sourceFile !== null) {
        this.source = p2.sourceFile;
      }
    };
    function getLineInfo(input, offset2) {
      for (var line2 = 1, cur = 0; ; ) {
        var nextBreak = nextLineBreak(input, cur, offset2);
        if (nextBreak < 0) {
          return new Position(line2, offset2 - cur);
        }
        ++line2;
        cur = nextBreak;
      }
    }
    var defaultOptions = {
      ecmaVersion: null,
      sourceType: "script",
      onInsertedSemicolon: null,
      onTrailingComma: null,
      allowReserved: null,
      allowReturnOutsideFunction: false,
      allowImportExportEverywhere: false,
      allowAwaitOutsideFunction: null,
      allowSuperOutsideMethod: null,
      allowHashBang: false,
      locations: false,
      onToken: null,
      onComment: null,
      ranges: false,
      program: null,
      sourceFile: null,
      directSourceFile: null,
      preserveParens: false
    };
    var warnedAboutEcmaVersion = false;
    function getOptions(opts) {
      var options2 = {};
      for (var opt in defaultOptions) {
        options2[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt];
      }
      if (options2.ecmaVersion === "latest") {
        options2.ecmaVersion = 1e8;
      } else if (options2.ecmaVersion == null) {
        if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
          warnedAboutEcmaVersion = true;
          console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
        }
        options2.ecmaVersion = 11;
      } else if (options2.ecmaVersion >= 2015) {
        options2.ecmaVersion -= 2009;
      }
      if (options2.allowReserved == null) {
        options2.allowReserved = options2.ecmaVersion < 5;
      }
      if (isArray(options2.onToken)) {
        var tokens = options2.onToken;
        options2.onToken = function(token2) {
          return tokens.push(token2);
        };
      }
      if (isArray(options2.onComment)) {
        options2.onComment = pushComment(options2, options2.onComment);
      }
      return options2;
    }
    function pushComment(options2, array2) {
      return function(block, text, start, end, startLoc, endLoc) {
        var comment = {
          type: block ? "Block" : "Line",
          value: text,
          start,
          end
        };
        if (options2.locations) {
          comment.loc = new SourceLocation(this, startLoc, endLoc);
        }
        if (options2.ranges) {
          comment.range = [start, end];
        }
        array2.push(comment);
      };
    }
    var SCOPE_TOP = 1;
    var SCOPE_FUNCTION = 2;
    var SCOPE_ASYNC = 4;
    var SCOPE_GENERATOR = 8;
    var SCOPE_ARROW = 16;
    var SCOPE_SIMPLE_CATCH = 32;
    var SCOPE_SUPER = 64;
    var SCOPE_DIRECT_SUPER = 128;
    var SCOPE_CLASS_STATIC_BLOCK = 256;
    var SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;
    function functionFlags(async2, generator) {
      return SCOPE_FUNCTION | (async2 ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
    }
    var BIND_NONE = 0;
    var BIND_VAR = 1;
    var BIND_LEXICAL = 2;
    var BIND_FUNCTION = 3;
    var BIND_SIMPLE_CATCH = 4;
    var BIND_OUTSIDE = 5;
    var Parser = function Parser2(options2, input, startPos) {
      this.options = options2 = getOptions(options2);
      this.sourceFile = options2.sourceFile;
      this.keywords = wordsRegexp(keywords$1[options2.ecmaVersion >= 6 ? 6 : options2.sourceType === "module" ? "5module" : 5]);
      var reserved = "";
      if (options2.allowReserved !== true) {
        reserved = reservedWords[options2.ecmaVersion >= 6 ? 6 : options2.ecmaVersion === 5 ? 5 : 3];
        if (options2.sourceType === "module") {
          reserved += " await";
        }
      }
      this.reservedWords = wordsRegexp(reserved);
      var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
      this.reservedWordsStrict = wordsRegexp(reservedStrict);
      this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
      this.input = String(input);
      this.containsEsc = false;
      if (startPos) {
        this.pos = startPos;
        this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
        this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
      } else {
        this.pos = this.lineStart = 0;
        this.curLine = 1;
      }
      this.type = types$1.eof;
      this.value = null;
      this.start = this.end = this.pos;
      this.startLoc = this.endLoc = this.curPosition();
      this.lastTokEndLoc = this.lastTokStartLoc = null;
      this.lastTokStart = this.lastTokEnd = this.pos;
      this.context = this.initialContext();
      this.exprAllowed = true;
      this.inModule = options2.sourceType === "module";
      this.strict = this.inModule || this.strictDirective(this.pos);
      this.potentialArrowAt = -1;
      this.potentialArrowInForAwait = false;
      this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
      this.labels = [];
      this.undefinedExports = /* @__PURE__ */ Object.create(null);
      if (this.pos === 0 && options2.allowHashBang && this.input.slice(0, 2) === "#!") {
        this.skipLineComment(2);
      }
      this.scopeStack = [];
      this.enterScope(SCOPE_TOP);
      this.regexpState = null;
      this.privateNameStack = [];
    };
    var prototypeAccessors = { inFunction: { configurable: true }, inGenerator: { configurable: true }, inAsync: { configurable: true }, canAwait: { configurable: true }, allowSuper: { configurable: true }, allowDirectSuper: { configurable: true }, treatFunctionsAsVar: { configurable: true }, allowNewDotTarget: { configurable: true }, inClassStaticBlock: { configurable: true } };
    Parser.prototype.parse = function parse2() {
      var node2 = this.options.program || this.startNode();
      this.nextToken();
      return this.parseTopLevel(node2);
    };
    prototypeAccessors.inFunction.get = function() {
      return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
    };
    prototypeAccessors.inGenerator.get = function() {
      return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 && !this.currentVarScope().inClassFieldInit;
    };
    prototypeAccessors.inAsync.get = function() {
      return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 && !this.currentVarScope().inClassFieldInit;
    };
    prototypeAccessors.canAwait.get = function() {
      for (var i2 = this.scopeStack.length - 1; i2 >= 0; i2--) {
        var scope = this.scopeStack[i2];
        if (scope.inClassFieldInit || scope.flags & SCOPE_CLASS_STATIC_BLOCK) {
          return false;
        }
        if (scope.flags & SCOPE_FUNCTION) {
          return (scope.flags & SCOPE_ASYNC) > 0;
        }
      }
      return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
    };
    prototypeAccessors.allowSuper.get = function() {
      var ref2 = this.currentThisScope();
      var flags = ref2.flags;
      var inClassFieldInit = ref2.inClassFieldInit;
      return (flags & SCOPE_SUPER) > 0 || inClassFieldInit || this.options.allowSuperOutsideMethod;
    };
    prototypeAccessors.allowDirectSuper.get = function() {
      return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
    };
    prototypeAccessors.treatFunctionsAsVar.get = function() {
      return this.treatFunctionsAsVarInScope(this.currentScope());
    };
    prototypeAccessors.allowNewDotTarget.get = function() {
      var ref2 = this.currentThisScope();
      var flags = ref2.flags;
      var inClassFieldInit = ref2.inClassFieldInit;
      return (flags & (SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK)) > 0 || inClassFieldInit;
    };
    prototypeAccessors.inClassStaticBlock.get = function() {
      return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0;
    };
    Parser.extend = function extend2() {
      var plugins2 = [], len = arguments.length;
      while (len--)
        plugins2[len] = arguments[len];
      var cls = this;
      for (var i2 = 0; i2 < plugins2.length; i2++) {
        cls = plugins2[i2](cls);
      }
      return cls;
    };
    Parser.parse = function parse2(input, options2) {
      return new this(options2, input).parse();
    };
    Parser.parseExpressionAt = function parseExpressionAt2(input, pos2, options2) {
      var parser2 = new this(options2, input, pos2);
      parser2.nextToken();
      return parser2.parseExpression();
    };
    Parser.tokenizer = function tokenizer2(input, options2) {
      return new this(options2, input);
    };
    Object.defineProperties(Parser.prototype, prototypeAccessors);
    var pp$9 = Parser.prototype;
    var literal = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
    pp$9.strictDirective = function(start) {
      for (; ; ) {
        skipWhiteSpace.lastIndex = start;
        start += skipWhiteSpace.exec(this.input)[0].length;
        var match2 = literal.exec(this.input.slice(start));
        if (!match2) {
          return false;
        }
        if ((match2[1] || match2[2]) === "use strict") {
          skipWhiteSpace.lastIndex = start + match2[0].length;
          var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
          var next = this.input.charAt(end);
          return next === ";" || next === "}" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "=");
        }
        start += match2[0].length;
        skipWhiteSpace.lastIndex = start;
        start += skipWhiteSpace.exec(this.input)[0].length;
        if (this.input[start] === ";") {
          start++;
        }
      }
    };
    pp$9.eat = function(type) {
      if (this.type === type) {
        this.next();
        return true;
      } else {
        return false;
      }
    };
    pp$9.isContextual = function(name) {
      return this.type === types$1.name && this.value === name && !this.containsEsc;
    };
    pp$9.eatContextual = function(name) {
      if (!this.isContextual(name)) {
        return false;
      }
      this.next();
      return true;
    };
    pp$9.expectContextual = function(name) {
      if (!this.eatContextual(name)) {
        this.unexpected();
      }
    };
    pp$9.canInsertSemicolon = function() {
      return this.type === types$1.eof || this.type === types$1.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
    };
    pp$9.insertSemicolon = function() {
      if (this.canInsertSemicolon()) {
        if (this.options.onInsertedSemicolon) {
          this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
        }
        return true;
      }
    };
    pp$9.semicolon = function() {
      if (!this.eat(types$1.semi) && !this.insertSemicolon()) {
        this.unexpected();
      }
    };
    pp$9.afterTrailingComma = function(tokType, notNext) {
      if (this.type === tokType) {
        if (this.options.onTrailingComma) {
          this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
        }
        if (!notNext) {
          this.next();
        }
        return true;
      }
    };
    pp$9.expect = function(type) {
      this.eat(type) || this.unexpected();
    };
    pp$9.unexpected = function(pos2) {
      this.raise(pos2 != null ? pos2 : this.start, "Unexpected token");
    };
    function DestructuringErrors() {
      this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
    }
    pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
      if (!refDestructuringErrors) {
        return;
      }
      if (refDestructuringErrors.trailingComma > -1) {
        this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
      }
      var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
      if (parens > -1) {
        this.raiseRecoverable(parens, "Parenthesized pattern");
      }
    };
    pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
      if (!refDestructuringErrors) {
        return false;
      }
      var shorthandAssign = refDestructuringErrors.shorthandAssign;
      var doubleProto = refDestructuringErrors.doubleProto;
      if (!andThrow) {
        return shorthandAssign >= 0 || doubleProto >= 0;
      }
      if (shorthandAssign >= 0) {
        this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
      }
      if (doubleProto >= 0) {
        this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
      }
    };
    pp$9.checkYieldAwaitInDefaultParams = function() {
      if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {
        this.raise(this.yieldPos, "Yield expression cannot be a default value");
      }
      if (this.awaitPos) {
        this.raise(this.awaitPos, "Await expression cannot be a default value");
      }
    };
    pp$9.isSimpleAssignTarget = function(expr) {
      if (expr.type === "ParenthesizedExpression") {
        return this.isSimpleAssignTarget(expr.expression);
      }
      return expr.type === "Identifier" || expr.type === "MemberExpression";
    };
    var pp$8 = Parser.prototype;
    pp$8.parseTopLevel = function(node2) {
      var exports2 = /* @__PURE__ */ Object.create(null);
      if (!node2.body) {
        node2.body = [];
      }
      while (this.type !== types$1.eof) {
        var stmt = this.parseStatement(null, true, exports2);
        node2.body.push(stmt);
      }
      if (this.inModule) {
        for (var i2 = 0, list2 = Object.keys(this.undefinedExports); i2 < list2.length; i2 += 1) {
          var name = list2[i2];
          this.raiseRecoverable(this.undefinedExports[name].start, "Export '" + name + "' is not defined");
        }
      }
      this.adaptDirectivePrologue(node2.body);
      this.next();
      node2.sourceType = this.options.sourceType;
      return this.finishNode(node2, "Program");
    };
    var loopLabel = { kind: "loop" };
    var switchLabel = { kind: "switch" };
    pp$8.isLet = function(context2) {
      if (this.options.ecmaVersion < 6 || !this.isContextual("let")) {
        return false;
      }
      skipWhiteSpace.lastIndex = this.pos;
      var skip = skipWhiteSpace.exec(this.input);
      var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
      if (nextCh === 91 || nextCh === 92 || nextCh > 55295 && nextCh < 56320) {
        return true;
      }
      if (context2) {
        return false;
      }
      if (nextCh === 123) {
        return true;
      }
      if (isIdentifierStart(nextCh, true)) {
        var pos2 = next + 1;
        while (isIdentifierChar(nextCh = this.input.charCodeAt(pos2), true)) {
          ++pos2;
        }
        if (nextCh === 92 || nextCh > 55295 && nextCh < 56320) {
          return true;
        }
        var ident = this.input.slice(next, pos2);
        if (!keywordRelationalOperator.test(ident)) {
          return true;
        }
      }
      return false;
    };
    pp$8.isAsyncFunction = function() {
      if (this.options.ecmaVersion < 8 || !this.isContextual("async")) {
        return false;
      }
      skipWhiteSpace.lastIndex = this.pos;
      var skip = skipWhiteSpace.exec(this.input);
      var next = this.pos + skip[0].length, after;
      return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 === this.input.length || !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 55295 && after < 56320));
    };
    pp$8.parseStatement = function(context2, topLevel, exports2) {
      var starttype = this.type, node2 = this.startNode(), kind;
      if (this.isLet(context2)) {
        starttype = types$1._var;
        kind = "let";
      }
      switch (starttype) {
        case types$1._break:
        case types$1._continue:
          return this.parseBreakContinueStatement(node2, starttype.keyword);
        case types$1._debugger:
          return this.parseDebuggerStatement(node2);
        case types$1._do:
          return this.parseDoStatement(node2);
        case types$1._for:
          return this.parseForStatement(node2);
        case types$1._function:
          if (context2 && (this.strict || context2 !== "if" && context2 !== "label") && this.options.ecmaVersion >= 6) {
            this.unexpected();
          }
          return this.parseFunctionStatement(node2, false, !context2);
        case types$1._class:
          if (context2) {
            this.unexpected();
          }
          return this.parseClass(node2, true);
        case types$1._if:
          return this.parseIfStatement(node2);
        case types$1._return:
          return this.parseReturnStatement(node2);
        case types$1._switch:
          return this.parseSwitchStatement(node2);
        case types$1._throw:
          return this.parseThrowStatement(node2);
        case types$1._try:
          return this.parseTryStatement(node2);
        case types$1._const:
        case types$1._var:
          kind = kind || this.value;
          if (context2 && kind !== "var") {
            this.unexpected();
          }
          return this.parseVarStatement(node2, kind);
        case types$1._while:
          return this.parseWhileStatement(node2);
        case types$1._with:
          return this.parseWithStatement(node2);
        case types$1.braceL:
          return this.parseBlock(true, node2);
        case types$1.semi:
          return this.parseEmptyStatement(node2);
        case types$1._export:
        case types$1._import:
          if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
            skipWhiteSpace.lastIndex = this.pos;
            var skip = skipWhiteSpace.exec(this.input);
            var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
            if (nextCh === 40 || nextCh === 46) {
              return this.parseExpressionStatement(node2, this.parseExpression());
            }
          }
          if (!this.options.allowImportExportEverywhere) {
            if (!topLevel) {
              this.raise(this.start, "'import' and 'export' may only appear at the top level");
            }
            if (!this.inModule) {
              this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
            }
          }
          return starttype === types$1._import ? this.parseImport(node2) : this.parseExport(node2, exports2);
        default:
          if (this.isAsyncFunction()) {
            if (context2) {
              this.unexpected();
            }
            this.next();
            return this.parseFunctionStatement(node2, true, !context2);
          }
          var maybeName = this.value, expr = this.parseExpression();
          if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon)) {
            return this.parseLabeledStatement(node2, maybeName, expr, context2);
          } else {
            return this.parseExpressionStatement(node2, expr);
          }
      }
    };
    pp$8.parseBreakContinueStatement = function(node2, keyword) {
      var isBreak = keyword === "break";
      this.next();
      if (this.eat(types$1.semi) || this.insertSemicolon()) {
        node2.label = null;
      } else if (this.type !== types$1.name) {
        this.unexpected();
      } else {
        node2.label = this.parseIdent();
        this.semicolon();
      }
      var i2 = 0;
      for (; i2 < this.labels.length; ++i2) {
        var lab = this.labels[i2];
        if (node2.label == null || lab.name === node2.label.name) {
          if (lab.kind != null && (isBreak || lab.kind === "loop")) {
            break;
          }
          if (node2.label && isBreak) {
            break;
          }
        }
      }
      if (i2 === this.labels.length) {
        this.raise(node2.start, "Unsyntactic " + keyword);
      }
      return this.finishNode(node2, isBreak ? "BreakStatement" : "ContinueStatement");
    };
    pp$8.parseDebuggerStatement = function(node2) {
      this.next();
      this.semicolon();
      return this.finishNode(node2, "DebuggerStatement");
    };
    pp$8.parseDoStatement = function(node2) {
      this.next();
      this.labels.push(loopLabel);
      node2.body = this.parseStatement("do");
      this.labels.pop();
      this.expect(types$1._while);
      node2.test = this.parseParenExpression();
      if (this.options.ecmaVersion >= 6) {
        this.eat(types$1.semi);
      } else {
        this.semicolon();
      }
      return this.finishNode(node2, "DoWhileStatement");
    };
    pp$8.parseForStatement = function(node2) {
      this.next();
      var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
      this.labels.push(loopLabel);
      this.enterScope(0);
      this.expect(types$1.parenL);
      if (this.type === types$1.semi) {
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }
        return this.parseFor(node2, null);
      }
      var isLet = this.isLet();
      if (this.type === types$1._var || this.type === types$1._const || isLet) {
        var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
        this.next();
        this.parseVar(init$1, true, kind);
        this.finishNode(init$1, "VariableDeclaration");
        if ((this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init$1.declarations.length === 1) {
          if (this.options.ecmaVersion >= 9) {
            if (this.type === types$1._in) {
              if (awaitAt > -1) {
                this.unexpected(awaitAt);
              }
            } else {
              node2.await = awaitAt > -1;
            }
          }
          return this.parseForIn(node2, init$1);
        }
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }
        return this.parseFor(node2, init$1);
      }
      var startsWithLet = this.isContextual("let"), isForOf = false;
      var refDestructuringErrors = new DestructuringErrors();
      var init2 = this.parseExpression(awaitAt > -1 ? "await" : true, refDestructuringErrors);
      if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
        if (this.options.ecmaVersion >= 9) {
          if (this.type === types$1._in) {
            if (awaitAt > -1) {
              this.unexpected(awaitAt);
            }
          } else {
            node2.await = awaitAt > -1;
          }
        }
        if (startsWithLet && isForOf) {
          this.raise(init2.start, "The left-hand side of a for-of loop may not start with 'let'.");
        }
        this.toAssignable(init2, false, refDestructuringErrors);
        this.checkLValPattern(init2);
        return this.parseForIn(node2, init2);
      } else {
        this.checkExpressionErrors(refDestructuringErrors, true);
      }
      if (awaitAt > -1) {
        this.unexpected(awaitAt);
      }
      return this.parseFor(node2, init2);
    };
    pp$8.parseFunctionStatement = function(node2, isAsync, declarationPosition) {
      this.next();
      return this.parseFunction(node2, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);
    };
    pp$8.parseIfStatement = function(node2) {
      this.next();
      node2.test = this.parseParenExpression();
      node2.consequent = this.parseStatement("if");
      node2.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
      return this.finishNode(node2, "IfStatement");
    };
    pp$8.parseReturnStatement = function(node2) {
      if (!this.inFunction && !this.options.allowReturnOutsideFunction) {
        this.raise(this.start, "'return' outside of function");
      }
      this.next();
      if (this.eat(types$1.semi) || this.insertSemicolon()) {
        node2.argument = null;
      } else {
        node2.argument = this.parseExpression();
        this.semicolon();
      }
      return this.finishNode(node2, "ReturnStatement");
    };
    pp$8.parseSwitchStatement = function(node2) {
      this.next();
      node2.discriminant = this.parseParenExpression();
      node2.cases = [];
      this.expect(types$1.braceL);
      this.labels.push(switchLabel);
      this.enterScope(0);
      var cur;
      for (var sawDefault = false; this.type !== types$1.braceR; ) {
        if (this.type === types$1._case || this.type === types$1._default) {
          var isCase = this.type === types$1._case;
          if (cur) {
            this.finishNode(cur, "SwitchCase");
          }
          node2.cases.push(cur = this.startNode());
          cur.consequent = [];
          this.next();
          if (isCase) {
            cur.test = this.parseExpression();
          } else {
            if (sawDefault) {
              this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
            }
            sawDefault = true;
            cur.test = null;
          }
          this.expect(types$1.colon);
        } else {
          if (!cur) {
            this.unexpected();
          }
          cur.consequent.push(this.parseStatement(null));
        }
      }
      this.exitScope();
      if (cur) {
        this.finishNode(cur, "SwitchCase");
      }
      this.next();
      this.labels.pop();
      return this.finishNode(node2, "SwitchStatement");
    };
    pp$8.parseThrowStatement = function(node2) {
      this.next();
      if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {
        this.raise(this.lastTokEnd, "Illegal newline after throw");
      }
      node2.argument = this.parseExpression();
      this.semicolon();
      return this.finishNode(node2, "ThrowStatement");
    };
    var empty$1 = [];
    pp$8.parseTryStatement = function(node2) {
      this.next();
      node2.block = this.parseBlock();
      node2.handler = null;
      if (this.type === types$1._catch) {
        var clause = this.startNode();
        this.next();
        if (this.eat(types$1.parenL)) {
          clause.param = this.parseBindingAtom();
          var simple = clause.param.type === "Identifier";
          this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
          this.checkLValPattern(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
          this.expect(types$1.parenR);
        } else {
          if (this.options.ecmaVersion < 10) {
            this.unexpected();
          }
          clause.param = null;
          this.enterScope(0);
        }
        clause.body = this.parseBlock(false);
        this.exitScope();
        node2.handler = this.finishNode(clause, "CatchClause");
      }
      node2.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
      if (!node2.handler && !node2.finalizer) {
        this.raise(node2.start, "Missing catch or finally clause");
      }
      return this.finishNode(node2, "TryStatement");
    };
    pp$8.parseVarStatement = function(node2, kind) {
      this.next();
      this.parseVar(node2, false, kind);
      this.semicolon();
      return this.finishNode(node2, "VariableDeclaration");
    };
    pp$8.parseWhileStatement = function(node2) {
      this.next();
      node2.test = this.parseParenExpression();
      this.labels.push(loopLabel);
      node2.body = this.parseStatement("while");
      this.labels.pop();
      return this.finishNode(node2, "WhileStatement");
    };
    pp$8.parseWithStatement = function(node2) {
      if (this.strict) {
        this.raise(this.start, "'with' in strict mode");
      }
      this.next();
      node2.object = this.parseParenExpression();
      node2.body = this.parseStatement("with");
      return this.finishNode(node2, "WithStatement");
    };
    pp$8.parseEmptyStatement = function(node2) {
      this.next();
      return this.finishNode(node2, "EmptyStatement");
    };
    pp$8.parseLabeledStatement = function(node2, maybeName, expr, context2) {
      for (var i$12 = 0, list2 = this.labels; i$12 < list2.length; i$12 += 1) {
        var label = list2[i$12];
        if (label.name === maybeName) {
          this.raise(expr.start, "Label '" + maybeName + "' is already declared");
        }
      }
      var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null;
      for (var i2 = this.labels.length - 1; i2 >= 0; i2--) {
        var label$1 = this.labels[i2];
        if (label$1.statementStart === node2.start) {
          label$1.statementStart = this.start;
          label$1.kind = kind;
        } else {
          break;
        }
      }
      this.labels.push({ name: maybeName, kind, statementStart: this.start });
      node2.body = this.parseStatement(context2 ? context2.indexOf("label") === -1 ? context2 + "label" : context2 : "label");
      this.labels.pop();
      node2.label = expr;
      return this.finishNode(node2, "LabeledStatement");
    };
    pp$8.parseExpressionStatement = function(node2, expr) {
      node2.expression = expr;
      this.semicolon();
      return this.finishNode(node2, "ExpressionStatement");
    };
    pp$8.parseBlock = function(createNewLexicalScope, node2, exitStrict) {
      if (createNewLexicalScope === void 0)
        createNewLexicalScope = true;
      if (node2 === void 0)
        node2 = this.startNode();
      node2.body = [];
      this.expect(types$1.braceL);
      if (createNewLexicalScope) {
        this.enterScope(0);
      }
      while (this.type !== types$1.braceR) {
        var stmt = this.parseStatement(null);
        node2.body.push(stmt);
      }
      if (exitStrict) {
        this.strict = false;
      }
      this.next();
      if (createNewLexicalScope) {
        this.exitScope();
      }
      return this.finishNode(node2, "BlockStatement");
    };
    pp$8.parseFor = function(node2, init2) {
      node2.init = init2;
      this.expect(types$1.semi);
      node2.test = this.type === types$1.semi ? null : this.parseExpression();
      this.expect(types$1.semi);
      node2.update = this.type === types$1.parenR ? null : this.parseExpression();
      this.expect(types$1.parenR);
      node2.body = this.parseStatement("for");
      this.exitScope();
      this.labels.pop();
      return this.finishNode(node2, "ForStatement");
    };
    pp$8.parseForIn = function(node2, init2) {
      var isForIn = this.type === types$1._in;
      this.next();
      if (init2.type === "VariableDeclaration" && init2.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init2.kind !== "var" || init2.declarations[0].id.type !== "Identifier")) {
        this.raise(init2.start, (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer");
      }
      node2.left = init2;
      node2.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
      this.expect(types$1.parenR);
      node2.body = this.parseStatement("for");
      this.exitScope();
      this.labels.pop();
      return this.finishNode(node2, isForIn ? "ForInStatement" : "ForOfStatement");
    };
    pp$8.parseVar = function(node2, isFor, kind) {
      node2.declarations = [];
      node2.kind = kind;
      for (; ; ) {
        var decl = this.startNode();
        this.parseVarId(decl, kind);
        if (this.eat(types$1.eq)) {
          decl.init = this.parseMaybeAssign(isFor);
        } else if (kind === "const" && !(this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
          this.unexpected();
        } else if (decl.id.type !== "Identifier" && !(isFor && (this.type === types$1._in || this.isContextual("of")))) {
          this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
        } else {
          decl.init = null;
        }
        node2.declarations.push(this.finishNode(decl, "VariableDeclarator"));
        if (!this.eat(types$1.comma)) {
          break;
        }
      }
      return node2;
    };
    pp$8.parseVarId = function(decl, kind) {
      decl.id = this.parseBindingAtom();
      this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
    };
    var FUNC_STATEMENT = 1;
    var FUNC_HANGING_STATEMENT = 2;
    var FUNC_NULLABLE_ID = 4;
    pp$8.parseFunction = function(node2, statement, allowExpressionBody, isAsync, forInit) {
      this.initFunction(node2);
      if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
        if (this.type === types$1.star && statement & FUNC_HANGING_STATEMENT) {
          this.unexpected();
        }
        node2.generator = this.eat(types$1.star);
      }
      if (this.options.ecmaVersion >= 8) {
        node2.async = !!isAsync;
      }
      if (statement & FUNC_STATEMENT) {
        node2.id = statement & FUNC_NULLABLE_ID && this.type !== types$1.name ? null : this.parseIdent();
        if (node2.id && !(statement & FUNC_HANGING_STATEMENT)) {
          this.checkLValSimple(node2.id, this.strict || node2.generator || node2.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);
        }
      }
      var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
      this.yieldPos = 0;
      this.awaitPos = 0;
      this.awaitIdentPos = 0;
      this.enterScope(functionFlags(node2.async, node2.generator));
      if (!(statement & FUNC_STATEMENT)) {
        node2.id = this.type === types$1.name ? this.parseIdent() : null;
      }
      this.parseFunctionParams(node2);
      this.parseFunctionBody(node2, allowExpressionBody, false, forInit);
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.finishNode(node2, statement & FUNC_STATEMENT ? "FunctionDeclaration" : "FunctionExpression");
    };
    pp$8.parseFunctionParams = function(node2) {
      this.expect(types$1.parenL);
      node2.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
      this.checkYieldAwaitInDefaultParams();
    };
    pp$8.parseClass = function(node2, isStatement) {
      this.next();
      var oldStrict = this.strict;
      this.strict = true;
      this.parseClassId(node2, isStatement);
      this.parseClassSuper(node2);
      var privateNameMap = this.enterClassBody();
      var classBody = this.startNode();
      var hadConstructor = false;
      classBody.body = [];
      this.expect(types$1.braceL);
      while (this.type !== types$1.braceR) {
        var element = this.parseClassElement(node2.superClass !== null);
        if (element) {
          classBody.body.push(element);
          if (element.type === "MethodDefinition" && element.kind === "constructor") {
            if (hadConstructor) {
              this.raise(element.start, "Duplicate constructor in the same class");
            }
            hadConstructor = true;
          } else if (element.key && element.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element)) {
            this.raiseRecoverable(element.key.start, "Identifier '#" + element.key.name + "' has already been declared");
          }
        }
      }
      this.strict = oldStrict;
      this.next();
      node2.body = this.finishNode(classBody, "ClassBody");
      this.exitClassBody();
      return this.finishNode(node2, isStatement ? "ClassDeclaration" : "ClassExpression");
    };
    pp$8.parseClassElement = function(constructorAllowsSuper) {
      if (this.eat(types$1.semi)) {
        return null;
      }
      var ecmaVersion2 = this.options.ecmaVersion;
      var node2 = this.startNode();
      var keyName = "";
      var isGenerator = false;
      var isAsync = false;
      var kind = "method";
      var isStatic = false;
      if (this.eatContextual("static")) {
        if (ecmaVersion2 >= 13 && this.eat(types$1.braceL)) {
          this.parseClassStaticBlock(node2);
          return node2;
        }
        if (this.isClassElementNameStart() || this.type === types$1.star) {
          isStatic = true;
        } else {
          keyName = "static";
        }
      }
      node2.static = isStatic;
      if (!keyName && ecmaVersion2 >= 8 && this.eatContextual("async")) {
        if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {
          isAsync = true;
        } else {
          keyName = "async";
        }
      }
      if (!keyName && (ecmaVersion2 >= 9 || !isAsync) && this.eat(types$1.star)) {
        isGenerator = true;
      }
      if (!keyName && !isAsync && !isGenerator) {
        var lastValue = this.value;
        if (this.eatContextual("get") || this.eatContextual("set")) {
          if (this.isClassElementNameStart()) {
            kind = lastValue;
          } else {
            keyName = lastValue;
          }
        }
      }
      if (keyName) {
        node2.computed = false;
        node2.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
        node2.key.name = keyName;
        this.finishNode(node2.key, "Identifier");
      } else {
        this.parseClassElementName(node2);
      }
      if (ecmaVersion2 < 13 || this.type === types$1.parenL || kind !== "method" || isGenerator || isAsync) {
        var isConstructor = !node2.static && checkKeyName(node2, "constructor");
        var allowsDirectSuper = isConstructor && constructorAllowsSuper;
        if (isConstructor && kind !== "method") {
          this.raise(node2.key.start, "Constructor can't have get/set modifier");
        }
        node2.kind = isConstructor ? "constructor" : kind;
        this.parseClassMethod(node2, isGenerator, isAsync, allowsDirectSuper);
      } else {
        this.parseClassField(node2);
      }
      return node2;
    };
    pp$8.isClassElementNameStart = function() {
      return this.type === types$1.name || this.type === types$1.privateId || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword;
    };
    pp$8.parseClassElementName = function(element) {
      if (this.type === types$1.privateId) {
        if (this.value === "constructor") {
          this.raise(this.start, "Classes can't have an element named '#constructor'");
        }
        element.computed = false;
        element.key = this.parsePrivateIdent();
      } else {
        this.parsePropertyName(element);
      }
    };
    pp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
      var key2 = method.key;
      if (method.kind === "constructor") {
        if (isGenerator) {
          this.raise(key2.start, "Constructor can't be a generator");
        }
        if (isAsync) {
          this.raise(key2.start, "Constructor can't be an async method");
        }
      } else if (method.static && checkKeyName(method, "prototype")) {
        this.raise(key2.start, "Classes may not have a static property named prototype");
      }
      var value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
      if (method.kind === "get" && value.params.length !== 0) {
        this.raiseRecoverable(value.start, "getter should have no params");
      }
      if (method.kind === "set" && value.params.length !== 1) {
        this.raiseRecoverable(value.start, "setter should have exactly one param");
      }
      if (method.kind === "set" && value.params[0].type === "RestElement") {
        this.raiseRecoverable(value.params[0].start, "Setter cannot use rest params");
      }
      return this.finishNode(method, "MethodDefinition");
    };
    pp$8.parseClassField = function(field) {
      if (checkKeyName(field, "constructor")) {
        this.raise(field.key.start, "Classes can't have a field named 'constructor'");
      } else if (field.static && checkKeyName(field, "prototype")) {
        this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
      }
      if (this.eat(types$1.eq)) {
        var scope = this.currentThisScope();
        var inClassFieldInit = scope.inClassFieldInit;
        scope.inClassFieldInit = true;
        field.value = this.parseMaybeAssign();
        scope.inClassFieldInit = inClassFieldInit;
      } else {
        field.value = null;
      }
      this.semicolon();
      return this.finishNode(field, "PropertyDefinition");
    };
    pp$8.parseClassStaticBlock = function(node2) {
      node2.body = [];
      var oldLabels = this.labels;
      this.labels = [];
      this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
      while (this.type !== types$1.braceR) {
        var stmt = this.parseStatement(null);
        node2.body.push(stmt);
      }
      this.next();
      this.exitScope();
      this.labels = oldLabels;
      return this.finishNode(node2, "StaticBlock");
    };
    pp$8.parseClassId = function(node2, isStatement) {
      if (this.type === types$1.name) {
        node2.id = this.parseIdent();
        if (isStatement) {
          this.checkLValSimple(node2.id, BIND_LEXICAL, false);
        }
      } else {
        if (isStatement === true) {
          this.unexpected();
        }
        node2.id = null;
      }
    };
    pp$8.parseClassSuper = function(node2) {
      node2.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(false) : null;
    };
    pp$8.enterClassBody = function() {
      var element = { declared: /* @__PURE__ */ Object.create(null), used: [] };
      this.privateNameStack.push(element);
      return element.declared;
    };
    pp$8.exitClassBody = function() {
      var ref2 = this.privateNameStack.pop();
      var declared = ref2.declared;
      var used = ref2.used;
      var len = this.privateNameStack.length;
      var parent = len === 0 ? null : this.privateNameStack[len - 1];
      for (var i2 = 0; i2 < used.length; ++i2) {
        var id = used[i2];
        if (!hasOwn(declared, id.name)) {
          if (parent) {
            parent.used.push(id);
          } else {
            this.raiseRecoverable(id.start, "Private field '#" + id.name + "' must be declared in an enclosing class");
          }
        }
      }
    };
    function isPrivateNameConflicted(privateNameMap, element) {
      var name = element.key.name;
      var curr = privateNameMap[name];
      var next = "true";
      if (element.type === "MethodDefinition" && (element.kind === "get" || element.kind === "set")) {
        next = (element.static ? "s" : "i") + element.kind;
      }
      if (curr === "iget" && next === "iset" || curr === "iset" && next === "iget" || curr === "sget" && next === "sset" || curr === "sset" && next === "sget") {
        privateNameMap[name] = "true";
        return false;
      } else if (!curr) {
        privateNameMap[name] = next;
        return false;
      } else {
        return true;
      }
    }
    function checkKeyName(node2, name) {
      var computed = node2.computed;
      var key2 = node2.key;
      return !computed && (key2.type === "Identifier" && key2.name === name || key2.type === "Literal" && key2.value === name);
    }
    pp$8.parseExport = function(node2, exports2) {
      this.next();
      if (this.eat(types$1.star)) {
        if (this.options.ecmaVersion >= 11) {
          if (this.eatContextual("as")) {
            node2.exported = this.parseModuleExportName();
            this.checkExport(exports2, node2.exported.name, this.lastTokStart);
          } else {
            node2.exported = null;
          }
        }
        this.expectContextual("from");
        if (this.type !== types$1.string) {
          this.unexpected();
        }
        node2.source = this.parseExprAtom();
        this.semicolon();
        return this.finishNode(node2, "ExportAllDeclaration");
      }
      if (this.eat(types$1._default)) {
        this.checkExport(exports2, "default", this.lastTokStart);
        var isAsync;
        if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
          var fNode = this.startNode();
          this.next();
          if (isAsync) {
            this.next();
          }
          node2.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
        } else if (this.type === types$1._class) {
          var cNode = this.startNode();
          node2.declaration = this.parseClass(cNode, "nullableID");
        } else {
          node2.declaration = this.parseMaybeAssign();
          this.semicolon();
        }
        return this.finishNode(node2, "ExportDefaultDeclaration");
      }
      if (this.shouldParseExportStatement()) {
        node2.declaration = this.parseStatement(null);
        if (node2.declaration.type === "VariableDeclaration") {
          this.checkVariableExport(exports2, node2.declaration.declarations);
        } else {
          this.checkExport(exports2, node2.declaration.id.name, node2.declaration.id.start);
        }
        node2.specifiers = [];
        node2.source = null;
      } else {
        node2.declaration = null;
        node2.specifiers = this.parseExportSpecifiers(exports2);
        if (this.eatContextual("from")) {
          if (this.type !== types$1.string) {
            this.unexpected();
          }
          node2.source = this.parseExprAtom();
        } else {
          for (var i2 = 0, list2 = node2.specifiers; i2 < list2.length; i2 += 1) {
            var spec = list2[i2];
            this.checkUnreserved(spec.local);
            this.checkLocalExport(spec.local);
            if (spec.local.type === "Literal") {
              this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
            }
          }
          node2.source = null;
        }
        this.semicolon();
      }
      return this.finishNode(node2, "ExportNamedDeclaration");
    };
    pp$8.checkExport = function(exports2, name, pos2) {
      if (!exports2) {
        return;
      }
      if (hasOwn(exports2, name)) {
        this.raiseRecoverable(pos2, "Duplicate export '" + name + "'");
      }
      exports2[name] = true;
    };
    pp$8.checkPatternExport = function(exports2, pat) {
      var type = pat.type;
      if (type === "Identifier") {
        this.checkExport(exports2, pat.name, pat.start);
      } else if (type === "ObjectPattern") {
        for (var i2 = 0, list2 = pat.properties; i2 < list2.length; i2 += 1) {
          var prop = list2[i2];
          this.checkPatternExport(exports2, prop);
        }
      } else if (type === "ArrayPattern") {
        for (var i$12 = 0, list$1 = pat.elements; i$12 < list$1.length; i$12 += 1) {
          var elt = list$1[i$12];
          if (elt) {
            this.checkPatternExport(exports2, elt);
          }
        }
      } else if (type === "Property") {
        this.checkPatternExport(exports2, pat.value);
      } else if (type === "AssignmentPattern") {
        this.checkPatternExport(exports2, pat.left);
      } else if (type === "RestElement") {
        this.checkPatternExport(exports2, pat.argument);
      } else if (type === "ParenthesizedExpression") {
        this.checkPatternExport(exports2, pat.expression);
      }
    };
    pp$8.checkVariableExport = function(exports2, decls) {
      if (!exports2) {
        return;
      }
      for (var i2 = 0, list2 = decls; i2 < list2.length; i2 += 1) {
        var decl = list2[i2];
        this.checkPatternExport(exports2, decl.id);
      }
    };
    pp$8.shouldParseExportStatement = function() {
      return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
    };
    pp$8.parseExportSpecifiers = function(exports2) {
      var nodes = [], first2 = true;
      this.expect(types$1.braceL);
      while (!this.eat(types$1.braceR)) {
        if (!first2) {
          this.expect(types$1.comma);
          if (this.afterTrailingComma(types$1.braceR)) {
            break;
          }
        } else {
          first2 = false;
        }
        var node2 = this.startNode();
        node2.local = this.parseModuleExportName();
        node2.exported = this.eatContextual("as") ? this.parseModuleExportName() : node2.local;
        this.checkExport(exports2, node2.exported[node2.exported.type === "Identifier" ? "name" : "value"], node2.exported.start);
        nodes.push(this.finishNode(node2, "ExportSpecifier"));
      }
      return nodes;
    };
    pp$8.parseImport = function(node2) {
      this.next();
      if (this.type === types$1.string) {
        node2.specifiers = empty$1;
        node2.source = this.parseExprAtom();
      } else {
        node2.specifiers = this.parseImportSpecifiers();
        this.expectContextual("from");
        node2.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();
      }
      this.semicolon();
      return this.finishNode(node2, "ImportDeclaration");
    };
    pp$8.parseImportSpecifiers = function() {
      var nodes = [], first2 = true;
      if (this.type === types$1.name) {
        var node2 = this.startNode();
        node2.local = this.parseIdent();
        this.checkLValSimple(node2.local, BIND_LEXICAL);
        nodes.push(this.finishNode(node2, "ImportDefaultSpecifier"));
        if (!this.eat(types$1.comma)) {
          return nodes;
        }
      }
      if (this.type === types$1.star) {
        var node$12 = this.startNode();
        this.next();
        this.expectContextual("as");
        node$12.local = this.parseIdent();
        this.checkLValSimple(node$12.local, BIND_LEXICAL);
        nodes.push(this.finishNode(node$12, "ImportNamespaceSpecifier"));
        return nodes;
      }
      this.expect(types$1.braceL);
      while (!this.eat(types$1.braceR)) {
        if (!first2) {
          this.expect(types$1.comma);
          if (this.afterTrailingComma(types$1.braceR)) {
            break;
          }
        } else {
          first2 = false;
        }
        var node$2 = this.startNode();
        node$2.imported = this.parseModuleExportName();
        if (this.eatContextual("as")) {
          node$2.local = this.parseIdent();
        } else {
          this.checkUnreserved(node$2.imported);
          node$2.local = node$2.imported;
        }
        this.checkLValSimple(node$2.local, BIND_LEXICAL);
        nodes.push(this.finishNode(node$2, "ImportSpecifier"));
      }
      return nodes;
    };
    pp$8.parseModuleExportName = function() {
      if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
        var stringLiteral = this.parseLiteral(this.value);
        if (loneSurrogate.test(stringLiteral.value)) {
          this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
        }
        return stringLiteral;
      }
      return this.parseIdent(true);
    };
    pp$8.adaptDirectivePrologue = function(statements) {
      for (var i2 = 0; i2 < statements.length && this.isDirectiveCandidate(statements[i2]); ++i2) {
        statements[i2].directive = statements[i2].expression.raw.slice(1, -1);
      }
    };
    pp$8.isDirectiveCandidate = function(statement) {
      return statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && (this.input[statement.start] === '"' || this.input[statement.start] === "'");
    };
    var pp$7 = Parser.prototype;
    pp$7.toAssignable = function(node2, isBinding, refDestructuringErrors) {
      if (this.options.ecmaVersion >= 6 && node2) {
        switch (node2.type) {
          case "Identifier":
            if (this.inAsync && node2.name === "await") {
              this.raise(node2.start, "Cannot use 'await' as identifier inside an async function");
            }
            break;
          case "ObjectPattern":
          case "ArrayPattern":
          case "AssignmentPattern":
          case "RestElement":
            break;
          case "ObjectExpression":
            node2.type = "ObjectPattern";
            if (refDestructuringErrors) {
              this.checkPatternErrors(refDestructuringErrors, true);
            }
            for (var i2 = 0, list2 = node2.properties; i2 < list2.length; i2 += 1) {
              var prop = list2[i2];
              this.toAssignable(prop, isBinding);
              if (prop.type === "RestElement" && (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")) {
                this.raise(prop.argument.start, "Unexpected token");
              }
            }
            break;
          case "Property":
            if (node2.kind !== "init") {
              this.raise(node2.key.start, "Object pattern can't contain getter or setter");
            }
            this.toAssignable(node2.value, isBinding);
            break;
          case "ArrayExpression":
            node2.type = "ArrayPattern";
            if (refDestructuringErrors) {
              this.checkPatternErrors(refDestructuringErrors, true);
            }
            this.toAssignableList(node2.elements, isBinding);
            break;
          case "SpreadElement":
            node2.type = "RestElement";
            this.toAssignable(node2.argument, isBinding);
            if (node2.argument.type === "AssignmentPattern") {
              this.raise(node2.argument.start, "Rest elements cannot have a default value");
            }
            break;
          case "AssignmentExpression":
            if (node2.operator !== "=") {
              this.raise(node2.left.end, "Only '=' operator can be used for specifying default value.");
            }
            node2.type = "AssignmentPattern";
            delete node2.operator;
            this.toAssignable(node2.left, isBinding);
            break;
          case "ParenthesizedExpression":
            this.toAssignable(node2.expression, isBinding, refDestructuringErrors);
            break;
          case "ChainExpression":
            this.raiseRecoverable(node2.start, "Optional chaining cannot appear in left-hand side");
            break;
          case "MemberExpression":
            if (!isBinding) {
              break;
            }
          default:
            this.raise(node2.start, "Assigning to rvalue");
        }
      } else if (refDestructuringErrors) {
        this.checkPatternErrors(refDestructuringErrors, true);
      }
      return node2;
    };
    pp$7.toAssignableList = function(exprList, isBinding) {
      var end = exprList.length;
      for (var i2 = 0; i2 < end; i2++) {
        var elt = exprList[i2];
        if (elt) {
          this.toAssignable(elt, isBinding);
        }
      }
      if (end) {
        var last = exprList[end - 1];
        if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") {
          this.unexpected(last.argument.start);
        }
      }
      return exprList;
    };
    pp$7.parseSpread = function(refDestructuringErrors) {
      var node2 = this.startNode();
      this.next();
      node2.argument = this.parseMaybeAssign(false, refDestructuringErrors);
      return this.finishNode(node2, "SpreadElement");
    };
    pp$7.parseRestBinding = function() {
      var node2 = this.startNode();
      this.next();
      if (this.options.ecmaVersion === 6 && this.type !== types$1.name) {
        this.unexpected();
      }
      node2.argument = this.parseBindingAtom();
      return this.finishNode(node2, "RestElement");
    };
    pp$7.parseBindingAtom = function() {
      if (this.options.ecmaVersion >= 6) {
        switch (this.type) {
          case types$1.bracketL:
            var node2 = this.startNode();
            this.next();
            node2.elements = this.parseBindingList(types$1.bracketR, true, true);
            return this.finishNode(node2, "ArrayPattern");
          case types$1.braceL:
            return this.parseObj(true);
        }
      }
      return this.parseIdent();
    };
    pp$7.parseBindingList = function(close2, allowEmpty, allowTrailingComma) {
      var elts = [], first2 = true;
      while (!this.eat(close2)) {
        if (first2) {
          first2 = false;
        } else {
          this.expect(types$1.comma);
        }
        if (allowEmpty && this.type === types$1.comma) {
          elts.push(null);
        } else if (allowTrailingComma && this.afterTrailingComma(close2)) {
          break;
        } else if (this.type === types$1.ellipsis) {
          var rest = this.parseRestBinding();
          this.parseBindingListItem(rest);
          elts.push(rest);
          if (this.type === types$1.comma) {
            this.raise(this.start, "Comma is not permitted after the rest element");
          }
          this.expect(close2);
          break;
        } else {
          var elem = this.parseMaybeDefault(this.start, this.startLoc);
          this.parseBindingListItem(elem);
          elts.push(elem);
        }
      }
      return elts;
    };
    pp$7.parseBindingListItem = function(param) {
      return param;
    };
    pp$7.parseMaybeDefault = function(startPos, startLoc, left) {
      left = left || this.parseBindingAtom();
      if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) {
        return left;
      }
      var node2 = this.startNodeAt(startPos, startLoc);
      node2.left = left;
      node2.right = this.parseMaybeAssign();
      return this.finishNode(node2, "AssignmentPattern");
    };
    pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
      if (bindingType === void 0)
        bindingType = BIND_NONE;
      var isBind = bindingType !== BIND_NONE;
      switch (expr.type) {
        case "Identifier":
          if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {
            this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
          }
          if (isBind) {
            if (bindingType === BIND_LEXICAL && expr.name === "let") {
              this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
            }
            if (checkClashes) {
              if (hasOwn(checkClashes, expr.name)) {
                this.raiseRecoverable(expr.start, "Argument name clash");
              }
              checkClashes[expr.name] = true;
            }
            if (bindingType !== BIND_OUTSIDE) {
              this.declareName(expr.name, bindingType, expr.start);
            }
          }
          break;
        case "ChainExpression":
          this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
          break;
        case "MemberExpression":
          if (isBind) {
            this.raiseRecoverable(expr.start, "Binding member expression");
          }
          break;
        case "ParenthesizedExpression":
          if (isBind) {
            this.raiseRecoverable(expr.start, "Binding parenthesized expression");
          }
          return this.checkLValSimple(expr.expression, bindingType, checkClashes);
        default:
          this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
      }
    };
    pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
      if (bindingType === void 0)
        bindingType = BIND_NONE;
      switch (expr.type) {
        case "ObjectPattern":
          for (var i2 = 0, list2 = expr.properties; i2 < list2.length; i2 += 1) {
            var prop = list2[i2];
            this.checkLValInnerPattern(prop, bindingType, checkClashes);
          }
          break;
        case "ArrayPattern":
          for (var i$12 = 0, list$1 = expr.elements; i$12 < list$1.length; i$12 += 1) {
            var elem = list$1[i$12];
            if (elem) {
              this.checkLValInnerPattern(elem, bindingType, checkClashes);
            }
          }
          break;
        default:
          this.checkLValSimple(expr, bindingType, checkClashes);
      }
    };
    pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
      if (bindingType === void 0)
        bindingType = BIND_NONE;
      switch (expr.type) {
        case "Property":
          this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
          break;
        case "AssignmentPattern":
          this.checkLValPattern(expr.left, bindingType, checkClashes);
          break;
        case "RestElement":
          this.checkLValPattern(expr.argument, bindingType, checkClashes);
          break;
        default:
          this.checkLValPattern(expr, bindingType, checkClashes);
      }
    };
    var TokContext = function TokContext2(token2, isExpr, preserveSpace, override, generator) {
      this.token = token2;
      this.isExpr = !!isExpr;
      this.preserveSpace = !!preserveSpace;
      this.override = override;
      this.generator = !!generator;
    };
    var types = {
      b_stat: new TokContext("{", false),
      b_expr: new TokContext("{", true),
      b_tmpl: new TokContext("${", false),
      p_stat: new TokContext("(", false),
      p_expr: new TokContext("(", true),
      q_tmpl: new TokContext("`", true, true, function(p2) {
        return p2.tryReadTemplateToken();
      }),
      f_stat: new TokContext("function", false),
      f_expr: new TokContext("function", true),
      f_expr_gen: new TokContext("function", true, false, null, true),
      f_gen: new TokContext("function", false, false, null, true)
    };
    var pp$6 = Parser.prototype;
    pp$6.initialContext = function() {
      return [types.b_stat];
    };
    pp$6.curContext = function() {
      return this.context[this.context.length - 1];
    };
    pp$6.braceIsBlock = function(prevType) {
      var parent = this.curContext();
      if (parent === types.f_expr || parent === types.f_stat) {
        return true;
      }
      if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr)) {
        return !parent.isExpr;
      }
      if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed) {
        return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
      }
      if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow) {
        return true;
      }
      if (prevType === types$1.braceL) {
        return parent === types.b_stat;
      }
      if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name) {
        return false;
      }
      return !this.exprAllowed;
    };
    pp$6.inGeneratorContext = function() {
      for (var i2 = this.context.length - 1; i2 >= 1; i2--) {
        var context2 = this.context[i2];
        if (context2.token === "function") {
          return context2.generator;
        }
      }
      return false;
    };
    pp$6.updateContext = function(prevType) {
      var update, type = this.type;
      if (type.keyword && prevType === types$1.dot) {
        this.exprAllowed = false;
      } else if (update = type.updateContext) {
        update.call(this, prevType);
      } else {
        this.exprAllowed = type.beforeExpr;
      }
    };
    pp$6.overrideContext = function(tokenCtx) {
      if (this.curContext() !== tokenCtx) {
        this.context[this.context.length - 1] = tokenCtx;
      }
    };
    types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
      if (this.context.length === 1) {
        this.exprAllowed = true;
        return;
      }
      var out2 = this.context.pop();
      if (out2 === types.b_stat && this.curContext().token === "function") {
        out2 = this.context.pop();
      }
      this.exprAllowed = !out2.isExpr;
    };
    types$1.braceL.updateContext = function(prevType) {
      this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
      this.exprAllowed = true;
    };
    types$1.dollarBraceL.updateContext = function() {
      this.context.push(types.b_tmpl);
      this.exprAllowed = true;
    };
    types$1.parenL.updateContext = function(prevType) {
      var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
      this.context.push(statementParens ? types.p_stat : types.p_expr);
      this.exprAllowed = true;
    };
    types$1.incDec.updateContext = function() {
    };
    types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
      if (prevType.beforeExpr && prevType !== types$1._else && !(prevType === types$1.semi && this.curContext() !== types.p_stat) && !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat)) {
        this.context.push(types.f_expr);
      } else {
        this.context.push(types.f_stat);
      }
      this.exprAllowed = false;
    };
    types$1.backQuote.updateContext = function() {
      if (this.curContext() === types.q_tmpl) {
        this.context.pop();
      } else {
        this.context.push(types.q_tmpl);
      }
      this.exprAllowed = false;
    };
    types$1.star.updateContext = function(prevType) {
      if (prevType === types$1._function) {
        var index2 = this.context.length - 1;
        if (this.context[index2] === types.f_expr) {
          this.context[index2] = types.f_expr_gen;
        } else {
          this.context[index2] = types.f_gen;
        }
      }
      this.exprAllowed = true;
    };
    types$1.name.updateContext = function(prevType) {
      var allowed = false;
      if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {
        if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) {
          allowed = true;
        }
      }
      this.exprAllowed = allowed;
    };
    var pp$5 = Parser.prototype;
    pp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {
      if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement") {
        return;
      }
      if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {
        return;
      }
      var key2 = prop.key;
      var name;
      switch (key2.type) {
        case "Identifier":
          name = key2.name;
          break;
        case "Literal":
          name = String(key2.value);
          break;
        default:
          return;
      }
      var kind = prop.kind;
      if (this.options.ecmaVersion >= 6) {
        if (name === "__proto__" && kind === "init") {
          if (propHash.proto) {
            if (refDestructuringErrors) {
              if (refDestructuringErrors.doubleProto < 0) {
                refDestructuringErrors.doubleProto = key2.start;
              }
            } else {
              this.raiseRecoverable(key2.start, "Redefinition of __proto__ property");
            }
          }
          propHash.proto = true;
        }
        return;
      }
      name = "$" + name;
      var other = propHash[name];
      if (other) {
        var redefinition;
        if (kind === "init") {
          redefinition = this.strict && other.init || other.get || other.set;
        } else {
          redefinition = other.init || other[kind];
        }
        if (redefinition) {
          this.raiseRecoverable(key2.start, "Redefinition of property");
        }
      } else {
        other = propHash[name] = {
          init: false,
          get: false,
          set: false
        };
      }
      other[kind] = true;
    };
    pp$5.parseExpression = function(forInit, refDestructuringErrors) {
      var startPos = this.start, startLoc = this.startLoc;
      var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
      if (this.type === types$1.comma) {
        var node2 = this.startNodeAt(startPos, startLoc);
        node2.expressions = [expr];
        while (this.eat(types$1.comma)) {
          node2.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));
        }
        return this.finishNode(node2, "SequenceExpression");
      }
      return expr;
    };
    pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
      if (this.isContextual("yield")) {
        if (this.inGenerator) {
          return this.parseYield(forInit);
        } else {
          this.exprAllowed = false;
        }
      }
      var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
      if (refDestructuringErrors) {
        oldParenAssign = refDestructuringErrors.parenthesizedAssign;
        oldTrailingComma = refDestructuringErrors.trailingComma;
        oldDoubleProto = refDestructuringErrors.doubleProto;
        refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
      } else {
        refDestructuringErrors = new DestructuringErrors();
        ownDestructuringErrors = true;
      }
      var startPos = this.start, startLoc = this.startLoc;
      if (this.type === types$1.parenL || this.type === types$1.name) {
        this.potentialArrowAt = this.start;
        this.potentialArrowInForAwait = forInit === "await";
      }
      var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
      if (afterLeftParse) {
        left = afterLeftParse.call(this, left, startPos, startLoc);
      }
      if (this.type.isAssign) {
        var node2 = this.startNodeAt(startPos, startLoc);
        node2.operator = this.value;
        if (this.type === types$1.eq) {
          left = this.toAssignable(left, false, refDestructuringErrors);
        }
        if (!ownDestructuringErrors) {
          refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
        }
        if (refDestructuringErrors.shorthandAssign >= left.start) {
          refDestructuringErrors.shorthandAssign = -1;
        }
        if (this.type === types$1.eq) {
          this.checkLValPattern(left);
        } else {
          this.checkLValSimple(left);
        }
        node2.left = left;
        this.next();
        node2.right = this.parseMaybeAssign(forInit);
        if (oldDoubleProto > -1) {
          refDestructuringErrors.doubleProto = oldDoubleProto;
        }
        return this.finishNode(node2, "AssignmentExpression");
      } else {
        if (ownDestructuringErrors) {
          this.checkExpressionErrors(refDestructuringErrors, true);
        }
      }
      if (oldParenAssign > -1) {
        refDestructuringErrors.parenthesizedAssign = oldParenAssign;
      }
      if (oldTrailingComma > -1) {
        refDestructuringErrors.trailingComma = oldTrailingComma;
      }
      return left;
    };
    pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
      var startPos = this.start, startLoc = this.startLoc;
      var expr = this.parseExprOps(forInit, refDestructuringErrors);
      if (this.checkExpressionErrors(refDestructuringErrors)) {
        return expr;
      }
      if (this.eat(types$1.question)) {
        var node2 = this.startNodeAt(startPos, startLoc);
        node2.test = expr;
        node2.consequent = this.parseMaybeAssign();
        this.expect(types$1.colon);
        node2.alternate = this.parseMaybeAssign(forInit);
        return this.finishNode(node2, "ConditionalExpression");
      }
      return expr;
    };
    pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
      var startPos = this.start, startLoc = this.startLoc;
      var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
      if (this.checkExpressionErrors(refDestructuringErrors)) {
        return expr;
      }
      return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);
    };
    pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
      var prec = this.type.binop;
      if (prec != null && (!forInit || this.type !== types$1._in)) {
        if (prec > minPrec) {
          var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;
          var coalesce = this.type === types$1.coalesce;
          if (coalesce) {
            prec = types$1.logicalAND.binop;
          }
          var op = this.value;
          this.next();
          var startPos = this.start, startLoc = this.startLoc;
          var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
          var node2 = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
          if (logical && this.type === types$1.coalesce || coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND)) {
            this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
          }
          return this.parseExprOp(node2, leftStartPos, leftStartLoc, minPrec, forInit);
        }
      }
      return left;
    };
    pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {
      if (right.type === "PrivateIdentifier") {
        this.raise(right.start, "Private identifier can only be left side of binary expression");
      }
      var node2 = this.startNodeAt(startPos, startLoc);
      node2.left = left;
      node2.operator = op;
      node2.right = right;
      return this.finishNode(node2, logical ? "LogicalExpression" : "BinaryExpression");
    };
    pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
      var startPos = this.start, startLoc = this.startLoc, expr;
      if (this.isContextual("await") && this.canAwait) {
        expr = this.parseAwait(forInit);
        sawUnary = true;
      } else if (this.type.prefix) {
        var node2 = this.startNode(), update = this.type === types$1.incDec;
        node2.operator = this.value;
        node2.prefix = true;
        this.next();
        node2.argument = this.parseMaybeUnary(null, true, update, forInit);
        this.checkExpressionErrors(refDestructuringErrors, true);
        if (update) {
          this.checkLValSimple(node2.argument);
        } else if (this.strict && node2.operator === "delete" && node2.argument.type === "Identifier") {
          this.raiseRecoverable(node2.start, "Deleting local variable in strict mode");
        } else if (node2.operator === "delete" && isPrivateFieldAccess(node2.argument)) {
          this.raiseRecoverable(node2.start, "Private fields can not be deleted");
        } else {
          sawUnary = true;
        }
        expr = this.finishNode(node2, update ? "UpdateExpression" : "UnaryExpression");
      } else if (!sawUnary && this.type === types$1.privateId) {
        if (forInit || this.privateNameStack.length === 0) {
          this.unexpected();
        }
        expr = this.parsePrivateIdent();
        if (this.type !== types$1._in) {
          this.unexpected();
        }
      } else {
        expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
        if (this.checkExpressionErrors(refDestructuringErrors)) {
          return expr;
        }
        while (this.type.postfix && !this.canInsertSemicolon()) {
          var node$12 = this.startNodeAt(startPos, startLoc);
          node$12.operator = this.value;
          node$12.prefix = false;
          node$12.argument = expr;
          this.checkLValSimple(expr);
          this.next();
          expr = this.finishNode(node$12, "UpdateExpression");
        }
      }
      if (!incDec && this.eat(types$1.starstar)) {
        if (sawUnary) {
          this.unexpected(this.lastTokStart);
        } else {
          return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false);
        }
      } else {
        return expr;
      }
    };
    function isPrivateFieldAccess(node2) {
      return node2.type === "MemberExpression" && node2.property.type === "PrivateIdentifier" || node2.type === "ChainExpression" && isPrivateFieldAccess(node2.expression);
    }
    pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
      var startPos = this.start, startLoc = this.startLoc;
      var expr = this.parseExprAtom(refDestructuringErrors, forInit);
      if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") {
        return expr;
      }
      var result2 = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
      if (refDestructuringErrors && result2.type === "MemberExpression") {
        if (refDestructuringErrors.parenthesizedAssign >= result2.start) {
          refDestructuringErrors.parenthesizedAssign = -1;
        }
        if (refDestructuringErrors.parenthesizedBind >= result2.start) {
          refDestructuringErrors.parenthesizedBind = -1;
        }
        if (refDestructuringErrors.trailingComma >= result2.start) {
          refDestructuringErrors.trailingComma = -1;
        }
      }
      return result2;
    };
    pp$5.parseSubscripts = function(base2, startPos, startLoc, noCalls, forInit) {
      var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base2.type === "Identifier" && base2.name === "async" && this.lastTokEnd === base2.end && !this.canInsertSemicolon() && base2.end - base2.start === 5 && this.potentialArrowAt === base2.start;
      var optionalChained = false;
      while (true) {
        var element = this.parseSubscript(base2, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);
        if (element.optional) {
          optionalChained = true;
        }
        if (element === base2 || element.type === "ArrowFunctionExpression") {
          if (optionalChained) {
            var chainNode = this.startNodeAt(startPos, startLoc);
            chainNode.expression = element;
            element = this.finishNode(chainNode, "ChainExpression");
          }
          return element;
        }
        base2 = element;
      }
    };
    pp$5.parseSubscript = function(base2, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
      var optionalSupported = this.options.ecmaVersion >= 11;
      var optional = optionalSupported && this.eat(types$1.questionDot);
      if (noCalls && optional) {
        this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
      }
      var computed = this.eat(types$1.bracketL);
      if (computed || optional && this.type !== types$1.parenL && this.type !== types$1.backQuote || this.eat(types$1.dot)) {
        var node2 = this.startNodeAt(startPos, startLoc);
        node2.object = base2;
        if (computed) {
          node2.property = this.parseExpression();
          this.expect(types$1.bracketR);
        } else if (this.type === types$1.privateId && base2.type !== "Super") {
          node2.property = this.parsePrivateIdent();
        } else {
          node2.property = this.parseIdent(this.options.allowReserved !== "never");
        }
        node2.computed = !!computed;
        if (optionalSupported) {
          node2.optional = optional;
        }
        base2 = this.finishNode(node2, "MemberExpression");
      } else if (!noCalls && this.eat(types$1.parenL)) {
        var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
        if (maybeAsyncArrow && !optional && !this.canInsertSemicolon() && this.eat(types$1.arrow)) {
          this.checkPatternErrors(refDestructuringErrors, false);
          this.checkYieldAwaitInDefaultParams();
          if (this.awaitIdentPos > 0) {
            this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
          }
          this.yieldPos = oldYieldPos;
          this.awaitPos = oldAwaitPos;
          this.awaitIdentPos = oldAwaitIdentPos;
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);
        }
        this.checkExpressionErrors(refDestructuringErrors, true);
        this.yieldPos = oldYieldPos || this.yieldPos;
        this.awaitPos = oldAwaitPos || this.awaitPos;
        this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
        var node$12 = this.startNodeAt(startPos, startLoc);
        node$12.callee = base2;
        node$12.arguments = exprList;
        if (optionalSupported) {
          node$12.optional = optional;
        }
        base2 = this.finishNode(node$12, "CallExpression");
      } else if (this.type === types$1.backQuote) {
        if (optional || optionalChained) {
          this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
        }
        var node$2 = this.startNodeAt(startPos, startLoc);
        node$2.tag = base2;
        node$2.quasi = this.parseTemplate({ isTagged: true });
        base2 = this.finishNode(node$2, "TaggedTemplateExpression");
      }
      return base2;
    };
    pp$5.parseExprAtom = function(refDestructuringErrors, forInit) {
      if (this.type === types$1.slash) {
        this.readRegexp();
      }
      var node2, canBeArrow = this.potentialArrowAt === this.start;
      switch (this.type) {
        case types$1._super:
          if (!this.allowSuper) {
            this.raise(this.start, "'super' keyword outside a method");
          }
          node2 = this.startNode();
          this.next();
          if (this.type === types$1.parenL && !this.allowDirectSuper) {
            this.raise(node2.start, "super() call outside constructor of a subclass");
          }
          if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL) {
            this.unexpected();
          }
          return this.finishNode(node2, "Super");
        case types$1._this:
          node2 = this.startNode();
          this.next();
          return this.finishNode(node2, "ThisExpression");
        case types$1.name:
          var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
          var id = this.parseIdent(false);
          if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function)) {
            this.overrideContext(types.f_expr);
            return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);
          }
          if (canBeArrow && !this.canInsertSemicolon()) {
            if (this.eat(types$1.arrow)) {
              return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit);
            }
            if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types$1.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
              id = this.parseIdent(false);
              if (this.canInsertSemicolon() || !this.eat(types$1.arrow)) {
                this.unexpected();
              }
              return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit);
            }
          }
          return id;
        case types$1.regexp:
          var value = this.value;
          node2 = this.parseLiteral(value.value);
          node2.regex = { pattern: value.pattern, flags: value.flags };
          return node2;
        case types$1.num:
        case types$1.string:
          return this.parseLiteral(this.value);
        case types$1._null:
        case types$1._true:
        case types$1._false:
          node2 = this.startNode();
          node2.value = this.type === types$1._null ? null : this.type === types$1._true;
          node2.raw = this.type.keyword;
          this.next();
          return this.finishNode(node2, "Literal");
        case types$1.parenL:
          var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
          if (refDestructuringErrors) {
            if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {
              refDestructuringErrors.parenthesizedAssign = start;
            }
            if (refDestructuringErrors.parenthesizedBind < 0) {
              refDestructuringErrors.parenthesizedBind = start;
            }
          }
          return expr;
        case types$1.bracketL:
          node2 = this.startNode();
          this.next();
          node2.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);
          return this.finishNode(node2, "ArrayExpression");
        case types$1.braceL:
          this.overrideContext(types.b_expr);
          return this.parseObj(false, refDestructuringErrors);
        case types$1._function:
          node2 = this.startNode();
          this.next();
          return this.parseFunction(node2, 0);
        case types$1._class:
          return this.parseClass(this.startNode(), false);
        case types$1._new:
          return this.parseNew();
        case types$1.backQuote:
          return this.parseTemplate();
        case types$1._import:
          if (this.options.ecmaVersion >= 11) {
            return this.parseExprImport();
          } else {
            return this.unexpected();
          }
        default:
          this.unexpected();
      }
    };
    pp$5.parseExprImport = function() {
      var node2 = this.startNode();
      if (this.containsEsc) {
        this.raiseRecoverable(this.start, "Escape sequence in keyword import");
      }
      var meta = this.parseIdent(true);
      switch (this.type) {
        case types$1.parenL:
          return this.parseDynamicImport(node2);
        case types$1.dot:
          node2.meta = meta;
          return this.parseImportMeta(node2);
        default:
          this.unexpected();
      }
    };
    pp$5.parseDynamicImport = function(node2) {
      this.next();
      node2.source = this.parseMaybeAssign();
      if (!this.eat(types$1.parenR)) {
        var errorPos = this.start;
        if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {
          this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
        } else {
          this.unexpected(errorPos);
        }
      }
      return this.finishNode(node2, "ImportExpression");
    };
    pp$5.parseImportMeta = function(node2) {
      this.next();
      var containsEsc = this.containsEsc;
      node2.property = this.parseIdent(true);
      if (node2.property.name !== "meta") {
        this.raiseRecoverable(node2.property.start, "The only valid meta property for import is 'import.meta'");
      }
      if (containsEsc) {
        this.raiseRecoverable(node2.start, "'import.meta' must not contain escaped characters");
      }
      if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere) {
        this.raiseRecoverable(node2.start, "Cannot use 'import.meta' outside a module");
      }
      return this.finishNode(node2, "MetaProperty");
    };
    pp$5.parseLiteral = function(value) {
      var node2 = this.startNode();
      node2.value = value;
      node2.raw = this.input.slice(this.start, this.end);
      if (node2.raw.charCodeAt(node2.raw.length - 1) === 110) {
        node2.bigint = node2.raw.slice(0, -1).replace(/_/g, "");
      }
      this.next();
      return this.finishNode(node2, "Literal");
    };
    pp$5.parseParenExpression = function() {
      this.expect(types$1.parenL);
      var val = this.parseExpression();
      this.expect(types$1.parenR);
      return val;
    };
    pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
      var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
      if (this.options.ecmaVersion >= 6) {
        this.next();
        var innerStartPos = this.start, innerStartLoc = this.startLoc;
        var exprList = [], first2 = true, lastIsComma = false;
        var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
        this.yieldPos = 0;
        this.awaitPos = 0;
        while (this.type !== types$1.parenR) {
          first2 ? first2 = false : this.expect(types$1.comma);
          if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
            lastIsComma = true;
            break;
          } else if (this.type === types$1.ellipsis) {
            spreadStart = this.start;
            exprList.push(this.parseParenItem(this.parseRestBinding()));
            if (this.type === types$1.comma) {
              this.raise(this.start, "Comma is not permitted after the rest element");
            }
            break;
          } else {
            exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
          }
        }
        var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
        this.expect(types$1.parenR);
        if (canBeArrow && !this.canInsertSemicolon() && this.eat(types$1.arrow)) {
          this.checkPatternErrors(refDestructuringErrors, false);
          this.checkYieldAwaitInDefaultParams();
          this.yieldPos = oldYieldPos;
          this.awaitPos = oldAwaitPos;
          return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
        }
        if (!exprList.length || lastIsComma) {
          this.unexpected(this.lastTokStart);
        }
        if (spreadStart) {
          this.unexpected(spreadStart);
        }
        this.checkExpressionErrors(refDestructuringErrors, true);
        this.yieldPos = oldYieldPos || this.yieldPos;
        this.awaitPos = oldAwaitPos || this.awaitPos;
        if (exprList.length > 1) {
          val = this.startNodeAt(innerStartPos, innerStartLoc);
          val.expressions = exprList;
          this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
        } else {
          val = exprList[0];
        }
      } else {
        val = this.parseParenExpression();
      }
      if (this.options.preserveParens) {
        var par = this.startNodeAt(startPos, startLoc);
        par.expression = val;
        return this.finishNode(par, "ParenthesizedExpression");
      } else {
        return val;
      }
    };
    pp$5.parseParenItem = function(item) {
      return item;
    };
    pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
      return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);
    };
    var empty = [];
    pp$5.parseNew = function() {
      if (this.containsEsc) {
        this.raiseRecoverable(this.start, "Escape sequence in keyword new");
      }
      var node2 = this.startNode();
      var meta = this.parseIdent(true);
      if (this.options.ecmaVersion >= 6 && this.eat(types$1.dot)) {
        node2.meta = meta;
        var containsEsc = this.containsEsc;
        node2.property = this.parseIdent(true);
        if (node2.property.name !== "target") {
          this.raiseRecoverable(node2.property.start, "The only valid meta property for new is 'new.target'");
        }
        if (containsEsc) {
          this.raiseRecoverable(node2.start, "'new.target' must not contain escaped characters");
        }
        if (!this.allowNewDotTarget) {
          this.raiseRecoverable(node2.start, "'new.target' can only be used in functions and class static block");
        }
        return this.finishNode(node2, "MetaProperty");
      }
      var startPos = this.start, startLoc = this.startLoc, isImport = this.type === types$1._import;
      node2.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true, false);
      if (isImport && node2.callee.type === "ImportExpression") {
        this.raise(startPos, "Cannot use new with import()");
      }
      if (this.eat(types$1.parenL)) {
        node2.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false);
      } else {
        node2.arguments = empty;
      }
      return this.finishNode(node2, "NewExpression");
    };
    pp$5.parseTemplateElement = function(ref2) {
      var isTagged = ref2.isTagged;
      var elem = this.startNode();
      if (this.type === types$1.invalidTemplate) {
        if (!isTagged) {
          this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
        }
        elem.value = {
          raw: this.value,
          cooked: null
        };
      } else {
        elem.value = {
          raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
          cooked: this.value
        };
      }
      this.next();
      elem.tail = this.type === types$1.backQuote;
      return this.finishNode(elem, "TemplateElement");
    };
    pp$5.parseTemplate = function(ref2) {
      if (ref2 === void 0)
        ref2 = {};
      var isTagged = ref2.isTagged;
      if (isTagged === void 0)
        isTagged = false;
      var node2 = this.startNode();
      this.next();
      node2.expressions = [];
      var curElt = this.parseTemplateElement({ isTagged });
      node2.quasis = [curElt];
      while (!curElt.tail) {
        if (this.type === types$1.eof) {
          this.raise(this.pos, "Unterminated template literal");
        }
        this.expect(types$1.dollarBraceL);
        node2.expressions.push(this.parseExpression());
        this.expect(types$1.braceR);
        node2.quasis.push(curElt = this.parseTemplateElement({ isTagged }));
      }
      this.next();
      return this.finishNode(node2, "TemplateLiteral");
    };
    pp$5.isAsyncProp = function(prop) {
      return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$1.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
    };
    pp$5.parseObj = function(isPattern, refDestructuringErrors) {
      var node2 = this.startNode(), first2 = true, propHash = {};
      node2.properties = [];
      this.next();
      while (!this.eat(types$1.braceR)) {
        if (!first2) {
          this.expect(types$1.comma);
          if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) {
            break;
          }
        } else {
          first2 = false;
        }
        var prop = this.parseProperty(isPattern, refDestructuringErrors);
        if (!isPattern) {
          this.checkPropClash(prop, propHash, refDestructuringErrors);
        }
        node2.properties.push(prop);
      }
      return this.finishNode(node2, isPattern ? "ObjectPattern" : "ObjectExpression");
    };
    pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
      var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
      if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
        if (isPattern) {
          prop.argument = this.parseIdent(false);
          if (this.type === types$1.comma) {
            this.raise(this.start, "Comma is not permitted after the rest element");
          }
          return this.finishNode(prop, "RestElement");
        }
        if (this.type === types$1.parenL && refDestructuringErrors) {
          if (refDestructuringErrors.parenthesizedAssign < 0) {
            refDestructuringErrors.parenthesizedAssign = this.start;
          }
          if (refDestructuringErrors.parenthesizedBind < 0) {
            refDestructuringErrors.parenthesizedBind = this.start;
          }
        }
        prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
        if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
          refDestructuringErrors.trailingComma = this.start;
        }
        return this.finishNode(prop, "SpreadElement");
      }
      if (this.options.ecmaVersion >= 6) {
        prop.method = false;
        prop.shorthand = false;
        if (isPattern || refDestructuringErrors) {
          startPos = this.start;
          startLoc = this.startLoc;
        }
        if (!isPattern) {
          isGenerator = this.eat(types$1.star);
        }
      }
      var containsEsc = this.containsEsc;
      this.parsePropertyName(prop);
      if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
        isAsync = true;
        isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
        this.parsePropertyName(prop, refDestructuringErrors);
      } else {
        isAsync = false;
      }
      this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
      return this.finishNode(prop, "Property");
    };
    pp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
      if ((isGenerator || isAsync) && this.type === types$1.colon) {
        this.unexpected();
      }
      if (this.eat(types$1.colon)) {
        prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
        prop.kind = "init";
      } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {
        if (isPattern) {
          this.unexpected();
        }
        prop.kind = "init";
        prop.method = true;
        prop.value = this.parseMethod(isGenerator, isAsync);
      } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq)) {
        if (isGenerator || isAsync) {
          this.unexpected();
        }
        prop.kind = prop.key.name;
        this.parsePropertyName(prop);
        prop.value = this.parseMethod(false);
        var paramCount = prop.kind === "get" ? 0 : 1;
        if (prop.value.params.length !== paramCount) {
          var start = prop.value.start;
          if (prop.kind === "get") {
            this.raiseRecoverable(start, "getter should have no params");
          } else {
            this.raiseRecoverable(start, "setter should have exactly one param");
          }
        } else {
          if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
            this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
          }
        }
      } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
        if (isGenerator || isAsync) {
          this.unexpected();
        }
        this.checkUnreserved(prop.key);
        if (prop.key.name === "await" && !this.awaitIdentPos) {
          this.awaitIdentPos = startPos;
        }
        prop.kind = "init";
        if (isPattern) {
          prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
        } else if (this.type === types$1.eq && refDestructuringErrors) {
          if (refDestructuringErrors.shorthandAssign < 0) {
            refDestructuringErrors.shorthandAssign = this.start;
          }
          prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
        } else {
          prop.value = this.copyNode(prop.key);
        }
        prop.shorthand = true;
      } else {
        this.unexpected();
      }
    };
    pp$5.parsePropertyName = function(prop) {
      if (this.options.ecmaVersion >= 6) {
        if (this.eat(types$1.bracketL)) {
          prop.computed = true;
          prop.key = this.parseMaybeAssign();
          this.expect(types$1.bracketR);
          return prop.key;
        } else {
          prop.computed = false;
        }
      }
      return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
    };
    pp$5.initFunction = function(node2) {
      node2.id = null;
      if (this.options.ecmaVersion >= 6) {
        node2.generator = node2.expression = false;
      }
      if (this.options.ecmaVersion >= 8) {
        node2.async = false;
      }
    };
    pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
      var node2 = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
      this.initFunction(node2);
      if (this.options.ecmaVersion >= 6) {
        node2.generator = isGenerator;
      }
      if (this.options.ecmaVersion >= 8) {
        node2.async = !!isAsync;
      }
      this.yieldPos = 0;
      this.awaitPos = 0;
      this.awaitIdentPos = 0;
      this.enterScope(functionFlags(isAsync, node2.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
      this.expect(types$1.parenL);
      node2.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
      this.checkYieldAwaitInDefaultParams();
      this.parseFunctionBody(node2, false, true, false);
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.finishNode(node2, "FunctionExpression");
    };
    pp$5.parseArrowExpression = function(node2, params, isAsync, forInit) {
      var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
      this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
      this.initFunction(node2);
      if (this.options.ecmaVersion >= 8) {
        node2.async = !!isAsync;
      }
      this.yieldPos = 0;
      this.awaitPos = 0;
      this.awaitIdentPos = 0;
      node2.params = this.toAssignableList(params, true);
      this.parseFunctionBody(node2, true, false, forInit);
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.finishNode(node2, "ArrowFunctionExpression");
    };
    pp$5.parseFunctionBody = function(node2, isArrowFunction, isMethod, forInit) {
      var isExpression = isArrowFunction && this.type !== types$1.braceL;
      var oldStrict = this.strict, useStrict = false;
      if (isExpression) {
        node2.body = this.parseMaybeAssign(forInit);
        node2.expression = true;
        this.checkParams(node2, false);
      } else {
        var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node2.params);
        if (!oldStrict || nonSimple) {
          useStrict = this.strictDirective(this.end);
          if (useStrict && nonSimple) {
            this.raiseRecoverable(node2.start, "Illegal 'use strict' directive in function with non-simple parameter list");
          }
        }
        var oldLabels = this.labels;
        this.labels = [];
        if (useStrict) {
          this.strict = true;
        }
        this.checkParams(node2, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node2.params));
        if (this.strict && node2.id) {
          this.checkLValSimple(node2.id, BIND_OUTSIDE);
        }
        node2.body = this.parseBlock(false, void 0, useStrict && !oldStrict);
        node2.expression = false;
        this.adaptDirectivePrologue(node2.body.body);
        this.labels = oldLabels;
      }
      this.exitScope();
    };
    pp$5.isSimpleParamList = function(params) {
      for (var i2 = 0, list2 = params; i2 < list2.length; i2 += 1) {
        var param = list2[i2];
        if (param.type !== "Identifier") {
          return false;
        }
      }
      return true;
    };
    pp$5.checkParams = function(node2, allowDuplicates) {
      var nameHash = /* @__PURE__ */ Object.create(null);
      for (var i2 = 0, list2 = node2.params; i2 < list2.length; i2 += 1) {
        var param = list2[i2];
        this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
      }
    };
    pp$5.parseExprList = function(close2, allowTrailingComma, allowEmpty, refDestructuringErrors) {
      var elts = [], first2 = true;
      while (!this.eat(close2)) {
        if (!first2) {
          this.expect(types$1.comma);
          if (allowTrailingComma && this.afterTrailingComma(close2)) {
            break;
          }
        } else {
          first2 = false;
        }
        var elt = void 0;
        if (allowEmpty && this.type === types$1.comma) {
          elt = null;
        } else if (this.type === types$1.ellipsis) {
          elt = this.parseSpread(refDestructuringErrors);
          if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0) {
            refDestructuringErrors.trailingComma = this.start;
          }
        } else {
          elt = this.parseMaybeAssign(false, refDestructuringErrors);
        }
        elts.push(elt);
      }
      return elts;
    };
    pp$5.checkUnreserved = function(ref2) {
      var start = ref2.start;
      var end = ref2.end;
      var name = ref2.name;
      if (this.inGenerator && name === "yield") {
        this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator");
      }
      if (this.inAsync && name === "await") {
        this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function");
      }
      if (this.currentThisScope().inClassFieldInit && name === "arguments") {
        this.raiseRecoverable(start, "Cannot use 'arguments' in class field initializer");
      }
      if (this.inClassStaticBlock && (name === "arguments" || name === "await")) {
        this.raise(start, "Cannot use " + name + " in class static initialization block");
      }
      if (this.keywords.test(name)) {
        this.raise(start, "Unexpected keyword '" + name + "'");
      }
      if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf("\\") !== -1) {
        return;
      }
      var re2 = this.strict ? this.reservedWordsStrict : this.reservedWords;
      if (re2.test(name)) {
        if (!this.inAsync && name === "await") {
          this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function");
        }
        this.raiseRecoverable(start, "The keyword '" + name + "' is reserved");
      }
    };
    pp$5.parseIdent = function(liberal, isBinding) {
      var node2 = this.startNode();
      if (this.type === types$1.name) {
        node2.name = this.value;
      } else if (this.type.keyword) {
        node2.name = this.type.keyword;
        if ((node2.name === "class" || node2.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
          this.context.pop();
        }
      } else {
        this.unexpected();
      }
      this.next(!!liberal);
      this.finishNode(node2, "Identifier");
      if (!liberal) {
        this.checkUnreserved(node2);
        if (node2.name === "await" && !this.awaitIdentPos) {
          this.awaitIdentPos = node2.start;
        }
      }
      return node2;
    };
    pp$5.parsePrivateIdent = function() {
      var node2 = this.startNode();
      if (this.type === types$1.privateId) {
        node2.name = this.value;
      } else {
        this.unexpected();
      }
      this.next();
      this.finishNode(node2, "PrivateIdentifier");
      if (this.privateNameStack.length === 0) {
        this.raise(node2.start, "Private field '#" + node2.name + "' must be declared in an enclosing class");
      } else {
        this.privateNameStack[this.privateNameStack.length - 1].used.push(node2);
      }
      return node2;
    };
    pp$5.parseYield = function(forInit) {
      if (!this.yieldPos) {
        this.yieldPos = this.start;
      }
      var node2 = this.startNode();
      this.next();
      if (this.type === types$1.semi || this.canInsertSemicolon() || this.type !== types$1.star && !this.type.startsExpr) {
        node2.delegate = false;
        node2.argument = null;
      } else {
        node2.delegate = this.eat(types$1.star);
        node2.argument = this.parseMaybeAssign(forInit);
      }
      return this.finishNode(node2, "YieldExpression");
    };
    pp$5.parseAwait = function(forInit) {
      if (!this.awaitPos) {
        this.awaitPos = this.start;
      }
      var node2 = this.startNode();
      this.next();
      node2.argument = this.parseMaybeUnary(null, true, false, forInit);
      return this.finishNode(node2, "AwaitExpression");
    };
    var pp$4 = Parser.prototype;
    pp$4.raise = function(pos2, message) {
      var loc = getLineInfo(this.input, pos2);
      message += " (" + loc.line + ":" + loc.column + ")";
      var err = new SyntaxError(message);
      err.pos = pos2;
      err.loc = loc;
      err.raisedAt = this.pos;
      throw err;
    };
    pp$4.raiseRecoverable = pp$4.raise;
    pp$4.curPosition = function() {
      if (this.options.locations) {
        return new Position(this.curLine, this.pos - this.lineStart);
      }
    };
    var pp$3 = Parser.prototype;
    var Scope = function Scope2(flags) {
      this.flags = flags;
      this.var = [];
      this.lexical = [];
      this.functions = [];
      this.inClassFieldInit = false;
    };
    pp$3.enterScope = function(flags) {
      this.scopeStack.push(new Scope(flags));
    };
    pp$3.exitScope = function() {
      this.scopeStack.pop();
    };
    pp$3.treatFunctionsAsVarInScope = function(scope) {
      return scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_TOP;
    };
    pp$3.declareName = function(name, bindingType, pos2) {
      var redeclared = false;
      if (bindingType === BIND_LEXICAL) {
        var scope = this.currentScope();
        redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
        scope.lexical.push(name);
        if (this.inModule && scope.flags & SCOPE_TOP) {
          delete this.undefinedExports[name];
        }
      } else if (bindingType === BIND_SIMPLE_CATCH) {
        var scope$1 = this.currentScope();
        scope$1.lexical.push(name);
      } else if (bindingType === BIND_FUNCTION) {
        var scope$2 = this.currentScope();
        if (this.treatFunctionsAsVar) {
          redeclared = scope$2.lexical.indexOf(name) > -1;
        } else {
          redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1;
        }
        scope$2.functions.push(name);
      } else {
        for (var i2 = this.scopeStack.length - 1; i2 >= 0; --i2) {
          var scope$3 = this.scopeStack[i2];
          if (scope$3.lexical.indexOf(name) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
            redeclared = true;
            break;
          }
          scope$3.var.push(name);
          if (this.inModule && scope$3.flags & SCOPE_TOP) {
            delete this.undefinedExports[name];
          }
          if (scope$3.flags & SCOPE_VAR) {
            break;
          }
        }
      }
      if (redeclared) {
        this.raiseRecoverable(pos2, "Identifier '" + name + "' has already been declared");
      }
    };
    pp$3.checkLocalExport = function(id) {
      if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1) {
        this.undefinedExports[id.name] = id;
      }
    };
    pp$3.currentScope = function() {
      return this.scopeStack[this.scopeStack.length - 1];
    };
    pp$3.currentVarScope = function() {
      for (var i2 = this.scopeStack.length - 1; ; i2--) {
        var scope = this.scopeStack[i2];
        if (scope.flags & SCOPE_VAR) {
          return scope;
        }
      }
    };
    pp$3.currentThisScope = function() {
      for (var i2 = this.scopeStack.length - 1; ; i2--) {
        var scope = this.scopeStack[i2];
        if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) {
          return scope;
        }
      }
    };
    var Node = function Node2(parser2, pos2, loc) {
      this.type = "";
      this.start = pos2;
      this.end = 0;
      if (parser2.options.locations) {
        this.loc = new SourceLocation(parser2, loc);
      }
      if (parser2.options.directSourceFile) {
        this.sourceFile = parser2.options.directSourceFile;
      }
      if (parser2.options.ranges) {
        this.range = [pos2, 0];
      }
    };
    var pp$2 = Parser.prototype;
    pp$2.startNode = function() {
      return new Node(this, this.start, this.startLoc);
    };
    pp$2.startNodeAt = function(pos2, loc) {
      return new Node(this, pos2, loc);
    };
    function finishNodeAt(node2, type, pos2, loc) {
      node2.type = type;
      node2.end = pos2;
      if (this.options.locations) {
        node2.loc.end = loc;
      }
      if (this.options.ranges) {
        node2.range[1] = pos2;
      }
      return node2;
    }
    pp$2.finishNode = function(node2, type) {
      return finishNodeAt.call(this, node2, type, this.lastTokEnd, this.lastTokEndLoc);
    };
    pp$2.finishNodeAt = function(node2, type, pos2, loc) {
      return finishNodeAt.call(this, node2, type, pos2, loc);
    };
    pp$2.copyNode = function(node2) {
      var newNode = new Node(this, node2.start, this.startLoc);
      for (var prop in node2) {
        newNode[prop] = node2[prop];
      }
      return newNode;
    };
    var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
    var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
    var ecma11BinaryProperties = ecma10BinaryProperties;
    var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
    var ecma13BinaryProperties = ecma12BinaryProperties;
    var unicodeBinaryProperties = {
      9: ecma9BinaryProperties,
      10: ecma10BinaryProperties,
      11: ecma11BinaryProperties,
      12: ecma12BinaryProperties,
      13: ecma13BinaryProperties
    };
    var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
    var ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
    var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
    var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
    var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
    var ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
    var unicodeScriptValues = {
      9: ecma9ScriptValues,
      10: ecma10ScriptValues,
      11: ecma11ScriptValues,
      12: ecma12ScriptValues,
      13: ecma13ScriptValues
    };
    var data = {};
    function buildUnicodeData(ecmaVersion2) {
      var d3 = data[ecmaVersion2] = {
        binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion2] + " " + unicodeGeneralCategoryValues),
        nonBinary: {
          General_Category: wordsRegexp(unicodeGeneralCategoryValues),
          Script: wordsRegexp(unicodeScriptValues[ecmaVersion2])
        }
      };
      d3.nonBinary.Script_Extensions = d3.nonBinary.Script;
      d3.nonBinary.gc = d3.nonBinary.General_Category;
      d3.nonBinary.sc = d3.nonBinary.Script;
      d3.nonBinary.scx = d3.nonBinary.Script_Extensions;
    }
    for (i$1 = 0, list = [9, 10, 11, 12, 13]; i$1 < list.length; i$1 += 1) {
      ecmaVersion = list[i$1];
      buildUnicodeData(ecmaVersion);
    }
    var ecmaVersion;
    var i$1;
    var list;
    var pp$1 = Parser.prototype;
    var RegExpValidationState = function RegExpValidationState2(parser2) {
      this.parser = parser2;
      this.validFlags = "gim" + (parser2.options.ecmaVersion >= 6 ? "uy" : "") + (parser2.options.ecmaVersion >= 9 ? "s" : "") + (parser2.options.ecmaVersion >= 13 ? "d" : "");
      this.unicodeProperties = data[parser2.options.ecmaVersion >= 13 ? 13 : parser2.options.ecmaVersion];
      this.source = "";
      this.flags = "";
      this.start = 0;
      this.switchU = false;
      this.switchN = false;
      this.pos = 0;
      this.lastIntValue = 0;
      this.lastStringValue = "";
      this.lastAssertionIsQuantifiable = false;
      this.numCapturingParens = 0;
      this.maxBackReference = 0;
      this.groupNames = [];
      this.backReferenceNames = [];
    };
    RegExpValidationState.prototype.reset = function reset(start, pattern2, flags) {
      var unicode2 = flags.indexOf("u") !== -1;
      this.start = start | 0;
      this.source = pattern2 + "";
      this.flags = flags;
      this.switchU = unicode2 && this.parser.options.ecmaVersion >= 6;
      this.switchN = unicode2 && this.parser.options.ecmaVersion >= 9;
    };
    RegExpValidationState.prototype.raise = function raise(message) {
      this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
    };
    RegExpValidationState.prototype.at = function at2(i2, forceU) {
      if (forceU === void 0)
        forceU = false;
      var s2 = this.source;
      var l2 = s2.length;
      if (i2 >= l2) {
        return -1;
      }
      var c3 = s2.charCodeAt(i2);
      if (!(forceU || this.switchU) || c3 <= 55295 || c3 >= 57344 || i2 + 1 >= l2) {
        return c3;
      }
      var next = s2.charCodeAt(i2 + 1);
      return next >= 56320 && next <= 57343 ? (c3 << 10) + next - 56613888 : c3;
    };
    RegExpValidationState.prototype.nextIndex = function nextIndex(i2, forceU) {
      if (forceU === void 0)
        forceU = false;
      var s2 = this.source;
      var l2 = s2.length;
      if (i2 >= l2) {
        return l2;
      }
      var c3 = s2.charCodeAt(i2), next;
      if (!(forceU || this.switchU) || c3 <= 55295 || c3 >= 57344 || i2 + 1 >= l2 || (next = s2.charCodeAt(i2 + 1)) < 56320 || next > 57343) {
        return i2 + 1;
      }
      return i2 + 2;
    };
    RegExpValidationState.prototype.current = function current(forceU) {
      if (forceU === void 0)
        forceU = false;
      return this.at(this.pos, forceU);
    };
    RegExpValidationState.prototype.lookahead = function lookahead(forceU) {
      if (forceU === void 0)
        forceU = false;
      return this.at(this.nextIndex(this.pos, forceU), forceU);
    };
    RegExpValidationState.prototype.advance = function advance(forceU) {
      if (forceU === void 0)
        forceU = false;
      this.pos = this.nextIndex(this.pos, forceU);
    };
    RegExpValidationState.prototype.eat = function eat(ch2, forceU) {
      if (forceU === void 0)
        forceU = false;
      if (this.current(forceU) === ch2) {
        this.advance(forceU);
        return true;
      }
      return false;
    };
    function codePointToString$1(ch2) {
      if (ch2 <= 65535) {
        return String.fromCharCode(ch2);
      }
      ch2 -= 65536;
      return String.fromCharCode((ch2 >> 10) + 55296, (ch2 & 1023) + 56320);
    }
    pp$1.validateRegExpFlags = function(state) {
      var validFlags = state.validFlags;
      var flags = state.flags;
      for (var i2 = 0; i2 < flags.length; i2++) {
        var flag = flags.charAt(i2);
        if (validFlags.indexOf(flag) === -1) {
          this.raise(state.start, "Invalid regular expression flag");
        }
        if (flags.indexOf(flag, i2 + 1) > -1) {
          this.raise(state.start, "Duplicate regular expression flag");
        }
      }
    };
    pp$1.validateRegExpPattern = function(state) {
      this.regexp_pattern(state);
      if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
        state.switchN = true;
        this.regexp_pattern(state);
      }
    };
    pp$1.regexp_pattern = function(state) {
      state.pos = 0;
      state.lastIntValue = 0;
      state.lastStringValue = "";
      state.lastAssertionIsQuantifiable = false;
      state.numCapturingParens = 0;
      state.maxBackReference = 0;
      state.groupNames.length = 0;
      state.backReferenceNames.length = 0;
      this.regexp_disjunction(state);
      if (state.pos !== state.source.length) {
        if (state.eat(41)) {
          state.raise("Unmatched ')'");
        }
        if (state.eat(93) || state.eat(125)) {
          state.raise("Lone quantifier brackets");
        }
      }
      if (state.maxBackReference > state.numCapturingParens) {
        state.raise("Invalid escape");
      }
      for (var i2 = 0, list2 = state.backReferenceNames; i2 < list2.length; i2 += 1) {
        var name = list2[i2];
        if (state.groupNames.indexOf(name) === -1) {
          state.raise("Invalid named capture referenced");
        }
      }
    };
    pp$1.regexp_disjunction = function(state) {
      this.regexp_alternative(state);
      while (state.eat(124)) {
        this.regexp_alternative(state);
      }
      if (this.regexp_eatQuantifier(state, true)) {
        state.raise("Nothing to repeat");
      }
      if (state.eat(123)) {
        state.raise("Lone quantifier brackets");
      }
    };
    pp$1.regexp_alternative = function(state) {
      while (state.pos < state.source.length && this.regexp_eatTerm(state)) {
      }
    };
    pp$1.regexp_eatTerm = function(state) {
      if (this.regexp_eatAssertion(state)) {
        if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
          if (state.switchU) {
            state.raise("Invalid quantifier");
          }
        }
        return true;
      }
      if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
        this.regexp_eatQuantifier(state);
        return true;
      }
      return false;
    };
    pp$1.regexp_eatAssertion = function(state) {
      var start = state.pos;
      state.lastAssertionIsQuantifiable = false;
      if (state.eat(94) || state.eat(36)) {
        return true;
      }
      if (state.eat(92)) {
        if (state.eat(66) || state.eat(98)) {
          return true;
        }
        state.pos = start;
      }
      if (state.eat(40) && state.eat(63)) {
        var lookbehind = false;
        if (this.options.ecmaVersion >= 9) {
          lookbehind = state.eat(60);
        }
        if (state.eat(61) || state.eat(33)) {
          this.regexp_disjunction(state);
          if (!state.eat(41)) {
            state.raise("Unterminated group");
          }
          state.lastAssertionIsQuantifiable = !lookbehind;
          return true;
        }
      }
      state.pos = start;
      return false;
    };
    pp$1.regexp_eatQuantifier = function(state, noError) {
      if (noError === void 0)
        noError = false;
      if (this.regexp_eatQuantifierPrefix(state, noError)) {
        state.eat(63);
        return true;
      }
      return false;
    };
    pp$1.regexp_eatQuantifierPrefix = function(state, noError) {
      return state.eat(42) || state.eat(43) || state.eat(63) || this.regexp_eatBracedQuantifier(state, noError);
    };
    pp$1.regexp_eatBracedQuantifier = function(state, noError) {
      var start = state.pos;
      if (state.eat(123)) {
        var min2 = 0, max = -1;
        if (this.regexp_eatDecimalDigits(state)) {
          min2 = state.lastIntValue;
          if (state.eat(44) && this.regexp_eatDecimalDigits(state)) {
            max = state.lastIntValue;
          }
          if (state.eat(125)) {
            if (max !== -1 && max < min2 && !noError) {
              state.raise("numbers out of order in {} quantifier");
            }
            return true;
          }
        }
        if (state.switchU && !noError) {
          state.raise("Incomplete quantifier");
        }
        state.pos = start;
      }
      return false;
    };
    pp$1.regexp_eatAtom = function(state) {
      return this.regexp_eatPatternCharacters(state) || state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
    };
    pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {
      var start = state.pos;
      if (state.eat(92)) {
        if (this.regexp_eatAtomEscape(state)) {
          return true;
        }
        state.pos = start;
      }
      return false;
    };
    pp$1.regexp_eatUncapturingGroup = function(state) {
      var start = state.pos;
      if (state.eat(40)) {
        if (state.eat(63) && state.eat(58)) {
          this.regexp_disjunction(state);
          if (state.eat(41)) {
            return true;
          }
          state.raise("Unterminated group");
        }
        state.pos = start;
      }
      return false;
    };
    pp$1.regexp_eatCapturingGroup = function(state) {
      if (state.eat(40)) {
        if (this.options.ecmaVersion >= 9) {
          this.regexp_groupSpecifier(state);
        } else if (state.current() === 63) {
          state.raise("Invalid group");
        }
        this.regexp_disjunction(state);
        if (state.eat(41)) {
          state.numCapturingParens += 1;
          return true;
        }
        state.raise("Unterminated group");
      }
      return false;
    };
    pp$1.regexp_eatExtendedAtom = function(state) {
      return state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
    };
    pp$1.regexp_eatInvalidBracedQuantifier = function(state) {
      if (this.regexp_eatBracedQuantifier(state, true)) {
        state.raise("Nothing to repeat");
      }
      return false;
    };
    pp$1.regexp_eatSyntaxCharacter = function(state) {
      var ch2 = state.current();
      if (isSyntaxCharacter(ch2)) {
        state.lastIntValue = ch2;
        state.advance();
        return true;
      }
      return false;
    };
    function isSyntaxCharacter(ch2) {
      return ch2 === 36 || ch2 >= 40 && ch2 <= 43 || ch2 === 46 || ch2 === 63 || ch2 >= 91 && ch2 <= 94 || ch2 >= 123 && ch2 <= 125;
    }
    pp$1.regexp_eatPatternCharacters = function(state) {
      var start = state.pos;
      var ch2 = 0;
      while ((ch2 = state.current()) !== -1 && !isSyntaxCharacter(ch2)) {
        state.advance();
      }
      return state.pos !== start;
    };
    pp$1.regexp_eatExtendedPatternCharacter = function(state) {
      var ch2 = state.current();
      if (ch2 !== -1 && ch2 !== 36 && !(ch2 >= 40 && ch2 <= 43) && ch2 !== 46 && ch2 !== 63 && ch2 !== 91 && ch2 !== 94 && ch2 !== 124) {
        state.advance();
        return true;
      }
      return false;
    };
    pp$1.regexp_groupSpecifier = function(state) {
      if (state.eat(63)) {
        if (this.regexp_eatGroupName(state)) {
          if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
            state.raise("Duplicate capture group name");
          }
          state.groupNames.push(state.lastStringValue);
          return;
        }
        state.raise("Invalid group");
      }
    };
    pp$1.regexp_eatGroupName = function(state) {
      state.lastStringValue = "";
      if (state.eat(60)) {
        if (this.regexp_eatRegExpIdentifierName(state) && state.eat(62)) {
          return true;
        }
        state.raise("Invalid capture group name");
      }
      return false;
    };
    pp$1.regexp_eatRegExpIdentifierName = function(state) {
      state.lastStringValue = "";
      if (this.regexp_eatRegExpIdentifierStart(state)) {
        state.lastStringValue += codePointToString$1(state.lastIntValue);
        while (this.regexp_eatRegExpIdentifierPart(state)) {
          state.lastStringValue += codePointToString$1(state.lastIntValue);
        }
        return true;
      }
      return false;
    };
    pp$1.regexp_eatRegExpIdentifierStart = function(state) {
      var start = state.pos;
      var forceU = this.options.ecmaVersion >= 11;
      var ch2 = state.current(forceU);
      state.advance(forceU);
      if (ch2 === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
        ch2 = state.lastIntValue;
      }
      if (isRegExpIdentifierStart(ch2)) {
        state.lastIntValue = ch2;
        return true;
      }
      state.pos = start;
      return false;
    };
    function isRegExpIdentifierStart(ch2) {
      return isIdentifierStart(ch2, true) || ch2 === 36 || ch2 === 95;
    }
    pp$1.regexp_eatRegExpIdentifierPart = function(state) {
      var start = state.pos;
      var forceU = this.options.ecmaVersion >= 11;
      var ch2 = state.current(forceU);
      state.advance(forceU);
      if (ch2 === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
        ch2 = state.lastIntValue;
      }
      if (isRegExpIdentifierPart(ch2)) {
        state.lastIntValue = ch2;
        return true;
      }
      state.pos = start;
      return false;
    };
    function isRegExpIdentifierPart(ch2) {
      return isIdentifierChar(ch2, true) || ch2 === 36 || ch2 === 95 || ch2 === 8204 || ch2 === 8205;
    }
    pp$1.regexp_eatAtomEscape = function(state) {
      if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {
        return true;
      }
      if (state.switchU) {
        if (state.current() === 99) {
          state.raise("Invalid unicode escape");
        }
        state.raise("Invalid escape");
      }
      return false;
    };
    pp$1.regexp_eatBackReference = function(state) {
      var start = state.pos;
      if (this.regexp_eatDecimalEscape(state)) {
        var n3 = state.lastIntValue;
        if (state.switchU) {
          if (n3 > state.maxBackReference) {
            state.maxBackReference = n3;
          }
          return true;
        }
        if (n3 <= state.numCapturingParens) {
          return true;
        }
        state.pos = start;
      }
      return false;
    };
    pp$1.regexp_eatKGroupName = function(state) {
      if (state.eat(107)) {
        if (this.regexp_eatGroupName(state)) {
          state.backReferenceNames.push(state.lastStringValue);
          return true;
        }
        state.raise("Invalid named reference");
      }
      return false;
    };
    pp$1.regexp_eatCharacterEscape = function(state) {
      return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
    };
    pp$1.regexp_eatCControlLetter = function(state) {
      var start = state.pos;
      if (state.eat(99)) {
        if (this.regexp_eatControlLetter(state)) {
          return true;
        }
        state.pos = start;
      }
      return false;
    };
    pp$1.regexp_eatZero = function(state) {
      if (state.current() === 48 && !isDecimalDigit(state.lookahead())) {
        state.lastIntValue = 0;
        state.advance();
        return true;
      }
      return false;
    };
    pp$1.regexp_eatControlEscape = function(state) {
      var ch2 = state.current();
      if (ch2 === 116) {
        state.lastIntValue = 9;
        state.advance();
        return true;
      }
      if (ch2 === 110) {
        state.lastIntValue = 10;
        state.advance();
        return true;
      }
      if (ch2 === 118) {
        state.lastIntValue = 11;
        state.advance();
        return true;
      }
      if (ch2 === 102) {
        state.lastIntValue = 12;
        state.advance();
        return true;
      }
      if (ch2 === 114) {
        state.lastIntValue = 13;
        state.advance();
        return true;
      }
      return false;
    };
    pp$1.regexp_eatControlLetter = function(state) {
      var ch2 = state.current();
      if (isControlLetter(ch2)) {
        state.lastIntValue = ch2 % 32;
        state.advance();
        return true;
      }
      return false;
    };
    function isControlLetter(ch2) {
      return ch2 >= 65 && ch2 <= 90 || ch2 >= 97 && ch2 <= 122;
    }
    pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
      if (forceU === void 0)
        forceU = false;
      var start = state.pos;
      var switchU = forceU || state.switchU;
      if (state.eat(117)) {
        if (this.regexp_eatFixedHexDigits(state, 4)) {
          var lead = state.lastIntValue;
          if (switchU && lead >= 55296 && lead <= 56319) {
            var leadSurrogateEnd = state.pos;
            if (state.eat(92) && state.eat(117) && this.regexp_eatFixedHexDigits(state, 4)) {
              var trail = state.lastIntValue;
              if (trail >= 56320 && trail <= 57343) {
                state.lastIntValue = (lead - 55296) * 1024 + (trail - 56320) + 65536;
                return true;
              }
            }
            state.pos = leadSurrogateEnd;
            state.lastIntValue = lead;
          }
          return true;
        }
        if (switchU && state.eat(123) && this.regexp_eatHexDigits(state) && state.eat(125) && isValidUnicode(state.lastIntValue)) {
          return true;
        }
        if (switchU) {
          state.raise("Invalid unicode escape");
        }
        state.pos = start;
      }
      return false;
    };
    function isValidUnicode(ch2) {
      return ch2 >= 0 && ch2 <= 1114111;
    }
    pp$1.regexp_eatIdentityEscape = function(state) {
      if (state.switchU) {
        if (this.regexp_eatSyntaxCharacter(state)) {
          return true;
        }
        if (state.eat(47)) {
          state.lastIntValue = 47;
          return true;
        }
        return false;
      }
      var ch2 = state.current();
      if (ch2 !== 99 && (!state.switchN || ch2 !== 107)) {
        state.lastIntValue = ch2;
        state.advance();
        return true;
      }
      return false;
    };
    pp$1.regexp_eatDecimalEscape = function(state) {
      state.lastIntValue = 0;
      var ch2 = state.current();
      if (ch2 >= 49 && ch2 <= 57) {
        do {
          state.lastIntValue = 10 * state.lastIntValue + (ch2 - 48);
          state.advance();
        } while ((ch2 = state.current()) >= 48 && ch2 <= 57);
        return true;
      }
      return false;
    };
    pp$1.regexp_eatCharacterClassEscape = function(state) {
      var ch2 = state.current();
      if (isCharacterClassEscape(ch2)) {
        state.lastIntValue = -1;
        state.advance();
        return true;
      }
      if (state.switchU && this.options.ecmaVersion >= 9 && (ch2 === 80 || ch2 === 112)) {
        state.lastIntValue = -1;
        state.advance();
        if (state.eat(123) && this.regexp_eatUnicodePropertyValueExpression(state) && state.eat(125)) {
          return true;
        }
        state.raise("Invalid property name");
      }
      return false;
    };
    function isCharacterClassEscape(ch2) {
      return ch2 === 100 || ch2 === 68 || ch2 === 115 || ch2 === 83 || ch2 === 119 || ch2 === 87;
    }
    pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {
      var start = state.pos;
      if (this.regexp_eatUnicodePropertyName(state) && state.eat(61)) {
        var name = state.lastStringValue;
        if (this.regexp_eatUnicodePropertyValue(state)) {
          var value = state.lastStringValue;
          this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
          return true;
        }
      }
      state.pos = start;
      if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
        var nameOrValue = state.lastStringValue;
        this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
        return true;
      }
      return false;
    };
    pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
      if (!hasOwn(state.unicodeProperties.nonBinary, name)) {
        state.raise("Invalid property name");
      }
      if (!state.unicodeProperties.nonBinary[name].test(value)) {
        state.raise("Invalid property value");
      }
    };
    pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
      if (!state.unicodeProperties.binary.test(nameOrValue)) {
        state.raise("Invalid property name");
      }
    };
    pp$1.regexp_eatUnicodePropertyName = function(state) {
      var ch2 = 0;
      state.lastStringValue = "";
      while (isUnicodePropertyNameCharacter(ch2 = state.current())) {
        state.lastStringValue += codePointToString$1(ch2);
        state.advance();
      }
      return state.lastStringValue !== "";
    };
    function isUnicodePropertyNameCharacter(ch2) {
      return isControlLetter(ch2) || ch2 === 95;
    }
    pp$1.regexp_eatUnicodePropertyValue = function(state) {
      var ch2 = 0;
      state.lastStringValue = "";
      while (isUnicodePropertyValueCharacter(ch2 = state.current())) {
        state.lastStringValue += codePointToString$1(ch2);
        state.advance();
      }
      return state.lastStringValue !== "";
    };
    function isUnicodePropertyValueCharacter(ch2) {
      return isUnicodePropertyNameCharacter(ch2) || isDecimalDigit(ch2);
    }
    pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
      return this.regexp_eatUnicodePropertyValue(state);
    };
    pp$1.regexp_eatCharacterClass = function(state) {
      if (state.eat(91)) {
        state.eat(94);
        this.regexp_classRanges(state);
        if (state.eat(93)) {
          return true;
        }
        state.raise("Unterminated character class");
      }
      return false;
    };
    pp$1.regexp_classRanges = function(state) {
      while (this.regexp_eatClassAtom(state)) {
        var left = state.lastIntValue;
        if (state.eat(45) && this.regexp_eatClassAtom(state)) {
          var right = state.lastIntValue;
          if (state.switchU && (left === -1 || right === -1)) {
            state.raise("Invalid character class");
          }
          if (left !== -1 && right !== -1 && left > right) {
            state.raise("Range out of order in character class");
          }
        }
      }
    };
    pp$1.regexp_eatClassAtom = function(state) {
      var start = state.pos;
      if (state.eat(92)) {
        if (this.regexp_eatClassEscape(state)) {
          return true;
        }
        if (state.switchU) {
          var ch$1 = state.current();
          if (ch$1 === 99 || isOctalDigit(ch$1)) {
            state.raise("Invalid class escape");
          }
          state.raise("Invalid escape");
        }
        state.pos = start;
      }
      var ch2 = state.current();
      if (ch2 !== 93) {
        state.lastIntValue = ch2;
        state.advance();
        return true;
      }
      return false;
    };
    pp$1.regexp_eatClassEscape = function(state) {
      var start = state.pos;
      if (state.eat(98)) {
        state.lastIntValue = 8;
        return true;
      }
      if (state.switchU && state.eat(45)) {
        state.lastIntValue = 45;
        return true;
      }
      if (!state.switchU && state.eat(99)) {
        if (this.regexp_eatClassControlLetter(state)) {
          return true;
        }
        state.pos = start;
      }
      return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
    };
    pp$1.regexp_eatClassControlLetter = function(state) {
      var ch2 = state.current();
      if (isDecimalDigit(ch2) || ch2 === 95) {
        state.lastIntValue = ch2 % 32;
        state.advance();
        return true;
      }
      return false;
    };
    pp$1.regexp_eatHexEscapeSequence = function(state) {
      var start = state.pos;
      if (state.eat(120)) {
        if (this.regexp_eatFixedHexDigits(state, 2)) {
          return true;
        }
        if (state.switchU) {
          state.raise("Invalid escape");
        }
        state.pos = start;
      }
      return false;
    };
    pp$1.regexp_eatDecimalDigits = function(state) {
      var start = state.pos;
      var ch2 = 0;
      state.lastIntValue = 0;
      while (isDecimalDigit(ch2 = state.current())) {
        state.lastIntValue = 10 * state.lastIntValue + (ch2 - 48);
        state.advance();
      }
      return state.pos !== start;
    };
    function isDecimalDigit(ch2) {
      return ch2 >= 48 && ch2 <= 57;
    }
    pp$1.regexp_eatHexDigits = function(state) {
      var start = state.pos;
      var ch2 = 0;
      state.lastIntValue = 0;
      while (isHexDigit(ch2 = state.current())) {
        state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch2);
        state.advance();
      }
      return state.pos !== start;
    };
    function isHexDigit(ch2) {
      return ch2 >= 48 && ch2 <= 57 || ch2 >= 65 && ch2 <= 70 || ch2 >= 97 && ch2 <= 102;
    }
    function hexToInt(ch2) {
      if (ch2 >= 65 && ch2 <= 70) {
        return 10 + (ch2 - 65);
      }
      if (ch2 >= 97 && ch2 <= 102) {
        return 10 + (ch2 - 97);
      }
      return ch2 - 48;
    }
    pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {
      if (this.regexp_eatOctalDigit(state)) {
        var n1 = state.lastIntValue;
        if (this.regexp_eatOctalDigit(state)) {
          var n22 = state.lastIntValue;
          if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
            state.lastIntValue = n1 * 64 + n22 * 8 + state.lastIntValue;
          } else {
            state.lastIntValue = n1 * 8 + n22;
          }
        } else {
          state.lastIntValue = n1;
        }
        return true;
      }
      return false;
    };
    pp$1.regexp_eatOctalDigit = function(state) {
      var ch2 = state.current();
      if (isOctalDigit(ch2)) {
        state.lastIntValue = ch2 - 48;
        state.advance();
        return true;
      }
      state.lastIntValue = 0;
      return false;
    };
    function isOctalDigit(ch2) {
      return ch2 >= 48 && ch2 <= 55;
    }
    pp$1.regexp_eatFixedHexDigits = function(state, length) {
      var start = state.pos;
      state.lastIntValue = 0;
      for (var i2 = 0; i2 < length; ++i2) {
        var ch2 = state.current();
        if (!isHexDigit(ch2)) {
          state.pos = start;
          return false;
        }
        state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch2);
        state.advance();
      }
      return true;
    };
    var Token = function Token2(p2) {
      this.type = p2.type;
      this.value = p2.value;
      this.start = p2.start;
      this.end = p2.end;
      if (p2.options.locations) {
        this.loc = new SourceLocation(p2, p2.startLoc, p2.endLoc);
      }
      if (p2.options.ranges) {
        this.range = [p2.start, p2.end];
      }
    };
    var pp = Parser.prototype;
    pp.next = function(ignoreEscapeSequenceInKeyword) {
      if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) {
        this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
      }
      if (this.options.onToken) {
        this.options.onToken(new Token(this));
      }
      this.lastTokEnd = this.end;
      this.lastTokStart = this.start;
      this.lastTokEndLoc = this.endLoc;
      this.lastTokStartLoc = this.startLoc;
      this.nextToken();
    };
    pp.getToken = function() {
      this.next();
      return new Token(this);
    };
    if (typeof Symbol !== "undefined") {
      pp[Symbol.iterator] = function() {
        var this$1$1 = this;
        return {
          next: function() {
            var token2 = this$1$1.getToken();
            return {
              done: token2.type === types$1.eof,
              value: token2
            };
          }
        };
      };
    }
    pp.nextToken = function() {
      var curContext = this.curContext();
      if (!curContext || !curContext.preserveSpace) {
        this.skipSpace();
      }
      this.start = this.pos;
      if (this.options.locations) {
        this.startLoc = this.curPosition();
      }
      if (this.pos >= this.input.length) {
        return this.finishToken(types$1.eof);
      }
      if (curContext.override) {
        return curContext.override(this);
      } else {
        this.readToken(this.fullCharCodeAtPos());
      }
    };
    pp.readToken = function(code) {
      if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92) {
        return this.readWord();
      }
      return this.getTokenFromCode(code);
    };
    pp.fullCharCodeAtPos = function() {
      var code = this.input.charCodeAt(this.pos);
      if (code <= 55295 || code >= 56320) {
        return code;
      }
      var next = this.input.charCodeAt(this.pos + 1);
      return next <= 56319 || next >= 57344 ? code : (code << 10) + next - 56613888;
    };
    pp.skipBlockComment = function() {
      var startLoc = this.options.onComment && this.curPosition();
      var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
      if (end === -1) {
        this.raise(this.pos - 2, "Unterminated comment");
      }
      this.pos = end + 2;
      if (this.options.locations) {
        for (var nextBreak = void 0, pos2 = start; (nextBreak = nextLineBreak(this.input, pos2, this.pos)) > -1; ) {
          ++this.curLine;
          pos2 = this.lineStart = nextBreak;
        }
      }
      if (this.options.onComment) {
        this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());
      }
    };
    pp.skipLineComment = function(startSkip) {
      var start = this.pos;
      var startLoc = this.options.onComment && this.curPosition();
      var ch2 = this.input.charCodeAt(this.pos += startSkip);
      while (this.pos < this.input.length && !isNewLine(ch2)) {
        ch2 = this.input.charCodeAt(++this.pos);
      }
      if (this.options.onComment) {
        this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());
      }
    };
    pp.skipSpace = function() {
      loop:
        while (this.pos < this.input.length) {
          var ch2 = this.input.charCodeAt(this.pos);
          switch (ch2) {
            case 32:
            case 160:
              ++this.pos;
              break;
            case 13:
              if (this.input.charCodeAt(this.pos + 1) === 10) {
                ++this.pos;
              }
            case 10:
            case 8232:
            case 8233:
              ++this.pos;
              if (this.options.locations) {
                ++this.curLine;
                this.lineStart = this.pos;
              }
              break;
            case 47:
              switch (this.input.charCodeAt(this.pos + 1)) {
                case 42:
                  this.skipBlockComment();
                  break;
                case 47:
                  this.skipLineComment(2);
                  break;
                default:
                  break loop;
              }
              break;
            default:
              if (ch2 > 8 && ch2 < 14 || ch2 >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch2))) {
                ++this.pos;
              } else {
                break loop;
              }
          }
        }
    };
    pp.finishToken = function(type, val) {
      this.end = this.pos;
      if (this.options.locations) {
        this.endLoc = this.curPosition();
      }
      var prevType = this.type;
      this.type = type;
      this.value = val;
      this.updateContext(prevType);
    };
    pp.readToken_dot = function() {
      var next = this.input.charCodeAt(this.pos + 1);
      if (next >= 48 && next <= 57) {
        return this.readNumber(true);
      }
      var next2 = this.input.charCodeAt(this.pos + 2);
      if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
        this.pos += 3;
        return this.finishToken(types$1.ellipsis);
      } else {
        ++this.pos;
        return this.finishToken(types$1.dot);
      }
    };
    pp.readToken_slash = function() {
      var next = this.input.charCodeAt(this.pos + 1);
      if (this.exprAllowed) {
        ++this.pos;
        return this.readRegexp();
      }
      if (next === 61) {
        return this.finishOp(types$1.assign, 2);
      }
      return this.finishOp(types$1.slash, 1);
    };
    pp.readToken_mult_modulo_exp = function(code) {
      var next = this.input.charCodeAt(this.pos + 1);
      var size = 1;
      var tokentype = code === 42 ? types$1.star : types$1.modulo;
      if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
        ++size;
        tokentype = types$1.starstar;
        next = this.input.charCodeAt(this.pos + 2);
      }
      if (next === 61) {
        return this.finishOp(types$1.assign, size + 1);
      }
      return this.finishOp(tokentype, size);
    };
    pp.readToken_pipe_amp = function(code) {
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === code) {
        if (this.options.ecmaVersion >= 12) {
          var next2 = this.input.charCodeAt(this.pos + 2);
          if (next2 === 61) {
            return this.finishOp(types$1.assign, 3);
          }
        }
        return this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2);
      }
      if (next === 61) {
        return this.finishOp(types$1.assign, 2);
      }
      return this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1);
    };
    pp.readToken_caret = function() {
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 61) {
        return this.finishOp(types$1.assign, 2);
      }
      return this.finishOp(types$1.bitwiseXOR, 1);
    };
    pp.readToken_plus_min = function(code) {
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === code) {
        if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
          this.skipLineComment(3);
          this.skipSpace();
          return this.nextToken();
        }
        return this.finishOp(types$1.incDec, 2);
      }
      if (next === 61) {
        return this.finishOp(types$1.assign, 2);
      }
      return this.finishOp(types$1.plusMin, 1);
    };
    pp.readToken_lt_gt = function(code) {
      var next = this.input.charCodeAt(this.pos + 1);
      var size = 1;
      if (next === code) {
        size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
        if (this.input.charCodeAt(this.pos + size) === 61) {
          return this.finishOp(types$1.assign, size + 1);
        }
        return this.finishOp(types$1.bitShift, size);
      }
      if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
        this.skipLineComment(4);
        this.skipSpace();
        return this.nextToken();
      }
      if (next === 61) {
        size = 2;
      }
      return this.finishOp(types$1.relational, size);
    };
    pp.readToken_eq_excl = function(code) {
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 61) {
        return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
      }
      if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
        this.pos += 2;
        return this.finishToken(types$1.arrow);
      }
      return this.finishOp(code === 61 ? types$1.eq : types$1.prefix, 1);
    };
    pp.readToken_question = function() {
      var ecmaVersion2 = this.options.ecmaVersion;
      if (ecmaVersion2 >= 11) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 46) {
          var next2 = this.input.charCodeAt(this.pos + 2);
          if (next2 < 48 || next2 > 57) {
            return this.finishOp(types$1.questionDot, 2);
          }
        }
        if (next === 63) {
          if (ecmaVersion2 >= 12) {
            var next2$1 = this.input.charCodeAt(this.pos + 2);
            if (next2$1 === 61) {
              return this.finishOp(types$1.assign, 3);
            }
          }
          return this.finishOp(types$1.coalesce, 2);
        }
      }
      return this.finishOp(types$1.question, 1);
    };
    pp.readToken_numberSign = function() {
      var ecmaVersion2 = this.options.ecmaVersion;
      var code = 35;
      if (ecmaVersion2 >= 13) {
        ++this.pos;
        code = this.fullCharCodeAtPos();
        if (isIdentifierStart(code, true) || code === 92) {
          return this.finishToken(types$1.privateId, this.readWord1());
        }
      }
      this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
    };
    pp.getTokenFromCode = function(code) {
      switch (code) {
        case 46:
          return this.readToken_dot();
        case 40:
          ++this.pos;
          return this.finishToken(types$1.parenL);
        case 41:
          ++this.pos;
          return this.finishToken(types$1.parenR);
        case 59:
          ++this.pos;
          return this.finishToken(types$1.semi);
        case 44:
          ++this.pos;
          return this.finishToken(types$1.comma);
        case 91:
          ++this.pos;
          return this.finishToken(types$1.bracketL);
        case 93:
          ++this.pos;
          return this.finishToken(types$1.bracketR);
        case 123:
          ++this.pos;
          return this.finishToken(types$1.braceL);
        case 125:
          ++this.pos;
          return this.finishToken(types$1.braceR);
        case 58:
          ++this.pos;
          return this.finishToken(types$1.colon);
        case 96:
          if (this.options.ecmaVersion < 6) {
            break;
          }
          ++this.pos;
          return this.finishToken(types$1.backQuote);
        case 48:
          var next = this.input.charCodeAt(this.pos + 1);
          if (next === 120 || next === 88) {
            return this.readRadixNumber(16);
          }
          if (this.options.ecmaVersion >= 6) {
            if (next === 111 || next === 79) {
              return this.readRadixNumber(8);
            }
            if (next === 98 || next === 66) {
              return this.readRadixNumber(2);
            }
          }
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          return this.readNumber(false);
        case 34:
        case 39:
          return this.readString(code);
        case 47:
          return this.readToken_slash();
        case 37:
        case 42:
          return this.readToken_mult_modulo_exp(code);
        case 124:
        case 38:
          return this.readToken_pipe_amp(code);
        case 94:
          return this.readToken_caret();
        case 43:
        case 45:
          return this.readToken_plus_min(code);
        case 60:
        case 62:
          return this.readToken_lt_gt(code);
        case 61:
        case 33:
          return this.readToken_eq_excl(code);
        case 63:
          return this.readToken_question();
        case 126:
          return this.finishOp(types$1.prefix, 1);
        case 35:
          return this.readToken_numberSign();
      }
      this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
    };
    pp.finishOp = function(type, size) {
      var str = this.input.slice(this.pos, this.pos + size);
      this.pos += size;
      return this.finishToken(type, str);
    };
    pp.readRegexp = function() {
      var escaped2, inClass, start = this.pos;
      for (; ; ) {
        if (this.pos >= this.input.length) {
          this.raise(start, "Unterminated regular expression");
        }
        var ch2 = this.input.charAt(this.pos);
        if (lineBreak.test(ch2)) {
          this.raise(start, "Unterminated regular expression");
        }
        if (!escaped2) {
          if (ch2 === "[") {
            inClass = true;
          } else if (ch2 === "]" && inClass) {
            inClass = false;
          } else if (ch2 === "/" && !inClass) {
            break;
          }
          escaped2 = ch2 === "\\";
        } else {
          escaped2 = false;
        }
        ++this.pos;
      }
      var pattern2 = this.input.slice(start, this.pos);
      ++this.pos;
      var flagsStart = this.pos;
      var flags = this.readWord1();
      if (this.containsEsc) {
        this.unexpected(flagsStart);
      }
      var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
      state.reset(start, pattern2, flags);
      this.validateRegExpFlags(state);
      this.validateRegExpPattern(state);
      var value = null;
      try {
        value = new RegExp(pattern2, flags);
      } catch (e2) {
      }
      return this.finishToken(types$1.regexp, { pattern: pattern2, flags, value });
    };
    pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
      var allowSeparators = this.options.ecmaVersion >= 12 && len === void 0;
      var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
      var start = this.pos, total = 0, lastCode = 0;
      for (var i2 = 0, e2 = len == null ? Infinity : len; i2 < e2; ++i2, ++this.pos) {
        var code = this.input.charCodeAt(this.pos), val = void 0;
        if (allowSeparators && code === 95) {
          if (isLegacyOctalNumericLiteral) {
            this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
          }
          if (lastCode === 95) {
            this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
          }
          if (i2 === 0) {
            this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
          }
          lastCode = code;
          continue;
        }
        if (code >= 97) {
          val = code - 97 + 10;
        } else if (code >= 65) {
          val = code - 65 + 10;
        } else if (code >= 48 && code <= 57) {
          val = code - 48;
        } else {
          val = Infinity;
        }
        if (val >= radix) {
          break;
        }
        lastCode = code;
        total = total * radix + val;
      }
      if (allowSeparators && lastCode === 95) {
        this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
      }
      if (this.pos === start || len != null && this.pos - start !== len) {
        return null;
      }
      return total;
    };
    function stringToNumber(str, isLegacyOctalNumericLiteral) {
      if (isLegacyOctalNumericLiteral) {
        return parseInt(str, 8);
      }
      return parseFloat(str.replace(/_/g, ""));
    }
    function stringToBigInt(str) {
      if (typeof BigInt !== "function") {
        return null;
      }
      return BigInt(str.replace(/_/g, ""));
    }
    pp.readRadixNumber = function(radix) {
      var start = this.pos;
      this.pos += 2;
      var val = this.readInt(radix);
      if (val == null) {
        this.raise(this.start + 2, "Expected number in radix " + radix);
      }
      if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
        val = stringToBigInt(this.input.slice(start, this.pos));
        ++this.pos;
      } else if (isIdentifierStart(this.fullCharCodeAtPos())) {
        this.raise(this.pos, "Identifier directly after number");
      }
      return this.finishToken(types$1.num, val);
    };
    pp.readNumber = function(startsWithDot) {
      var start = this.pos;
      if (!startsWithDot && this.readInt(10, void 0, true) === null) {
        this.raise(start, "Invalid number");
      }
      var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
      if (octal && this.strict) {
        this.raise(start, "Invalid number");
      }
      var next = this.input.charCodeAt(this.pos);
      if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
        var val$1 = stringToBigInt(this.input.slice(start, this.pos));
        ++this.pos;
        if (isIdentifierStart(this.fullCharCodeAtPos())) {
          this.raise(this.pos, "Identifier directly after number");
        }
        return this.finishToken(types$1.num, val$1);
      }
      if (octal && /[89]/.test(this.input.slice(start, this.pos))) {
        octal = false;
      }
      if (next === 46 && !octal) {
        ++this.pos;
        this.readInt(10);
        next = this.input.charCodeAt(this.pos);
      }
      if ((next === 69 || next === 101) && !octal) {
        next = this.input.charCodeAt(++this.pos);
        if (next === 43 || next === 45) {
          ++this.pos;
        }
        if (this.readInt(10) === null) {
          this.raise(start, "Invalid number");
        }
      }
      if (isIdentifierStart(this.fullCharCodeAtPos())) {
        this.raise(this.pos, "Identifier directly after number");
      }
      var val = stringToNumber(this.input.slice(start, this.pos), octal);
      return this.finishToken(types$1.num, val);
    };
    pp.readCodePoint = function() {
      var ch2 = this.input.charCodeAt(this.pos), code;
      if (ch2 === 123) {
        if (this.options.ecmaVersion < 6) {
          this.unexpected();
        }
        var codePos = ++this.pos;
        code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
        ++this.pos;
        if (code > 1114111) {
          this.invalidStringToken(codePos, "Code point out of bounds");
        }
      } else {
        code = this.readHexChar(4);
      }
      return code;
    };
    function codePointToString(code) {
      if (code <= 65535) {
        return String.fromCharCode(code);
      }
      code -= 65536;
      return String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
    }
    pp.readString = function(quote) {
      var out2 = "", chunkStart = ++this.pos;
      for (; ; ) {
        if (this.pos >= this.input.length) {
          this.raise(this.start, "Unterminated string constant");
        }
        var ch2 = this.input.charCodeAt(this.pos);
        if (ch2 === quote) {
          break;
        }
        if (ch2 === 92) {
          out2 += this.input.slice(chunkStart, this.pos);
          out2 += this.readEscapedChar(false);
          chunkStart = this.pos;
        } else if (ch2 === 8232 || ch2 === 8233) {
          if (this.options.ecmaVersion < 10) {
            this.raise(this.start, "Unterminated string constant");
          }
          ++this.pos;
          if (this.options.locations) {
            this.curLine++;
            this.lineStart = this.pos;
          }
        } else {
          if (isNewLine(ch2)) {
            this.raise(this.start, "Unterminated string constant");
          }
          ++this.pos;
        }
      }
      out2 += this.input.slice(chunkStart, this.pos++);
      return this.finishToken(types$1.string, out2);
    };
    var INVALID_TEMPLATE_ESCAPE_ERROR = {};
    pp.tryReadTemplateToken = function() {
      this.inTemplateElement = true;
      try {
        this.readTmplToken();
      } catch (err) {
        if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
          this.readInvalidTemplateToken();
        } else {
          throw err;
        }
      }
      this.inTemplateElement = false;
    };
    pp.invalidStringToken = function(position, message) {
      if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
        throw INVALID_TEMPLATE_ESCAPE_ERROR;
      } else {
        this.raise(position, message);
      }
    };
    pp.readTmplToken = function() {
      var out2 = "", chunkStart = this.pos;
      for (; ; ) {
        if (this.pos >= this.input.length) {
          this.raise(this.start, "Unterminated template");
        }
        var ch2 = this.input.charCodeAt(this.pos);
        if (ch2 === 96 || ch2 === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
          if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {
            if (ch2 === 36) {
              this.pos += 2;
              return this.finishToken(types$1.dollarBraceL);
            } else {
              ++this.pos;
              return this.finishToken(types$1.backQuote);
            }
          }
          out2 += this.input.slice(chunkStart, this.pos);
          return this.finishToken(types$1.template, out2);
        }
        if (ch2 === 92) {
          out2 += this.input.slice(chunkStart, this.pos);
          out2 += this.readEscapedChar(true);
          chunkStart = this.pos;
        } else if (isNewLine(ch2)) {
          out2 += this.input.slice(chunkStart, this.pos);
          ++this.pos;
          switch (ch2) {
            case 13:
              if (this.input.charCodeAt(this.pos) === 10) {
                ++this.pos;
              }
            case 10:
              out2 += "\n";
              break;
            default:
              out2 += String.fromCharCode(ch2);
              break;
          }
          if (this.options.locations) {
            ++this.curLine;
            this.lineStart = this.pos;
          }
          chunkStart = this.pos;
        } else {
          ++this.pos;
        }
      }
    };
    pp.readInvalidTemplateToken = function() {
      for (; this.pos < this.input.length; this.pos++) {
        switch (this.input[this.pos]) {
          case "\\":
            ++this.pos;
            break;
          case "$":
            if (this.input[this.pos + 1] !== "{") {
              break;
            }
          case "`":
            return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos));
        }
      }
      this.raise(this.start, "Unterminated template");
    };
    pp.readEscapedChar = function(inTemplate) {
      var ch2 = this.input.charCodeAt(++this.pos);
      ++this.pos;
      switch (ch2) {
        case 110:
          return "\n";
        case 114:
          return "\r";
        case 120:
          return String.fromCharCode(this.readHexChar(2));
        case 117:
          return codePointToString(this.readCodePoint());
        case 116:
          return "	";
        case 98:
          return "\b";
        case 118:
          return "\v";
        case 102:
          return "\f";
        case 13:
          if (this.input.charCodeAt(this.pos) === 10) {
            ++this.pos;
          }
        case 10:
          if (this.options.locations) {
            this.lineStart = this.pos;
            ++this.curLine;
          }
          return "";
        case 56:
        case 57:
          if (this.strict) {
            this.invalidStringToken(this.pos - 1, "Invalid escape sequence");
          }
          if (inTemplate) {
            var codePos = this.pos - 1;
            this.invalidStringToken(codePos, "Invalid escape sequence in template string");
            return null;
          }
        default:
          if (ch2 >= 48 && ch2 <= 55) {
            var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
            var octal = parseInt(octalStr, 8);
            if (octal > 255) {
              octalStr = octalStr.slice(0, -1);
              octal = parseInt(octalStr, 8);
            }
            this.pos += octalStr.length - 1;
            ch2 = this.input.charCodeAt(this.pos);
            if ((octalStr !== "0" || ch2 === 56 || ch2 === 57) && (this.strict || inTemplate)) {
              this.invalidStringToken(this.pos - 1 - octalStr.length, inTemplate ? "Octal literal in template string" : "Octal literal in strict mode");
            }
            return String.fromCharCode(octal);
          }
          if (isNewLine(ch2)) {
            return "";
          }
          return String.fromCharCode(ch2);
      }
    };
    pp.readHexChar = function(len) {
      var codePos = this.pos;
      var n3 = this.readInt(16, len);
      if (n3 === null) {
        this.invalidStringToken(codePos, "Bad character escape sequence");
      }
      return n3;
    };
    pp.readWord1 = function() {
      this.containsEsc = false;
      var word = "", first2 = true, chunkStart = this.pos;
      var astral = this.options.ecmaVersion >= 6;
      while (this.pos < this.input.length) {
        var ch2 = this.fullCharCodeAtPos();
        if (isIdentifierChar(ch2, astral)) {
          this.pos += ch2 <= 65535 ? 1 : 2;
        } else if (ch2 === 92) {
          this.containsEsc = true;
          word += this.input.slice(chunkStart, this.pos);
          var escStart = this.pos;
          if (this.input.charCodeAt(++this.pos) !== 117) {
            this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
          }
          ++this.pos;
          var esc = this.readCodePoint();
          if (!(first2 ? isIdentifierStart : isIdentifierChar)(esc, astral)) {
            this.invalidStringToken(escStart, "Invalid Unicode escape");
          }
          word += codePointToString(esc);
          chunkStart = this.pos;
        } else {
          break;
        }
        first2 = false;
      }
      return word + this.input.slice(chunkStart, this.pos);
    };
    pp.readWord = function() {
      var word = this.readWord1();
      var type = types$1.name;
      if (this.keywords.test(word)) {
        type = keywords[word];
      }
      return this.finishToken(type, word);
    };
    var version = "8.7.0";
    Parser.acorn = {
      Parser,
      version,
      defaultOptions,
      Position,
      SourceLocation,
      getLineInfo,
      Node,
      TokenType,
      tokTypes: types$1,
      keywordTypes: keywords,
      TokContext,
      tokContexts: types,
      isIdentifierChar,
      isIdentifierStart,
      Token,
      isNewLine,
      lineBreak,
      lineBreakG,
      nonASCIIwhitespace
    };
    function parse$d(input, options2) {
      return Parser.parse(input, options2);
    }
    function parseExpressionAt(input, pos2, options2) {
      return Parser.parseExpressionAt(input, pos2, options2);
    }
    function tokenizer(input, options2) {
      return Parser.tokenizer(input, options2);
    }
    var acorn = {
      __proto__: null,
      Node,
      Parser,
      Position,
      SourceLocation,
      TokContext,
      Token,
      TokenType,
      defaultOptions,
      getLineInfo,
      isIdentifierChar,
      isIdentifierStart,
      isNewLine,
      keywordTypes: keywords,
      lineBreak,
      lineBreakG,
      nonASCIIwhitespace,
      parse: parse$d,
      parseExpressionAt,
      tokContexts: types,
      tokTypes: types$1,
      tokenizer,
      version
    };
    var ansiRegex$1 = ({ onlyFirst = false } = {}) => {
      const pattern2 = [
        "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
        "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
      ].join("|");
      return new RegExp(pattern2, onlyFirst ? void 0 : "g");
    };
    var ansiRegex = ansiRegex$1;
    var stripAnsi = (string2) => typeof string2 === "string" ? string2.replace(ansiRegex(), "") : string2;
    function prepareError(err) {
      return {
        message: stripAnsi(err.message),
        stack: stripAnsi(cleanStack(err.stack || "")),
        id: err.id,
        frame: stripAnsi(err.frame || ""),
        plugin: err.plugin,
        pluginCode: err.pluginCode,
        loc: err.loc
      };
    }
    function buildErrorMessage(err, args = [], includeStack = true) {
      if (err.plugin)
        args.push(`  Plugin: ${colors$1.magenta(err.plugin)}`);
      if (err.id)
        args.push(`  File: ${colors$1.cyan(err.id)}`);
      if (err.frame)
        args.push(colors$1.yellow(pad$1(err.frame)));
      if (includeStack && err.stack)
        args.push(pad$1(cleanStack(err.stack)));
      return args.join("\n");
    }
    function cleanStack(stack2) {
      return stack2.split(/\n/g).filter((l2) => /^\s*at/.test(l2)).join("\n");
    }
    function logError(server2, err) {
      const msg = buildErrorMessage(err, [
        colors$1.red(`Internal server error: ${err.message}`)
      ]);
      server2.config.logger.error(msg, {
        clear: true,
        timestamp: true,
        error: err
      });
      server2.ws.send({
        type: "error",
        err: prepareError(err)
      });
    }
    function errorMiddleware(server2, allowNext = false) {
      return function viteErrorMiddleware(err, _req, res, next) {
        logError(server2, err);
        if (allowNext) {
          next();
        } else {
          res.statusCode = 500;
          res.end(`
        <!DOCTYPE html>
        <html lang="en">
          <head>
            <meta charset="UTF-8" />
            <title>Error</title>
            <script type="module">
              import { ErrorOverlay } from '/@vite/client'
              document.body.appendChild(new ErrorOverlay(${JSON.stringify(prepareError(err)).replace(/</g, "\\u003c")}))
            <\/script>
          </head>
          <body>
          </body>
        </html>
      `);
        }
      };
    }
    var parser = Parser;
    async function createPluginContainer({ plugins: plugins2, logger, root: root2, build: { rollupOptions } }, moduleGraph, watcher) {
      const isDebug2 = process.env.DEBUG;
      const seenResolves = {};
      const debugResolve = createDebugger("vite:resolve");
      const debugPluginResolve = createDebugger("vite:plugin-resolve", {
        onlyWhenFocused: "vite:plugin"
      });
      const debugPluginTransform = createDebugger("vite:plugin-transform", {
        onlyWhenFocused: "vite:plugin"
      });
      const watchFiles = /* @__PURE__ */ new Set();
      const rollupPkgPath = path$r.resolve(__require.resolve("rollup"), "../../package.json");
      const minimalContext = {
        meta: {
          rollupVersion: JSON.parse(fs__default.readFileSync(rollupPkgPath, "utf-8")).version,
          watchMode: true
        }
      };
      function warnIncompatibleMethod(method, plugin) {
        logger.warn(colors$1.cyan(`[plugin:${plugin}] `) + colors$1.yellow(`context method ${colors$1.bold(`${method}()`)} is not supported in serve mode. This plugin is likely not vite-compatible.`));
      }
      const ModuleInfoProxy = {
        get(info, key2) {
          if (key2 in info) {
            return info[key2];
          }
          throw Error(`[vite] The "${key2}" property of ModuleInfo is not supported.`);
        }
      };
      const EMPTY_OBJECT = Object.freeze({});
      function getModuleInfo(id) {
        const module2 = moduleGraph === null || moduleGraph === void 0 ? void 0 : moduleGraph.getModuleById(id);
        if (!module2) {
          return null;
        }
        if (!module2.info) {
          module2.info = new Proxy({ id, meta: module2.meta || EMPTY_OBJECT }, ModuleInfoProxy);
        }
        return module2.info;
      }
      function updateModuleInfo(id, { meta }) {
        if (meta) {
          const moduleInfo = getModuleInfo(id);
          if (moduleInfo) {
            moduleInfo.meta = __spreadValues2(__spreadValues2({}, moduleInfo.meta), meta);
          }
        }
      }
      class Context {
        constructor(initialPlugin) {
          this.meta = minimalContext.meta;
          this.ssr = false;
          this._scan = false;
          this._activeId = null;
          this._activeCode = null;
          this._addedImports = null;
          this._activePlugin = initialPlugin || null;
        }
        parse(code, opts = {}) {
          return parser.parse(code, __spreadValues2({
            sourceType: "module",
            ecmaVersion: "latest",
            locations: true
          }, opts));
        }
        async resolve(id, importer, options2) {
          let skip;
          if ((options2 === null || options2 === void 0 ? void 0 : options2.skipSelf) && this._activePlugin) {
            skip = new Set(this._resolveSkips);
            skip.add(this._activePlugin);
          }
          let out2 = await container.resolveId(id, importer, {
            skip,
            ssr: this.ssr,
            scan: this._scan
          });
          if (typeof out2 === "string")
            out2 = { id: out2 };
          return out2;
        }
        getModuleInfo(id) {
          return getModuleInfo(id);
        }
        getModuleIds() {
          return moduleGraph ? moduleGraph.idToModuleMap.keys() : Array.prototype[Symbol.iterator]();
        }
        addWatchFile(id) {
          watchFiles.add(id);
          (this._addedImports || (this._addedImports = /* @__PURE__ */ new Set())).add(id);
          if (watcher)
            ensureWatchedFile(watcher, id, root2);
        }
        getWatchFiles() {
          return [...watchFiles];
        }
        emitFile(assetOrFile) {
          warnIncompatibleMethod(`emitFile`, this._activePlugin.name);
          return "";
        }
        setAssetSource() {
          warnIncompatibleMethod(`setAssetSource`, this._activePlugin.name);
        }
        getFileName() {
          warnIncompatibleMethod(`getFileName`, this._activePlugin.name);
          return "";
        }
        warn(e2, position) {
          const err = formatError(e2, position, this);
          const msg = buildErrorMessage(err, [colors$1.yellow(`warning: ${err.message}`)], false);
          logger.warn(msg, {
            clear: true,
            timestamp: true
          });
        }
        error(e2, position) {
          throw formatError(e2, position, this);
        }
      }
      function formatError(e2, position, ctx) {
        const err = typeof e2 === "string" ? new Error(e2) : e2;
        if (err.pluginCode) {
          return err;
        }
        if (err.file && err.name === "CssSyntaxError") {
          err.id = normalizePath$4(err.file);
        }
        if (ctx._activePlugin)
          err.plugin = ctx._activePlugin.name;
        if (ctx._activeId && !err.id)
          err.id = ctx._activeId;
        if (ctx._activeCode) {
          err.pluginCode = ctx._activeCode;
          const pos2 = position != null ? position : err.pos != null ? err.pos : err.position;
          if (pos2 != null) {
            let errLocation;
            try {
              errLocation = numberToPos(ctx._activeCode, pos2);
            } catch (err2) {
              logger.error(colors$1.red(`Error in error handler:
${err2.stack || err2.message}
`), { error: err2 });
              throw err;
            }
            err.loc = err.loc || __spreadValues2({
              file: err.id
            }, errLocation);
            err.frame = err.frame || generateCodeFrame(ctx._activeCode, pos2);
          } else if (err.loc) {
            if (!err.frame) {
              let code = ctx._activeCode;
              if (err.loc.file) {
                err.id = normalizePath$4(err.loc.file);
                try {
                  code = fs__default.readFileSync(err.loc.file, "utf-8");
                } catch {
                }
              }
              err.frame = generateCodeFrame(code, err.loc);
            }
          } else if (err.line && err.column) {
            err.loc = {
              file: err.id,
              line: err.line,
              column: err.column
            };
            err.frame = err.frame || generateCodeFrame(err.id, err.loc);
          }
          if (err.loc && ctx instanceof TransformContext) {
            const rawSourceMap = ctx._getCombinedSourcemap();
            if (rawSourceMap) {
              const traced = new TraceMap(rawSourceMap);
              const { source: source2, line: line2, column: column2 } = originalPositionFor(traced, {
                line: Number(err.loc.line),
                column: Number(err.loc.column)
              });
              if (source2 && line2 != null && column2 != null) {
                err.loc = { file: source2, line: line2, column: column2 };
              }
            }
          }
        }
        return err;
      }
      class TransformContext extends Context {
        constructor(filename2, code, inMap) {
          super();
          this.originalSourcemap = null;
          this.sourcemapChain = [];
          this.combinedMap = null;
          this.filename = filename2;
          this.originalCode = code;
          if (inMap) {
            this.sourcemapChain.push(inMap);
          }
        }
        _getCombinedSourcemap(createIfNull = false) {
          let combinedMap = this.combinedMap;
          for (let m3 of this.sourcemapChain) {
            if (typeof m3 === "string")
              m3 = JSON.parse(m3);
            if (!("version" in m3)) {
              combinedMap = this.combinedMap = null;
              this.sourcemapChain.length = 0;
              break;
            }
            if (!combinedMap) {
              combinedMap = m3;
            } else {
              combinedMap = combineSourcemaps(cleanUrl(this.filename), [
                __spreadProps2(__spreadValues2({}, m3), {
                  sourcesContent: combinedMap.sourcesContent
                }),
                combinedMap
              ]);
            }
          }
          if (!combinedMap) {
            return createIfNull ? new MagicString(this.originalCode).generateMap({
              includeContent: true,
              hires: true,
              source: cleanUrl(this.filename)
            }) : null;
          }
          if (combinedMap !== this.combinedMap) {
            this.combinedMap = combinedMap;
            this.sourcemapChain.length = 0;
          }
          return this.combinedMap;
        }
        getCombinedSourcemap() {
          return this._getCombinedSourcemap(true);
        }
      }
      let closed = false;
      const container = {
        options: await (async () => {
          let options2 = rollupOptions;
          for (const plugin of plugins2) {
            if (!plugin.options)
              continue;
            options2 = await plugin.options.call(minimalContext, options2) || options2;
          }
          if (options2.acornInjectPlugins) {
            parser = Parser.extend(options2.acornInjectPlugins);
          }
          return __spreadValues2({
            acorn,
            acornInjectPlugins: []
          }, options2);
        })(),
        getModuleInfo,
        async buildStart() {
          await Promise.all(plugins2.map((plugin) => {
            if (plugin.buildStart) {
              return plugin.buildStart.call(new Context(plugin), container.options);
            }
          }));
        },
        async resolveId(rawId, importer = path$r.join(root2, "index.html"), options2) {
          const skip = options2 === null || options2 === void 0 ? void 0 : options2.skip;
          const ssr = options2 === null || options2 === void 0 ? void 0 : options2.ssr;
          const scan2 = !!(options2 === null || options2 === void 0 ? void 0 : options2.scan);
          const ctx = new Context();
          ctx.ssr = !!ssr;
          ctx._scan = scan2;
          ctx._resolveSkips = skip;
          const resolveStart = isDebug2 ? perf_hooks.performance.now() : 0;
          let id = null;
          const partial2 = {};
          for (const plugin of plugins2) {
            if (!plugin.resolveId)
              continue;
            if (skip === null || skip === void 0 ? void 0 : skip.has(plugin))
              continue;
            ctx._activePlugin = plugin;
            const pluginResolveStart = isDebug2 ? perf_hooks.performance.now() : 0;
            const result2 = await plugin.resolveId.call(ctx, rawId, importer, { ssr, scan: scan2 });
            if (!result2)
              continue;
            if (typeof result2 === "string") {
              id = result2;
            } else {
              id = result2.id;
              Object.assign(partial2, result2);
            }
            isDebug2 && debugPluginResolve(timeFrom(pluginResolveStart), plugin.name, prettifyUrl(id, root2));
            break;
          }
          if (isDebug2 && rawId !== id && !rawId.startsWith(FS_PREFIX)) {
            const key2 = rawId + id;
            if (!seenResolves[key2]) {
              seenResolves[key2] = true;
              debugResolve(`${timeFrom(resolveStart)} ${colors$1.cyan(rawId)} -> ${colors$1.dim(id)}`);
            }
          }
          if (id) {
            partial2.id = isExternalUrl(id) ? id : normalizePath$4(id);
            return partial2;
          } else {
            return null;
          }
        },
        async load(id, options2) {
          const ssr = options2 === null || options2 === void 0 ? void 0 : options2.ssr;
          const ctx = new Context();
          ctx.ssr = !!ssr;
          for (const plugin of plugins2) {
            if (!plugin.load)
              continue;
            ctx._activePlugin = plugin;
            const result2 = await plugin.load.call(ctx, id, { ssr });
            if (result2 != null) {
              if (isObject$5(result2)) {
                updateModuleInfo(id, result2);
              }
              return result2;
            }
          }
          return null;
        },
        async transform(code, id, options2) {
          const inMap = options2 === null || options2 === void 0 ? void 0 : options2.inMap;
          const ssr = options2 === null || options2 === void 0 ? void 0 : options2.ssr;
          const ctx = new TransformContext(id, code, inMap);
          ctx.ssr = !!ssr;
          for (const plugin of plugins2) {
            if (!plugin.transform)
              continue;
            ctx._activePlugin = plugin;
            ctx._activeId = id;
            ctx._activeCode = code;
            const start = isDebug2 ? perf_hooks.performance.now() : 0;
            let result2;
            try {
              result2 = await plugin.transform.call(ctx, code, id, { ssr });
            } catch (e2) {
              ctx.error(e2);
            }
            if (!result2)
              continue;
            isDebug2 && debugPluginTransform(timeFrom(start), plugin.name, prettifyUrl(id, root2));
            if (isObject$5(result2)) {
              if (result2.code !== void 0) {
                code = result2.code;
                if (result2.map) {
                  ctx.sourcemapChain.push(result2.map);
                }
              }
              updateModuleInfo(id, result2);
            } else {
              code = result2;
            }
          }
          return {
            code,
            map: ctx._getCombinedSourcemap()
          };
        },
        async close() {
          if (closed)
            return;
          const ctx = new Context();
          await Promise.all(plugins2.map((p2) => p2.buildEnd && p2.buildEnd.call(ctx)));
          await Promise.all(plugins2.map((p2) => p2.closeBundle && p2.closeBundle.call(ctx)));
          closed = true;
        }
      };
      return container;
    }
    var debug$d = createDebugger("vite:deps");
    var htmlTypesRE = /\.(html|vue|svelte|astro)$/;
    var importsRE = /(?<!\/\/.*)(?<=^|;|\*\/)\s*import(?!\s+type)(?:[\w*{}\n\r\t, ]+from\s*)?\s*("[^"]+"|'[^']+')\s*(?=$|;|\/\/|\/\*)/gm;
    async function scanImports(config2) {
      var _a2, _b, _c;
      const start = perf_hooks.performance.now();
      let entries = [];
      const explicitEntryPatterns = config2.optimizeDeps.entries;
      const buildInput = (_a2 = config2.build.rollupOptions) === null || _a2 === void 0 ? void 0 : _a2.input;
      if (explicitEntryPatterns) {
        entries = await globEntries(explicitEntryPatterns, config2);
      } else if (buildInput) {
        const resolvePath = (p2) => path__default.resolve(config2.root, p2);
        if (typeof buildInput === "string") {
          entries = [resolvePath(buildInput)];
        } else if (Array.isArray(buildInput)) {
          entries = buildInput.map(resolvePath);
        } else if (isObject$5(buildInput)) {
          entries = Object.values(buildInput).map(resolvePath);
        } else {
          throw new Error("invalid rollupOptions.input value.");
        }
      } else {
        entries = await globEntries("**/*.html", config2);
      }
      entries = entries.filter((entry2) => (JS_TYPES_RE.test(entry2) || htmlTypesRE.test(entry2)) && fs__default.existsSync(entry2));
      if (!entries.length) {
        if (!explicitEntryPatterns && !config2.optimizeDeps.include) {
          config2.logger.warn(colors$1.yellow("(!) Could not auto-determine entry point from rollupOptions or html files and there are no explicit optimizeDeps.include patterns. Skipping dependency pre-bundling."));
        }
        return { deps: {}, missing: {} };
      } else {
        debug$d(`Crawling dependencies using entries:
  ${entries.join("\n  ")}`);
      }
      const deps = {};
      const missing = {};
      const container = await createPluginContainer(config2);
      const plugin = esbuildScanPlugin(config2, container, deps, missing, entries);
      const _a3 = (_c = (_b = config2.optimizeDeps) === null || _b === void 0 ? void 0 : _b.esbuildOptions) !== null && _c !== void 0 ? _c : {}, { plugins: plugins2 = [] } = _a3, esbuildOptions = __objRest(_a3, ["plugins"]);
      await Promise.all(entries.map((entry2) => esbuild.build(__spreadValues2({
        absWorkingDir: process.cwd(),
        write: false,
        entryPoints: [entry2],
        bundle: true,
        format: "esm",
        logLevel: "error",
        plugins: [...plugins2, plugin]
      }, esbuildOptions))));
      debug$d(`Scan completed in ${(perf_hooks.performance.now() - start).toFixed(2)}ms:`, deps);
      return {
        deps: orderedDependencies(deps),
        missing
      };
    }
    function orderedDependencies(deps) {
      const depsList = Object.entries(deps);
      depsList.sort((a2, b2) => a2[0].localeCompare(b2[0]));
      return Object.fromEntries(depsList);
    }
    function globEntries(pattern2, config2) {
      return out(pattern2, {
        cwd: config2.root,
        ignore: [
          "**/node_modules/**",
          `**/${config2.build.outDir}/**`,
          ...config2.optimizeDeps.entries ? [] : [`**/__tests__/**`, `**/coverage/**`]
        ],
        absolute: true
      });
    }
    var scriptModuleRE = /(<script\b[^>]*type\s*=\s*(?:"module"|'module')[^>]*>)(.*?)<\/script>/gims;
    var scriptRE = /(<script\b(?:\s[^>]*>|>))(.*?)<\/script>/gims;
    var commentRE = /<!--.*?-->/gs;
    var srcRE = /\bsrc\s*=\s*(?:"([^"]+)"|'([^']+)'|([^\s'">]+))/im;
    var typeRE = /\btype\s*=\s*(?:"([^"]+)"|'([^']+)'|([^\s'">]+))/im;
    var langRE = /\blang\s*=\s*(?:"([^"]+)"|'([^']+)'|([^\s'">]+))/im;
    var contextRE = /\bcontext\s*=\s*(?:"([^"]+)"|'([^']+)'|([^\s'">]+))/im;
    function esbuildScanPlugin(config2, container, depImports, missing, entries) {
      var _a2, _b;
      const seen2 = /* @__PURE__ */ new Map();
      const resolve2 = async (id, importer) => {
        const key2 = id + (importer && path__default.dirname(importer));
        if (seen2.has(key2)) {
          return seen2.get(key2);
        }
        const resolved = await container.resolveId(id, importer && normalizePath$4(importer), {
          scan: true
        });
        const res = resolved === null || resolved === void 0 ? void 0 : resolved.id;
        seen2.set(key2, res);
        return res;
      };
      const include = (_a2 = config2.optimizeDeps) === null || _a2 === void 0 ? void 0 : _a2.include;
      const exclude = [
        ...((_b = config2.optimizeDeps) === null || _b === void 0 ? void 0 : _b.exclude) || [],
        "@vite/client",
        "@vite/env"
      ];
      const isOptimizable = (id) => {
        var _a3;
        return OPTIMIZABLE_ENTRY_RE.test(id) || !!((_a3 = config2.optimizeDeps.extensions) === null || _a3 === void 0 ? void 0 : _a3.some((ext2) => id.endsWith(ext2)));
      };
      const externalUnlessEntry = ({ path: path2 }) => ({
        path: path2,
        external: !entries.includes(path2)
      });
      return {
        name: "vite:dep-scan",
        setup(build2) {
          const scripts = {};
          build2.onResolve({ filter: externalRE }, ({ path: path2 }) => ({
            path: path2,
            external: true
          }));
          build2.onResolve({ filter: dataUrlRE }, ({ path: path2 }) => ({
            path: path2,
            external: true
          }));
          build2.onResolve({ filter: virtualModuleRE }, ({ path: path2 }) => {
            return {
              path: path2.replace(virtualModulePrefix, ""),
              namespace: "script"
            };
          });
          build2.onLoad({ filter: /.*/, namespace: "script" }, ({ path: path2 }) => {
            return scripts[path2];
          });
          build2.onResolve({ filter: htmlTypesRE }, async ({ path: path2, importer }) => {
            const resolved = await resolve2(path2, importer);
            if (!resolved)
              return;
            if (resolved.includes("node_modules") && isOptimizable(resolved))
              return;
            return {
              path: resolved,
              namespace: "html"
            };
          });
          build2.onLoad({ filter: htmlTypesRE, namespace: "html" }, async ({ path: path2 }) => {
            let raw = fs__default.readFileSync(path2, "utf-8");
            raw = raw.replace(commentRE, "<!---->");
            const isHtml = path2.endsWith(".html");
            const regex = isHtml ? scriptModuleRE : scriptRE;
            regex.lastIndex = 0;
            let js2 = "";
            let scriptId = 0;
            let match2;
            while (match2 = regex.exec(raw)) {
              const [, openTag, content2] = match2;
              const typeMatch = openTag.match(typeRE);
              const type = typeMatch && (typeMatch[1] || typeMatch[2] || typeMatch[3]);
              const langMatch = openTag.match(langRE);
              const lang = langMatch && (langMatch[1] || langMatch[2] || langMatch[3]);
              if (type && !(type.includes("javascript") || type.includes("ecmascript") || type === "module")) {
                continue;
              }
              let loader = "js";
              if (lang === "ts" || lang === "tsx" || lang === "jsx") {
                loader = lang;
              }
              const srcMatch = openTag.match(srcRE);
              if (srcMatch) {
                const src2 = srcMatch[1] || srcMatch[2] || srcMatch[3];
                js2 += `import ${JSON.stringify(src2)}
`;
              } else if (content2.trim()) {
                const contents = content2 + (loader.startsWith("ts") ? extractImportPaths(content2) : "");
                const key2 = `${path2}?id=${scriptId++}`;
                if (contents.includes("import.meta.glob")) {
                  scripts[key2] = {
                    loader: "js",
                    contents: await transformGlob(contents, path2, config2.root, loader, resolve2, config2.logger)
                  };
                } else {
                  scripts[key2] = {
                    loader,
                    contents
                  };
                }
                const virtualModulePath = JSON.stringify(virtualModulePrefix + key2);
                const contextMatch = openTag.match(contextRE);
                const context2 = contextMatch && (contextMatch[1] || contextMatch[2] || contextMatch[3]);
                if (path2.endsWith(".svelte") && context2 !== "module") {
                  js2 += `import ${virtualModulePath}
`;
                } else {
                  js2 += `export * from ${virtualModulePath}
`;
                }
              }
            }
            if (!path2.endsWith(".vue") || !js2.includes("export default")) {
              js2 += "\nexport default {}";
            }
            return {
              loader: "js",
              contents: js2
            };
          });
          build2.onResolve({
            filter: /^[\w@][^:]/
          }, async ({ path: id, importer }) => {
            if (moduleListContains(exclude, id)) {
              return externalUnlessEntry({ path: id });
            }
            if (depImports[id]) {
              return externalUnlessEntry({ path: id });
            }
            const resolved = await resolve2(id, importer);
            if (resolved) {
              if (shouldExternalizeDep(resolved, id)) {
                return externalUnlessEntry({ path: id });
              }
              if (resolved.includes("node_modules") || (include === null || include === void 0 ? void 0 : include.includes(id))) {
                if (isOptimizable(resolved)) {
                  depImports[id] = resolved;
                }
                return externalUnlessEntry({ path: id });
              } else if (isScannable(resolved)) {
                const namespace = htmlTypesRE.test(resolved) ? "html" : void 0;
                return {
                  path: path__default.resolve(resolved),
                  namespace
                };
              } else {
                return externalUnlessEntry({ path: id });
              }
            } else {
              missing[id] = normalizePath$4(importer);
            }
          });
          build2.onResolve({
            filter: /\.(css|less|sass|scss|styl|stylus|pcss|postcss|json)$/
          }, externalUnlessEntry);
          build2.onResolve({
            filter: new RegExp(`\\.(${KNOWN_ASSET_TYPES.join("|")})$`)
          }, externalUnlessEntry);
          build2.onResolve({ filter: SPECIAL_QUERY_RE }, ({ path: path2 }) => ({
            path: path2,
            external: true
          }));
          build2.onResolve({
            filter: /.*/
          }, async ({ path: id, importer }) => {
            const resolved = await resolve2(id, importer);
            if (resolved) {
              if (shouldExternalizeDep(resolved, id) || !isScannable(resolved)) {
                return externalUnlessEntry({ path: id });
              }
              const namespace = htmlTypesRE.test(resolved) ? "html" : void 0;
              return {
                path: path__default.resolve(cleanUrl(resolved)),
                namespace
              };
            } else {
              return externalUnlessEntry({ path: id });
            }
          });
          build2.onLoad({ filter: JS_TYPES_RE }, ({ path: id }) => {
            let ext2 = path__default.extname(id).slice(1);
            if (ext2 === "mjs")
              ext2 = "js";
            let contents = fs__default.readFileSync(id, "utf-8");
            if (ext2.endsWith("x") && config2.esbuild && config2.esbuild.jsxInject) {
              contents = config2.esbuild.jsxInject + `
` + contents;
            }
            if (contents.includes("import.meta.glob")) {
              return transformGlob(contents, id, config2.root, ext2, resolve2, config2.logger).then((contents2) => ({
                loader: ext2,
                contents: contents2
              }));
            }
            return {
              loader: ext2,
              contents
            };
          });
        }
      };
    }
    async function transformGlob(source2, importer, root2, loader, resolve2, logger) {
      if (loader !== "js") {
        source2 = (await esbuild.transform(source2, { loader })).code;
      }
      await init;
      const imports = parse$h(source2)[0];
      const s2 = new MagicString(source2);
      for (let index2 = 0; index2 < imports.length; index2++) {
        const { s: start, e: end, ss: expStart } = imports[index2];
        const url2 = source2.slice(start, end);
        if (url2 !== "import.meta")
          continue;
        if (source2.slice(end, end + 5) !== ".glob")
          continue;
        const { importsString, exp, endIndex } = await transformImportGlob(source2, start, normalizePath$4(importer), index2, root2, logger, void 0, resolve2);
        s2.prepend(importsString);
        s2.overwrite(expStart, endIndex, exp, { contentOnly: true });
      }
      return s2.toString();
    }
    function extractImportPaths(code) {
      code = code.replace(multilineCommentsRE, "/* */").replace(singlelineCommentsRE, "");
      let js2 = "";
      let m3;
      while ((m3 = importsRE.exec(code)) != null) {
        if (m3.index === importsRE.lastIndex) {
          importsRE.lastIndex++;
        }
        js2 += `
import ${m3[1]}`;
      }
      return js2;
    }
    function shouldExternalizeDep(resolvedId, rawId) {
      if (!path__default.isAbsolute(resolvedId)) {
        return true;
      }
      if (resolvedId === rawId || resolvedId.includes("\0")) {
        return true;
      }
      return false;
    }
    function isScannable(id) {
      return JS_TYPES_RE.test(id) || htmlTypesRE.test(id);
    }
    var debuggerViteDeps = createDebugger("vite:deps");
    var debug$c = debuggerViteDeps;
    var isDebugEnabled$1 = _debug("vite:deps").enabled;
    var jsExtensionRE = /\.js$/i;
    var jsMapExtensionRE = /\.js\.map$/i;
    async function optimizeDeps(config2, force = config2.server.force, asCommand = false) {
      const log2 = asCommand ? config2.logger.info : debug$c;
      const cachedMetadata = loadCachedDepOptimizationMetadata(config2, force, asCommand);
      if (cachedMetadata) {
        return cachedMetadata;
      }
      const depsInfo = await discoverProjectDependencies(config2);
      const depsString = depsLogString(Object.keys(depsInfo));
      log2(colors$1.green(`Optimizing dependencies:
  ${depsString}`));
      const result2 = await runOptimizeDeps(config2, depsInfo);
      result2.commit();
      return result2.metadata;
    }
    function createOptimizedDepsMetadata(config2, timestamp2) {
      const hash = getDepHash(config2);
      return {
        hash,
        browserHash: getOptimizedBrowserHash(hash, {}, timestamp2),
        optimized: {},
        chunks: {},
        discovered: {},
        depInfoList: []
      };
    }
    function addOptimizedDepInfo(metadata, type, depInfo) {
      metadata[type][depInfo.id] = depInfo;
      metadata.depInfoList.push(depInfo);
      return depInfo;
    }
    function loadCachedDepOptimizationMetadata(config2, force = config2.server.force, asCommand = false) {
      const log2 = asCommand ? config2.logger.info : debug$c;
      if (fs__default.existsSync(path__default.join(config2.cacheDir, "_metadata.json"))) {
        emptyDir(config2.cacheDir);
      }
      const depsCacheDir = getDepsCacheDir(config2);
      if (!force) {
        let cachedMetadata;
        try {
          const cachedMetadataPath = path__default.join(depsCacheDir, "_metadata.json");
          cachedMetadata = parseOptimizedDepsMetadata(fs__default.readFileSync(cachedMetadataPath, "utf-8"), depsCacheDir);
        } catch (e2) {
        }
        if (cachedMetadata && cachedMetadata.hash === getDepHash(config2)) {
          log2("Hash is consistent. Skipping. Use --force to override.");
          return cachedMetadata;
        }
      } else {
        config2.logger.info("Forced re-optimization of dependencies");
      }
      removeDirSync(depsCacheDir);
    }
    async function discoverProjectDependencies(config2, timestamp2) {
      const { deps, missing } = await scanImports(config2);
      const missingIds = Object.keys(missing);
      if (missingIds.length) {
        throw new Error(`The following dependencies are imported but could not be resolved:

  ${missingIds.map((id) => `${colors$1.cyan(id)} ${colors$1.white(colors$1.dim(`(imported by ${missing[id]})`))}`).join(`
  `)}

Are they installed?`);
      }
      await addManuallyIncludedOptimizeDeps(deps, config2);
      const browserHash = getOptimizedBrowserHash(getDepHash(config2), deps, timestamp2);
      const discovered = {};
      for (const id in deps) {
        const entry2 = deps[id];
        discovered[id] = {
          id,
          file: getOptimizedDepPath(id, config2),
          src: entry2,
          browserHash
        };
      }
      return discovered;
    }
    function depsLogString(qualifiedIds) {
      if (isDebugEnabled$1) {
        return colors$1.yellow(qualifiedIds.join(`
  `));
      } else {
        const total = qualifiedIds.length;
        const maxListed = 5;
        const listed = Math.min(total, maxListed);
        const extra = Math.max(0, total - maxListed);
        return colors$1.yellow(qualifiedIds.slice(0, listed).join(`, `) + (extra > 0 ? `, ...and ${extra} more` : ``));
      }
    }
    async function runOptimizeDeps(config2, depsInfo) {
      var _a2, _b, _c, _d;
      config2 = __spreadProps2(__spreadValues2({}, config2), {
        command: "build"
      });
      const depsCacheDir = getDepsCacheDir(config2);
      const processingCacheDir = getProcessingDepsCacheDir(config2);
      if (fs__default.existsSync(processingCacheDir)) {
        emptyDir(processingCacheDir);
      } else {
        fs__default.mkdirSync(processingCacheDir, { recursive: true });
      }
      writeFile(path__default.resolve(processingCacheDir, "package.json"), JSON.stringify({ type: "module" }));
      const metadata = createOptimizedDepsMetadata(config2);
      metadata.browserHash = getOptimizedBrowserHash(metadata.hash, depsFromOptimizedDepInfo(depsInfo));
      const qualifiedIds = Object.keys(depsInfo);
      if (!qualifiedIds.length) {
        return {
          metadata,
          commit() {
            commitProcessingDepsCacheSync();
          },
          cancel
        };
      }
      const flatIdDeps = {};
      const idToExports = {};
      const flatIdToExports = {};
      const _a3 = (_b = (_a2 = config2.optimizeDeps) === null || _a2 === void 0 ? void 0 : _a2.esbuildOptions) !== null && _b !== void 0 ? _b : {}, { plugins: plugins2 = [] } = _a3, esbuildOptions = __objRest(_a3, ["plugins"]);
      await init;
      for (const id in depsInfo) {
        const flatId = flattenId(id);
        const filePath = flatIdDeps[flatId] = depsInfo[id].src;
        let exportsData;
        if ((_c = config2.optimizeDeps.extensions) === null || _c === void 0 ? void 0 : _c.some((ext2) => filePath.endsWith(ext2))) {
          const result3 = await esbuild.build(__spreadProps2(__spreadValues2({}, esbuildOptions), {
            plugins: plugins2,
            entryPoints: [filePath],
            write: false,
            format: "esm"
          }));
          exportsData = parse$h(result3.outputFiles[0].text);
        } else {
          const entryContent = fs__default.readFileSync(filePath, "utf-8");
          try {
            exportsData = parse$h(entryContent);
          } catch {
            debug$c(`Unable to parse dependency: ${id}. Trying again with a JSX transform.`);
            const transformed = await transformWithEsbuild(entryContent, filePath, {
              loader: "jsx"
            });
            esbuildOptions.loader = __spreadValues2({
              ".js": "jsx"
            }, esbuildOptions.loader);
            exportsData = parse$h(transformed.code);
          }
          for (const { ss: ss2, se: se2 } of exportsData[0]) {
            const exp = entryContent.slice(ss2, se2);
            if (/export\s+\*\s+from/.test(exp)) {
              exportsData.hasReExports = true;
            }
          }
        }
        idToExports[id] = exportsData;
        flatIdToExports[flatId] = exportsData;
      }
      const define = {
        "process.env.NODE_ENV": JSON.stringify(config2.mode)
      };
      for (const key2 in config2.define) {
        const value = config2.define[key2];
        define[key2] = typeof value === "string" ? value : JSON.stringify(value);
      }
      const start = perf_hooks.performance.now();
      const result2 = await esbuild.build(__spreadValues2({
        absWorkingDir: process.cwd(),
        entryPoints: Object.keys(flatIdDeps),
        bundle: true,
        format: "esm",
        target: config2.build.target || void 0,
        external: (_d = config2.optimizeDeps) === null || _d === void 0 ? void 0 : _d.exclude,
        logLevel: "error",
        splitting: true,
        sourcemap: true,
        outdir: processingCacheDir,
        ignoreAnnotations: true,
        metafile: true,
        define,
        plugins: [
          ...plugins2,
          esbuildDepPlugin(flatIdDeps, flatIdToExports, config2)
        ]
      }, esbuildOptions));
      const meta = result2.metafile;
      const processingCacheDirOutputPath = path__default.relative(process.cwd(), processingCacheDir);
      for (const id in depsInfo) {
        const output = esbuildOutputFromId(meta.outputs, id, processingCacheDir);
        addOptimizedDepInfo(metadata, "optimized", __spreadProps2(__spreadValues2({}, depsInfo[id]), {
          needsInterop: needsInterop(id, idToExports[id], output),
          fileHash: getHash(metadata.hash + depsInfo[id].file + JSON.stringify(output.imports)),
          browserHash: metadata.browserHash
        }));
      }
      for (const o2 of Object.keys(meta.outputs)) {
        if (!o2.match(jsMapExtensionRE)) {
          const id = path__default.relative(processingCacheDirOutputPath, o2).replace(jsExtensionRE, "");
          const file = getOptimizedDepPath(id, config2);
          if (!findOptimizedDepInfoInRecord(metadata.optimized, (depInfo) => depInfo.file === file)) {
            addOptimizedDepInfo(metadata, "chunks", {
              id,
              file,
              needsInterop: false,
              browserHash: metadata.browserHash
            });
          }
        }
      }
      const dataPath = path__default.join(processingCacheDir, "_metadata.json");
      writeFile(dataPath, stringifyOptimizedDepsMetadata(metadata, depsCacheDir));
      debug$c(`deps bundled in ${(perf_hooks.performance.now() - start).toFixed(2)}ms`);
      return {
        metadata,
        commit() {
          commitProcessingDepsCacheSync();
        },
        cancel
      };
      function commitProcessingDepsCacheSync() {
        removeDirSync(depsCacheDir);
        fs__default.renameSync(processingCacheDir, depsCacheDir);
      }
      function cancel() {
        removeDirSync(processingCacheDir);
      }
    }
    function removeDirSync(dir) {
      var _a2;
      if (fs__default.existsSync(dir)) {
        const rmSync = (_a2 = fs__default.rmSync) !== null && _a2 !== void 0 ? _a2 : fs__default.rmdirSync;
        rmSync(dir, { recursive: true });
      }
    }
    async function findKnownImports(config2) {
      const deps = (await scanImports(config2)).deps;
      await addManuallyIncludedOptimizeDeps(deps, config2);
      return Object.keys(deps);
    }
    async function addManuallyIncludedOptimizeDeps(deps, config2) {
      var _a2;
      const include = (_a2 = config2.optimizeDeps) === null || _a2 === void 0 ? void 0 : _a2.include;
      if (include) {
        const resolve2 = config2.createResolver({ asSrc: false });
        for (const id of include) {
          const normalizedId = normalizeId(id);
          if (!deps[normalizedId]) {
            const entry2 = await resolve2(id);
            if (entry2) {
              deps[normalizedId] = entry2;
            } else {
              throw new Error(`Failed to resolve force included dependency: ${colors$1.cyan(id)}`);
            }
          }
        }
      }
    }
    function newDepOptimizationProcessing() {
      let resolve2;
      const promise2 = new Promise((_resolve) => {
        resolve2 = _resolve;
      });
      return { promise: promise2, resolve: resolve2 };
    }
    function depsFromOptimizedDepInfo(depsInfo) {
      return Object.fromEntries(Object.entries(depsInfo).map((d3) => [d3[0], d3[1].src]));
    }
    function getOptimizedDepPath(id, config2) {
      return normalizePath$4(path__default.resolve(getDepsCacheDir(config2), flattenId(id) + ".js"));
    }
    function getDepsCacheDir(config2) {
      return normalizePath$4(path__default.resolve(config2.cacheDir, "deps"));
    }
    function getProcessingDepsCacheDir(config2) {
      return normalizePath$4(path__default.resolve(config2.cacheDir, "processing"));
    }
    function isOptimizedDepFile(id, config2) {
      return id.startsWith(getDepsCacheDir(config2));
    }
    function createIsOptimizedDepUrl(config2) {
      const { root: root2 } = config2;
      const depsCacheDir = getDepsCacheDir(config2);
      const depsCacheDirRelative = normalizePath$4(path__default.relative(root2, depsCacheDir));
      const depsCacheDirPrefix = depsCacheDirRelative.startsWith("../") ? `/@fs/${normalizePath$4(depsCacheDir).replace(/^\//, "")}` : `/${depsCacheDirRelative}`;
      return function isOptimizedDepUrl(url2) {
        return url2.startsWith(depsCacheDirPrefix);
      };
    }
    function parseOptimizedDepsMetadata(jsonMetadata, depsCacheDir) {
      const { hash, browserHash, optimized, chunks } = JSON.parse(jsonMetadata, (key2, value) => {
        if (key2 === "file" || key2 === "src") {
          return normalizePath$4(path__default.resolve(depsCacheDir, value));
        }
        return value;
      });
      if (!chunks || Object.values(optimized).some((depInfo) => !depInfo.fileHash)) {
        return;
      }
      const metadata = {
        hash,
        browserHash,
        optimized: {},
        discovered: {},
        chunks: {},
        depInfoList: []
      };
      for (const id of Object.keys(optimized)) {
        addOptimizedDepInfo(metadata, "optimized", __spreadProps2(__spreadValues2({}, optimized[id]), {
          id,
          browserHash
        }));
      }
      for (const id of Object.keys(chunks)) {
        addOptimizedDepInfo(metadata, "chunks", __spreadProps2(__spreadValues2({}, chunks[id]), {
          id,
          browserHash,
          needsInterop: false
        }));
      }
      return metadata;
    }
    function stringifyOptimizedDepsMetadata(metadata, depsCacheDir) {
      const { hash, browserHash, optimized, chunks } = metadata;
      return JSON.stringify({
        hash,
        browserHash,
        optimized: Object.fromEntries(Object.values(optimized).map(({ id, src: src2, file, fileHash, needsInterop: needsInterop2 }) => [
          id,
          {
            src: src2,
            file,
            fileHash,
            needsInterop: needsInterop2
          }
        ])),
        chunks: Object.fromEntries(Object.values(chunks).map(({ id, file }) => [id, { file }]))
      }, (key2, value) => {
        if (key2 === "file" || key2 === "src") {
          return normalizePath$4(path__default.relative(depsCacheDir, value));
        }
        return value;
      }, 2);
    }
    function esbuildOutputFromId(outputs, id, cacheDirOutputPath) {
      const flatId = flattenId(id) + ".js";
      return outputs[normalizePath$4(path__default.relative(process.cwd(), path__default.join(cacheDirOutputPath, flatId)))];
    }
    var KNOWN_INTEROP_IDS = /* @__PURE__ */ new Set(["moment"]);
    function needsInterop(id, exportsData, output) {
      if (KNOWN_INTEROP_IDS.has(id)) {
        return true;
      }
      const [imports, exports2] = exportsData;
      if (!exports2.length && !imports.length) {
        return true;
      }
      const generatedExports = output.exports;
      if (!generatedExports || isSingleDefaultExport(generatedExports) && !isSingleDefaultExport(exports2)) {
        return true;
      }
      return false;
    }
    function isSingleDefaultExport(exports2) {
      return exports2.length === 1 && exports2[0] === "default";
    }
    var lockfileFormats = ["package-lock.json", "yarn.lock", "pnpm-lock.yaml"];
    function getDepHash(config2) {
      var _a2, _b, _c, _d, _e2, _f;
      let content2 = lookupFile(config2.root, lockfileFormats) || "";
      content2 += JSON.stringify({
        mode: config2.mode,
        root: config2.root,
        define: config2.define,
        resolve: config2.resolve,
        buildTarget: config2.build.target,
        assetsInclude: config2.assetsInclude,
        plugins: config2.plugins.map((p2) => p2.name),
        optimizeDeps: {
          include: (_a2 = config2.optimizeDeps) === null || _a2 === void 0 ? void 0 : _a2.include,
          exclude: (_b = config2.optimizeDeps) === null || _b === void 0 ? void 0 : _b.exclude,
          esbuildOptions: __spreadProps2(__spreadValues2({}, (_c = config2.optimizeDeps) === null || _c === void 0 ? void 0 : _c.esbuildOptions), {
            plugins: (_f = (_e2 = (_d = config2.optimizeDeps) === null || _d === void 0 ? void 0 : _d.esbuildOptions) === null || _e2 === void 0 ? void 0 : _e2.plugins) === null || _f === void 0 ? void 0 : _f.map((p2) => p2.name)
          })
        }
      }, (_2, value) => {
        if (typeof value === "function" || value instanceof RegExp) {
          return value.toString();
        }
        return value;
      });
      return getHash(content2);
    }
    function getOptimizedBrowserHash(hash, deps, timestamp2 = "") {
      return getHash(hash + JSON.stringify(deps) + timestamp2);
    }
    function getHash(text) {
      return require$$1$2.createHash("sha256").update(text).digest("hex").substring(0, 8);
    }
    function optimizedDepInfoFromId(metadata, id) {
      return metadata.optimized[id] || metadata.discovered[id] || metadata.chunks[id];
    }
    function optimizedDepInfoFromFile(metadata, file) {
      return metadata.depInfoList.find((depInfo) => depInfo.file === file);
    }
    function findOptimizedDepInfoInRecord(dependenciesInfo, callbackFn) {
      for (const o2 of Object.keys(dependenciesInfo)) {
        const info = dependenciesInfo[o2];
        if (callbackFn(info, o2)) {
          return info;
        }
      }
    }
    async function optimizedDepNeedsInterop(metadata, file) {
      const depInfo = optimizedDepInfoFromFile(metadata, file);
      if (!depInfo)
        return void 0;
      await depInfo.processing;
      return depInfo === null || depInfo === void 0 ? void 0 : depInfo.needsInterop;
    }
    var index$1 = {
      __proto__: null,
      debuggerViteDeps,
      optimizeDeps,
      createOptimizedDepsMetadata,
      addOptimizedDepInfo,
      loadCachedDepOptimizationMetadata,
      discoverProjectDependencies,
      depsLogString,
      runOptimizeDeps,
      findKnownImports,
      newDepOptimizationProcessing,
      depsFromOptimizedDepInfo,
      getOptimizedDepPath,
      getDepsCacheDir,
      isOptimizedDepFile,
      createIsOptimizedDepUrl,
      getDepHash,
      getHash,
      optimizedDepInfoFromId,
      optimizedDepInfoFromFile,
      optimizedDepNeedsInterop
    };
    function loop(exports2, keys) {
      if (typeof exports2 === "string") {
        return exports2;
      }
      if (exports2) {
        let idx, tmp;
        if (Array.isArray(exports2)) {
          for (idx = 0; idx < exports2.length; idx++) {
            if (tmp = loop(exports2[idx], keys))
              return tmp;
          }
        } else {
          for (idx in exports2) {
            if (keys.has(idx)) {
              return loop(exports2[idx], keys);
            }
          }
        }
      }
    }
    function bail(name, entry2, condition) {
      throw new Error(condition ? `No known conditions for "${entry2}" entry in "${name}" package` : `Missing "${entry2}" export in "${name}" package`);
    }
    function toName(name, entry2) {
      return entry2 === name ? "." : entry2[0] === "." ? entry2 : entry2.replace(new RegExp("^" + name + "/"), "./");
    }
    function resolve(pkg, entry2 = ".", options2 = {}) {
      let { name, exports: exports2 } = pkg;
      if (exports2) {
        let { browser: browser2, require: require2, unsafe, conditions = [] } = options2;
        let target = toName(name, entry2);
        if (target[0] !== ".")
          target = "./" + target;
        if (typeof exports2 === "string") {
          return target === "." ? exports2 : bail(name, target);
        }
        let allows = /* @__PURE__ */ new Set(["default", ...conditions]);
        unsafe || allows.add(require2 ? "require" : "import");
        unsafe || allows.add(browser2 ? "browser" : "node");
        let key2, tmp, isSingle = false;
        for (key2 in exports2) {
          isSingle = key2[0] !== ".";
          break;
        }
        if (isSingle) {
          return target === "." ? loop(exports2, allows) || bail(name, target, 1) : bail(name, target);
        }
        if (tmp = exports2[target]) {
          return loop(tmp, allows) || bail(name, target, 1);
        }
        for (key2 in exports2) {
          tmp = key2[key2.length - 1];
          if (tmp === "/" && target.startsWith(key2)) {
            return (tmp = loop(exports2[key2], allows)) ? tmp + target.substring(key2.length) : bail(name, target, 1);
          }
          if (tmp === "*" && target.startsWith(key2.slice(0, -1))) {
            if (target.substring(key2.length - 1).length > 0) {
              return (tmp = loop(exports2[key2], allows)) ? tmp.replace("*", target.substring(key2.length - 1)) : bail(name, target, 1);
            }
          }
        }
        return bail(name, target);
      }
    }
    var isDebug$5 = process.env.DEBUG;
    var debug$b = createDebugger("vite:resolve-details", {
      onlyWhenFocused: true
    });
    function invalidatePackageData(packageCache, pkgPath) {
      packageCache.delete(pkgPath);
      const pkgDir = path__default.dirname(pkgPath);
      packageCache.forEach((pkg, cacheKey) => {
        if (pkg.dir === pkgDir) {
          packageCache.delete(cacheKey);
        }
      });
    }
    function resolvePackageData(id, basedir, preserveSymlinks = false, packageCache) {
      let pkg;
      let cacheKey;
      if (packageCache) {
        cacheKey = `${id}&${basedir}&${preserveSymlinks}`;
        if (pkg = packageCache.get(cacheKey)) {
          return pkg;
        }
      }
      let pkgPath;
      try {
        pkgPath = resolveFrom(`${id}/package.json`, basedir, preserveSymlinks);
        pkg = loadPackageData(pkgPath, true, packageCache);
        if (packageCache) {
          packageCache.set(cacheKey, pkg);
        }
        return pkg;
      } catch (e2) {
        if (e2 instanceof SyntaxError) {
          isDebug$5 && debug$b(`Parsing failed: ${pkgPath}`);
        } else if (e2.code !== "MODULE_NOT_FOUND") {
          throw e2;
        }
      }
      return null;
    }
    function loadPackageData(pkgPath, preserveSymlinks, packageCache) {
      if (!preserveSymlinks) {
        pkgPath = fs__default.realpathSync.native(pkgPath);
      }
      let cached;
      if (cached = packageCache === null || packageCache === void 0 ? void 0 : packageCache.get(pkgPath)) {
        return cached;
      }
      const data2 = JSON.parse(fs__default.readFileSync(pkgPath, "utf-8"));
      const pkgDir = path__default.dirname(pkgPath);
      const { sideEffects } = data2;
      let hasSideEffects;
      if (typeof sideEffects === "boolean") {
        hasSideEffects = () => sideEffects;
      } else if (Array.isArray(sideEffects)) {
        hasSideEffects = createFilter$1(sideEffects, null, { resolve: pkgDir });
      } else {
        hasSideEffects = () => true;
      }
      const pkg = {
        dir: pkgDir,
        data: data2,
        hasSideEffects,
        webResolvedImports: {},
        nodeResolvedImports: {},
        setResolvedCache(key2, entry2, targetWeb) {
          if (targetWeb) {
            pkg.webResolvedImports[key2] = entry2;
          } else {
            pkg.nodeResolvedImports[key2] = entry2;
          }
        },
        getResolvedCache(key2, targetWeb) {
          if (targetWeb) {
            return pkg.webResolvedImports[key2];
          } else {
            return pkg.nodeResolvedImports[key2];
          }
        }
      };
      packageCache === null || packageCache === void 0 ? void 0 : packageCache.set(pkgPath, pkg);
      return pkg;
    }
    function watchPackageDataPlugin(config2) {
      const watchQueue = /* @__PURE__ */ new Set();
      let watchFile = (id) => {
        watchQueue.add(id);
      };
      const { packageCache } = config2;
      const setPackageData = packageCache.set.bind(packageCache);
      packageCache.set = (id, pkg) => {
        if (id.endsWith(".json")) {
          watchFile(id);
        }
        return setPackageData(id, pkg);
      };
      return {
        name: "vite:watch-package-data",
        buildStart() {
          watchFile = this.addWatchFile;
          watchQueue.forEach(watchFile);
          watchQueue.clear();
        },
        buildEnd() {
          watchFile = (id) => watchQueue.add(id);
        },
        watchChange(id) {
          if (id.endsWith("/package.json")) {
            invalidatePackageData(packageCache, id);
          }
        }
      };
    }
    var browserExternalId = "__vite-browser-external";
    var isDebug$4 = process.env.DEBUG;
    var debug$a = createDebugger("vite:resolve-details", {
      onlyWhenFocused: true
    });
    function resolvePlugin(baseOptions) {
      const { root: root2, isProduction, asSrc, ssrConfig, preferRelative = false } = baseOptions;
      let server2;
      let isOptimizedDepUrl;
      const { target: ssrTarget, noExternal: ssrNoExternal } = ssrConfig !== null && ssrConfig !== void 0 ? ssrConfig : {};
      return {
        name: "vite:resolve",
        configureServer(_server) {
          server2 = _server;
          isOptimizedDepUrl = createIsOptimizedDepUrl(server2.config);
        },
        async resolveId(id, importer, resolveOpts) {
          var _a2, _b, _c, _d, _e2;
          const ssr = (resolveOpts === null || resolveOpts === void 0 ? void 0 : resolveOpts.ssr) === true;
          if (id.startsWith(browserExternalId)) {
            return id;
          }
          if (/\?commonjs/.test(id) || id === "commonjsHelpers.js") {
            return;
          }
          const targetWeb = !ssr || ssrTarget === "webworker";
          const isRequire2 = (_c = (_b = (_a2 = resolveOpts === null || resolveOpts === void 0 ? void 0 : resolveOpts.custom) === null || _a2 === void 0 ? void 0 : _a2["node-resolve"]) === null || _b === void 0 ? void 0 : _b.isRequire) !== null && _c !== void 0 ? _c : false;
          const options2 = __spreadProps2(__spreadValues2({
            isRequire: isRequire2
          }, baseOptions), {
            isFromTsImporter: isTsRequest(importer !== null && importer !== void 0 ? importer : ""),
            scan: (_d = resolveOpts === null || resolveOpts === void 0 ? void 0 : resolveOpts.scan) !== null && _d !== void 0 ? _d : baseOptions.scan
          });
          let res;
          if (asSrc && (isOptimizedDepUrl === null || isOptimizedDepUrl === void 0 ? void 0 : isOptimizedDepUrl(id))) {
            const optimizedPath = id.startsWith(FS_PREFIX) ? fsPathFromId(id) : normalizePath$4(ensureVolumeInPath(path__default.resolve(root2, id.slice(1))));
            return optimizedPath;
          }
          if (asSrc && id.startsWith(FS_PREFIX)) {
            const fsPath = fsPathFromId(id);
            res = tryFsResolve(fsPath, options2);
            isDebug$4 && debug$a(`[@fs] ${colors$1.cyan(id)} -> ${colors$1.dim(res)}`);
            return res || fsPath;
          }
          if (asSrc && id.startsWith("/")) {
            const fsPath = path__default.resolve(root2, id.slice(1));
            if (res = tryFsResolve(fsPath, options2)) {
              isDebug$4 && debug$a(`[url] ${colors$1.cyan(id)} -> ${colors$1.dim(res)}`);
              return res;
            }
          }
          if (id.startsWith(".") || preferRelative && /^\w/.test(id)) {
            const basedir = importer ? path__default.dirname(importer) : process.cwd();
            const fsPath = path__default.resolve(basedir, id);
            const normalizedFsPath = normalizePath$4(fsPath);
            if ((server2 === null || server2 === void 0 ? void 0 : server2._optimizedDeps) && isOptimizedDepFile(normalizedFsPath, server2.config)) {
              if (!normalizedFsPath.match(DEP_VERSION_RE)) {
                const browserHash = (_e2 = optimizedDepInfoFromFile(server2._optimizedDeps.metadata, normalizedFsPath)) === null || _e2 === void 0 ? void 0 : _e2.browserHash;
                if (browserHash) {
                  return injectQuery(normalizedFsPath, `v=${browserHash}`);
                }
              }
              return normalizedFsPath;
            }
            const pathFromBasedir = normalizedFsPath.slice(basedir.length);
            if (pathFromBasedir.startsWith("/node_modules/")) {
              const bareImport = pathFromBasedir.slice("/node_modules/".length);
              if ((res = tryNodeResolve(bareImport, importer, options2, targetWeb, server2, ssr)) && res.id.startsWith(normalizedFsPath)) {
                return res;
              }
            }
            if (targetWeb && (res = tryResolveBrowserMapping(fsPath, importer, options2, true))) {
              return res;
            }
            if (res = tryFsResolve(fsPath, options2)) {
              isDebug$4 && debug$a(`[relative] ${colors$1.cyan(id)} -> ${colors$1.dim(res)}`);
              const pkg = importer != null && idToPkgMap.get(importer);
              if (pkg) {
                idToPkgMap.set(res, pkg);
                return {
                  id: res,
                  moduleSideEffects: pkg.hasSideEffects(res)
                };
              }
              return res;
            }
          }
          if (path__default.isAbsolute(id) && (res = tryFsResolve(id, options2))) {
            isDebug$4 && debug$a(`[fs] ${colors$1.cyan(id)} -> ${colors$1.dim(res)}`);
            return res;
          }
          if (isExternalUrl(id)) {
            return {
              id,
              external: true
            };
          }
          if (isDataUrl(id)) {
            return null;
          }
          if (bareImportRE.test(id)) {
            if (asSrc && server2 && !ssr && !options2.scan && (res = await tryOptimizedResolve(id, server2, importer))) {
              return res;
            }
            if (targetWeb && (res = tryResolveBrowserMapping(id, importer, options2, false))) {
              return res;
            }
            if (res = tryNodeResolve(id, importer, options2, targetWeb, server2, ssr)) {
              return res;
            }
            if (isBuiltin(id)) {
              if (ssr) {
                if (ssrNoExternal === true) {
                  let message = `Cannot bundle Node.js built-in "${id}"`;
                  if (importer) {
                    message += ` imported from "${path__default.relative(process.cwd(), importer)}"`;
                  }
                  message += `. Consider disabling ssr.noExternal or remove the built-in dependency.`;
                  this.error(message);
                }
                return {
                  id,
                  external: true
                };
              } else {
                if (!asSrc) {
                  debug$a(`externalized node built-in "${id}" to empty module. (imported by: ${colors$1.white(colors$1.dim(importer))})`);
                }
                return isProduction ? browserExternalId : `${browserExternalId}:${id}`;
              }
            }
          }
          isDebug$4 && debug$a(`[fallthrough] ${colors$1.dim(id)}`);
        },
        load(id) {
          if (id.startsWith(browserExternalId)) {
            return isProduction ? `export default {}` : `export default new Proxy({}, {
  get() {
    throw new Error('Module "${id.slice(browserExternalId.length + 1)}" has been externalized for browser compatibility and cannot be accessed in client code.')
  }
})`;
          }
        }
      };
    }
    function splitFileAndPostfix(path2) {
      let file = path2;
      let postfix = "";
      let postfixIndex = path2.indexOf("?");
      if (postfixIndex < 0) {
        postfixIndex = path2.indexOf("#");
      }
      if (postfixIndex > 0) {
        file = path2.slice(0, postfixIndex);
        postfix = path2.slice(postfixIndex);
      }
      return { file, postfix };
    }
    function tryFsResolve(fsPath, options2, tryIndex = true, targetWeb = true) {
      const { file, postfix } = splitFileAndPostfix(fsPath);
      let res;
      if (postfix && (res = tryResolveFile(fsPath, "", options2, false, targetWeb, options2.tryPrefix, options2.skipPackageJson))) {
        return res;
      }
      if (res = tryResolveFile(file, postfix, options2, false, targetWeb, options2.tryPrefix, options2.skipPackageJson)) {
        return res;
      }
      for (const ext2 of options2.extensions || DEFAULT_EXTENSIONS$1) {
        if (postfix && (res = tryResolveFile(fsPath + ext2, "", options2, false, targetWeb, options2.tryPrefix, options2.skipPackageJson))) {
          return res;
        }
        if (res = tryResolveFile(file + ext2, postfix, options2, false, targetWeb, options2.tryPrefix, options2.skipPackageJson)) {
          return res;
        }
      }
      if (postfix && (res = tryResolveFile(fsPath, "", options2, tryIndex, targetWeb, options2.tryPrefix, options2.skipPackageJson))) {
        return res;
      }
      if (res = tryResolveFile(file, postfix, options2, tryIndex, targetWeb, options2.tryPrefix, options2.skipPackageJson)) {
        return res;
      }
    }
    function tryResolveFile(file, postfix, options2, tryIndex, targetWeb, tryPrefix, skipPackageJson) {
      if (isFileReadable(file)) {
        if (!fs__default.statSync(file).isDirectory()) {
          return getRealPath(file, options2.preserveSymlinks) + postfix;
        } else if (tryIndex) {
          if (!skipPackageJson) {
            const pkgPath = file + "/package.json";
            try {
              const pkg = loadPackageData(pkgPath, options2.preserveSymlinks);
              const resolved = resolvePackageEntry(file, pkg, targetWeb, options2);
              return resolved;
            } catch (e2) {
              if (e2.code !== "ENOENT") {
                throw e2;
              }
            }
          }
          const index2 = tryFsResolve(file + "/index", options2);
          if (index2)
            return index2 + postfix;
        }
      }
      const tryTsExtension = options2.isFromTsImporter && isPossibleTsOutput(file);
      if (tryTsExtension) {
        const tsSrcPaths = getPotentialTsSrcPaths(file);
        for (const srcPath of tsSrcPaths) {
          const res = tryResolveFile(srcPath, postfix, options2, tryIndex, targetWeb, tryPrefix, skipPackageJson);
          if (res)
            return res;
        }
        return;
      }
      if (tryPrefix) {
        const prefixed = `${path__default.dirname(file)}/${tryPrefix}${path__default.basename(file)}`;
        return tryResolveFile(prefixed, postfix, options2, tryIndex, targetWeb);
      }
    }
    var idToPkgMap = /* @__PURE__ */ new Map();
    function tryNodeResolve(id, importer, options2, targetWeb, server2, ssr) {
      var _a2;
      const { root: root2, dedupe, isBuild, preserveSymlinks, packageCache } = options2;
      const lastArrowIndex = id.lastIndexOf(">");
      const nestedRoot = id.substring(0, lastArrowIndex).trim();
      const nestedPath = id.substring(lastArrowIndex + 1).trim();
      const possiblePkgIds = [];
      for (let prevSlashIndex = -1; ; ) {
        let slashIndex = nestedPath.indexOf("/", prevSlashIndex + 1);
        if (slashIndex < 0) {
          slashIndex = nestedPath.length;
        }
        const part = nestedPath.slice(prevSlashIndex + 1, prevSlashIndex = slashIndex);
        if (!part) {
          break;
        }
        if (possiblePkgIds.length ? path__default.extname(part) : part[0] === "@") {
          continue;
        }
        const possiblePkgId = nestedPath.slice(0, slashIndex);
        possiblePkgIds.push(possiblePkgId);
      }
      let basedir;
      if (dedupe === null || dedupe === void 0 ? void 0 : dedupe.some((id2) => possiblePkgIds.includes(id2))) {
        basedir = root2;
      } else if (importer && path__default.isAbsolute(importer) && fs__default.existsSync(cleanUrl(importer))) {
        basedir = path__default.dirname(importer);
      } else {
        basedir = root2;
      }
      if (nestedRoot) {
        basedir = nestedResolveFrom(nestedRoot, basedir, preserveSymlinks);
      }
      let pkg;
      const pkgId = possiblePkgIds.reverse().find((pkgId2) => {
        pkg = resolvePackageData(pkgId2, basedir, preserveSymlinks, packageCache);
        return pkg;
      });
      if (!pkg) {
        return;
      }
      let resolveId2 = resolvePackageEntry;
      let unresolvedId = pkgId;
      if (unresolvedId !== nestedPath) {
        resolveId2 = resolveDeepImport;
        unresolvedId = "." + nestedPath.slice(pkgId.length);
      }
      let resolved;
      try {
        resolved = resolveId2(unresolvedId, pkg, targetWeb, options2);
      } catch (err) {
        if (!options2.tryEsmOnly) {
          throw err;
        }
      }
      if (!resolved && options2.tryEsmOnly) {
        resolved = resolveId2(unresolvedId, pkg, targetWeb, __spreadProps2(__spreadValues2({}, options2), {
          isRequire: false,
          mainFields: DEFAULT_MAIN_FIELDS,
          extensions: DEFAULT_EXTENSIONS$1
        }));
      }
      if (!resolved) {
        return;
      }
      idToPkgMap.set(resolved, pkg);
      if (isBuild) {
        return {
          id: resolved,
          moduleSideEffects: pkg.hasSideEffects(resolved)
        };
      } else {
        if (!resolved.includes("node_modules") || !server2 || !server2._optimizedDeps || options2.scan) {
          return { id: resolved };
        }
        const isJsType = OPTIMIZABLE_ENTRY_RE.test(resolved);
        const exclude = (_a2 = server2.config.optimizeDeps) === null || _a2 === void 0 ? void 0 : _a2.exclude;
        if (!isJsType || (importer === null || importer === void 0 ? void 0 : importer.includes("node_modules")) || (exclude === null || exclude === void 0 ? void 0 : exclude.includes(pkgId)) || (exclude === null || exclude === void 0 ? void 0 : exclude.includes(nestedPath)) || SPECIAL_QUERY_RE.test(resolved) || ssr) {
          const versionHash = server2._optimizedDeps.metadata.browserHash;
          if (versionHash && isJsType) {
            resolved = injectQuery(resolved, `v=${versionHash}`);
          }
        } else {
          const optimizedInfo = server2._optimizedDeps.registerMissingImport(id, resolved);
          resolved = getOptimizedUrl(optimizedInfo);
        }
        return { id: resolved };
      }
    }
    var getOptimizedUrl = (optimizedData) => `${optimizedData.file}?v=${optimizedData.browserHash}`;
    async function tryOptimizedResolve(id, server2, importer) {
      const optimizedDeps = server2._optimizedDeps;
      if (!optimizedDeps)
        return;
      await optimizedDeps.scanProcessing;
      const depInfo = optimizedDepInfoFromId(optimizedDeps.metadata, id);
      if (depInfo) {
        return getOptimizedUrl(depInfo);
      }
      if (!importer)
        return;
      let resolvedSrc;
      for (const optimizedData of optimizedDeps.metadata.depInfoList) {
        if (!optimizedData.src)
          continue;
        const pkgPath = optimizedData.id;
        if (!pkgPath.endsWith(id))
          continue;
        if (resolvedSrc == null) {
          try {
            resolvedSrc = normalizePath$4(resolveFrom(id, path__default.dirname(importer)));
          } catch {
            break;
          }
        }
        if (optimizedData.src === resolvedSrc) {
          return getOptimizedUrl(optimizedData);
        }
      }
    }
    function resolvePackageEntry(id, { dir, data: data2, setResolvedCache, getResolvedCache }, targetWeb, options2) {
      var _a2, _b;
      const cached = getResolvedCache(".", targetWeb);
      if (cached) {
        return cached;
      }
      try {
        let entryPoint;
        if (data2.exports) {
          entryPoint = resolveExports(data2, ".", options2, targetWeb);
        }
        if (targetWeb && (!entryPoint || entryPoint.endsWith(".mjs"))) {
          const browserEntry = typeof data2.browser === "string" ? data2.browser : isObject$5(data2.browser) && data2.browser["."];
          if (browserEntry) {
            if (!options2.isRequire && typeof data2.module === "string" && data2.module !== browserEntry) {
              const resolvedBrowserEntry = tryFsResolve(path__default.join(dir, browserEntry), options2);
              if (resolvedBrowserEntry) {
                const content2 = fs__default.readFileSync(resolvedBrowserEntry, "utf-8");
                if (/typeof exports\s*==/.test(content2) && /typeof module\s*==/.test(content2) || /module\.exports\s*=/.test(content2)) {
                  entryPoint = data2.module;
                }
              }
            } else {
              entryPoint = browserEntry;
            }
          }
        }
        if (!entryPoint || entryPoint.endsWith(".mjs")) {
          for (const field of options2.mainFields || DEFAULT_MAIN_FIELDS) {
            if (typeof data2[field] === "string") {
              entryPoint = data2[field];
              break;
            }
          }
        }
        entryPoint || (entryPoint = data2.main);
        const entryPoints = entryPoint ? [entryPoint] : ["index.js", "index.json", "index.node"];
        for (let entry2 of entryPoints) {
          if (((_a2 = options2.mainFields) === null || _a2 === void 0 ? void 0 : _a2[0]) === "sass" && !((_b = options2.extensions) === null || _b === void 0 ? void 0 : _b.includes(path__default.extname(entry2)))) {
            entry2 = "";
            options2.skipPackageJson = true;
          }
          const { browser: browserField } = data2;
          if (targetWeb && isObject$5(browserField)) {
            entry2 = mapWithBrowserField(entry2, browserField) || entry2;
          }
          const entryPointPath = path__default.join(dir, entry2);
          const resolvedEntryPoint = tryFsResolve(entryPointPath, options2);
          if (resolvedEntryPoint) {
            isDebug$4 && debug$a(`[package entry] ${colors$1.cyan(id)} -> ${colors$1.dim(resolvedEntryPoint)}`);
            setResolvedCache(".", resolvedEntryPoint, targetWeb);
            return resolvedEntryPoint;
          }
        }
        packageEntryFailure(id);
      } catch (e2) {
        packageEntryFailure(id, e2.message);
      }
    }
    function packageEntryFailure(id, details) {
      throw new Error(`Failed to resolve entry for package "${id}". The package may have incorrect main/module/exports specified in its package.json` + (details ? ": " + details : "."));
    }
    function resolveExports(pkg, key2, options2, targetWeb) {
      const conditions = [options2.isProduction ? "production" : "development"];
      if (!options2.isRequire) {
        conditions.push("module");
      }
      if (options2.conditions) {
        conditions.push(...options2.conditions);
      }
      return resolve(pkg, key2, {
        browser: targetWeb,
        require: options2.isRequire,
        conditions
      });
    }
    function resolveDeepImport(id, { webResolvedImports, setResolvedCache, getResolvedCache, dir, data: data2 }, targetWeb, options2) {
      const cache2 = getResolvedCache(id, targetWeb);
      if (cache2) {
        return cache2;
      }
      let relativeId = id;
      const { exports: exportsField, browser: browserField } = data2;
      if (exportsField) {
        if (isObject$5(exportsField) && !Array.isArray(exportsField)) {
          const { file, postfix } = splitFileAndPostfix(relativeId);
          const exportsId = resolveExports(data2, file, options2, targetWeb);
          if (exportsId !== void 0) {
            relativeId = exportsId + postfix;
          } else {
            relativeId = void 0;
          }
        } else {
          relativeId = void 0;
        }
        if (!relativeId) {
          throw new Error(`Package subpath '${relativeId}' is not defined by "exports" in ${path__default.join(dir, "package.json")}.`);
        }
      } else if (targetWeb && isObject$5(browserField)) {
        const { file, postfix } = splitFileAndPostfix(relativeId);
        const mapped = mapWithBrowserField(file, browserField);
        if (mapped) {
          relativeId = mapped + postfix;
        } else if (mapped === false) {
          return webResolvedImports[id] = browserExternalId;
        }
      }
      if (relativeId) {
        const resolved = tryFsResolve(path__default.join(dir, relativeId), options2, !exportsField, targetWeb);
        if (resolved) {
          isDebug$4 && debug$a(`[node/deep-import] ${colors$1.cyan(id)} -> ${colors$1.dim(resolved)}`);
          setResolvedCache(id, resolved, targetWeb);
          return resolved;
        }
      }
    }
    function tryResolveBrowserMapping(id, importer, options2, isFilePath) {
      let res;
      const pkg = importer && idToPkgMap.get(importer);
      if (pkg && isObject$5(pkg.data.browser)) {
        const mapId = isFilePath ? "./" + slash$1(path__default.relative(pkg.dir, id)) : id;
        const browserMappedPath = mapWithBrowserField(mapId, pkg.data.browser);
        if (browserMappedPath) {
          const fsPath = path__default.join(pkg.dir, browserMappedPath);
          if (res = tryFsResolve(fsPath, options2)) {
            isDebug$4 && debug$a(`[browser mapped] ${colors$1.cyan(id)} -> ${colors$1.dim(res)}`);
            idToPkgMap.set(res, pkg);
            return {
              id: res,
              moduleSideEffects: pkg.hasSideEffects(res)
            };
          }
        } else if (browserMappedPath === false) {
          return browserExternalId;
        }
      }
    }
    function mapWithBrowserField(relativePathInPkgDir, map2) {
      const normalizedPath = path__default.posix.normalize(relativePathInPkgDir);
      for (const key2 in map2) {
        const normalizedKey = path__default.posix.normalize(key2);
        if (normalizedPath === normalizedKey || equalWithoutSuffix(normalizedPath, normalizedKey, ".js") || equalWithoutSuffix(normalizedPath, normalizedKey, "/index.js")) {
          return map2[key2];
        }
      }
    }
    function equalWithoutSuffix(path2, key2, suffix) {
      return key2.endsWith(suffix) && key2.slice(0, -suffix.length) === path2;
    }
    function getRealPath(resolved, preserveSymlinks) {
      resolved = ensureVolumeInPath(resolved);
      if (!preserveSymlinks && browserExternalId !== resolved) {
        resolved = fs__default.realpathSync(resolved);
      }
      return normalizePath$4(resolved);
    }
    var debug$9 = createDebugger("vite:ssr-external");
    function stripNesting(packages) {
      return packages.map((s2) => {
        const arr = s2.split(">");
        return arr[arr.length - 1].trim();
      });
    }
    function resolveSSRExternal(config2, knownImports) {
      var _a2;
      knownImports = stripNesting(knownImports);
      const ssrConfig = config2.ssr;
      if ((ssrConfig === null || ssrConfig === void 0 ? void 0 : ssrConfig.noExternal) === true) {
        return [];
      }
      const ssrExternals = /* @__PURE__ */ new Set();
      const seen2 = /* @__PURE__ */ new Set();
      (_a2 = ssrConfig === null || ssrConfig === void 0 ? void 0 : ssrConfig.external) === null || _a2 === void 0 ? void 0 : _a2.forEach((id) => {
        ssrExternals.add(id);
        seen2.add(id);
      });
      collectExternals(config2.root, config2.resolve.preserveSymlinks, ssrExternals, seen2, config2.logger);
      const importedDeps = knownImports.map(getNpmPackageName).filter(isDefined);
      for (const dep of importedDeps) {
        if (!seen2.has(dep)) {
          ssrExternals.add(dep);
        }
      }
      ssrExternals.delete("vite");
      let externals = [...ssrExternals];
      if (ssrConfig === null || ssrConfig === void 0 ? void 0 : ssrConfig.noExternal) {
        externals = externals.filter(createFilter$1(void 0, ssrConfig.noExternal, { resolve: false }));
      }
      return externals;
    }
    var CJS_CONTENT_RE = /\bmodule\.exports\b|\bexports[.\[]|\brequire\s*\(|\bObject\.(defineProperty|defineProperties|assign)\s*\(\s*exports\b/;
    function collectExternals(root2, preserveSymlinks, ssrExternals, seen2, logger) {
      var _a2;
      const rootPkgContent = lookupFile(root2, ["package.json"]);
      if (!rootPkgContent) {
        return;
      }
      const rootPkg = JSON.parse(rootPkgContent);
      const deps = __spreadValues2(__spreadValues2({}, rootPkg.devDependencies), rootPkg.dependencies);
      const resolveOptions = {
        root: root2,
        preserveSymlinks,
        isProduction: false,
        isBuild: true
      };
      const depsToTrace = /* @__PURE__ */ new Set();
      for (const id in deps) {
        if (seen2.has(id))
          continue;
        seen2.add(id);
        let esmEntry;
        let requireEntry;
        try {
          esmEntry = (_a2 = tryNodeResolve(id, void 0, resolveOptions, true, void 0, true)) === null || _a2 === void 0 ? void 0 : _a2.id;
          requireEntry = normalizePath$4(__require.resolve(id, { paths: [root2] }));
        } catch (e2) {
          try {
            const pkgPath = resolveFrom(`${id}/package.json`, root2);
            if (pkgPath.includes("node_modules")) {
              ssrExternals.add(id);
            } else {
              depsToTrace.add(path__default.dirname(pkgPath));
            }
            continue;
          } catch {
          }
          debug$9(`Failed to resolve entries for package "${id}"
`, e2);
          continue;
        }
        if (!esmEntry) {
          ssrExternals.add(id);
        } else if (!esmEntry.includes("node_modules")) {
          const pkgPath = resolveFrom(`${id}/package.json`, root2);
          depsToTrace.add(path__default.dirname(pkgPath));
        } else if (esmEntry !== requireEntry) {
          ssrExternals.add(id);
        } else if (/\.m?js$/.test(esmEntry)) {
          const pkgPath = resolveFrom(`${id}/package.json`, root2);
          const pkgContent = fs__default.readFileSync(pkgPath, "utf-8");
          if (!pkgContent) {
            continue;
          }
          const pkg = JSON.parse(pkgContent);
          if (pkg.type === "module" || esmEntry.endsWith(".mjs")) {
            ssrExternals.add(id);
            continue;
          }
          const content2 = fs__default.readFileSync(esmEntry, "utf-8");
          if (CJS_CONTENT_RE.test(content2)) {
            ssrExternals.add(id);
            continue;
          }
          logger.warn(`${id} doesn't appear to be written in CJS, but also doesn't appear to be a valid ES module (i.e. it doesn't have "type": "module" or an .mjs extension for the entry point). Please contact the package author to fix.`);
        }
      }
      for (const depRoot of depsToTrace) {
        collectExternals(depRoot, preserveSymlinks, ssrExternals, seen2, logger);
      }
    }
    function shouldExternalizeForSSR(id, externals) {
      const should = externals.some((e2) => {
        if (id === e2) {
          return true;
        }
        if (id.startsWith(e2 + "/") && (!path__default.extname(id) || id.endsWith(".js"))) {
          return true;
        }
      });
      return should;
    }
    function getNpmPackageName(importPath) {
      const parts = importPath.split("/");
      if (parts[0].startsWith("@")) {
        if (!parts[1])
          return null;
        return `${parts[0]}/${parts[1]}`;
      } else {
        return parts[0];
      }
    }
    function ssrManifestPlugin(config2) {
      const ssrManifest = {};
      const base2 = config2.base;
      return {
        name: "vite:ssr-manifest",
        generateBundle(_options, bundle) {
          var _a2;
          for (const file in bundle) {
            const chunk = bundle[file];
            if (chunk.type === "chunk") {
              for (const id in chunk.modules) {
                const normalizedId = normalizePath$4(path$r.relative(config2.root, id));
                const mappedChunks = (_a2 = ssrManifest[normalizedId]) !== null && _a2 !== void 0 ? _a2 : ssrManifest[normalizedId] = [];
                if (!chunk.isEntry) {
                  mappedChunks.push(base2 + chunk.fileName);
                  chunk.viteMetadata.importedCss.forEach((file2) => {
                    mappedChunks.push(base2 + file2);
                  });
                }
                chunk.viteMetadata.importedAssets.forEach((file2) => {
                  mappedChunks.push(base2 + file2);
                });
              }
              if (chunk.code.includes(preloadMethod)) {
                const code = chunk.code;
                let imports;
                try {
                  imports = parse$h(code)[0].filter((i2) => i2.d > -1);
                } catch (e2) {
                  this.error(e2, e2.idx);
                }
                if (imports.length) {
                  for (let index2 = 0; index2 < imports.length; index2++) {
                    const { s: start, e: end, n: name } = imports[index2];
                    const url2 = code.slice(start, end);
                    const deps = [];
                    const ownerFilename = chunk.fileName;
                    const analyzed = /* @__PURE__ */ new Set();
                    const addDeps = (filename2) => {
                      if (filename2 === ownerFilename)
                        return;
                      if (analyzed.has(filename2))
                        return;
                      analyzed.add(filename2);
                      const chunk2 = bundle[filename2];
                      if (chunk2) {
                        chunk2.viteMetadata.importedCss.forEach((file2) => {
                          deps.push(`/${file2}`);
                        });
                        chunk2.imports.forEach(addDeps);
                      }
                    };
                    const normalizedFile = normalizePath$4(path$r.join(path$r.dirname(chunk.fileName), url2.slice(1, -1)));
                    addDeps(normalizedFile);
                    ssrManifest[path$r.basename(name)] = deps;
                  }
                }
              }
            }
          }
          this.emitFile({
            fileName: typeof config2.build.ssrManifest === "string" ? config2.build.ssrManifest : "ssr-manifest.json",
            type: "asset",
            source: JSON.stringify(ssrManifest, null, 2)
          });
        }
      };
    }
    function assetImportMetaUrlPlugin(config2) {
      return {
        name: "vite:asset-import-meta-url",
        async transform(code, id, options2) {
          if (!(options2 === null || options2 === void 0 ? void 0 : options2.ssr) && code.includes("new URL") && code.includes(`import.meta.url`)) {
            const importMetaUrlRE = /\bnew\s+URL\s*\(\s*('[^']+'|"[^"]+"|`[^`]+`)\s*,\s*import\.meta\.url\s*,?\s*\)/g;
            const noCommentsCode = code.replace(multilineCommentsRE, blankReplacer).replace(singlelineCommentsRE, blankReplacer).replace(stringsRE, (m3) => `'${"\0".repeat(m3.length - 2)}'`);
            let s2 = null;
            let match2;
            while (match2 = importMetaUrlRE.exec(noCommentsCode)) {
              const { 0: exp, 1: emptyUrl, index: index2 } = match2;
              const urlStart = exp.indexOf(emptyUrl) + index2;
              const urlEnd = urlStart + emptyUrl.length;
              const rawUrl = code.slice(urlStart, urlEnd);
              if (!s2)
                s2 = new MagicString(code);
              if (rawUrl[0] === "`" && /\$\{/.test(rawUrl)) {
                const ast = this.parse(rawUrl);
                const templateLiteral = ast.body[0].expression;
                if (templateLiteral.expressions.length) {
                  const pattern2 = buildGlobPattern(templateLiteral);
                  s2.overwrite(index2, index2 + exp.length, `new URL(import.meta.globEagerDefault(${JSON.stringify(pattern2)})[${rawUrl}], self.location)`, { contentOnly: true });
                  continue;
                }
              }
              const url2 = rawUrl.slice(1, -1);
              const file = path__default.resolve(path__default.dirname(id), url2);
              const builtUrl = await fileToUrl(file, config2, this).catch(() => {
                config2.logger.warnOnce(`
${exp} doesn't exist at build time, it will remain unchanged to be resolved at runtime`);
                return url2;
              });
              s2.overwrite(index2, index2 + exp.length, `new URL(${JSON.stringify(builtUrl)}, self.location)`, { contentOnly: true });
            }
            if (s2) {
              return {
                code: s2.toString(),
                map: config2.build.sourcemap ? s2.generateMap({ hires: true }) : null
              };
            }
          }
          return null;
        }
      };
    }
    function buildGlobPattern(ast) {
      let pattern2 = "";
      let lastElementIndex = -1;
      for (const exp of ast.expressions) {
        for (let i2 = lastElementIndex + 1; i2 < ast.quasis.length; i2++) {
          const el2 = ast.quasis[i2];
          if (el2.end < exp.start) {
            pattern2 += el2.value.raw;
            lastElementIndex = i2;
          }
        }
        pattern2 += "**";
      }
      for (let i2 = lastElementIndex + 1; i2 < ast.quasis.length; i2++) {
        pattern2 += ast.quasis[i2].value.raw;
      }
      return pattern2;
    }
    function loadFallbackPlugin() {
      return {
        name: "vite:load-fallback",
        async load(id) {
          try {
            return await fs$n.promises.readFile(cleanUrl(id), "utf-8");
          } catch (e2) {
            return fs$n.promises.readFile(id, "utf-8");
          }
        }
      };
    }
    function resolveBuildOptions(raw) {
      const resolved = __spreadProps2(__spreadValues2({
        target: "modules",
        polyfillModulePreload: true,
        outDir: "dist",
        assetsDir: "assets",
        assetsInlineLimit: 4096,
        cssCodeSplit: !(raw === null || raw === void 0 ? void 0 : raw.lib),
        cssTarget: false,
        sourcemap: false,
        rollupOptions: {},
        minify: (raw === null || raw === void 0 ? void 0 : raw.ssr) ? false : "esbuild",
        terserOptions: {},
        write: true,
        emptyOutDir: null,
        manifest: false,
        lib: false,
        ssr: false,
        ssrManifest: false,
        reportCompressedSize: true,
        chunkSizeWarningLimit: 500,
        watch: null
      }, raw), {
        commonjsOptions: __spreadValues2({
          include: [/node_modules/],
          extensions: [".js", ".cjs"]
        }, raw === null || raw === void 0 ? void 0 : raw.commonjsOptions),
        dynamicImportVarsOptions: __spreadValues2({
          warnOnError: true,
          exclude: [/node_modules/]
        }, raw === null || raw === void 0 ? void 0 : raw.dynamicImportVarsOptions)
      });
      if (resolved.target === "modules") {
        resolved.target = [
          "es2019",
          "edge88",
          "firefox78",
          "chrome87",
          "safari13.1"
        ];
      } else if (resolved.target === "esnext" && resolved.minify === "terser") {
        resolved.target = "es2019";
      }
      if (!resolved.cssTarget) {
        resolved.cssTarget = resolved.target;
      }
      if (resolved.minify === "false") {
        resolved.minify = false;
      }
      if (resolved.minify === true) {
        resolved.minify = "esbuild";
      }
      return resolved;
    }
    function resolveBuildPlugins(config2) {
      const options2 = config2.build;
      return {
        pre: [
          watchPackageDataPlugin(config2),
          commonjs(options2.commonjsOptions),
          dataURIPlugin(),
          dynamicImportVariables(options2.dynamicImportVarsOptions),
          assetImportMetaUrlPlugin(config2),
          ...options2.rollupOptions.plugins ? options2.rollupOptions.plugins.filter(Boolean) : []
        ],
        post: [
          buildImportAnalysisPlugin(config2),
          buildEsbuildPlugin(config2),
          ...options2.minify ? [terserPlugin(config2)] : [],
          ...options2.manifest ? [manifestPlugin(config2)] : [],
          ...options2.ssrManifest ? [ssrManifestPlugin(config2)] : [],
          buildReporterPlugin(config2),
          loadFallbackPlugin()
        ]
      };
    }
    var parallelCallCounts = 0;
    var parallelBuilds = [];
    async function build(inlineConfig = {}) {
      parallelCallCounts++;
      try {
        return await doBuild(inlineConfig);
      } finally {
        parallelCallCounts--;
        if (parallelCallCounts <= 0) {
          await Promise.all(parallelBuilds.map((bundle) => bundle.close()));
          parallelBuilds.length = 0;
        }
      }
    }
    async function doBuild(inlineConfig = {}) {
      var _a2, _b, _c, _d;
      const config2 = await resolveConfig(inlineConfig, "build", "production");
      const options2 = config2.build;
      const ssr = !!options2.ssr;
      const libOptions = options2.lib;
      config2.logger.info(colors$1.cyan(`vite v${require_package().version} ${colors$1.green(`building ${ssr ? `SSR bundle ` : ``}for ${config2.mode}...`)}`));
      const resolve2 = (p2) => path__default.resolve(config2.root, p2);
      const input = libOptions ? resolve2(libOptions.entry) : typeof options2.ssr === "string" ? resolve2(options2.ssr) : ((_a2 = options2.rollupOptions) === null || _a2 === void 0 ? void 0 : _a2.input) || resolve2("index.html");
      if (ssr && typeof input === "string" && input.endsWith(".html")) {
        throw new Error(`rollupOptions.input should not be an html file when building for SSR. Please specify a dedicated SSR entry.`);
      }
      const outDir = resolve2(options2.outDir);
      const plugins2 = ssr ? config2.plugins.map((p2) => injectSsrFlagToHooks(p2)) : config2.plugins;
      const userExternal = (_b = options2.rollupOptions) === null || _b === void 0 ? void 0 : _b.external;
      let external = userExternal;
      if (ssr) {
        let knownImports;
        const dataPath = path__default.join(getDepsCacheDir(config2), "_metadata.json");
        try {
          const data2 = JSON.parse(fs__default.readFileSync(dataPath, "utf-8"));
          knownImports = Object.keys(data2.optimized);
        } catch (e2) {
        }
        if (!knownImports) {
          knownImports = await findKnownImports(config2);
        }
        external = resolveExternal(resolveSSRExternal(config2, knownImports), userExternal);
      }
      const rollup = (init_rollup_browser(), __toCommonJS(rollup_browser_exports));
      const rollupOptions = __spreadProps2(__spreadValues2({
        input,
        context: "globalThis",
        preserveEntrySignatures: ssr ? "allow-extension" : libOptions ? "strict" : false
      }, options2.rollupOptions), {
        plugins: plugins2,
        external,
        onwarn(warning, warn2) {
          onRollupWarning(warning, warn2, config2);
        }
      });
      const outputBuildError = (e2) => {
        let msg = colors$1.red((e2.plugin ? `[${e2.plugin}] ` : "") + e2.message);
        if (e2.id) {
          msg += `
file: ${colors$1.cyan(e2.id + (e2.loc ? `:${e2.loc.line}:${e2.loc.column}` : ""))}`;
        }
        if (e2.frame) {
          msg += `
` + colors$1.yellow(e2.frame);
        }
        config2.logger.error(msg, { error: e2 });
      };
      try {
        const buildOutputOptions = (output = {}) => {
          if (output.output) {
            config2.logger.warn(`You've set "rollupOptions.output.output" in your config. This is deprecated and will override all Vite.js default output options. Please use "rollupOptions.output" instead.`);
          }
          return __spreadValues2({
            dir: outDir,
            format: ssr ? "cjs" : "es",
            exports: ssr ? "named" : "auto",
            sourcemap: options2.sourcemap,
            name: libOptions ? libOptions.name : void 0,
            entryFileNames: ssr ? `[name].js` : libOptions ? resolveLibFilename(libOptions, output.format || "es", config2.root) : path__default.posix.join(options2.assetsDir, `[name].[hash].js`),
            chunkFileNames: libOptions ? `[name].js` : path__default.posix.join(options2.assetsDir, `[name].[hash].js`),
            assetFileNames: libOptions ? `[name].[ext]` : path__default.posix.join(options2.assetsDir, `[name].[hash].[ext]`),
            namespaceToStringTag: true,
            inlineDynamicImports: ssr && typeof input === "string"
          }, output);
        };
        const outputs = resolveBuildOutputs((_c = options2.rollupOptions) === null || _c === void 0 ? void 0 : _c.output, libOptions, config2.logger);
        if (config2.build.watch) {
          config2.logger.info(colors$1.cyan(`
watching for file changes...`));
          const output = [];
          if (Array.isArray(outputs)) {
            for (const resolvedOutput of outputs) {
              output.push(buildOutputOptions(resolvedOutput));
            }
          } else {
            output.push(buildOutputOptions(outputs));
          }
          const watcherOptions = config2.build.watch;
          const watcher = rollup.watch(__spreadProps2(__spreadValues2({}, rollupOptions), {
            output,
            watch: __spreadProps2(__spreadValues2({}, watcherOptions), {
              chokidar: __spreadProps2(__spreadValues2({
                ignoreInitial: true,
                ignorePermissionErrors: true
              }, watcherOptions.chokidar), {
                ignored: [
                  "**/node_modules/**",
                  "**/.git/**",
                  ...((_d = watcherOptions === null || watcherOptions === void 0 ? void 0 : watcherOptions.chokidar) === null || _d === void 0 ? void 0 : _d.ignored) || []
                ]
              })
            })
          }));
          watcher.on("event", (event) => {
            if (event.code === "BUNDLE_START") {
              config2.logger.info(colors$1.cyan(`
build started...`));
              if (options2.write) {
                prepareOutDir(outDir, options2.emptyOutDir, config2);
              }
            } else if (event.code === "BUNDLE_END") {
              event.result.close();
              config2.logger.info(colors$1.cyan(`built in ${event.duration}ms.`));
            } else if (event.code === "ERROR") {
              outputBuildError(event.error);
            }
          });
          watcher.close();
          return watcher;
        }
        const bundle = await rollup.rollup(rollupOptions);
        parallelBuilds.push(bundle);
        const generate2 = (output = {}) => {
          return bundle[options2.write ? "write" : "generate"](buildOutputOptions(output));
        };
        if (options2.write) {
          prepareOutDir(outDir, options2.emptyOutDir, config2);
        }
        if (Array.isArray(outputs)) {
          const res = [];
          for (const output of outputs) {
            res.push(await generate2(output));
          }
          return res;
        } else {
          return await generate2(outputs);
        }
      } catch (e2) {
        outputBuildError(e2);
        throw e2;
      }
    }
    function prepareOutDir(outDir, emptyOutDir, config2) {
      if (fs__default.existsSync(outDir)) {
        if (emptyOutDir == null && !normalizePath$4(outDir).startsWith(config2.root + "/")) {
          config2.logger.warn(colors$1.yellow(`
${colors$1.bold(`(!)`)} outDir ${colors$1.white(colors$1.dim(outDir))} is not inside project root and will not be emptied.
Use --emptyOutDir to override.
`));
        } else if (emptyOutDir !== false) {
          emptyDir(outDir, [".git"]);
        }
      }
      if (config2.publicDir && fs__default.existsSync(config2.publicDir)) {
        copyDir(config2.publicDir, outDir);
      }
    }
    function getPkgName(root2) {
      const { name } = JSON.parse(lookupFile(root2, ["package.json"]) || `{}`);
      return (name === null || name === void 0 ? void 0 : name.startsWith("@")) ? name.split("/")[1] : name;
    }
    function resolveLibFilename(libOptions, format2, root2) {
      if (typeof libOptions.fileName === "function") {
        return libOptions.fileName(format2);
      }
      const name = libOptions.fileName || getPkgName(root2);
      if (!name)
        throw new Error('Name in package.json is required if option "build.lib.fileName" is not provided.');
      return `${name}.${format2}.js`;
    }
    function resolveBuildOutputs(outputs, libOptions, logger) {
      if (libOptions) {
        const formats = libOptions.formats || ["es", "umd"];
        if ((formats.includes("umd") || formats.includes("iife")) && !libOptions.name) {
          throw new Error(`Option "build.lib.name" is required when output formats include "umd" or "iife".`);
        }
        if (!outputs) {
          return formats.map((format2) => ({ format: format2 }));
        } else if (!Array.isArray(outputs)) {
          return formats.map((format2) => __spreadProps2(__spreadValues2({}, outputs), { format: format2 }));
        } else if (libOptions.formats) {
          logger.warn(colors$1.yellow(`"build.lib.formats" will be ignored because "build.rollupOptions.output" is already an array format`));
        }
      }
      return outputs;
    }
    var warningIgnoreList = [`CIRCULAR_DEPENDENCY`, `THIS_IS_UNDEFINED`];
    var dynamicImportWarningIgnoreList = [
      `Unsupported expression`,
      `statically analyzed`
    ];
    function onRollupWarning(warning, warn2, config2) {
      var _a2;
      if (warning.code === "UNRESOLVED_IMPORT") {
        const id = warning.source;
        const importer = warning.importer;
        if (!importer || !/\?commonjs-external$/.test(importer)) {
          throw new Error(`[vite]: Rollup failed to resolve import "${id}" from "${importer}".
This is most likely unintended because it can break your application at runtime.
If you do want to externalize this module explicitly add it to
\`build.rollupOptions.external\``);
        }
      }
      if (warning.plugin === "rollup-plugin-dynamic-import-variables" && dynamicImportWarningIgnoreList.some((msg) => warning.message.includes(msg))) {
        return;
      }
      if (!warningIgnoreList.includes(warning.code)) {
        const userOnWarn = (_a2 = config2.build.rollupOptions) === null || _a2 === void 0 ? void 0 : _a2.onwarn;
        if (userOnWarn) {
          userOnWarn(warning, warn2);
        } else if (warning.code === "PLUGIN_WARNING") {
          config2.logger.warn(`${colors$1.bold(colors$1.yellow(`[plugin:${warning.plugin}]`))} ${colors$1.yellow(warning.message)}`);
        } else {
          warn2(warning);
        }
      }
    }
    function resolveExternal(ssrExternals, user) {
      return (id, parentId, isResolved) => {
        if (shouldExternalizeForSSR(id, ssrExternals)) {
          return true;
        }
        if (user) {
          if (typeof user === "function") {
            return user(id, parentId, isResolved);
          } else if (Array.isArray(user)) {
            return user.some((test) => isExternal(id, test));
          } else {
            return isExternal(id, user);
          }
        }
      };
    }
    function isExternal(id, test) {
      if (typeof test === "string") {
        return id === test;
      } else {
        return test.test(id);
      }
    }
    function injectSsrFlagToHooks(plugin) {
      const { resolveId: resolveId2, load: load2, transform: transform2 } = plugin;
      return __spreadProps2(__spreadValues2({}, plugin), {
        resolveId: wrapSsrResolveId(resolveId2),
        load: wrapSsrLoad(load2),
        transform: wrapSsrTransform(transform2)
      });
    }
    function wrapSsrResolveId(fn2) {
      if (!fn2)
        return;
      return function(id, importer, options2) {
        return fn2.call(this, id, importer, injectSsrFlag(options2));
      };
    }
    function wrapSsrLoad(fn2) {
      if (!fn2)
        return;
      return function(id, ...args) {
        return fn2.call(this, id, injectSsrFlag(args[0]));
      };
    }
    function wrapSsrTransform(fn2) {
      if (!fn2)
        return;
      return function(code, importer, ...args) {
        return fn2.call(this, code, importer, injectSsrFlag(args[0]));
      };
    }
    function injectSsrFlag(options2) {
      return __spreadProps2(__spreadValues2({}, options2 !== null && options2 !== void 0 ? options2 : {}), { ssr: true });
    }
    var build$1 = {
      __proto__: null,
      resolveBuildOptions,
      resolveBuildPlugins,
      build,
      resolveLibFilename,
      onRollupWarning
    };
    var src = { exports: {} };
    var browser = { exports: {} };
    var debug$8 = { exports: {} };
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var y = d * 365.25;
    var ms = function(val, options2) {
      options2 = options2 || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse$c(val);
      } else if (type === "number" && isNaN(val) === false) {
        return options2.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse$c(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match2 = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
      if (!match2) {
        return;
      }
      var n3 = parseFloat(match2[1]);
      var type = (match2[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n3 * y;
        case "days":
        case "day":
        case "d":
          return n3 * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n3 * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n3 * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n3 * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n3;
        default:
          return void 0;
      }
    }
    function fmtShort(ms3) {
      if (ms3 >= d) {
        return Math.round(ms3 / d) + "d";
      }
      if (ms3 >= h) {
        return Math.round(ms3 / h) + "h";
      }
      if (ms3 >= m) {
        return Math.round(ms3 / m) + "m";
      }
      if (ms3 >= s) {
        return Math.round(ms3 / s) + "s";
      }
      return ms3 + "ms";
    }
    function fmtLong(ms3) {
      return plural(ms3, d, "day") || plural(ms3, h, "hour") || plural(ms3, m, "minute") || plural(ms3, s, "second") || ms3 + " ms";
    }
    function plural(ms3, n3, name) {
      if (ms3 < n3) {
        return;
      }
      if (ms3 < n3 * 1.5) {
        return Math.floor(ms3 / n3) + " " + name;
      }
      return Math.ceil(ms3 / n3) + " " + name + "s";
    }
    (function(module2, exports2) {
      exports2 = module2.exports = createDebug.debug = createDebug["default"] = createDebug;
      exports2.coerce = coerce;
      exports2.disable = disable;
      exports2.enable = enable;
      exports2.enabled = enabled;
      exports2.humanize = ms;
      exports2.names = [];
      exports2.skips = [];
      exports2.formatters = {};
      var prevTime;
      function selectColor(namespace) {
        var hash = 0, i2;
        for (i2 in namespace) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i2);
          hash |= 0;
        }
        return exports2.colors[Math.abs(hash) % exports2.colors.length];
      }
      function createDebug(namespace) {
        function debug2() {
          if (!debug2.enabled)
            return;
          var self2 = debug2;
          var curr = +new Date();
          var ms3 = curr - (prevTime || curr);
          self2.diff = ms3;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          var args = new Array(arguments.length);
          for (var i2 = 0; i2 < args.length; i2++) {
            args[i2] = arguments[i2];
          }
          args[0] = exports2.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          var index2 = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match2, format2) {
            if (match2 === "%%")
              return match2;
            index2++;
            var formatter2 = exports2.formatters[format2];
            if (typeof formatter2 === "function") {
              var val = args[index2];
              match2 = formatter2.call(self2, val);
              args.splice(index2, 1);
              index2--;
            }
            return match2;
          });
          exports2.formatArgs.call(self2, args);
          var logFn = debug2.log || exports2.log || console.log.bind(console);
          logFn.apply(self2, args);
        }
        debug2.namespace = namespace;
        debug2.enabled = exports2.enabled(namespace);
        debug2.useColors = exports2.useColors();
        debug2.color = selectColor(namespace);
        if (typeof exports2.init === "function") {
          exports2.init(debug2);
        }
        return debug2;
      }
      function enable(namespaces) {
        exports2.save(namespaces);
        exports2.names = [];
        exports2.skips = [];
        var split2 = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        var len = split2.length;
        for (var i2 = 0; i2 < len; i2++) {
          if (!split2[i2])
            continue;
          namespaces = split2[i2].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            exports2.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
          } else {
            exports2.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        exports2.enable("");
      }
      function enabled(name) {
        var i2, len;
        for (i2 = 0, len = exports2.skips.length; i2 < len; i2++) {
          if (exports2.skips[i2].test(name)) {
            return false;
          }
        }
        for (i2 = 0, len = exports2.names.length; i2 < len; i2++) {
          if (exports2.names[i2].test(name)) {
            return true;
          }
        }
        return false;
      }
      function coerce(val) {
        if (val instanceof Error)
          return val.stack || val.message;
        return val;
      }
    })(debug$8, debug$8.exports);
    (function(module2, exports2) {
      exports2 = module2.exports = debug$8.exports;
      exports2.log = log2;
      exports2.formatArgs = formatArgs;
      exports2.save = save;
      exports2.load = load2;
      exports2.useColors = useColors;
      exports2.storage = typeof chrome != "undefined" && typeof chrome.storage != "undefined" ? chrome.storage.local : localstorage();
      exports2.colors = [
        "lightseagreen",
        "forestgreen",
        "goldenrod",
        "dodgerblue",
        "darkorchid",
        "crimson"
      ];
      function useColors() {
        if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
          return true;
        }
        return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
      }
      exports2.formatters.j = function(v2) {
        try {
          return JSON.stringify(v2);
        } catch (err) {
          return "[UnexpectedJSONParseError]: " + err.message;
        }
      };
      function formatArgs(args) {
        var useColors2 = this.useColors;
        args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports2.humanize(this.diff);
        if (!useColors2)
          return;
        var c3 = "color: " + this.color;
        args.splice(1, 0, c3, "color: inherit");
        var index2 = 0;
        var lastC = 0;
        args[0].replace(/%[a-zA-Z%]/g, function(match2) {
          if (match2 === "%%")
            return;
          index2++;
          if (match2 === "%c") {
            lastC = index2;
          }
        });
        args.splice(lastC, 0, c3);
      }
      function log2() {
        return typeof console === "object" && console.log && Function.prototype.apply.call(console.log, console, arguments);
      }
      function save(namespaces) {
        try {
          if (namespaces == null) {
            exports2.storage.removeItem("debug");
          } else {
            exports2.storage.debug = namespaces;
          }
        } catch (e2) {
        }
      }
      function load2() {
        var r2;
        try {
          r2 = exports2.storage.debug;
        } catch (e2) {
        }
        if (!r2 && typeof process !== "undefined" && "env" in process) {
          r2 = process.env.DEBUG;
        }
        return r2;
      }
      exports2.enable(load2());
      function localstorage() {
        try {
          return window.localStorage;
        } catch (e2) {
        }
      }
    })(browser, browser.exports);
    var node = { exports: {} };
    (function(module2, exports2) {
      var tty2 = require$$0__default;
      var util2 = require$$0__default$1;
      exports2 = module2.exports = debug$8.exports;
      exports2.init = init2;
      exports2.log = log2;
      exports2.formatArgs = formatArgs;
      exports2.save = save;
      exports2.load = load2;
      exports2.useColors = useColors;
      exports2.colors = [6, 2, 3, 4, 5, 1];
      exports2.inspectOpts = Object.keys(process.env).filter(function(key2) {
        return /^debug_/i.test(key2);
      }).reduce(function(obj, key2) {
        var prop = key2.substring(6).toLowerCase().replace(/_([a-z])/g, function(_2, k2) {
          return k2.toUpperCase();
        });
        var val = process.env[key2];
        if (/^(yes|on|true|enabled)$/i.test(val))
          val = true;
        else if (/^(no|off|false|disabled)$/i.test(val))
          val = false;
        else if (val === "null")
          val = null;
        else
          val = Number(val);
        obj[prop] = val;
        return obj;
      }, {});
      var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
      if (fd !== 1 && fd !== 2) {
        util2.deprecate(function() {
        }, "except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)")();
      }
      var stream2 = fd === 1 ? process.stdout : fd === 2 ? process.stderr : createWritableStdioStream(fd);
      function useColors() {
        return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty2.isatty(fd);
      }
      exports2.formatters.o = function(v2) {
        this.inspectOpts.colors = this.useColors;
        return util2.inspect(v2, this.inspectOpts).split("\n").map(function(str) {
          return str.trim();
        }).join(" ");
      };
      exports2.formatters.O = function(v2) {
        this.inspectOpts.colors = this.useColors;
        return util2.inspect(v2, this.inspectOpts);
      };
      function formatArgs(args) {
        var name = this.namespace;
        var useColors2 = this.useColors;
        if (useColors2) {
          var c3 = this.color;
          var prefix = "  \x1B[3" + c3 + ";1m" + name + " \x1B[0m";
          args[0] = prefix + args[0].split("\n").join("\n" + prefix);
          args.push("\x1B[3" + c3 + "m+" + exports2.humanize(this.diff) + "\x1B[0m");
        } else {
          args[0] = new Date().toUTCString() + " " + name + " " + args[0];
        }
      }
      function log2() {
        return stream2.write(util2.format.apply(util2, arguments) + "\n");
      }
      function save(namespaces) {
        if (namespaces == null) {
          delete process.env.DEBUG;
        } else {
          process.env.DEBUG = namespaces;
        }
      }
      function load2() {
        return process.env.DEBUG;
      }
      function createWritableStdioStream(fd2) {
        var stream3;
        var tty_wrap = process.binding("tty_wrap");
        switch (tty_wrap.guessHandleType(fd2)) {
          case "TTY":
            stream3 = new tty2.WriteStream(fd2);
            stream3._type = "tty";
            if (stream3._handle && stream3._handle.unref) {
              stream3._handle.unref();
            }
            break;
          case "FILE":
            var fs3 = fs__default;
            stream3 = new fs3.SyncWriteStream(fd2, { autoClose: false });
            stream3._type = "fs";
            break;
          case "PIPE":
          case "TCP":
            var net2 = require$$3__default;
            stream3 = new net2.Socket({
              fd: fd2,
              readable: false,
              writable: true
            });
            stream3.readable = false;
            stream3.read = null;
            stream3._type = "pipe";
            if (stream3._handle && stream3._handle.unref) {
              stream3._handle.unref();
            }
            break;
          default:
            throw new Error("Implement me. Unknown stream file type!");
        }
        stream3.fd = fd2;
        stream3._isStdio = true;
        return stream3;
      }
      function init2(debug2) {
        debug2.inspectOpts = {};
        var keys = Object.keys(exports2.inspectOpts);
        for (var i2 = 0; i2 < keys.length; i2++) {
          debug2.inspectOpts[keys[i2]] = exports2.inspectOpts[keys[i2]];
        }
      }
      exports2.enable(load2());
    })(node, node.exports);
    if (typeof process !== "undefined" && process.type === "renderer") {
      src.exports = browser.exports;
    } else {
      src.exports = node.exports;
    }
    var encodeurl = encodeUrl$1;
    var ENCODE_CHARS_REGEXP = /(?:[^\x21\x25\x26-\x3B\x3D\x3F-\x5B\x5D\x5F\x61-\x7A\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g;
    var UNMATCHED_SURROGATE_PAIR_REGEXP = /(^|[^\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/g;
    var UNMATCHED_SURROGATE_PAIR_REPLACE = "$1\uFFFD$2";
    function encodeUrl$1(url2) {
      return String(url2).replace(UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE).replace(ENCODE_CHARS_REGEXP, encodeURI);
    }
    var matchHtmlRegExp = /["'&<>]/;
    var escapeHtml_1 = escapeHtml$1;
    function escapeHtml$1(string2) {
      var str = "" + string2;
      var match2 = matchHtmlRegExp.exec(str);
      if (!match2) {
        return str;
      }
      var escape2;
      var html = "";
      var index2 = 0;
      var lastIndex = 0;
      for (index2 = match2.index; index2 < str.length; index2++) {
        switch (str.charCodeAt(index2)) {
          case 34:
            escape2 = "&quot;";
            break;
          case 38:
            escape2 = "&amp;";
            break;
          case 39:
            escape2 = "&#39;";
            break;
          case 60:
            escape2 = "&lt;";
            break;
          case 62:
            escape2 = "&gt;";
            break;
          default:
            continue;
        }
        if (lastIndex !== index2) {
          html += str.substring(lastIndex, index2);
        }
        lastIndex = index2 + 1;
        html += escape2;
      }
      return lastIndex !== index2 ? html + str.substring(lastIndex, index2) : html;
    }
    var onFinished$2 = { exports: {} };
    var eeFirst = first$1;
    function first$1(stuff, done) {
      if (!Array.isArray(stuff))
        throw new TypeError("arg must be an array of [ee, events...] arrays");
      var cleanups = [];
      for (var i2 = 0; i2 < stuff.length; i2++) {
        var arr = stuff[i2];
        if (!Array.isArray(arr) || arr.length < 2)
          throw new TypeError("each array member must be [ee, events...]");
        var ee2 = arr[0];
        for (var j2 = 1; j2 < arr.length; j2++) {
          var event = arr[j2];
          var fn2 = listener(event, callback);
          ee2.on(event, fn2);
          cleanups.push({
            ee: ee2,
            event,
            fn: fn2
          });
        }
      }
      function callback() {
        cleanup();
        done.apply(null, arguments);
      }
      function cleanup() {
        var x2;
        for (var i3 = 0; i3 < cleanups.length; i3++) {
          x2 = cleanups[i3];
          x2.ee.removeListener(x2.event, x2.fn);
        }
      }
      function thunk(fn3) {
        done = fn3;
      }
      thunk.cancel = cleanup;
      return thunk;
    }
    function listener(event, done) {
      return function onevent(arg1) {
        var args = new Array(arguments.length);
        var ee2 = this;
        var err = event === "error" ? arg1 : null;
        for (var i2 = 0; i2 < args.length; i2++) {
          args[i2] = arguments[i2];
        }
        done(err, ee2, event, args);
      };
    }
    onFinished$2.exports = onFinished$1;
    onFinished$2.exports.isFinished = isFinished$1;
    var first = eeFirst;
    var defer$2 = typeof setImmediate === "function" ? setImmediate : function(fn2) {
      process.nextTick(fn2.bind.apply(fn2, arguments));
    };
    function onFinished$1(msg, listener2) {
      if (isFinished$1(msg) !== false) {
        defer$2(listener2, null, msg);
        return msg;
      }
      attachListener(msg, listener2);
      return msg;
    }
    function isFinished$1(msg) {
      var socket = msg.socket;
      if (typeof msg.finished === "boolean") {
        return Boolean(msg.finished || socket && !socket.writable);
      }
      if (typeof msg.complete === "boolean") {
        return Boolean(msg.upgrade || !socket || !socket.readable || msg.complete && !msg.readable);
      }
      return void 0;
    }
    function attachFinishedListener(msg, callback) {
      var eeMsg;
      var eeSocket;
      var finished = false;
      function onFinish(error2) {
        eeMsg.cancel();
        eeSocket.cancel();
        finished = true;
        callback(error2);
      }
      eeMsg = eeSocket = first([[msg, "end", "finish"]], onFinish);
      function onSocket(socket) {
        msg.removeListener("socket", onSocket);
        if (finished)
          return;
        if (eeMsg !== eeSocket)
          return;
        eeSocket = first([[socket, "error", "close"]], onFinish);
      }
      if (msg.socket) {
        onSocket(msg.socket);
        return;
      }
      msg.on("socket", onSocket);
      if (msg.socket === void 0) {
        patchAssignSocket(msg, onSocket);
      }
    }
    function attachListener(msg, listener2) {
      var attached = msg.__onFinished;
      if (!attached || !attached.queue) {
        attached = msg.__onFinished = createListener(msg);
        attachFinishedListener(msg, attached);
      }
      attached.queue.push(listener2);
    }
    function createListener(msg) {
      function listener2(err) {
        if (msg.__onFinished === listener2)
          msg.__onFinished = null;
        if (!listener2.queue)
          return;
        var queue2 = listener2.queue;
        listener2.queue = null;
        for (var i2 = 0; i2 < queue2.length; i2++) {
          queue2[i2](err, msg);
        }
      }
      listener2.queue = [];
      return listener2;
    }
    function patchAssignSocket(res, callback) {
      var assignSocket = res.assignSocket;
      if (typeof assignSocket !== "function")
        return;
      res.assignSocket = function _assignSocket(socket) {
        assignSocket.call(this, socket);
        callback(socket);
      };
    }
    var parseurl$1 = { exports: {} };
    var url$3 = require$$0__default$5;
    var parse$b = url$3.parse;
    var Url = url$3.Url;
    parseurl$1.exports = parseurl;
    parseurl$1.exports.original = originalurl;
    function parseurl(req2) {
      var url2 = req2.url;
      if (url2 === void 0) {
        return void 0;
      }
      var parsed = req2._parsedUrl;
      if (fresh(url2, parsed)) {
        return parsed;
      }
      parsed = fastparse(url2);
      parsed._raw = url2;
      return req2._parsedUrl = parsed;
    }
    function originalurl(req2) {
      var url2 = req2.originalUrl;
      if (typeof url2 !== "string") {
        return parseurl(req2);
      }
      var parsed = req2._parsedOriginalUrl;
      if (fresh(url2, parsed)) {
        return parsed;
      }
      parsed = fastparse(url2);
      parsed._raw = url2;
      return req2._parsedOriginalUrl = parsed;
    }
    function fastparse(str) {
      if (typeof str !== "string" || str.charCodeAt(0) !== 47) {
        return parse$b(str);
      }
      var pathname = str;
      var query = null;
      var search = null;
      for (var i2 = 1; i2 < str.length; i2++) {
        switch (str.charCodeAt(i2)) {
          case 63:
            if (search === null) {
              pathname = str.substring(0, i2);
              query = str.substring(i2 + 1);
              search = str.substring(i2);
            }
            break;
          case 9:
          case 10:
          case 12:
          case 13:
          case 32:
          case 35:
          case 160:
          case 65279:
            return parse$b(str);
        }
      }
      var url2 = Url !== void 0 ? new Url() : {};
      url2.path = str;
      url2.href = str;
      url2.pathname = pathname;
      if (search !== null) {
        url2.query = query;
        url2.search = search;
      }
      return url2;
    }
    function fresh(url2, parsedUrl) {
      return typeof parsedUrl === "object" && parsedUrl !== null && (Url === void 0 || parsedUrl instanceof Url) && parsedUrl._raw === url2;
    }
    var require$$0$1 = {
      "100": "Continue",
      "101": "Switching Protocols",
      "102": "Processing",
      "103": "Early Hints",
      "200": "OK",
      "201": "Created",
      "202": "Accepted",
      "203": "Non-Authoritative Information",
      "204": "No Content",
      "205": "Reset Content",
      "206": "Partial Content",
      "207": "Multi-Status",
      "208": "Already Reported",
      "226": "IM Used",
      "300": "Multiple Choices",
      "301": "Moved Permanently",
      "302": "Found",
      "303": "See Other",
      "304": "Not Modified",
      "305": "Use Proxy",
      "306": "(Unused)",
      "307": "Temporary Redirect",
      "308": "Permanent Redirect",
      "400": "Bad Request",
      "401": "Unauthorized",
      "402": "Payment Required",
      "403": "Forbidden",
      "404": "Not Found",
      "405": "Method Not Allowed",
      "406": "Not Acceptable",
      "407": "Proxy Authentication Required",
      "408": "Request Timeout",
      "409": "Conflict",
      "410": "Gone",
      "411": "Length Required",
      "412": "Precondition Failed",
      "413": "Payload Too Large",
      "414": "URI Too Long",
      "415": "Unsupported Media Type",
      "416": "Range Not Satisfiable",
      "417": "Expectation Failed",
      "418": "I'm a teapot",
      "421": "Misdirected Request",
      "422": "Unprocessable Entity",
      "423": "Locked",
      "424": "Failed Dependency",
      "425": "Unordered Collection",
      "426": "Upgrade Required",
      "428": "Precondition Required",
      "429": "Too Many Requests",
      "431": "Request Header Fields Too Large",
      "451": "Unavailable For Legal Reasons",
      "500": "Internal Server Error",
      "501": "Not Implemented",
      "502": "Bad Gateway",
      "503": "Service Unavailable",
      "504": "Gateway Timeout",
      "505": "HTTP Version Not Supported",
      "506": "Variant Also Negotiates",
      "507": "Insufficient Storage",
      "508": "Loop Detected",
      "509": "Bandwidth Limit Exceeded",
      "510": "Not Extended",
      "511": "Network Authentication Required"
    };
    var codes = require$$0$1;
    var statuses$1 = status;
    status.STATUS_CODES = codes;
    status.codes = populateStatusesMap(status, codes);
    status.redirect = {
      300: true,
      301: true,
      302: true,
      303: true,
      305: true,
      307: true,
      308: true
    };
    status.empty = {
      204: true,
      205: true,
      304: true
    };
    status.retry = {
      502: true,
      503: true,
      504: true
    };
    function populateStatusesMap(statuses2, codes2) {
      var arr = [];
      Object.keys(codes2).forEach(function forEachCode(code) {
        var message = codes2[code];
        var status2 = Number(code);
        statuses2[status2] = message;
        statuses2[message] = status2;
        statuses2[message.toLowerCase()] = status2;
        arr.push(status2);
      });
      return arr;
    }
    function status(code) {
      if (typeof code === "number") {
        if (!status[code])
          throw new Error("invalid status code: " + code);
        return code;
      }
      if (typeof code !== "string") {
        throw new TypeError("code must be a number or string");
      }
      var n3 = parseInt(code, 10);
      if (!isNaN(n3)) {
        if (!status[n3])
          throw new Error("invalid status code: " + n3);
        return n3;
      }
      n3 = status[code.toLowerCase()];
      if (!n3)
        throw new Error('invalid status message: "' + code + '"');
      return n3;
    }
    var unpipe_1 = unpipe$1;
    function hasPipeDataListeners(stream2) {
      var listeners = stream2.listeners("data");
      for (var i2 = 0; i2 < listeners.length; i2++) {
        if (listeners[i2].name === "ondata") {
          return true;
        }
      }
      return false;
    }
    function unpipe$1(stream2) {
      if (!stream2) {
        throw new TypeError("argument stream is required");
      }
      if (typeof stream2.unpipe === "function") {
        stream2.unpipe();
        return;
      }
      if (!hasPipeDataListeners(stream2)) {
        return;
      }
      var listener2;
      var listeners = stream2.listeners("close");
      for (var i2 = 0; i2 < listeners.length; i2++) {
        listener2 = listeners[i2];
        if (listener2.name !== "cleanup" && listener2.name !== "onclose") {
          continue;
        }
        listener2.call(stream2);
      }
    }
    var debug$7 = src.exports("finalhandler");
    var encodeUrl = encodeurl;
    var escapeHtml = escapeHtml_1;
    var onFinished = onFinished$2.exports;
    var parseUrl$1 = parseurl$1.exports;
    var statuses = statuses$1;
    var unpipe = unpipe_1;
    var DOUBLE_SPACE_REGEXP = /\x20{2}/g;
    var NEWLINE_REGEXP = /\n/g;
    var defer$1 = typeof setImmediate === "function" ? setImmediate : function(fn2) {
      process.nextTick(fn2.bind.apply(fn2, arguments));
    };
    var isFinished = onFinished.isFinished;
    function createHtmlDocument(message) {
      var body = escapeHtml(message).replace(NEWLINE_REGEXP, "<br>").replace(DOUBLE_SPACE_REGEXP, " &nbsp;");
      return '<!DOCTYPE html>\n<html lang="en">\n<head>\n<meta charset="utf-8">\n<title>Error</title>\n</head>\n<body>\n<pre>' + body + "</pre>\n</body>\n</html>\n";
    }
    var finalhandler_1 = finalhandler$1;
    function finalhandler$1(req2, res, options2) {
      var opts = options2 || {};
      var env2 = opts.env || "development";
      var onerror = opts.onerror;
      return function(err) {
        var headers;
        var msg;
        var status2;
        if (!err && headersSent(res)) {
          debug$7("cannot 404 after headers sent");
          return;
        }
        if (err) {
          status2 = getErrorStatusCode(err);
          if (status2 === void 0) {
            status2 = getResponseStatusCode(res);
          } else {
            headers = getErrorHeaders(err);
          }
          msg = getErrorMessage(err, status2, env2);
        } else {
          status2 = 404;
          msg = "Cannot " + req2.method + " " + encodeUrl(getResourceName(req2));
        }
        debug$7("default %s", status2);
        if (err && onerror) {
          defer$1(onerror, err, req2, res);
        }
        if (headersSent(res)) {
          debug$7("cannot %d after headers sent", status2);
          req2.socket.destroy();
          return;
        }
        send$2(req2, res, status2, headers, msg);
      };
    }
    function getErrorHeaders(err) {
      if (!err.headers || typeof err.headers !== "object") {
        return void 0;
      }
      var headers = /* @__PURE__ */ Object.create(null);
      var keys = Object.keys(err.headers);
      for (var i2 = 0; i2 < keys.length; i2++) {
        var key2 = keys[i2];
        headers[key2] = err.headers[key2];
      }
      return headers;
    }
    function getErrorMessage(err, status2, env2) {
      var msg;
      if (env2 !== "production") {
        msg = err.stack;
        if (!msg && typeof err.toString === "function") {
          msg = err.toString();
        }
      }
      return msg || statuses[status2];
    }
    function getErrorStatusCode(err) {
      if (typeof err.status === "number" && err.status >= 400 && err.status < 600) {
        return err.status;
      }
      if (typeof err.statusCode === "number" && err.statusCode >= 400 && err.statusCode < 600) {
        return err.statusCode;
      }
      return void 0;
    }
    function getResourceName(req2) {
      try {
        return parseUrl$1.original(req2).pathname;
      } catch (e2) {
        return "resource";
      }
    }
    function getResponseStatusCode(res) {
      var status2 = res.statusCode;
      if (typeof status2 !== "number" || status2 < 400 || status2 > 599) {
        status2 = 500;
      }
      return status2;
    }
    function headersSent(res) {
      return typeof res.headersSent !== "boolean" ? Boolean(res._header) : res.headersSent;
    }
    function send$2(req2, res, status2, headers, message) {
      function write() {
        var body = createHtmlDocument(message);
        res.statusCode = status2;
        res.statusMessage = statuses[status2];
        setHeaders(res, headers);
        res.setHeader("Content-Security-Policy", "default-src 'none'");
        res.setHeader("X-Content-Type-Options", "nosniff");
        res.setHeader("Content-Type", "text/html; charset=utf-8");
        res.setHeader("Content-Length", Buffer.byteLength(body, "utf8"));
        if (req2.method === "HEAD") {
          res.end();
          return;
        }
        res.end(body, "utf8");
      }
      if (isFinished(req2)) {
        write();
        return;
      }
      unpipe(req2);
      onFinished(req2, write);
      req2.resume();
    }
    function setHeaders(res, headers) {
      if (!headers) {
        return;
      }
      var keys = Object.keys(headers);
      for (var i2 = 0; i2 < keys.length; i2++) {
        var key2 = keys[i2];
        res.setHeader(key2, headers[key2]);
      }
    }
    var utilsMerge = { exports: {} };
    (function(module2, exports2) {
      module2.exports = function(a2, b2) {
        if (a2 && b2) {
          for (var key2 in b2) {
            a2[key2] = b2[key2];
          }
        }
        return a2;
      };
    })(utilsMerge);
    var debug$6 = src.exports("connect:dispatcher");
    var EventEmitter$3 = require$$0__default$2.EventEmitter;
    var finalhandler = finalhandler_1;
    var http$4 = require$$1__default$2;
    var merge = utilsMerge.exports;
    var parseUrl = parseurl$1.exports;
    var connect = createServer$1;
    var env = "development";
    var proto = {};
    var defer = typeof setImmediate === "function" ? setImmediate : function(fn2) {
      process.nextTick(fn2.bind.apply(fn2, arguments));
    };
    function createServer$1() {
      function app(req2, res, next) {
        app.handle(req2, res, next);
      }
      merge(app, proto);
      merge(app, EventEmitter$3.prototype);
      app.route = "/";
      app.stack = [];
      return app;
    }
    proto.use = function use(route, fn2) {
      var handle = fn2;
      var path2 = route;
      if (typeof route !== "string") {
        handle = route;
        path2 = "/";
      }
      if (typeof handle.handle === "function") {
        var server2 = handle;
        server2.route = path2;
        handle = function(req2, res, next) {
          server2.handle(req2, res, next);
        };
      }
      if (handle instanceof http$4.Server) {
        handle = handle.listeners("request")[0];
      }
      if (path2[path2.length - 1] === "/") {
        path2 = path2.slice(0, -1);
      }
      debug$6("use %s %s", path2 || "/", handle.name || "anonymous");
      this.stack.push({ route: path2, handle });
      return this;
    };
    proto.handle = function handle(req2, res, out2) {
      var index2 = 0;
      var protohost = getProtohost(req2.url) || "";
      var removed = "";
      var slashAdded = false;
      var stack2 = this.stack;
      var done = out2 || finalhandler(req2, res, {
        env,
        onerror: logerror
      });
      req2.originalUrl = req2.originalUrl || req2.url;
      function next(err) {
        if (slashAdded) {
          req2.url = req2.url.substr(1);
          slashAdded = false;
        }
        if (removed.length !== 0) {
          req2.url = protohost + removed + req2.url.substr(protohost.length);
          removed = "";
        }
        var layer = stack2[index2++];
        if (!layer) {
          defer(done, err);
          return;
        }
        var path2 = parseUrl(req2).pathname || "/";
        var route = layer.route;
        if (path2.toLowerCase().substr(0, route.length) !== route.toLowerCase()) {
          return next(err);
        }
        var c3 = path2.length > route.length && path2[route.length];
        if (c3 && c3 !== "/" && c3 !== ".") {
          return next(err);
        }
        if (route.length !== 0 && route !== "/") {
          removed = route;
          req2.url = protohost + req2.url.substr(protohost.length + removed.length);
          if (!protohost && req2.url[0] !== "/") {
            req2.url = "/" + req2.url;
            slashAdded = true;
          }
        }
        call(layer.handle, route, err, req2, res, next);
      }
      next();
    };
    proto.listen = function listen() {
      var server2 = http$4.createServer(this);
      return server2.listen.apply(server2, arguments);
    };
    function call(handle, route, err, req2, res, next) {
      var arity = handle.length;
      var error2 = err;
      var hasError = Boolean(err);
      debug$6("%s %s : %s", handle.name || "<anonymous>", route, req2.originalUrl);
      try {
        if (hasError && arity === 4) {
          handle(err, req2, res, next);
          return;
        } else if (!hasError && arity < 4) {
          handle(req2, res, next);
          return;
        }
      } catch (e2) {
        error2 = e2;
      }
      next(error2);
    }
    function logerror(err) {
      if (env !== "test")
        console.error(err.stack || err.toString());
    }
    function getProtohost(url2) {
      if (url2.length === 0 || url2[0] === "/") {
        return void 0;
      }
      var fqdnIndex = url2.indexOf("://");
      return fqdnIndex !== -1 && url2.lastIndexOf("?", fqdnIndex) === -1 ? url2.substr(0, url2.indexOf("/", 3 + fqdnIndex)) : void 0;
    }
    var lib$1 = { exports: {} };
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i2 = 0; i2 < 10; i2++) {
          test2["_" + String.fromCharCode(i2)] = i2;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n3) {
          return test2[n3];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    var objectAssign = shouldUseNative() ? Object.assign : function(target, source2) {
      var from;
      var to2 = toObject(target);
      var symbols;
      for (var s2 = 1; s2 < arguments.length; s2++) {
        from = Object(arguments[s2]);
        for (var key2 in from) {
          if (hasOwnProperty.call(from, key2)) {
            to2[key2] = from[key2];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from);
          for (var i2 = 0; i2 < symbols.length; i2++) {
            if (propIsEnumerable.call(from, symbols[i2])) {
              to2[symbols[i2]] = from[symbols[i2]];
            }
          }
        }
      }
      return to2;
    };
    var vary$1 = { exports: {} };
    vary$1.exports = vary;
    vary$1.exports.append = append;
    var FIELD_NAME_REGEXP = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
    function append(header, field) {
      if (typeof header !== "string") {
        throw new TypeError("header argument is required");
      }
      if (!field) {
        throw new TypeError("field argument is required");
      }
      var fields = !Array.isArray(field) ? parse$a(String(field)) : field;
      for (var j2 = 0; j2 < fields.length; j2++) {
        if (!FIELD_NAME_REGEXP.test(fields[j2])) {
          throw new TypeError("field argument contains an invalid header name");
        }
      }
      if (header === "*") {
        return header;
      }
      var val = header;
      var vals = parse$a(header.toLowerCase());
      if (fields.indexOf("*") !== -1 || vals.indexOf("*") !== -1) {
        return "*";
      }
      for (var i2 = 0; i2 < fields.length; i2++) {
        var fld = fields[i2].toLowerCase();
        if (vals.indexOf(fld) === -1) {
          vals.push(fld);
          val = val ? val + ", " + fields[i2] : fields[i2];
        }
      }
      return val;
    }
    function parse$a(header) {
      var end = 0;
      var list2 = [];
      var start = 0;
      for (var i2 = 0, len = header.length; i2 < len; i2++) {
        switch (header.charCodeAt(i2)) {
          case 32:
            if (start === end) {
              start = end = i2 + 1;
            }
            break;
          case 44:
            list2.push(header.substring(start, end));
            start = end = i2 + 1;
            break;
          default:
            end = i2 + 1;
            break;
        }
      }
      list2.push(header.substring(start, end));
      return list2;
    }
    function vary(res, field) {
      if (!res || !res.getHeader || !res.setHeader) {
        throw new TypeError("res argument is required");
      }
      var val = res.getHeader("Vary") || "";
      var header = Array.isArray(val) ? val.join(", ") : String(val);
      if (val = append(header, field)) {
        res.setHeader("Vary", val);
      }
    }
    (function() {
      var assign = objectAssign;
      var vary2 = vary$1.exports;
      var defaults = {
        origin: "*",
        methods: "GET,HEAD,PUT,PATCH,POST,DELETE",
        preflightContinue: false,
        optionsSuccessStatus: 204
      };
      function isString2(s2) {
        return typeof s2 === "string" || s2 instanceof String;
      }
      function isOriginAllowed(origin, allowedOrigin) {
        if (Array.isArray(allowedOrigin)) {
          for (var i2 = 0; i2 < allowedOrigin.length; ++i2) {
            if (isOriginAllowed(origin, allowedOrigin[i2])) {
              return true;
            }
          }
          return false;
        } else if (isString2(allowedOrigin)) {
          return origin === allowedOrigin;
        } else if (allowedOrigin instanceof RegExp) {
          return allowedOrigin.test(origin);
        } else {
          return !!allowedOrigin;
        }
      }
      function configureOrigin(options2, req2) {
        var requestOrigin = req2.headers.origin, headers = [], isAllowed;
        if (!options2.origin || options2.origin === "*") {
          headers.push([{
            key: "Access-Control-Allow-Origin",
            value: "*"
          }]);
        } else if (isString2(options2.origin)) {
          headers.push([{
            key: "Access-Control-Allow-Origin",
            value: options2.origin
          }]);
          headers.push([{
            key: "Vary",
            value: "Origin"
          }]);
        } else {
          isAllowed = isOriginAllowed(requestOrigin, options2.origin);
          headers.push([{
            key: "Access-Control-Allow-Origin",
            value: isAllowed ? requestOrigin : false
          }]);
          headers.push([{
            key: "Vary",
            value: "Origin"
          }]);
        }
        return headers;
      }
      function configureMethods(options2) {
        var methods = options2.methods;
        if (methods.join) {
          methods = options2.methods.join(",");
        }
        return {
          key: "Access-Control-Allow-Methods",
          value: methods
        };
      }
      function configureCredentials(options2) {
        if (options2.credentials === true) {
          return {
            key: "Access-Control-Allow-Credentials",
            value: "true"
          };
        }
        return null;
      }
      function configureAllowedHeaders(options2, req2) {
        var allowedHeaders = options2.allowedHeaders || options2.headers;
        var headers = [];
        if (!allowedHeaders) {
          allowedHeaders = req2.headers["access-control-request-headers"];
          headers.push([{
            key: "Vary",
            value: "Access-Control-Request-Headers"
          }]);
        } else if (allowedHeaders.join) {
          allowedHeaders = allowedHeaders.join(",");
        }
        if (allowedHeaders && allowedHeaders.length) {
          headers.push([{
            key: "Access-Control-Allow-Headers",
            value: allowedHeaders
          }]);
        }
        return headers;
      }
      function configureExposedHeaders(options2) {
        var headers = options2.exposedHeaders;
        if (!headers) {
          return null;
        } else if (headers.join) {
          headers = headers.join(",");
        }
        if (headers && headers.length) {
          return {
            key: "Access-Control-Expose-Headers",
            value: headers
          };
        }
        return null;
      }
      function configureMaxAge(options2) {
        var maxAge = (typeof options2.maxAge === "number" || options2.maxAge) && options2.maxAge.toString();
        if (maxAge && maxAge.length) {
          return {
            key: "Access-Control-Max-Age",
            value: maxAge
          };
        }
        return null;
      }
      function applyHeaders(headers, res) {
        for (var i2 = 0, n3 = headers.length; i2 < n3; i2++) {
          var header = headers[i2];
          if (header) {
            if (Array.isArray(header)) {
              applyHeaders(header, res);
            } else if (header.key === "Vary" && header.value) {
              vary2(res, header.value);
            } else if (header.value) {
              res.setHeader(header.key, header.value);
            }
          }
        }
      }
      function cors(options2, req2, res, next) {
        var headers = [], method = req2.method && req2.method.toUpperCase && req2.method.toUpperCase();
        if (method === "OPTIONS") {
          headers.push(configureOrigin(options2, req2));
          headers.push(configureCredentials(options2));
          headers.push(configureMethods(options2));
          headers.push(configureAllowedHeaders(options2, req2));
          headers.push(configureMaxAge(options2));
          headers.push(configureExposedHeaders(options2));
          applyHeaders(headers, res);
          if (options2.preflightContinue) {
            next();
          } else {
            res.statusCode = options2.optionsSuccessStatus;
            res.setHeader("Content-Length", "0");
            res.end();
          }
        } else {
          headers.push(configureOrigin(options2, req2));
          headers.push(configureCredentials(options2));
          headers.push(configureExposedHeaders(options2));
          applyHeaders(headers, res);
          next();
        }
      }
      function middlewareWrapper(o2) {
        var optionsCallback = null;
        if (typeof o2 === "function") {
          optionsCallback = o2;
        } else {
          optionsCallback = function(req2, cb) {
            cb(null, o2);
          };
        }
        return function corsMiddleware2(req2, res, next) {
          optionsCallback(req2, function(err, options2) {
            if (err) {
              next(err);
            } else {
              var corsOptions = assign({}, defaults, options2);
              var originCallback = null;
              if (corsOptions.origin && typeof corsOptions.origin === "function") {
                originCallback = corsOptions.origin;
              } else if (corsOptions.origin) {
                originCallback = function(origin, cb) {
                  cb(null, corsOptions.origin);
                };
              }
              if (originCallback) {
                originCallback(req2.headers.origin, function(err2, origin) {
                  if (err2 || !origin) {
                    next(err2);
                  } else {
                    corsOptions.origin = origin;
                    cors(corsOptions, req2, res, next);
                  }
                });
              } else {
                next();
              }
            }
          });
        };
      }
      lib$1.exports = middlewareWrapper;
    })();
    var corsMiddleware = lib$1.exports;
    var chokidar = {};
    var utils$4 = {};
    var path$b = path__default;
    var WIN_SLASH = "\\\\/";
    var WIN_NO_SLASH = `[^${WIN_SLASH}]`;
    var DOT_LITERAL = "\\.";
    var PLUS_LITERAL = "\\+";
    var QMARK_LITERAL = "\\?";
    var SLASH_LITERAL = "\\/";
    var ONE_CHAR = "(?=.)";
    var QMARK = "[^/]";
    var END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
    var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
    var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
    var NO_DOT = `(?!${DOT_LITERAL})`;
    var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
    var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
    var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
    var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
    var STAR$1 = `${QMARK}*?`;
    var POSIX_CHARS = {
      DOT_LITERAL,
      PLUS_LITERAL,
      QMARK_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      QMARK,
      END_ANCHOR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK_NO_DOT,
      STAR: STAR$1,
      START_ANCHOR
    };
    var WINDOWS_CHARS = __spreadProps2(__spreadValues2({}, POSIX_CHARS), {
      SLASH_LITERAL: `[${WIN_SLASH}]`,
      QMARK: WIN_NO_SLASH,
      STAR: `${WIN_NO_SLASH}*?`,
      DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
      NO_DOT: `(?!${DOT_LITERAL})`,
      NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
      NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
      START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
      END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
    });
    var POSIX_REGEX_SOURCE$1 = {
      alnum: "a-zA-Z0-9",
      alpha: "a-zA-Z",
      ascii: "\\x00-\\x7F",
      blank: " \\t",
      cntrl: "\\x00-\\x1F\\x7F",
      digit: "0-9",
      graph: "\\x21-\\x7E",
      lower: "a-z",
      print: "\\x20-\\x7E ",
      punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
      space: " \\t\\r\\n\\v\\f",
      upper: "A-Z",
      word: "A-Za-z0-9_",
      xdigit: "A-Fa-f0-9"
    };
    var constants$4 = {
      MAX_LENGTH: 1024 * 64,
      POSIX_REGEX_SOURCE: POSIX_REGEX_SOURCE$1,
      REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
      REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
      REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
      REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
      REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
      REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
      REPLACEMENTS: {
        "***": "*",
        "**/**": "**",
        "**/**/**": "**"
      },
      CHAR_0: 48,
      CHAR_9: 57,
      CHAR_UPPERCASE_A: 65,
      CHAR_LOWERCASE_A: 97,
      CHAR_UPPERCASE_Z: 90,
      CHAR_LOWERCASE_Z: 122,
      CHAR_LEFT_PARENTHESES: 40,
      CHAR_RIGHT_PARENTHESES: 41,
      CHAR_ASTERISK: 42,
      CHAR_AMPERSAND: 38,
      CHAR_AT: 64,
      CHAR_BACKWARD_SLASH: 92,
      CHAR_CARRIAGE_RETURN: 13,
      CHAR_CIRCUMFLEX_ACCENT: 94,
      CHAR_COLON: 58,
      CHAR_COMMA: 44,
      CHAR_DOT: 46,
      CHAR_DOUBLE_QUOTE: 34,
      CHAR_EQUAL: 61,
      CHAR_EXCLAMATION_MARK: 33,
      CHAR_FORM_FEED: 12,
      CHAR_FORWARD_SLASH: 47,
      CHAR_GRAVE_ACCENT: 96,
      CHAR_HASH: 35,
      CHAR_HYPHEN_MINUS: 45,
      CHAR_LEFT_ANGLE_BRACKET: 60,
      CHAR_LEFT_CURLY_BRACE: 123,
      CHAR_LEFT_SQUARE_BRACKET: 91,
      CHAR_LINE_FEED: 10,
      CHAR_NO_BREAK_SPACE: 160,
      CHAR_PERCENT: 37,
      CHAR_PLUS: 43,
      CHAR_QUESTION_MARK: 63,
      CHAR_RIGHT_ANGLE_BRACKET: 62,
      CHAR_RIGHT_CURLY_BRACE: 125,
      CHAR_RIGHT_SQUARE_BRACKET: 93,
      CHAR_SEMICOLON: 59,
      CHAR_SINGLE_QUOTE: 39,
      CHAR_SPACE: 32,
      CHAR_TAB: 9,
      CHAR_UNDERSCORE: 95,
      CHAR_VERTICAL_LINE: 124,
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
      SEP: path$b.sep,
      extglobChars(chars2) {
        return {
          "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars2.STAR})` },
          "?": { type: "qmark", open: "(?:", close: ")?" },
          "+": { type: "plus", open: "(?:", close: ")+" },
          "*": { type: "star", open: "(?:", close: ")*" },
          "@": { type: "at", open: "(?:", close: ")" }
        };
      },
      globChars(win322) {
        return win322 === true ? WINDOWS_CHARS : POSIX_CHARS;
      }
    };
    (function(exports2) {
      const path2 = path__default;
      const win322 = process.platform === "win32";
      const {
        REGEX_BACKSLASH,
        REGEX_REMOVE_BACKSLASH,
        REGEX_SPECIAL_CHARS,
        REGEX_SPECIAL_CHARS_GLOBAL
      } = constants$4;
      exports2.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
      exports2.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
      exports2.isRegexChar = (str) => str.length === 1 && exports2.hasRegexChars(str);
      exports2.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
      exports2.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
      exports2.removeBackslashes = (str) => {
        return str.replace(REGEX_REMOVE_BACKSLASH, (match2) => {
          return match2 === "\\" ? "" : match2;
        });
      };
      exports2.supportsLookbehinds = () => {
        const segs = process.version.slice(1).split(".").map(Number);
        if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
          return true;
        }
        return false;
      };
      exports2.isWindows = (options2) => {
        if (options2 && typeof options2.windows === "boolean") {
          return options2.windows;
        }
        return win322 === true || path2.sep === "\\";
      };
      exports2.escapeLast = (input, char, lastIdx) => {
        const idx = input.lastIndexOf(char, lastIdx);
        if (idx === -1)
          return input;
        if (input[idx - 1] === "\\")
          return exports2.escapeLast(input, char, idx - 1);
        return `${input.slice(0, idx)}\\${input.slice(idx)}`;
      };
      exports2.removePrefix = (input, state = {}) => {
        let output = input;
        if (output.startsWith("./")) {
          output = output.slice(2);
          state.prefix = "./";
        }
        return output;
      };
      exports2.wrapOutput = (input, state = {}, options2 = {}) => {
        const prepend = options2.contains ? "" : "^";
        const append2 = options2.contains ? "" : "$";
        let output = `${prepend}(?:${input})${append2}`;
        if (state.negated === true) {
          output = `(?:^(?!${output}).*$)`;
        }
        return output;
      };
    })(utils$4);
    var utils$3 = utils$4;
    var {
      CHAR_ASTERISK,
      CHAR_AT,
      CHAR_BACKWARD_SLASH,
      CHAR_COMMA,
      CHAR_DOT,
      CHAR_EXCLAMATION_MARK,
      CHAR_FORWARD_SLASH,
      CHAR_LEFT_CURLY_BRACE,
      CHAR_LEFT_PARENTHESES,
      CHAR_LEFT_SQUARE_BRACKET,
      CHAR_PLUS,
      CHAR_QUESTION_MARK,
      CHAR_RIGHT_CURLY_BRACE,
      CHAR_RIGHT_PARENTHESES,
      CHAR_RIGHT_SQUARE_BRACKET
    } = constants$4;
    var isPathSeparator = (code) => {
      return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
    };
    var depth = (token2) => {
      if (token2.isPrefix !== true) {
        token2.depth = token2.isGlobstar ? Infinity : 1;
      }
    };
    var scan$1 = (input, options2) => {
      const opts = options2 || {};
      const length = input.length - 1;
      const scanToEnd = opts.parts === true || opts.scanToEnd === true;
      const slashes = [];
      const tokens = [];
      const parts = [];
      let str = input;
      let index2 = -1;
      let start = 0;
      let lastIndex = 0;
      let isBrace = false;
      let isBracket = false;
      let isGlob2 = false;
      let isExtglob2 = false;
      let isGlobstar = false;
      let braceEscaped = false;
      let backslashes = false;
      let negated = false;
      let negatedExtglob = false;
      let finished = false;
      let braces2 = 0;
      let prev;
      let code;
      let token2 = { value: "", depth: 0, isGlob: false };
      const eos = () => index2 >= length;
      const peek2 = () => str.charCodeAt(index2 + 1);
      const advance = () => {
        prev = code;
        return str.charCodeAt(++index2);
      };
      while (index2 < length) {
        code = advance();
        let next;
        if (code === CHAR_BACKWARD_SLASH) {
          backslashes = token2.backslashes = true;
          code = advance();
          if (code === CHAR_LEFT_CURLY_BRACE) {
            braceEscaped = true;
          }
          continue;
        }
        if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
          braces2++;
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token2.backslashes = true;
              advance();
              continue;
            }
            if (code === CHAR_LEFT_CURLY_BRACE) {
              braces2++;
              continue;
            }
            if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
              isBrace = token2.isBrace = true;
              isGlob2 = token2.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (braceEscaped !== true && code === CHAR_COMMA) {
              isBrace = token2.isBrace = true;
              isGlob2 = token2.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (code === CHAR_RIGHT_CURLY_BRACE) {
              braces2--;
              if (braces2 === 0) {
                braceEscaped = false;
                isBrace = token2.isBrace = true;
                finished = true;
                break;
              }
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_FORWARD_SLASH) {
          slashes.push(index2);
          tokens.push(token2);
          token2 = { value: "", depth: 0, isGlob: false };
          if (finished === true)
            continue;
          if (prev === CHAR_DOT && index2 === start + 1) {
            start += 2;
            continue;
          }
          lastIndex = index2 + 1;
          continue;
        }
        if (opts.noext !== true) {
          const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
          if (isExtglobChar === true && peek2() === CHAR_LEFT_PARENTHESES) {
            isGlob2 = token2.isGlob = true;
            isExtglob2 = token2.isExtglob = true;
            finished = true;
            if (code === CHAR_EXCLAMATION_MARK && index2 === start) {
              negatedExtglob = true;
            }
            if (scanToEnd === true) {
              while (eos() !== true && (code = advance())) {
                if (code === CHAR_BACKWARD_SLASH) {
                  backslashes = token2.backslashes = true;
                  code = advance();
                  continue;
                }
                if (code === CHAR_RIGHT_PARENTHESES) {
                  isGlob2 = token2.isGlob = true;
                  finished = true;
                  break;
                }
              }
              continue;
            }
            break;
          }
        }
        if (code === CHAR_ASTERISK) {
          if (prev === CHAR_ASTERISK)
            isGlobstar = token2.isGlobstar = true;
          isGlob2 = token2.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_QUESTION_MARK) {
          isGlob2 = token2.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_LEFT_SQUARE_BRACKET) {
          while (eos() !== true && (next = advance())) {
            if (next === CHAR_BACKWARD_SLASH) {
              backslashes = token2.backslashes = true;
              advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              isBracket = token2.isBracket = true;
              isGlob2 = token2.isGlob = true;
              finished = true;
              break;
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index2 === start) {
          negated = token2.negated = true;
          start++;
          continue;
        }
        if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
          isGlob2 = token2.isGlob = true;
          if (scanToEnd === true) {
            while (eos() !== true && (code = advance())) {
              if (code === CHAR_LEFT_PARENTHESES) {
                backslashes = token2.backslashes = true;
                code = advance();
                continue;
              }
              if (code === CHAR_RIGHT_PARENTHESES) {
                finished = true;
                break;
              }
            }
            continue;
          }
          break;
        }
        if (isGlob2 === true) {
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
      }
      if (opts.noext === true) {
        isExtglob2 = false;
        isGlob2 = false;
      }
      let base2 = str;
      let prefix = "";
      let glob2 = "";
      if (start > 0) {
        prefix = str.slice(0, start);
        str = str.slice(start);
        lastIndex -= start;
      }
      if (base2 && isGlob2 === true && lastIndex > 0) {
        base2 = str.slice(0, lastIndex);
        glob2 = str.slice(lastIndex);
      } else if (isGlob2 === true) {
        base2 = "";
        glob2 = str;
      } else {
        base2 = str;
      }
      if (base2 && base2 !== "" && base2 !== "/" && base2 !== str) {
        if (isPathSeparator(base2.charCodeAt(base2.length - 1))) {
          base2 = base2.slice(0, -1);
        }
      }
      if (opts.unescape === true) {
        if (glob2)
          glob2 = utils$3.removeBackslashes(glob2);
        if (base2 && backslashes === true) {
          base2 = utils$3.removeBackslashes(base2);
        }
      }
      const state = {
        prefix,
        input,
        start,
        base: base2,
        glob: glob2,
        isBrace,
        isBracket,
        isGlob: isGlob2,
        isExtglob: isExtglob2,
        isGlobstar,
        negated,
        negatedExtglob
      };
      if (opts.tokens === true) {
        state.maxDepth = 0;
        if (!isPathSeparator(code)) {
          tokens.push(token2);
        }
        state.tokens = tokens;
      }
      if (opts.parts === true || opts.tokens === true) {
        let prevIndex;
        for (let idx = 0; idx < slashes.length; idx++) {
          const n3 = prevIndex ? prevIndex + 1 : start;
          const i2 = slashes[idx];
          const value = input.slice(n3, i2);
          if (opts.tokens) {
            if (idx === 0 && start !== 0) {
              tokens[idx].isPrefix = true;
              tokens[idx].value = prefix;
            } else {
              tokens[idx].value = value;
            }
            depth(tokens[idx]);
            state.maxDepth += tokens[idx].depth;
          }
          if (idx !== 0 || value !== "") {
            parts.push(value);
          }
          prevIndex = i2;
        }
        if (prevIndex && prevIndex + 1 < input.length) {
          const value = input.slice(prevIndex + 1);
          parts.push(value);
          if (opts.tokens) {
            tokens[tokens.length - 1].value = value;
            depth(tokens[tokens.length - 1]);
            state.maxDepth += tokens[tokens.length - 1].depth;
          }
        }
        state.slashes = slashes;
        state.parts = parts;
      }
      return state;
    };
    var scan_1 = scan$1;
    var constants$3 = constants$4;
    var utils$2 = utils$4;
    var {
      MAX_LENGTH,
      POSIX_REGEX_SOURCE,
      REGEX_NON_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_BACKREF,
      REPLACEMENTS
    } = constants$3;
    var expandRange = (args, options2) => {
      if (typeof options2.expandRange === "function") {
        return options2.expandRange(...args, options2);
      }
      args.sort();
      const value = `[${args.join("-")}]`;
      return value;
    };
    var syntaxError = (type, char) => {
      return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
    };
    var parse$9 = (input, options2) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      input = REPLACEMENTS[input] || input;
      const opts = __spreadValues2({}, options2);
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      let len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      const bos = { type: "bos", value: "", output: opts.prepend || "" };
      const tokens = [bos];
      const capture = opts.capture ? "" : "?:";
      const win322 = utils$2.isWindows(options2);
      const PLATFORM_CHARS = constants$3.globChars(win322);
      const EXTGLOB_CHARS = constants$3.extglobChars(PLATFORM_CHARS);
      const {
        DOT_LITERAL: DOT_LITERAL2,
        PLUS_LITERAL: PLUS_LITERAL2,
        SLASH_LITERAL: SLASH_LITERAL2,
        ONE_CHAR: ONE_CHAR2,
        DOTS_SLASH: DOTS_SLASH2,
        NO_DOT: NO_DOT2,
        NO_DOT_SLASH: NO_DOT_SLASH2,
        NO_DOTS_SLASH: NO_DOTS_SLASH2,
        QMARK: QMARK2,
        QMARK_NO_DOT: QMARK_NO_DOT2,
        STAR: STAR2,
        START_ANCHOR: START_ANCHOR2
      } = PLATFORM_CHARS;
      const globstar = (opts2) => {
        return `(${capture}(?:(?!${START_ANCHOR2}${opts2.dot ? DOTS_SLASH2 : DOT_LITERAL2}).)*?)`;
      };
      const nodot = opts.dot ? "" : NO_DOT2;
      const qmarkNoDot = opts.dot ? QMARK2 : QMARK_NO_DOT2;
      let star2 = opts.bash === true ? globstar(opts) : STAR2;
      if (opts.capture) {
        star2 = `(${star2})`;
      }
      if (typeof opts.noext === "boolean") {
        opts.noextglob = opts.noext;
      }
      const state = {
        input,
        index: -1,
        start: 0,
        dot: opts.dot === true,
        consumed: "",
        output: "",
        prefix: "",
        backtrack: false,
        negated: false,
        brackets: 0,
        braces: 0,
        parens: 0,
        quotes: 0,
        globstar: false,
        tokens
      };
      input = utils$2.removePrefix(input, state);
      len = input.length;
      const extglobs = [];
      const braces2 = [];
      const stack2 = [];
      let prev = bos;
      let value;
      const eos = () => state.index === len - 1;
      const peek2 = state.peek = (n3 = 1) => input[state.index + n3];
      const advance = state.advance = () => input[++state.index] || "";
      const remaining = () => input.slice(state.index + 1);
      const consume = (value2 = "", num = 0) => {
        state.consumed += value2;
        state.index += num;
      };
      const append2 = (token2) => {
        state.output += token2.output != null ? token2.output : token2.value;
        consume(token2.value);
      };
      const negate = () => {
        let count = 1;
        while (peek2() === "!" && (peek2(2) !== "(" || peek2(3) === "?")) {
          advance();
          state.start++;
          count++;
        }
        if (count % 2 === 0) {
          return false;
        }
        state.negated = true;
        state.start++;
        return true;
      };
      const increment = (type) => {
        state[type]++;
        stack2.push(type);
      };
      const decrement = (type) => {
        state[type]--;
        stack2.pop();
      };
      const push2 = (tok) => {
        if (prev.type === "globstar") {
          const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
          const isExtglob2 = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
          if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob2) {
            state.output = state.output.slice(0, -prev.output.length);
            prev.type = "star";
            prev.value = "*";
            prev.output = star2;
            state.output += prev.output;
          }
        }
        if (extglobs.length && tok.type !== "paren") {
          extglobs[extglobs.length - 1].inner += tok.value;
        }
        if (tok.value || tok.output)
          append2(tok);
        if (prev && prev.type === "text" && tok.type === "text") {
          prev.value += tok.value;
          prev.output = (prev.output || "") + tok.value;
          return;
        }
        tok.prev = prev;
        tokens.push(tok);
        prev = tok;
      };
      const extglobOpen = (type, value2) => {
        const token2 = __spreadProps2(__spreadValues2({}, EXTGLOB_CHARS[value2]), { conditions: 1, inner: "" });
        token2.prev = prev;
        token2.parens = state.parens;
        token2.output = state.output;
        const output = (opts.capture ? "(" : "") + token2.open;
        increment("parens");
        push2({ type, value: value2, output: state.output ? "" : ONE_CHAR2 });
        push2({ type: "paren", extglob: true, value: advance(), output });
        extglobs.push(token2);
      };
      const extglobClose = (token2) => {
        let output = token2.close + (opts.capture ? ")" : "");
        let rest;
        if (token2.type === "negate") {
          let extglobStar = star2;
          if (token2.inner && token2.inner.length > 1 && token2.inner.includes("/")) {
            extglobStar = globstar(opts);
          }
          if (extglobStar !== star2 || eos() || /^\)+$/.test(remaining())) {
            output = token2.close = `)$))${extglobStar}`;
          }
          if (token2.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
            const expression = parse$9(rest, __spreadProps2(__spreadValues2({}, options2), { fastpaths: false })).output;
            output = token2.close = `)${expression})${extglobStar})`;
          }
          if (token2.prev.type === "bos") {
            state.negatedExtglob = true;
          }
        }
        push2({ type: "paren", extglob: true, value, output });
        decrement("parens");
      };
      if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
        let backslashes = false;
        let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m3, esc, chars2, first2, rest, index2) => {
          if (first2 === "\\") {
            backslashes = true;
            return m3;
          }
          if (first2 === "?") {
            if (esc) {
              return esc + first2 + (rest ? QMARK2.repeat(rest.length) : "");
            }
            if (index2 === 0) {
              return qmarkNoDot + (rest ? QMARK2.repeat(rest.length) : "");
            }
            return QMARK2.repeat(chars2.length);
          }
          if (first2 === ".") {
            return DOT_LITERAL2.repeat(chars2.length);
          }
          if (first2 === "*") {
            if (esc) {
              return esc + first2 + (rest ? star2 : "");
            }
            return star2;
          }
          return esc ? m3 : `\\${m3}`;
        });
        if (backslashes === true) {
          if (opts.unescape === true) {
            output = output.replace(/\\/g, "");
          } else {
            output = output.replace(/\\+/g, (m3) => {
              return m3.length % 2 === 0 ? "\\\\" : m3 ? "\\" : "";
            });
          }
        }
        if (output === input && opts.contains === true) {
          state.output = input;
          return state;
        }
        state.output = utils$2.wrapOutput(output, state, options2);
        return state;
      }
      while (!eos()) {
        value = advance();
        if (value === "\0") {
          continue;
        }
        if (value === "\\") {
          const next = peek2();
          if (next === "/" && opts.bash !== true) {
            continue;
          }
          if (next === "." || next === ";") {
            continue;
          }
          if (!next) {
            value += "\\";
            push2({ type: "text", value });
            continue;
          }
          const match2 = /^\\+/.exec(remaining());
          let slashes = 0;
          if (match2 && match2[0].length > 2) {
            slashes = match2[0].length;
            state.index += slashes;
            if (slashes % 2 !== 0) {
              value += "\\";
            }
          }
          if (opts.unescape === true) {
            value = advance();
          } else {
            value += advance();
          }
          if (state.brackets === 0) {
            push2({ type: "text", value });
            continue;
          }
        }
        if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
          if (opts.posix !== false && value === ":") {
            const inner = prev.value.slice(1);
            if (inner.includes("[")) {
              prev.posix = true;
              if (inner.includes(":")) {
                const idx = prev.value.lastIndexOf("[");
                const pre = prev.value.slice(0, idx);
                const rest2 = prev.value.slice(idx + 2);
                const posix2 = POSIX_REGEX_SOURCE[rest2];
                if (posix2) {
                  prev.value = pre + posix2;
                  state.backtrack = true;
                  advance();
                  if (!bos.output && tokens.indexOf(prev) === 1) {
                    bos.output = ONE_CHAR2;
                  }
                  continue;
                }
              }
            }
          }
          if (value === "[" && peek2() !== ":" || value === "-" && peek2() === "]") {
            value = `\\${value}`;
          }
          if (value === "]" && (prev.value === "[" || prev.value === "[^")) {
            value = `\\${value}`;
          }
          if (opts.posix === true && value === "!" && prev.value === "[") {
            value = "^";
          }
          prev.value += value;
          append2({ value });
          continue;
        }
        if (state.quotes === 1 && value !== '"') {
          value = utils$2.escapeRegex(value);
          prev.value += value;
          append2({ value });
          continue;
        }
        if (value === '"') {
          state.quotes = state.quotes === 1 ? 0 : 1;
          if (opts.keepQuotes === true) {
            push2({ type: "text", value });
          }
          continue;
        }
        if (value === "(") {
          increment("parens");
          push2({ type: "paren", value });
          continue;
        }
        if (value === ")") {
          if (state.parens === 0 && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("opening", "("));
          }
          const extglob = extglobs[extglobs.length - 1];
          if (extglob && state.parens === extglob.parens + 1) {
            extglobClose(extglobs.pop());
            continue;
          }
          push2({ type: "paren", value, output: state.parens ? ")" : "\\)" });
          decrement("parens");
          continue;
        }
        if (value === "[") {
          if (opts.nobracket === true || !remaining().includes("]")) {
            if (opts.nobracket !== true && opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("closing", "]"));
            }
            value = `\\${value}`;
          } else {
            increment("brackets");
          }
          push2({ type: "bracket", value });
          continue;
        }
        if (value === "]") {
          if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
            push2({ type: "text", value, output: `\\${value}` });
            continue;
          }
          if (state.brackets === 0) {
            if (opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("opening", "["));
            }
            push2({ type: "text", value, output: `\\${value}` });
            continue;
          }
          decrement("brackets");
          const prevValue = prev.value.slice(1);
          if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
            value = `/${value}`;
          }
          prev.value += value;
          append2({ value });
          if (opts.literalBrackets === false || utils$2.hasRegexChars(prevValue)) {
            continue;
          }
          const escaped2 = utils$2.escapeRegex(prev.value);
          state.output = state.output.slice(0, -prev.value.length);
          if (opts.literalBrackets === true) {
            state.output += escaped2;
            prev.value = escaped2;
            continue;
          }
          prev.value = `(${capture}${escaped2}|${prev.value})`;
          state.output += prev.value;
          continue;
        }
        if (value === "{" && opts.nobrace !== true) {
          increment("braces");
          const open2 = {
            type: "brace",
            value,
            output: "(",
            outputIndex: state.output.length,
            tokensIndex: state.tokens.length
          };
          braces2.push(open2);
          push2(open2);
          continue;
        }
        if (value === "}") {
          const brace = braces2[braces2.length - 1];
          if (opts.nobrace === true || !brace) {
            push2({ type: "text", value, output: value });
            continue;
          }
          let output = ")";
          if (brace.dots === true) {
            const arr = tokens.slice();
            const range2 = [];
            for (let i2 = arr.length - 1; i2 >= 0; i2--) {
              tokens.pop();
              if (arr[i2].type === "brace") {
                break;
              }
              if (arr[i2].type !== "dots") {
                range2.unshift(arr[i2].value);
              }
            }
            output = expandRange(range2, opts);
            state.backtrack = true;
          }
          if (brace.comma !== true && brace.dots !== true) {
            const out2 = state.output.slice(0, brace.outputIndex);
            const toks = state.tokens.slice(brace.tokensIndex);
            brace.value = brace.output = "\\{";
            value = output = "\\}";
            state.output = out2;
            for (const t of toks) {
              state.output += t.output || t.value;
            }
          }
          push2({ type: "brace", value, output });
          decrement("braces");
          braces2.pop();
          continue;
        }
        if (value === "|") {
          if (extglobs.length > 0) {
            extglobs[extglobs.length - 1].conditions++;
          }
          push2({ type: "text", value });
          continue;
        }
        if (value === ",") {
          let output = value;
          const brace = braces2[braces2.length - 1];
          if (brace && stack2[stack2.length - 1] === "braces") {
            brace.comma = true;
            output = "|";
          }
          push2({ type: "comma", value, output });
          continue;
        }
        if (value === "/") {
          if (prev.type === "dot" && state.index === state.start + 1) {
            state.start = state.index + 1;
            state.consumed = "";
            state.output = "";
            tokens.pop();
            prev = bos;
            continue;
          }
          push2({ type: "slash", value, output: SLASH_LITERAL2 });
          continue;
        }
        if (value === ".") {
          if (state.braces > 0 && prev.type === "dot") {
            if (prev.value === ".")
              prev.output = DOT_LITERAL2;
            const brace = braces2[braces2.length - 1];
            prev.type = "dots";
            prev.output += value;
            prev.value += value;
            brace.dots = true;
            continue;
          }
          if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
            push2({ type: "text", value, output: DOT_LITERAL2 });
            continue;
          }
          push2({ type: "dot", value, output: DOT_LITERAL2 });
          continue;
        }
        if (value === "?") {
          const isGroup = prev && prev.value === "(";
          if (!isGroup && opts.noextglob !== true && peek2() === "(" && peek2(2) !== "?") {
            extglobOpen("qmark", value);
            continue;
          }
          if (prev && prev.type === "paren") {
            const next = peek2();
            let output = value;
            if (next === "<" && !utils$2.supportsLookbehinds()) {
              throw new Error("Node.js v10 or higher is required for regex lookbehinds");
            }
            if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
              output = `\\${value}`;
            }
            push2({ type: "text", value, output });
            continue;
          }
          if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
            push2({ type: "qmark", value, output: QMARK_NO_DOT2 });
            continue;
          }
          push2({ type: "qmark", value, output: QMARK2 });
          continue;
        }
        if (value === "!") {
          if (opts.noextglob !== true && peek2() === "(") {
            if (peek2(2) !== "?" || !/[!=<:]/.test(peek2(3))) {
              extglobOpen("negate", value);
              continue;
            }
          }
          if (opts.nonegate !== true && state.index === 0) {
            negate();
            continue;
          }
        }
        if (value === "+") {
          if (opts.noextglob !== true && peek2() === "(" && peek2(2) !== "?") {
            extglobOpen("plus", value);
            continue;
          }
          if (prev && prev.value === "(" || opts.regex === false) {
            push2({ type: "plus", value, output: PLUS_LITERAL2 });
            continue;
          }
          if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
            push2({ type: "plus", value });
            continue;
          }
          push2({ type: "plus", value: PLUS_LITERAL2 });
          continue;
        }
        if (value === "@") {
          if (opts.noextglob !== true && peek2() === "(" && peek2(2) !== "?") {
            push2({ type: "at", extglob: true, value, output: "" });
            continue;
          }
          push2({ type: "text", value });
          continue;
        }
        if (value !== "*") {
          if (value === "$" || value === "^") {
            value = `\\${value}`;
          }
          const match2 = REGEX_NON_SPECIAL_CHARS.exec(remaining());
          if (match2) {
            value += match2[0];
            state.index += match2[0].length;
          }
          push2({ type: "text", value });
          continue;
        }
        if (prev && (prev.type === "globstar" || prev.star === true)) {
          prev.type = "star";
          prev.star = true;
          prev.value += value;
          prev.output = star2;
          state.backtrack = true;
          state.globstar = true;
          consume(value);
          continue;
        }
        let rest = remaining();
        if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
          extglobOpen("star", value);
          continue;
        }
        if (prev.type === "star") {
          if (opts.noglobstar === true) {
            consume(value);
            continue;
          }
          const prior = prev.prev;
          const before = prior.prev;
          const isStart = prior.type === "slash" || prior.type === "bos";
          const afterStar = before && (before.type === "star" || before.type === "globstar");
          if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
            push2({ type: "star", value, output: "" });
            continue;
          }
          const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
          const isExtglob2 = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
          if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob2) {
            push2({ type: "star", value, output: "" });
            continue;
          }
          while (rest.slice(0, 3) === "/**") {
            const after = input[state.index + 4];
            if (after && after !== "/") {
              break;
            }
            rest = rest.slice(3);
            consume("/**", 3);
          }
          if (prior.type === "bos" && eos()) {
            prev.type = "globstar";
            prev.value += value;
            prev.output = globstar(opts);
            state.output = prev.output;
            state.globstar = true;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
            prev.value += value;
            state.globstar = true;
            state.output += prior.output + prev.output;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
            const end = rest[1] !== void 0 ? "|$" : "";
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = `${globstar(opts)}${SLASH_LITERAL2}|${SLASH_LITERAL2}${end})`;
            prev.value += value;
            state.output += prior.output + prev.output;
            state.globstar = true;
            consume(value + advance());
            push2({ type: "slash", value: "/", output: "" });
            continue;
          }
          if (prior.type === "bos" && rest[0] === "/") {
            prev.type = "globstar";
            prev.value += value;
            prev.output = `(?:^|${SLASH_LITERAL2}|${globstar(opts)}${SLASH_LITERAL2})`;
            state.output = prev.output;
            state.globstar = true;
            consume(value + advance());
            push2({ type: "slash", value: "/", output: "" });
            continue;
          }
          state.output = state.output.slice(0, -prev.output.length);
          prev.type = "globstar";
          prev.output = globstar(opts);
          prev.value += value;
          state.output += prev.output;
          state.globstar = true;
          consume(value);
          continue;
        }
        const token2 = { type: "star", value, output: star2 };
        if (opts.bash === true) {
          token2.output = ".*?";
          if (prev.type === "bos" || prev.type === "slash") {
            token2.output = nodot + token2.output;
          }
          push2(token2);
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
          token2.output = value;
          push2(token2);
          continue;
        }
        if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
          if (prev.type === "dot") {
            state.output += NO_DOT_SLASH2;
            prev.output += NO_DOT_SLASH2;
          } else if (opts.dot === true) {
            state.output += NO_DOTS_SLASH2;
            prev.output += NO_DOTS_SLASH2;
          } else {
            state.output += nodot;
            prev.output += nodot;
          }
          if (peek2() !== "*") {
            state.output += ONE_CHAR2;
            prev.output += ONE_CHAR2;
          }
        }
        push2(token2);
      }
      while (state.brackets > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", "]"));
        state.output = utils$2.escapeLast(state.output, "[");
        decrement("brackets");
      }
      while (state.parens > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", ")"));
        state.output = utils$2.escapeLast(state.output, "(");
        decrement("parens");
      }
      while (state.braces > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", "}"));
        state.output = utils$2.escapeLast(state.output, "{");
        decrement("braces");
      }
      if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
        push2({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL2}?` });
      }
      if (state.backtrack === true) {
        state.output = "";
        for (const token2 of state.tokens) {
          state.output += token2.output != null ? token2.output : token2.value;
          if (token2.suffix) {
            state.output += token2.suffix;
          }
        }
      }
      return state;
    };
    parse$9.fastpaths = (input, options2) => {
      const opts = __spreadValues2({}, options2);
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      const len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      input = REPLACEMENTS[input] || input;
      const win322 = utils$2.isWindows(options2);
      const {
        DOT_LITERAL: DOT_LITERAL2,
        SLASH_LITERAL: SLASH_LITERAL2,
        ONE_CHAR: ONE_CHAR2,
        DOTS_SLASH: DOTS_SLASH2,
        NO_DOT: NO_DOT2,
        NO_DOTS: NO_DOTS2,
        NO_DOTS_SLASH: NO_DOTS_SLASH2,
        STAR: STAR2,
        START_ANCHOR: START_ANCHOR2
      } = constants$3.globChars(win322);
      const nodot = opts.dot ? NO_DOTS2 : NO_DOT2;
      const slashDot = opts.dot ? NO_DOTS_SLASH2 : NO_DOT2;
      const capture = opts.capture ? "" : "?:";
      const state = { negated: false, prefix: "" };
      let star2 = opts.bash === true ? ".*?" : STAR2;
      if (opts.capture) {
        star2 = `(${star2})`;
      }
      const globstar = (opts2) => {
        if (opts2.noglobstar === true)
          return star2;
        return `(${capture}(?:(?!${START_ANCHOR2}${opts2.dot ? DOTS_SLASH2 : DOT_LITERAL2}).)*?)`;
      };
      const create = (str) => {
        switch (str) {
          case "*":
            return `${nodot}${ONE_CHAR2}${star2}`;
          case ".*":
            return `${DOT_LITERAL2}${ONE_CHAR2}${star2}`;
          case "*.*":
            return `${nodot}${star2}${DOT_LITERAL2}${ONE_CHAR2}${star2}`;
          case "*/*":
            return `${nodot}${star2}${SLASH_LITERAL2}${ONE_CHAR2}${slashDot}${star2}`;
          case "**":
            return nodot + globstar(opts);
          case "**/*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL2})?${slashDot}${ONE_CHAR2}${star2}`;
          case "**/*.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL2})?${slashDot}${star2}${DOT_LITERAL2}${ONE_CHAR2}${star2}`;
          case "**/.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL2})?${DOT_LITERAL2}${ONE_CHAR2}${star2}`;
          default: {
            const match2 = /^(.*?)\.(\w+)$/.exec(str);
            if (!match2)
              return;
            const source3 = create(match2[1]);
            if (!source3)
              return;
            return source3 + DOT_LITERAL2 + match2[2];
          }
        }
      };
      const output = utils$2.removePrefix(input, state);
      let source2 = create(output);
      if (source2 && opts.strictSlashes !== true) {
        source2 += `${SLASH_LITERAL2}?`;
      }
      return source2;
    };
    var parse_1$1 = parse$9;
    var path$a = path__default;
    var scan = scan_1;
    var parse$8 = parse_1$1;
    var utils$1 = utils$4;
    var constants$2 = constants$4;
    var isObject = (val) => val && typeof val === "object" && !Array.isArray(val);
    var picomatch$4 = (glob2, options2, returnState = false) => {
      if (Array.isArray(glob2)) {
        const fns = glob2.map((input) => picomatch$4(input, options2, returnState));
        const arrayMatcher = (str) => {
          for (const isMatch2 of fns) {
            const state2 = isMatch2(str);
            if (state2)
              return state2;
          }
          return false;
        };
        return arrayMatcher;
      }
      const isState = isObject(glob2) && glob2.tokens && glob2.input;
      if (glob2 === "" || typeof glob2 !== "string" && !isState) {
        throw new TypeError("Expected pattern to be a non-empty string");
      }
      const opts = options2 || {};
      const posix2 = utils$1.isWindows(options2);
      const regex = isState ? picomatch$4.compileRe(glob2, options2) : picomatch$4.makeRe(glob2, options2, false, true);
      const state = regex.state;
      delete regex.state;
      let isIgnored2 = () => false;
      if (opts.ignore) {
        const ignoreOpts = __spreadProps2(__spreadValues2({}, options2), { ignore: null, onMatch: null, onResult: null });
        isIgnored2 = picomatch$4(opts.ignore, ignoreOpts, returnState);
      }
      const matcher2 = (input, returnObject = false) => {
        const { isMatch: isMatch2, match: match2, output } = picomatch$4.test(input, regex, options2, { glob: glob2, posix: posix2 });
        const result2 = { glob: glob2, state, regex, posix: posix2, input, output, match: match2, isMatch: isMatch2 };
        if (typeof opts.onResult === "function") {
          opts.onResult(result2);
        }
        if (isMatch2 === false) {
          result2.isMatch = false;
          return returnObject ? result2 : false;
        }
        if (isIgnored2(input)) {
          if (typeof opts.onIgnore === "function") {
            opts.onIgnore(result2);
          }
          result2.isMatch = false;
          return returnObject ? result2 : false;
        }
        if (typeof opts.onMatch === "function") {
          opts.onMatch(result2);
        }
        return returnObject ? result2 : true;
      };
      if (returnState) {
        matcher2.state = state;
      }
      return matcher2;
    };
    picomatch$4.test = (input, regex, options2, { glob: glob2, posix: posix2 } = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected input to be a string");
      }
      if (input === "") {
        return { isMatch: false, output: "" };
      }
      const opts = options2 || {};
      const format2 = opts.format || (posix2 ? utils$1.toPosixSlashes : null);
      let match2 = input === glob2;
      let output = match2 && format2 ? format2(input) : input;
      if (match2 === false) {
        output = format2 ? format2(input) : input;
        match2 = output === glob2;
      }
      if (match2 === false || opts.capture === true) {
        if (opts.matchBase === true || opts.basename === true) {
          match2 = picomatch$4.matchBase(input, regex, options2, posix2);
        } else {
          match2 = regex.exec(output);
        }
      }
      return { isMatch: Boolean(match2), match: match2, output };
    };
    picomatch$4.matchBase = (input, glob2, options2, posix2 = utils$1.isWindows(options2)) => {
      const regex = glob2 instanceof RegExp ? glob2 : picomatch$4.makeRe(glob2, options2);
      return regex.test(path$a.basename(input));
    };
    picomatch$4.isMatch = (str, patterns2, options2) => picomatch$4(patterns2, options2)(str);
    picomatch$4.parse = (pattern2, options2) => {
      if (Array.isArray(pattern2))
        return pattern2.map((p2) => picomatch$4.parse(p2, options2));
      return parse$8(pattern2, __spreadProps2(__spreadValues2({}, options2), { fastpaths: false }));
    };
    picomatch$4.scan = (input, options2) => scan(input, options2);
    picomatch$4.compileRe = (state, options2, returnOutput = false, returnState = false) => {
      if (returnOutput === true) {
        return state.output;
      }
      const opts = options2 || {};
      const prepend = opts.contains ? "" : "^";
      const append2 = opts.contains ? "" : "$";
      let source2 = `${prepend}(?:${state.output})${append2}`;
      if (state && state.negated === true) {
        source2 = `^(?!${source2}).*$`;
      }
      const regex = picomatch$4.toRegex(source2, options2);
      if (returnState === true) {
        regex.state = state;
      }
      return regex;
    };
    picomatch$4.makeRe = (input, options2 = {}, returnOutput = false, returnState = false) => {
      if (!input || typeof input !== "string") {
        throw new TypeError("Expected a non-empty string");
      }
      let parsed = { negated: false, fastpaths: true };
      if (options2.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
        parsed.output = parse$8.fastpaths(input, options2);
      }
      if (!parsed.output) {
        parsed = parse$8(input, options2);
      }
      return picomatch$4.compileRe(parsed, options2, returnOutput, returnState);
    };
    picomatch$4.toRegex = (source2, options2) => {
      try {
        const opts = options2 || {};
        return new RegExp(source2, opts.flags || (opts.nocase ? "i" : ""));
      } catch (err) {
        if (options2 && options2.debug === true)
          throw err;
        return /$^/;
      }
    };
    picomatch$4.constants = constants$2;
    var picomatch_1 = picomatch$4;
    var picomatch$3 = picomatch_1;
    var fs$b = fs__default;
    var { Readable } = require$$0__default$3;
    var sysPath$3 = path__default;
    var { promisify: promisify$3 } = require$$0__default$1;
    var picomatch$2 = picomatch$3;
    var readdir$1 = promisify$3(fs$b.readdir);
    var stat$3 = promisify$3(fs$b.stat);
    var lstat$2 = promisify$3(fs$b.lstat);
    var realpath$1 = promisify$3(fs$b.realpath);
    var BANG$2 = "!";
    var RECURSIVE_ERROR_CODE = "READDIRP_RECURSIVE_ERROR";
    var NORMAL_FLOW_ERRORS = /* @__PURE__ */ new Set(["ENOENT", "EPERM", "EACCES", "ELOOP", RECURSIVE_ERROR_CODE]);
    var FILE_TYPE = "files";
    var DIR_TYPE = "directories";
    var FILE_DIR_TYPE = "files_directories";
    var EVERYTHING_TYPE = "all";
    var ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE];
    var isNormalFlowError = (error2) => NORMAL_FLOW_ERRORS.has(error2.code);
    var [maj, min] = process.versions.node.split(".").slice(0, 2).map((n3) => Number.parseInt(n3, 10));
    var wantBigintFsStats = process.platform === "win32" && (maj > 10 || maj === 10 && min >= 5);
    var normalizeFilter = (filter2) => {
      if (filter2 === void 0)
        return;
      if (typeof filter2 === "function")
        return filter2;
      if (typeof filter2 === "string") {
        const glob2 = picomatch$2(filter2.trim());
        return (entry2) => glob2(entry2.basename);
      }
      if (Array.isArray(filter2)) {
        const positive = [];
        const negative = [];
        for (const item of filter2) {
          const trimmed = item.trim();
          if (trimmed.charAt(0) === BANG$2) {
            negative.push(picomatch$2(trimmed.slice(1)));
          } else {
            positive.push(picomatch$2(trimmed));
          }
        }
        if (negative.length > 0) {
          if (positive.length > 0) {
            return (entry2) => positive.some((f2) => f2(entry2.basename)) && !negative.some((f2) => f2(entry2.basename));
          }
          return (entry2) => !negative.some((f2) => f2(entry2.basename));
        }
        return (entry2) => positive.some((f2) => f2(entry2.basename));
      }
    };
    var ReaddirpStream = class extends Readable {
      static get defaultOptions() {
        return {
          root: ".",
          fileFilter: (path2) => true,
          directoryFilter: (path2) => true,
          type: FILE_TYPE,
          lstat: false,
          depth: 2147483648,
          alwaysStat: false
        };
      }
      constructor(options2 = {}) {
        super({
          objectMode: true,
          autoDestroy: true,
          highWaterMark: options2.highWaterMark || 4096
        });
        const opts = __spreadValues2(__spreadValues2({}, ReaddirpStream.defaultOptions), options2);
        const { root: root2, type } = opts;
        this._fileFilter = normalizeFilter(opts.fileFilter);
        this._directoryFilter = normalizeFilter(opts.directoryFilter);
        const statMethod = opts.lstat ? lstat$2 : stat$3;
        if (wantBigintFsStats) {
          this._stat = (path2) => statMethod(path2, { bigint: true });
        } else {
          this._stat = statMethod;
        }
        this._maxDepth = opts.depth;
        this._wantsDir = [DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);
        this._wantsFile = [FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);
        this._wantsEverything = type === EVERYTHING_TYPE;
        this._root = sysPath$3.resolve(root2);
        this._isDirent = "Dirent" in fs$b && !opts.alwaysStat;
        this._statsProp = this._isDirent ? "dirent" : "stats";
        this._rdOptions = { encoding: "utf8", withFileTypes: this._isDirent };
        this.parents = [this._exploreDir(root2, 1)];
        this.reading = false;
        this.parent = void 0;
      }
      async _read(batch) {
        if (this.reading)
          return;
        this.reading = true;
        try {
          while (!this.destroyed && batch > 0) {
            const { path: path2, depth: depth2, files = [] } = this.parent || {};
            if (files.length > 0) {
              const slice2 = files.splice(0, batch).map((dirent) => this._formatEntry(dirent, path2));
              for (const entry2 of await Promise.all(slice2)) {
                if (this.destroyed)
                  return;
                const entryType = await this._getEntryType(entry2);
                if (entryType === "directory" && this._directoryFilter(entry2)) {
                  if (depth2 <= this._maxDepth) {
                    this.parents.push(this._exploreDir(entry2.fullPath, depth2 + 1));
                  }
                  if (this._wantsDir) {
                    this.push(entry2);
                    batch--;
                  }
                } else if ((entryType === "file" || this._includeAsFile(entry2)) && this._fileFilter(entry2)) {
                  if (this._wantsFile) {
                    this.push(entry2);
                    batch--;
                  }
                }
              }
            } else {
              const parent = this.parents.pop();
              if (!parent) {
                this.push(null);
                break;
              }
              this.parent = await parent;
              if (this.destroyed)
                return;
            }
          }
        } catch (error2) {
          this.destroy(error2);
        } finally {
          this.reading = false;
        }
      }
      async _exploreDir(path2, depth2) {
        let files;
        try {
          files = await readdir$1(path2, this._rdOptions);
        } catch (error2) {
          this._onError(error2);
        }
        return { files, depth: depth2, path: path2 };
      }
      async _formatEntry(dirent, path2) {
        let entry2;
        try {
          const basename = this._isDirent ? dirent.name : dirent;
          const fullPath = sysPath$3.resolve(sysPath$3.join(path2, basename));
          entry2 = { path: sysPath$3.relative(this._root, fullPath), fullPath, basename };
          entry2[this._statsProp] = this._isDirent ? dirent : await this._stat(fullPath);
        } catch (err) {
          this._onError(err);
        }
        return entry2;
      }
      _onError(err) {
        if (isNormalFlowError(err) && !this.destroyed) {
          this.emit("warn", err);
        } else {
          this.destroy(err);
        }
      }
      async _getEntryType(entry2) {
        const stats = entry2 && entry2[this._statsProp];
        if (!stats) {
          return;
        }
        if (stats.isFile()) {
          return "file";
        }
        if (stats.isDirectory()) {
          return "directory";
        }
        if (stats && stats.isSymbolicLink()) {
          const full = entry2.fullPath;
          try {
            const entryRealPath = await realpath$1(full);
            const entryRealPathStats = await lstat$2(entryRealPath);
            if (entryRealPathStats.isFile()) {
              return "file";
            }
            if (entryRealPathStats.isDirectory()) {
              const len = entryRealPath.length;
              if (full.startsWith(entryRealPath) && full.substr(len, 1) === sysPath$3.sep) {
                const recursiveError = new Error(`Circular symlink detected: "${full}" points to "${entryRealPath}"`);
                recursiveError.code = RECURSIVE_ERROR_CODE;
                return this._onError(recursiveError);
              }
              return "directory";
            }
          } catch (error2) {
            this._onError(error2);
          }
        }
      }
      _includeAsFile(entry2) {
        const stats = entry2 && entry2[this._statsProp];
        return stats && this._wantsEverything && !stats.isDirectory();
      }
    };
    var readdirp$1 = (root2, options2 = {}) => {
      let type = options2.entryType || options2.type;
      if (type === "both")
        type = FILE_DIR_TYPE;
      if (type)
        options2.type = type;
      if (!root2) {
        throw new Error("readdirp: root argument is required. Usage: readdirp(root, options)");
      } else if (typeof root2 !== "string") {
        throw new TypeError("readdirp: root argument must be a string. Usage: readdirp(root, options)");
      } else if (type && !ALL_TYPES.includes(type)) {
        throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(", ")}`);
      }
      options2.root = root2;
      return new ReaddirpStream(options2);
    };
    var readdirpPromise = (root2, options2 = {}) => {
      return new Promise((resolve2, reject) => {
        const files = [];
        readdirp$1(root2, options2).on("data", (entry2) => files.push(entry2)).on("end", () => resolve2(files)).on("error", (error2) => reject(error2));
      });
    };
    readdirp$1.promise = readdirpPromise;
    readdirp$1.ReaddirpStream = ReaddirpStream;
    readdirp$1.default = readdirp$1;
    var readdirp_1 = readdirp$1;
    var anymatch$2 = { exports: {} };
    var normalizePath$2 = function(path2, stripTrailing) {
      if (typeof path2 !== "string") {
        throw new TypeError("expected path to be a string");
      }
      if (path2 === "\\" || path2 === "/")
        return "/";
      var len = path2.length;
      if (len <= 1)
        return path2;
      var prefix = "";
      if (len > 4 && path2[3] === "\\") {
        var ch2 = path2[2];
        if ((ch2 === "?" || ch2 === ".") && path2.slice(0, 2) === "\\\\") {
          path2 = path2.slice(2);
          prefix = "//";
        }
      }
      var segs = path2.split(/[/\\]+/);
      if (stripTrailing !== false && segs[segs.length - 1] === "") {
        segs.pop();
      }
      return prefix + segs.join("/");
    };
    Object.defineProperty(anymatch$2.exports, "__esModule", { value: true });
    var picomatch$1 = picomatch$3;
    var normalizePath$1 = normalizePath$2;
    var BANG$1 = "!";
    var DEFAULT_OPTIONS = { returnIndex: false };
    var arrify$1 = (item) => Array.isArray(item) ? item : [item];
    var createPattern = (matcher2, options2) => {
      if (typeof matcher2 === "function") {
        return matcher2;
      }
      if (typeof matcher2 === "string") {
        const glob2 = picomatch$1(matcher2, options2);
        return (string2) => matcher2 === string2 || glob2(string2);
      }
      if (matcher2 instanceof RegExp) {
        return (string2) => matcher2.test(string2);
      }
      return (string2) => false;
    };
    var matchPatterns = (patterns2, negPatterns, args, returnIndex) => {
      const isList = Array.isArray(args);
      const _path = isList ? args[0] : args;
      if (!isList && typeof _path !== "string") {
        throw new TypeError("anymatch: second argument must be a string: got " + Object.prototype.toString.call(_path));
      }
      const path2 = normalizePath$1(_path);
      for (let index2 = 0; index2 < negPatterns.length; index2++) {
        const nglob = negPatterns[index2];
        if (nglob(path2)) {
          return returnIndex ? -1 : false;
        }
      }
      const applied = isList && [path2].concat(args.slice(1));
      for (let index2 = 0; index2 < patterns2.length; index2++) {
        const pattern2 = patterns2[index2];
        if (isList ? pattern2(...applied) : pattern2(path2)) {
          return returnIndex ? index2 : true;
        }
      }
      return returnIndex ? -1 : false;
    };
    var anymatch$1 = (matchers, testString, options2 = DEFAULT_OPTIONS) => {
      if (matchers == null) {
        throw new TypeError("anymatch: specify first argument");
      }
      const opts = typeof options2 === "boolean" ? { returnIndex: options2 } : options2;
      const returnIndex = opts.returnIndex || false;
      const mtchers = arrify$1(matchers);
      const negatedGlobs = mtchers.filter((item) => typeof item === "string" && item.charAt(0) === BANG$1).map((item) => item.slice(1)).map((item) => picomatch$1(item, opts));
      const patterns2 = mtchers.filter((item) => typeof item !== "string" || typeof item === "string" && item.charAt(0) !== BANG$1).map((matcher2) => createPattern(matcher2, opts));
      if (testString == null) {
        return (testString2, ri2 = false) => {
          const returnIndex2 = typeof ri2 === "boolean" ? ri2 : false;
          return matchPatterns(patterns2, negatedGlobs, testString2, returnIndex2);
        };
      }
      return matchPatterns(patterns2, negatedGlobs, testString, returnIndex);
    };
    anymatch$1.default = anymatch$1;
    anymatch$2.exports = anymatch$1;
    var require$$0 = [
      "3dm",
      "3ds",
      "3g2",
      "3gp",
      "7z",
      "a",
      "aac",
      "adp",
      "ai",
      "aif",
      "aiff",
      "alz",
      "ape",
      "apk",
      "appimage",
      "ar",
      "arj",
      "asf",
      "au",
      "avi",
      "bak",
      "baml",
      "bh",
      "bin",
      "bk",
      "bmp",
      "btif",
      "bz2",
      "bzip2",
      "cab",
      "caf",
      "cgm",
      "class",
      "cmx",
      "cpio",
      "cr2",
      "cur",
      "dat",
      "dcm",
      "deb",
      "dex",
      "djvu",
      "dll",
      "dmg",
      "dng",
      "doc",
      "docm",
      "docx",
      "dot",
      "dotm",
      "dra",
      "DS_Store",
      "dsk",
      "dts",
      "dtshd",
      "dvb",
      "dwg",
      "dxf",
      "ecelp4800",
      "ecelp7470",
      "ecelp9600",
      "egg",
      "eol",
      "eot",
      "epub",
      "exe",
      "f4v",
      "fbs",
      "fh",
      "fla",
      "flac",
      "flatpak",
      "fli",
      "flv",
      "fpx",
      "fst",
      "fvt",
      "g3",
      "gh",
      "gif",
      "graffle",
      "gz",
      "gzip",
      "h261",
      "h263",
      "h264",
      "icns",
      "ico",
      "ief",
      "img",
      "ipa",
      "iso",
      "jar",
      "jpeg",
      "jpg",
      "jpgv",
      "jpm",
      "jxr",
      "key",
      "ktx",
      "lha",
      "lib",
      "lvp",
      "lz",
      "lzh",
      "lzma",
      "lzo",
      "m3u",
      "m4a",
      "m4v",
      "mar",
      "mdi",
      "mht",
      "mid",
      "midi",
      "mj2",
      "mka",
      "mkv",
      "mmr",
      "mng",
      "mobi",
      "mov",
      "movie",
      "mp3",
      "mp4",
      "mp4a",
      "mpeg",
      "mpg",
      "mpga",
      "mxu",
      "nef",
      "npx",
      "numbers",
      "nupkg",
      "o",
      "odp",
      "ods",
      "odt",
      "oga",
      "ogg",
      "ogv",
      "otf",
      "ott",
      "pages",
      "pbm",
      "pcx",
      "pdb",
      "pdf",
      "pea",
      "pgm",
      "pic",
      "png",
      "pnm",
      "pot",
      "potm",
      "potx",
      "ppa",
      "ppam",
      "ppm",
      "pps",
      "ppsm",
      "ppsx",
      "ppt",
      "pptm",
      "pptx",
      "psd",
      "pya",
      "pyc",
      "pyo",
      "pyv",
      "qt",
      "rar",
      "ras",
      "raw",
      "resources",
      "rgb",
      "rip",
      "rlc",
      "rmf",
      "rmvb",
      "rpm",
      "rtf",
      "rz",
      "s3m",
      "s7z",
      "scpt",
      "sgi",
      "shar",
      "snap",
      "sil",
      "sketch",
      "slk",
      "smv",
      "snk",
      "so",
      "stl",
      "suo",
      "sub",
      "swf",
      "tar",
      "tbz",
      "tbz2",
      "tga",
      "tgz",
      "thmx",
      "tif",
      "tiff",
      "tlz",
      "ttc",
      "ttf",
      "txz",
      "udf",
      "uvh",
      "uvi",
      "uvm",
      "uvp",
      "uvs",
      "uvu",
      "viv",
      "vob",
      "war",
      "wav",
      "wax",
      "wbmp",
      "wdp",
      "weba",
      "webm",
      "webp",
      "whl",
      "wim",
      "wm",
      "wma",
      "wmv",
      "wmx",
      "woff",
      "woff2",
      "wrm",
      "wvx",
      "xbm",
      "xif",
      "xla",
      "xlam",
      "xls",
      "xlsb",
      "xlsm",
      "xlsx",
      "xlt",
      "xltm",
      "xltx",
      "xm",
      "xmind",
      "xpi",
      "xpm",
      "xwd",
      "xz",
      "z",
      "zip",
      "zipx"
    ];
    var binaryExtensions$1 = require$$0;
    var path$9 = path__default;
    var binaryExtensions = binaryExtensions$1;
    var extensions = new Set(binaryExtensions);
    var isBinaryPath$1 = (filePath) => extensions.has(path$9.extname(filePath).slice(1).toLowerCase());
    var constants$1 = {};
    (function(exports2) {
      const { sep } = path__default;
      const { platform: platform2 } = process;
      const os3 = require$$1__default;
      exports2.EV_ALL = "all";
      exports2.EV_READY = "ready";
      exports2.EV_ADD = "add";
      exports2.EV_CHANGE = "change";
      exports2.EV_ADD_DIR = "addDir";
      exports2.EV_UNLINK = "unlink";
      exports2.EV_UNLINK_DIR = "unlinkDir";
      exports2.EV_RAW = "raw";
      exports2.EV_ERROR = "error";
      exports2.STR_DATA = "data";
      exports2.STR_END = "end";
      exports2.STR_CLOSE = "close";
      exports2.FSEVENT_CREATED = "created";
      exports2.FSEVENT_MODIFIED = "modified";
      exports2.FSEVENT_DELETED = "deleted";
      exports2.FSEVENT_MOVED = "moved";
      exports2.FSEVENT_CLONED = "cloned";
      exports2.FSEVENT_UNKNOWN = "unknown";
      exports2.FSEVENT_TYPE_FILE = "file";
      exports2.FSEVENT_TYPE_DIRECTORY = "directory";
      exports2.FSEVENT_TYPE_SYMLINK = "symlink";
      exports2.KEY_LISTENERS = "listeners";
      exports2.KEY_ERR = "errHandlers";
      exports2.KEY_RAW = "rawEmitters";
      exports2.HANDLER_KEYS = [exports2.KEY_LISTENERS, exports2.KEY_ERR, exports2.KEY_RAW];
      exports2.DOT_SLASH = `.${sep}`;
      exports2.BACK_SLASH_RE = /\\/g;
      exports2.DOUBLE_SLASH_RE = /\/\//;
      exports2.SLASH_OR_BACK_SLASH_RE = /[/\\]/;
      exports2.DOT_RE = /\..*\.(sw[px])$|~$|\.subl.*\.tmp/;
      exports2.REPLACER_RE = /^\.[/\\]/;
      exports2.SLASH = "/";
      exports2.SLASH_SLASH = "//";
      exports2.BRACE_START = "{";
      exports2.BANG = "!";
      exports2.ONE_DOT = ".";
      exports2.TWO_DOTS = "..";
      exports2.STAR = "*";
      exports2.GLOBSTAR = "**";
      exports2.ROOT_GLOBSTAR = "/**/*";
      exports2.SLASH_GLOBSTAR = "/**";
      exports2.DIR_SUFFIX = "Dir";
      exports2.ANYMATCH_OPTS = { dot: true };
      exports2.STRING_TYPE = "string";
      exports2.FUNCTION_TYPE = "function";
      exports2.EMPTY_STR = "";
      exports2.EMPTY_FN = () => {
      };
      exports2.IDENTITY_FN = (val) => val;
      exports2.isWindows = platform2 === "win32";
      exports2.isMacos = platform2 === "darwin";
      exports2.isLinux = platform2 === "linux";
      exports2.isIBMi = os3.type() === "OS400";
    })(constants$1);
    var fs$a = fs__default;
    var sysPath$2 = path__default;
    var { promisify: promisify$2 } = require$$0__default$1;
    var isBinaryPath = isBinaryPath$1;
    var {
      isWindows: isWindows$2,
      isLinux,
      EMPTY_FN: EMPTY_FN$2,
      EMPTY_STR: EMPTY_STR$1,
      KEY_LISTENERS,
      KEY_ERR,
      KEY_RAW,
      HANDLER_KEYS,
      EV_CHANGE: EV_CHANGE$2,
      EV_ADD: EV_ADD$2,
      EV_ADD_DIR: EV_ADD_DIR$2,
      EV_ERROR: EV_ERROR$2,
      STR_DATA: STR_DATA$1,
      STR_END: STR_END$2,
      BRACE_START: BRACE_START$1,
      STAR
    } = constants$1;
    var THROTTLE_MODE_WATCH = "watch";
    var open$1 = promisify$2(fs$a.open);
    var stat$2 = promisify$2(fs$a.stat);
    var lstat$1 = promisify$2(fs$a.lstat);
    var close = promisify$2(fs$a.close);
    var fsrealpath = promisify$2(fs$a.realpath);
    var statMethods$1 = { lstat: lstat$1, stat: stat$2 };
    var foreach = (val, fn2) => {
      if (val instanceof Set) {
        val.forEach(fn2);
      } else {
        fn2(val);
      }
    };
    var addAndConvert = (main2, prop, item) => {
      let container = main2[prop];
      if (!(container instanceof Set)) {
        main2[prop] = container = /* @__PURE__ */ new Set([container]);
      }
      container.add(item);
    };
    var clearItem = (cont) => (key2) => {
      const set2 = cont[key2];
      if (set2 instanceof Set) {
        set2.clear();
      } else {
        delete cont[key2];
      }
    };
    var delFromSet = (main2, prop, item) => {
      const container = main2[prop];
      if (container instanceof Set) {
        container.delete(item);
      } else if (container === item) {
        delete main2[prop];
      }
    };
    var isEmptySet = (val) => val instanceof Set ? val.size === 0 : !val;
    var FsWatchInstances = /* @__PURE__ */ new Map();
    function createFsWatchInstance(path2, options2, listener2, errHandler, emitRaw) {
      const handleEvent = (rawEvent, evPath) => {
        listener2(path2);
        emitRaw(rawEvent, evPath, { watchedPath: path2 });
        if (evPath && path2 !== evPath) {
          fsWatchBroadcast(sysPath$2.resolve(path2, evPath), KEY_LISTENERS, sysPath$2.join(path2, evPath));
        }
      };
      try {
        return fs$a.watch(path2, options2, handleEvent);
      } catch (error2) {
        errHandler(error2);
      }
    }
    var fsWatchBroadcast = (fullPath, type, val1, val2, val3) => {
      const cont = FsWatchInstances.get(fullPath);
      if (!cont)
        return;
      foreach(cont[type], (listener2) => {
        listener2(val1, val2, val3);
      });
    };
    var setFsWatchListener = (path2, fullPath, options2, handlers) => {
      const { listener: listener2, errHandler, rawEmitter } = handlers;
      let cont = FsWatchInstances.get(fullPath);
      let watcher;
      if (!options2.persistent) {
        watcher = createFsWatchInstance(path2, options2, listener2, errHandler, rawEmitter);
        return watcher.close.bind(watcher);
      }
      if (cont) {
        addAndConvert(cont, KEY_LISTENERS, listener2);
        addAndConvert(cont, KEY_ERR, errHandler);
        addAndConvert(cont, KEY_RAW, rawEmitter);
      } else {
        watcher = createFsWatchInstance(path2, options2, fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS), errHandler, fsWatchBroadcast.bind(null, fullPath, KEY_RAW));
        if (!watcher)
          return;
        watcher.on(EV_ERROR$2, async (error2) => {
          const broadcastErr = fsWatchBroadcast.bind(null, fullPath, KEY_ERR);
          cont.watcherUnusable = true;
          if (isWindows$2 && error2.code === "EPERM") {
            try {
              const fd = await open$1(path2, "r");
              await close(fd);
              broadcastErr(error2);
            } catch (err) {
            }
          } else {
            broadcastErr(error2);
          }
        });
        cont = {
          listeners: listener2,
          errHandlers: errHandler,
          rawEmitters: rawEmitter,
          watcher
        };
        FsWatchInstances.set(fullPath, cont);
      }
      return () => {
        delFromSet(cont, KEY_LISTENERS, listener2);
        delFromSet(cont, KEY_ERR, errHandler);
        delFromSet(cont, KEY_RAW, rawEmitter);
        if (isEmptySet(cont.listeners)) {
          cont.watcher.close();
          FsWatchInstances.delete(fullPath);
          HANDLER_KEYS.forEach(clearItem(cont));
          cont.watcher = void 0;
          Object.freeze(cont);
        }
      };
    };
    var FsWatchFileInstances = /* @__PURE__ */ new Map();
    var setFsWatchFileListener = (path2, fullPath, options2, handlers) => {
      const { listener: listener2, rawEmitter } = handlers;
      let cont = FsWatchFileInstances.get(fullPath);
      const copts = cont && cont.options;
      if (copts && (copts.persistent < options2.persistent || copts.interval > options2.interval)) {
        fs$a.unwatchFile(fullPath);
        cont = void 0;
      }
      if (cont) {
        addAndConvert(cont, KEY_LISTENERS, listener2);
        addAndConvert(cont, KEY_RAW, rawEmitter);
      } else {
        cont = {
          listeners: listener2,
          rawEmitters: rawEmitter,
          options: options2,
          watcher: fs$a.watchFile(fullPath, options2, (curr, prev) => {
            foreach(cont.rawEmitters, (rawEmitter2) => {
              rawEmitter2(EV_CHANGE$2, fullPath, { curr, prev });
            });
            const currmtime = curr.mtimeMs;
            if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) {
              foreach(cont.listeners, (listener3) => listener3(path2, curr));
            }
          })
        };
        FsWatchFileInstances.set(fullPath, cont);
      }
      return () => {
        delFromSet(cont, KEY_LISTENERS, listener2);
        delFromSet(cont, KEY_RAW, rawEmitter);
        if (isEmptySet(cont.listeners)) {
          FsWatchFileInstances.delete(fullPath);
          fs$a.unwatchFile(fullPath);
          cont.options = cont.watcher = void 0;
          Object.freeze(cont);
        }
      };
    };
    var NodeFsHandler$1 = class {
      constructor(fsW) {
        this.fsw = fsW;
        this._boundHandleError = (error2) => fsW._handleError(error2);
      }
      _watchWithNodeFs(path2, listener2) {
        const opts = this.fsw.options;
        const directory = sysPath$2.dirname(path2);
        const basename = sysPath$2.basename(path2);
        const parent = this.fsw._getWatchedDir(directory);
        parent.add(basename);
        const absolutePath = sysPath$2.resolve(path2);
        const options2 = { persistent: opts.persistent };
        if (!listener2)
          listener2 = EMPTY_FN$2;
        let closer;
        if (opts.usePolling) {
          options2.interval = opts.enableBinaryInterval && isBinaryPath(basename) ? opts.binaryInterval : opts.interval;
          closer = setFsWatchFileListener(path2, absolutePath, options2, {
            listener: listener2,
            rawEmitter: this.fsw._emitRaw
          });
        } else {
          closer = setFsWatchListener(path2, absolutePath, options2, {
            listener: listener2,
            errHandler: this._boundHandleError,
            rawEmitter: this.fsw._emitRaw
          });
        }
        return closer;
      }
      _handleFile(file, stats, initialAdd) {
        if (this.fsw.closed) {
          return;
        }
        const dirname = sysPath$2.dirname(file);
        const basename = sysPath$2.basename(file);
        const parent = this.fsw._getWatchedDir(dirname);
        let prevStats = stats;
        if (parent.has(basename))
          return;
        const listener2 = async (path2, newStats) => {
          if (!this.fsw._throttle(THROTTLE_MODE_WATCH, file, 5))
            return;
          if (!newStats || newStats.mtimeMs === 0) {
            try {
              const newStats2 = await stat$2(file);
              if (this.fsw.closed)
                return;
              const at2 = newStats2.atimeMs;
              const mt2 = newStats2.mtimeMs;
              if (!at2 || at2 <= mt2 || mt2 !== prevStats.mtimeMs) {
                this.fsw._emit(EV_CHANGE$2, file, newStats2);
              }
              if (isLinux && prevStats.ino !== newStats2.ino) {
                this.fsw._closeFile(path2);
                prevStats = newStats2;
                this.fsw._addPathCloser(path2, this._watchWithNodeFs(file, listener2));
              } else {
                prevStats = newStats2;
              }
            } catch (error2) {
              this.fsw._remove(dirname, basename);
            }
          } else if (parent.has(basename)) {
            const at2 = newStats.atimeMs;
            const mt2 = newStats.mtimeMs;
            if (!at2 || at2 <= mt2 || mt2 !== prevStats.mtimeMs) {
              this.fsw._emit(EV_CHANGE$2, file, newStats);
            }
            prevStats = newStats;
          }
        };
        const closer = this._watchWithNodeFs(file, listener2);
        if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {
          if (!this.fsw._throttle(EV_ADD$2, file, 0))
            return;
          this.fsw._emit(EV_ADD$2, file, stats);
        }
        return closer;
      }
      async _handleSymlink(entry2, directory, path2, item) {
        if (this.fsw.closed) {
          return;
        }
        const full = entry2.fullPath;
        const dir = this.fsw._getWatchedDir(directory);
        if (!this.fsw.options.followSymlinks) {
          this.fsw._incrReadyCount();
          let linkPath;
          try {
            linkPath = await fsrealpath(path2);
          } catch (e2) {
            this.fsw._emitReady();
            return true;
          }
          if (this.fsw.closed)
            return;
          if (dir.has(item)) {
            if (this.fsw._symlinkPaths.get(full) !== linkPath) {
              this.fsw._symlinkPaths.set(full, linkPath);
              this.fsw._emit(EV_CHANGE$2, path2, entry2.stats);
            }
          } else {
            dir.add(item);
            this.fsw._symlinkPaths.set(full, linkPath);
            this.fsw._emit(EV_ADD$2, path2, entry2.stats);
          }
          this.fsw._emitReady();
          return true;
        }
        if (this.fsw._symlinkPaths.has(full)) {
          return true;
        }
        this.fsw._symlinkPaths.set(full, true);
      }
      _handleRead(directory, initialAdd, wh2, target, dir, depth2, throttler) {
        directory = sysPath$2.join(directory, EMPTY_STR$1);
        if (!wh2.hasGlob) {
          throttler = this.fsw._throttle("readdir", directory, 1e3);
          if (!throttler)
            return;
        }
        const previous = this.fsw._getWatchedDir(wh2.path);
        const current = /* @__PURE__ */ new Set();
        let stream2 = this.fsw._readdirp(directory, {
          fileFilter: (entry2) => wh2.filterPath(entry2),
          directoryFilter: (entry2) => wh2.filterDir(entry2),
          depth: 0
        }).on(STR_DATA$1, async (entry2) => {
          if (this.fsw.closed) {
            stream2 = void 0;
            return;
          }
          const item = entry2.path;
          let path2 = sysPath$2.join(directory, item);
          current.add(item);
          if (entry2.stats.isSymbolicLink() && await this._handleSymlink(entry2, directory, path2, item)) {
            return;
          }
          if (this.fsw.closed) {
            stream2 = void 0;
            return;
          }
          if (item === target || !target && !previous.has(item)) {
            this.fsw._incrReadyCount();
            path2 = sysPath$2.join(dir, sysPath$2.relative(dir, path2));
            this._addToNodeFs(path2, initialAdd, wh2, depth2 + 1);
          }
        }).on(EV_ERROR$2, this._boundHandleError);
        return new Promise((resolve2) => stream2.once(STR_END$2, () => {
          if (this.fsw.closed) {
            stream2 = void 0;
            return;
          }
          const wasThrottled = throttler ? throttler.clear() : false;
          resolve2();
          previous.getChildren().filter((item) => {
            return item !== directory && !current.has(item) && (!wh2.hasGlob || wh2.filterPath({
              fullPath: sysPath$2.resolve(directory, item)
            }));
          }).forEach((item) => {
            this.fsw._remove(directory, item);
          });
          stream2 = void 0;
          if (wasThrottled)
            this._handleRead(directory, false, wh2, target, dir, depth2, throttler);
        }));
      }
      async _handleDir(dir, stats, initialAdd, depth2, target, wh2, realpath2) {
        const parentDir = this.fsw._getWatchedDir(sysPath$2.dirname(dir));
        const tracked = parentDir.has(sysPath$2.basename(dir));
        if (!(initialAdd && this.fsw.options.ignoreInitial) && !target && !tracked) {
          if (!wh2.hasGlob || wh2.globFilter(dir))
            this.fsw._emit(EV_ADD_DIR$2, dir, stats);
        }
        parentDir.add(sysPath$2.basename(dir));
        this.fsw._getWatchedDir(dir);
        let throttler;
        let closer;
        const oDepth = this.fsw.options.depth;
        if ((oDepth == null || depth2 <= oDepth) && !this.fsw._symlinkPaths.has(realpath2)) {
          if (!target) {
            await this._handleRead(dir, initialAdd, wh2, target, dir, depth2, throttler);
            if (this.fsw.closed)
              return;
          }
          closer = this._watchWithNodeFs(dir, (dirPath, stats2) => {
            if (stats2 && stats2.mtimeMs === 0)
              return;
            this._handleRead(dirPath, false, wh2, target, dir, depth2, throttler);
          });
        }
        return closer;
      }
      async _addToNodeFs(path2, initialAdd, priorWh, depth2, target) {
        const ready = this.fsw._emitReady;
        if (this.fsw._isIgnored(path2) || this.fsw.closed) {
          ready();
          return false;
        }
        const wh2 = this.fsw._getWatchHelpers(path2, depth2);
        if (!wh2.hasGlob && priorWh) {
          wh2.hasGlob = priorWh.hasGlob;
          wh2.globFilter = priorWh.globFilter;
          wh2.filterPath = (entry2) => priorWh.filterPath(entry2);
          wh2.filterDir = (entry2) => priorWh.filterDir(entry2);
        }
        try {
          const stats = await statMethods$1[wh2.statMethod](wh2.watchPath);
          if (this.fsw.closed)
            return;
          if (this.fsw._isIgnored(wh2.watchPath, stats)) {
            ready();
            return false;
          }
          const follow = this.fsw.options.followSymlinks && !path2.includes(STAR) && !path2.includes(BRACE_START$1);
          let closer;
          if (stats.isDirectory()) {
            const absPath = sysPath$2.resolve(path2);
            const targetPath = follow ? await fsrealpath(path2) : path2;
            if (this.fsw.closed)
              return;
            closer = await this._handleDir(wh2.watchPath, stats, initialAdd, depth2, target, wh2, targetPath);
            if (this.fsw.closed)
              return;
            if (absPath !== targetPath && targetPath !== void 0) {
              this.fsw._symlinkPaths.set(absPath, targetPath);
            }
          } else if (stats.isSymbolicLink()) {
            const targetPath = follow ? await fsrealpath(path2) : path2;
            if (this.fsw.closed)
              return;
            const parent = sysPath$2.dirname(wh2.watchPath);
            this.fsw._getWatchedDir(parent).add(wh2.watchPath);
            this.fsw._emit(EV_ADD$2, wh2.watchPath, stats);
            closer = await this._handleDir(parent, stats, initialAdd, depth2, path2, wh2, targetPath);
            if (this.fsw.closed)
              return;
            if (targetPath !== void 0) {
              this.fsw._symlinkPaths.set(sysPath$2.resolve(path2), targetPath);
            }
          } else {
            closer = this._handleFile(wh2.watchPath, stats, initialAdd);
          }
          ready();
          this.fsw._addPathCloser(path2, closer);
          return false;
        } catch (error2) {
          if (this.fsw._handleError(error2)) {
            ready();
            return path2;
          }
        }
      }
    };
    var nodefsHandler = NodeFsHandler$1;
    var fseventsHandler = { exports: {} };
    var fs$9 = fs__default;
    var sysPath$1 = path__default;
    var { promisify: promisify$1 } = require$$0__default$1;
    var fsevents;
    try {
      fsevents = eval("require")("fsevents");
    } catch (error2) {
      if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR)
        console.error(error2);
    }
    if (fsevents) {
      const mtch = process.version.match(/v(\d+)\.(\d+)/);
      if (mtch && mtch[1] && mtch[2]) {
        const maj2 = Number.parseInt(mtch[1], 10);
        const min2 = Number.parseInt(mtch[2], 10);
        if (maj2 === 8 && min2 < 16) {
          fsevents = void 0;
        }
      }
    }
    var {
      EV_ADD: EV_ADD$1,
      EV_CHANGE: EV_CHANGE$1,
      EV_ADD_DIR: EV_ADD_DIR$1,
      EV_UNLINK: EV_UNLINK$1,
      EV_ERROR: EV_ERROR$1,
      STR_DATA,
      STR_END: STR_END$1,
      FSEVENT_CREATED,
      FSEVENT_MODIFIED,
      FSEVENT_DELETED,
      FSEVENT_MOVED,
      FSEVENT_UNKNOWN,
      FSEVENT_TYPE_FILE,
      FSEVENT_TYPE_DIRECTORY,
      FSEVENT_TYPE_SYMLINK,
      ROOT_GLOBSTAR,
      DIR_SUFFIX,
      DOT_SLASH,
      FUNCTION_TYPE: FUNCTION_TYPE$1,
      EMPTY_FN: EMPTY_FN$1,
      IDENTITY_FN
    } = constants$1;
    var Depth = (value) => isNaN(value) ? {} : { depth: value };
    var stat$1 = promisify$1(fs$9.stat);
    var lstat = promisify$1(fs$9.lstat);
    var realpath = promisify$1(fs$9.realpath);
    var statMethods = { stat: stat$1, lstat };
    var FSEventsWatchers = /* @__PURE__ */ new Map();
    var consolidateThreshhold = 10;
    var wrongEventFlags = /* @__PURE__ */ new Set([
      69888,
      70400,
      71424,
      72704,
      73472,
      131328,
      131840,
      262912
    ]);
    var createFSEventsInstance = (path2, callback) => {
      const stop = fsevents.watch(path2, callback);
      return { stop };
    };
    function setFSEventsListener(path2, realPath, listener2, rawEmitter) {
      let watchPath = sysPath$1.extname(realPath) ? sysPath$1.dirname(realPath) : realPath;
      const parentPath = sysPath$1.dirname(watchPath);
      let cont = FSEventsWatchers.get(watchPath);
      if (couldConsolidate(parentPath)) {
        watchPath = parentPath;
      }
      const resolvedPath = sysPath$1.resolve(path2);
      const hasSymlink = resolvedPath !== realPath;
      const filteredListener = (fullPath, flags, info) => {
        if (hasSymlink)
          fullPath = fullPath.replace(realPath, resolvedPath);
        if (fullPath === resolvedPath || !fullPath.indexOf(resolvedPath + sysPath$1.sep))
          listener2(fullPath, flags, info);
      };
      let watchedParent = false;
      for (const watchedPath of FSEventsWatchers.keys()) {
        if (realPath.indexOf(sysPath$1.resolve(watchedPath) + sysPath$1.sep) === 0) {
          watchPath = watchedPath;
          cont = FSEventsWatchers.get(watchPath);
          watchedParent = true;
          break;
        }
      }
      if (cont || watchedParent) {
        cont.listeners.add(filteredListener);
      } else {
        cont = {
          listeners: /* @__PURE__ */ new Set([filteredListener]),
          rawEmitter,
          watcher: createFSEventsInstance(watchPath, (fullPath, flags) => {
            if (!cont.listeners.size)
              return;
            const info = fsevents.getInfo(fullPath, flags);
            cont.listeners.forEach((list2) => {
              list2(fullPath, flags, info);
            });
            cont.rawEmitter(info.event, fullPath, info);
          })
        };
        FSEventsWatchers.set(watchPath, cont);
      }
      return () => {
        const lst = cont.listeners;
        lst.delete(filteredListener);
        if (!lst.size) {
          FSEventsWatchers.delete(watchPath);
          if (cont.watcher)
            return cont.watcher.stop().then(() => {
              cont.rawEmitter = cont.watcher = void 0;
              Object.freeze(cont);
            });
        }
      };
    }
    var couldConsolidate = (path2) => {
      let count = 0;
      for (const watchPath of FSEventsWatchers.keys()) {
        if (watchPath.indexOf(path2) === 0) {
          count++;
          if (count >= consolidateThreshhold) {
            return true;
          }
        }
      }
      return false;
    };
    var canUse = () => fsevents && FSEventsWatchers.size < 128;
    var calcDepth = (path2, root2) => {
      let i2 = 0;
      while (!path2.indexOf(root2) && (path2 = sysPath$1.dirname(path2)) !== root2)
        i2++;
      return i2;
    };
    var sameTypes = (info, stats) => info.type === FSEVENT_TYPE_DIRECTORY && stats.isDirectory() || info.type === FSEVENT_TYPE_SYMLINK && stats.isSymbolicLink() || info.type === FSEVENT_TYPE_FILE && stats.isFile();
    var FsEventsHandler$1 = class {
      constructor(fsw) {
        this.fsw = fsw;
      }
      checkIgnored(path2, stats) {
        const ipaths = this.fsw._ignoredPaths;
        if (this.fsw._isIgnored(path2, stats)) {
          ipaths.add(path2);
          if (stats && stats.isDirectory()) {
            ipaths.add(path2 + ROOT_GLOBSTAR);
          }
          return true;
        }
        ipaths.delete(path2);
        ipaths.delete(path2 + ROOT_GLOBSTAR);
      }
      addOrChange(path2, fullPath, realPath, parent, watchedDir, item, info, opts) {
        const event = watchedDir.has(item) ? EV_CHANGE$1 : EV_ADD$1;
        this.handleEvent(event, path2, fullPath, realPath, parent, watchedDir, item, info, opts);
      }
      async checkExists(path2, fullPath, realPath, parent, watchedDir, item, info, opts) {
        try {
          const stats = await stat$1(path2);
          if (this.fsw.closed)
            return;
          if (sameTypes(info, stats)) {
            this.addOrChange(path2, fullPath, realPath, parent, watchedDir, item, info, opts);
          } else {
            this.handleEvent(EV_UNLINK$1, path2, fullPath, realPath, parent, watchedDir, item, info, opts);
          }
        } catch (error2) {
          if (error2.code === "EACCES") {
            this.addOrChange(path2, fullPath, realPath, parent, watchedDir, item, info, opts);
          } else {
            this.handleEvent(EV_UNLINK$1, path2, fullPath, realPath, parent, watchedDir, item, info, opts);
          }
        }
      }
      handleEvent(event, path2, fullPath, realPath, parent, watchedDir, item, info, opts) {
        if (this.fsw.closed || this.checkIgnored(path2))
          return;
        if (event === EV_UNLINK$1) {
          const isDirectory2 = info.type === FSEVENT_TYPE_DIRECTORY;
          if (isDirectory2 || watchedDir.has(item)) {
            this.fsw._remove(parent, item, isDirectory2);
          }
        } else {
          if (event === EV_ADD$1) {
            if (info.type === FSEVENT_TYPE_DIRECTORY)
              this.fsw._getWatchedDir(path2);
            if (info.type === FSEVENT_TYPE_SYMLINK && opts.followSymlinks) {
              const curDepth = opts.depth === void 0 ? void 0 : calcDepth(fullPath, realPath) + 1;
              return this._addToFsEvents(path2, false, true, curDepth);
            }
            this.fsw._getWatchedDir(parent).add(item);
          }
          const eventName = info.type === FSEVENT_TYPE_DIRECTORY ? event + DIR_SUFFIX : event;
          this.fsw._emit(eventName, path2);
          if (eventName === EV_ADD_DIR$1)
            this._addToFsEvents(path2, false, true);
        }
      }
      _watchWithFsEvents(watchPath, realPath, transform2, globFilter) {
        if (this.fsw.closed || this.fsw._isIgnored(watchPath))
          return;
        const opts = this.fsw.options;
        const watchCallback = async (fullPath, flags, info) => {
          if (this.fsw.closed)
            return;
          if (opts.depth !== void 0 && calcDepth(fullPath, realPath) > opts.depth)
            return;
          const path2 = transform2(sysPath$1.join(watchPath, sysPath$1.relative(watchPath, fullPath)));
          if (globFilter && !globFilter(path2))
            return;
          const parent = sysPath$1.dirname(path2);
          const item = sysPath$1.basename(path2);
          const watchedDir = this.fsw._getWatchedDir(info.type === FSEVENT_TYPE_DIRECTORY ? path2 : parent);
          if (wrongEventFlags.has(flags) || info.event === FSEVENT_UNKNOWN) {
            if (typeof opts.ignored === FUNCTION_TYPE$1) {
              let stats;
              try {
                stats = await stat$1(path2);
              } catch (error2) {
              }
              if (this.fsw.closed)
                return;
              if (this.checkIgnored(path2, stats))
                return;
              if (sameTypes(info, stats)) {
                this.addOrChange(path2, fullPath, realPath, parent, watchedDir, item, info, opts);
              } else {
                this.handleEvent(EV_UNLINK$1, path2, fullPath, realPath, parent, watchedDir, item, info, opts);
              }
            } else {
              this.checkExists(path2, fullPath, realPath, parent, watchedDir, item, info, opts);
            }
          } else {
            switch (info.event) {
              case FSEVENT_CREATED:
              case FSEVENT_MODIFIED:
                return this.addOrChange(path2, fullPath, realPath, parent, watchedDir, item, info, opts);
              case FSEVENT_DELETED:
              case FSEVENT_MOVED:
                return this.checkExists(path2, fullPath, realPath, parent, watchedDir, item, info, opts);
            }
          }
        };
        const closer = setFSEventsListener(watchPath, realPath, watchCallback, this.fsw._emitRaw);
        this.fsw._emitReady();
        return closer;
      }
      async _handleFsEventsSymlink(linkPath, fullPath, transform2, curDepth) {
        if (this.fsw.closed || this.fsw._symlinkPaths.has(fullPath))
          return;
        this.fsw._symlinkPaths.set(fullPath, true);
        this.fsw._incrReadyCount();
        try {
          const linkTarget = await realpath(linkPath);
          if (this.fsw.closed)
            return;
          if (this.fsw._isIgnored(linkTarget)) {
            return this.fsw._emitReady();
          }
          this.fsw._incrReadyCount();
          this._addToFsEvents(linkTarget || linkPath, (path2) => {
            let aliasedPath = linkPath;
            if (linkTarget && linkTarget !== DOT_SLASH) {
              aliasedPath = path2.replace(linkTarget, linkPath);
            } else if (path2 !== DOT_SLASH) {
              aliasedPath = sysPath$1.join(linkPath, path2);
            }
            return transform2(aliasedPath);
          }, false, curDepth);
        } catch (error2) {
          if (this.fsw._handleError(error2)) {
            return this.fsw._emitReady();
          }
        }
      }
      emitAdd(newPath, stats, processPath, opts, forceAdd) {
        const pp2 = processPath(newPath);
        const isDir = stats.isDirectory();
        const dirObj = this.fsw._getWatchedDir(sysPath$1.dirname(pp2));
        const base2 = sysPath$1.basename(pp2);
        if (isDir)
          this.fsw._getWatchedDir(pp2);
        if (dirObj.has(base2))
          return;
        dirObj.add(base2);
        if (!opts.ignoreInitial || forceAdd === true) {
          this.fsw._emit(isDir ? EV_ADD_DIR$1 : EV_ADD$1, pp2, stats);
        }
      }
      initWatch(realPath, path2, wh2, processPath) {
        if (this.fsw.closed)
          return;
        const closer = this._watchWithFsEvents(wh2.watchPath, sysPath$1.resolve(realPath || wh2.watchPath), processPath, wh2.globFilter);
        this.fsw._addPathCloser(path2, closer);
      }
      async _addToFsEvents(path2, transform2, forceAdd, priorDepth) {
        if (this.fsw.closed) {
          return;
        }
        const opts = this.fsw.options;
        const processPath = typeof transform2 === FUNCTION_TYPE$1 ? transform2 : IDENTITY_FN;
        const wh2 = this.fsw._getWatchHelpers(path2);
        try {
          const stats = await statMethods[wh2.statMethod](wh2.watchPath);
          if (this.fsw.closed)
            return;
          if (this.fsw._isIgnored(wh2.watchPath, stats)) {
            throw null;
          }
          if (stats.isDirectory()) {
            if (!wh2.globFilter)
              this.emitAdd(processPath(path2), stats, processPath, opts, forceAdd);
            if (priorDepth && priorDepth > opts.depth)
              return;
            this.fsw._readdirp(wh2.watchPath, __spreadValues2({
              fileFilter: (entry2) => wh2.filterPath(entry2),
              directoryFilter: (entry2) => wh2.filterDir(entry2)
            }, Depth(opts.depth - (priorDepth || 0)))).on(STR_DATA, (entry2) => {
              if (this.fsw.closed) {
                return;
              }
              if (entry2.stats.isDirectory() && !wh2.filterPath(entry2))
                return;
              const joinedPath = sysPath$1.join(wh2.watchPath, entry2.path);
              const { fullPath } = entry2;
              if (wh2.followSymlinks && entry2.stats.isSymbolicLink()) {
                const curDepth = opts.depth === void 0 ? void 0 : calcDepth(joinedPath, sysPath$1.resolve(wh2.watchPath)) + 1;
                this._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);
              } else {
                this.emitAdd(joinedPath, entry2.stats, processPath, opts, forceAdd);
              }
            }).on(EV_ERROR$1, EMPTY_FN$1).on(STR_END$1, () => {
              this.fsw._emitReady();
            });
          } else {
            this.emitAdd(wh2.watchPath, stats, processPath, opts, forceAdd);
            this.fsw._emitReady();
          }
        } catch (error2) {
          if (!error2 || this.fsw._handleError(error2)) {
            this.fsw._emitReady();
            this.fsw._emitReady();
          }
        }
        if (opts.persistent && forceAdd !== true) {
          if (typeof transform2 === FUNCTION_TYPE$1) {
            this.initWatch(void 0, path2, wh2, processPath);
          } else {
            let realPath;
            try {
              realPath = await realpath(wh2.watchPath);
            } catch (e2) {
            }
            this.initWatch(realPath, path2, wh2, processPath);
          }
        }
      }
    };
    fseventsHandler.exports = FsEventsHandler$1;
    fseventsHandler.exports.canUse = canUse;
    var { EventEmitter: EventEmitter$2 } = require$$0__default$2;
    var fs$8 = fs__default;
    var sysPath = path__default;
    var { promisify } = require$$0__default$1;
    var readdirp = readdirp_1;
    var anymatch = anymatch$2.exports.default;
    var globParent = globParent$2;
    var isGlob = isGlob$2;
    var braces$1 = braces_1;
    var normalizePath = normalizePath$2;
    var NodeFsHandler = nodefsHandler;
    var FsEventsHandler = fseventsHandler.exports;
    var {
      EV_ALL,
      EV_READY,
      EV_ADD,
      EV_CHANGE,
      EV_UNLINK,
      EV_ADD_DIR,
      EV_UNLINK_DIR,
      EV_RAW,
      EV_ERROR,
      STR_CLOSE,
      STR_END,
      BACK_SLASH_RE,
      DOUBLE_SLASH_RE,
      SLASH_OR_BACK_SLASH_RE,
      DOT_RE,
      REPLACER_RE,
      SLASH,
      SLASH_SLASH,
      BRACE_START,
      BANG,
      ONE_DOT,
      TWO_DOTS,
      GLOBSTAR,
      SLASH_GLOBSTAR,
      ANYMATCH_OPTS,
      STRING_TYPE,
      FUNCTION_TYPE,
      EMPTY_STR,
      EMPTY_FN,
      isWindows: isWindows$1,
      isMacos,
      isIBMi
    } = constants$1;
    var stat = promisify(fs$8.stat);
    var readdir = promisify(fs$8.readdir);
    var arrify = (value = []) => Array.isArray(value) ? value : [value];
    var flatten = (list2, result2 = []) => {
      list2.forEach((item) => {
        if (Array.isArray(item)) {
          flatten(item, result2);
        } else {
          result2.push(item);
        }
      });
      return result2;
    };
    var unifyPaths = (paths_) => {
      const paths = flatten(arrify(paths_));
      if (!paths.every((p2) => typeof p2 === STRING_TYPE)) {
        throw new TypeError(`Non-string provided as watch path: ${paths}`);
      }
      return paths.map(normalizePathToUnix);
    };
    var toUnix = (string2) => {
      let str = string2.replace(BACK_SLASH_RE, SLASH);
      let prepend = false;
      if (str.startsWith(SLASH_SLASH)) {
        prepend = true;
      }
      while (str.match(DOUBLE_SLASH_RE)) {
        str = str.replace(DOUBLE_SLASH_RE, SLASH);
      }
      if (prepend) {
        str = SLASH + str;
      }
      return str;
    };
    var normalizePathToUnix = (path2) => toUnix(sysPath.normalize(toUnix(path2)));
    var normalizeIgnored = (cwd = EMPTY_STR) => (path2) => {
      if (typeof path2 !== STRING_TYPE)
        return path2;
      return normalizePathToUnix(sysPath.isAbsolute(path2) ? path2 : sysPath.join(cwd, path2));
    };
    var getAbsolutePath = (path2, cwd) => {
      if (sysPath.isAbsolute(path2)) {
        return path2;
      }
      if (path2.startsWith(BANG)) {
        return BANG + sysPath.join(cwd, path2.slice(1));
      }
      return sysPath.join(cwd, path2);
    };
    var undef = (opts, key2) => opts[key2] === void 0;
    var DirEntry = class {
      constructor(dir, removeWatcher) {
        this.path = dir;
        this._removeWatcher = removeWatcher;
        this.items = /* @__PURE__ */ new Set();
      }
      add(item) {
        const { items } = this;
        if (!items)
          return;
        if (item !== ONE_DOT && item !== TWO_DOTS)
          items.add(item);
      }
      async remove(item) {
        const { items } = this;
        if (!items)
          return;
        items.delete(item);
        if (items.size > 0)
          return;
        const dir = this.path;
        try {
          await readdir(dir);
        } catch (err) {
          if (this._removeWatcher) {
            this._removeWatcher(sysPath.dirname(dir), sysPath.basename(dir));
          }
        }
      }
      has(item) {
        const { items } = this;
        if (!items)
          return;
        return items.has(item);
      }
      getChildren() {
        const { items } = this;
        if (!items)
          return;
        return [...items.values()];
      }
      dispose() {
        this.items.clear();
        delete this.path;
        delete this._removeWatcher;
        delete this.items;
        Object.freeze(this);
      }
    };
    var STAT_METHOD_F = "stat";
    var STAT_METHOD_L = "lstat";
    var WatchHelper = class {
      constructor(path2, watchPath, follow, fsw) {
        this.fsw = fsw;
        this.path = path2 = path2.replace(REPLACER_RE, EMPTY_STR);
        this.watchPath = watchPath;
        this.fullWatchPath = sysPath.resolve(watchPath);
        this.hasGlob = watchPath !== path2;
        if (path2 === EMPTY_STR)
          this.hasGlob = false;
        this.globSymlink = this.hasGlob && follow ? void 0 : false;
        this.globFilter = this.hasGlob ? anymatch(path2, void 0, ANYMATCH_OPTS) : false;
        this.dirParts = this.getDirParts(path2);
        this.dirParts.forEach((parts) => {
          if (parts.length > 1)
            parts.pop();
        });
        this.followSymlinks = follow;
        this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L;
      }
      checkGlobSymlink(entry2) {
        if (this.globSymlink === void 0) {
          this.globSymlink = entry2.fullParentDir === this.fullWatchPath ? false : { realPath: entry2.fullParentDir, linkPath: this.fullWatchPath };
        }
        if (this.globSymlink) {
          return entry2.fullPath.replace(this.globSymlink.realPath, this.globSymlink.linkPath);
        }
        return entry2.fullPath;
      }
      entryPath(entry2) {
        return sysPath.join(this.watchPath, sysPath.relative(this.watchPath, this.checkGlobSymlink(entry2)));
      }
      filterPath(entry2) {
        const { stats } = entry2;
        if (stats && stats.isSymbolicLink())
          return this.filterDir(entry2);
        const resolvedPath = this.entryPath(entry2);
        const matchesGlob = this.hasGlob && typeof this.globFilter === FUNCTION_TYPE ? this.globFilter(resolvedPath) : true;
        return matchesGlob && this.fsw._isntIgnored(resolvedPath, stats) && this.fsw._hasReadPermissions(stats);
      }
      getDirParts(path2) {
        if (!this.hasGlob)
          return [];
        const parts = [];
        const expandedPath = path2.includes(BRACE_START) ? braces$1.expand(path2) : [path2];
        expandedPath.forEach((path3) => {
          parts.push(sysPath.relative(this.watchPath, path3).split(SLASH_OR_BACK_SLASH_RE));
        });
        return parts;
      }
      filterDir(entry2) {
        if (this.hasGlob) {
          const entryParts = this.getDirParts(this.checkGlobSymlink(entry2));
          let globstar = false;
          this.unmatchedGlob = !this.dirParts.some((parts) => {
            return parts.every((part, i2) => {
              if (part === GLOBSTAR)
                globstar = true;
              return globstar || !entryParts[0][i2] || anymatch(part, entryParts[0][i2], ANYMATCH_OPTS);
            });
          });
        }
        return !this.unmatchedGlob && this.fsw._isntIgnored(this.entryPath(entry2), entry2.stats);
      }
    };
    var FSWatcher = class extends EventEmitter$2 {
      constructor(_opts) {
        super();
        const opts = {};
        if (_opts)
          Object.assign(opts, _opts);
        this._watched = /* @__PURE__ */ new Map();
        this._closers = /* @__PURE__ */ new Map();
        this._ignoredPaths = /* @__PURE__ */ new Set();
        this._throttled = /* @__PURE__ */ new Map();
        this._symlinkPaths = /* @__PURE__ */ new Map();
        this._streams = /* @__PURE__ */ new Set();
        this.closed = false;
        if (undef(opts, "persistent"))
          opts.persistent = true;
        if (undef(opts, "ignoreInitial"))
          opts.ignoreInitial = false;
        if (undef(opts, "ignorePermissionErrors"))
          opts.ignorePermissionErrors = false;
        if (undef(opts, "interval"))
          opts.interval = 100;
        if (undef(opts, "binaryInterval"))
          opts.binaryInterval = 300;
        if (undef(opts, "disableGlobbing"))
          opts.disableGlobbing = false;
        opts.enableBinaryInterval = opts.binaryInterval !== opts.interval;
        if (undef(opts, "useFsEvents"))
          opts.useFsEvents = !opts.usePolling;
        const canUseFsEvents = FsEventsHandler.canUse();
        if (!canUseFsEvents)
          opts.useFsEvents = false;
        if (undef(opts, "usePolling") && !opts.useFsEvents) {
          opts.usePolling = isMacos;
        }
        if (isIBMi) {
          opts.usePolling = true;
        }
        const envPoll = process.env.CHOKIDAR_USEPOLLING;
        if (envPoll !== void 0) {
          const envLower = envPoll.toLowerCase();
          if (envLower === "false" || envLower === "0") {
            opts.usePolling = false;
          } else if (envLower === "true" || envLower === "1") {
            opts.usePolling = true;
          } else {
            opts.usePolling = !!envLower;
          }
        }
        const envInterval = process.env.CHOKIDAR_INTERVAL;
        if (envInterval) {
          opts.interval = Number.parseInt(envInterval, 10);
        }
        if (undef(opts, "atomic"))
          opts.atomic = !opts.usePolling && !opts.useFsEvents;
        if (opts.atomic)
          this._pendingUnlinks = /* @__PURE__ */ new Map();
        if (undef(opts, "followSymlinks"))
          opts.followSymlinks = true;
        if (undef(opts, "awaitWriteFinish"))
          opts.awaitWriteFinish = false;
        if (opts.awaitWriteFinish === true)
          opts.awaitWriteFinish = {};
        const awf = opts.awaitWriteFinish;
        if (awf) {
          if (!awf.stabilityThreshold)
            awf.stabilityThreshold = 2e3;
          if (!awf.pollInterval)
            awf.pollInterval = 100;
          this._pendingWrites = /* @__PURE__ */ new Map();
        }
        if (opts.ignored)
          opts.ignored = arrify(opts.ignored);
        let readyCalls = 0;
        this._emitReady = () => {
          readyCalls++;
          if (readyCalls >= this._readyCount) {
            this._emitReady = EMPTY_FN;
            this._readyEmitted = true;
            process.nextTick(() => this.emit(EV_READY));
          }
        };
        this._emitRaw = (...args) => this.emit(EV_RAW, ...args);
        this._readyEmitted = false;
        this.options = opts;
        if (opts.useFsEvents) {
          this._fsEventsHandler = new FsEventsHandler(this);
        } else {
          this._nodeFsHandler = new NodeFsHandler(this);
        }
        Object.freeze(opts);
      }
      add(paths_, _origAdd, _internal) {
        const { cwd, disableGlobbing } = this.options;
        this.closed = false;
        let paths = unifyPaths(paths_);
        if (cwd) {
          paths = paths.map((path2) => {
            const absPath = getAbsolutePath(path2, cwd);
            if (disableGlobbing || !isGlob(path2)) {
              return absPath;
            }
            return normalizePath(absPath);
          });
        }
        paths = paths.filter((path2) => {
          if (path2.startsWith(BANG)) {
            this._ignoredPaths.add(path2.slice(1));
            return false;
          }
          this._ignoredPaths.delete(path2);
          this._ignoredPaths.delete(path2 + SLASH_GLOBSTAR);
          this._userIgnored = void 0;
          return true;
        });
        if (this.options.useFsEvents && this._fsEventsHandler) {
          if (!this._readyCount)
            this._readyCount = paths.length;
          if (this.options.persistent)
            this._readyCount *= 2;
          paths.forEach((path2) => this._fsEventsHandler._addToFsEvents(path2));
        } else {
          if (!this._readyCount)
            this._readyCount = 0;
          this._readyCount += paths.length;
          Promise.all(paths.map(async (path2) => {
            const res = await this._nodeFsHandler._addToNodeFs(path2, !_internal, 0, 0, _origAdd);
            if (res)
              this._emitReady();
            return res;
          })).then((results) => {
            if (this.closed)
              return;
            results.filter((item) => item).forEach((item) => {
              this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));
            });
          });
        }
        return this;
      }
      unwatch(paths_) {
        if (this.closed)
          return this;
        const paths = unifyPaths(paths_);
        const { cwd } = this.options;
        paths.forEach((path2) => {
          if (!sysPath.isAbsolute(path2) && !this._closers.has(path2)) {
            if (cwd)
              path2 = sysPath.join(cwd, path2);
            path2 = sysPath.resolve(path2);
          }
          this._closePath(path2);
          this._ignoredPaths.add(path2);
          if (this._watched.has(path2)) {
            this._ignoredPaths.add(path2 + SLASH_GLOBSTAR);
          }
          this._userIgnored = void 0;
        });
        return this;
      }
      close() {
        if (this.closed)
          return this._closePromise;
        this.closed = true;
        this.removeAllListeners();
        const closers = [];
        this._closers.forEach((closerList) => closerList.forEach((closer) => {
          const promise2 = closer();
          if (promise2 instanceof Promise)
            closers.push(promise2);
        }));
        this._streams.forEach((stream2) => stream2.destroy());
        this._userIgnored = void 0;
        this._readyCount = 0;
        this._readyEmitted = false;
        this._watched.forEach((dirent) => dirent.dispose());
        ["closers", "watched", "streams", "symlinkPaths", "throttled"].forEach((key2) => {
          this[`_${key2}`].clear();
        });
        this._closePromise = closers.length ? Promise.all(closers).then(() => void 0) : Promise.resolve();
        return this._closePromise;
      }
      getWatched() {
        const watchList = {};
        this._watched.forEach((entry2, dir) => {
          const key2 = this.options.cwd ? sysPath.relative(this.options.cwd, dir) : dir;
          watchList[key2 || ONE_DOT] = entry2.getChildren().sort();
        });
        return watchList;
      }
      emitWithAll(event, args) {
        this.emit(...args);
        if (event !== EV_ERROR)
          this.emit(EV_ALL, ...args);
      }
      async _emit(event, path2, val1, val2, val3) {
        if (this.closed)
          return;
        const opts = this.options;
        if (isWindows$1)
          path2 = sysPath.normalize(path2);
        if (opts.cwd)
          path2 = sysPath.relative(opts.cwd, path2);
        const args = [event, path2];
        if (val3 !== void 0)
          args.push(val1, val2, val3);
        else if (val2 !== void 0)
          args.push(val1, val2);
        else if (val1 !== void 0)
          args.push(val1);
        const awf = opts.awaitWriteFinish;
        let pw;
        if (awf && (pw = this._pendingWrites.get(path2))) {
          pw.lastChange = new Date();
          return this;
        }
        if (opts.atomic) {
          if (event === EV_UNLINK) {
            this._pendingUnlinks.set(path2, args);
            setTimeout(() => {
              this._pendingUnlinks.forEach((entry2, path3) => {
                this.emit(...entry2);
                this.emit(EV_ALL, ...entry2);
                this._pendingUnlinks.delete(path3);
              });
            }, typeof opts.atomic === "number" ? opts.atomic : 100);
            return this;
          }
          if (event === EV_ADD && this._pendingUnlinks.has(path2)) {
            event = args[0] = EV_CHANGE;
            this._pendingUnlinks.delete(path2);
          }
        }
        if (awf && (event === EV_ADD || event === EV_CHANGE) && this._readyEmitted) {
          const awfEmit = (err, stats) => {
            if (err) {
              event = args[0] = EV_ERROR;
              args[1] = err;
              this.emitWithAll(event, args);
            } else if (stats) {
              if (args.length > 2) {
                args[2] = stats;
              } else {
                args.push(stats);
              }
              this.emitWithAll(event, args);
            }
          };
          this._awaitWriteFinish(path2, awf.stabilityThreshold, event, awfEmit);
          return this;
        }
        if (event === EV_CHANGE) {
          const isThrottled = !this._throttle(EV_CHANGE, path2, 50);
          if (isThrottled)
            return this;
        }
        if (opts.alwaysStat && val1 === void 0 && (event === EV_ADD || event === EV_ADD_DIR || event === EV_CHANGE)) {
          const fullPath = opts.cwd ? sysPath.join(opts.cwd, path2) : path2;
          let stats;
          try {
            stats = await stat(fullPath);
          } catch (err) {
          }
          if (!stats || this.closed)
            return;
          args.push(stats);
        }
        this.emitWithAll(event, args);
        return this;
      }
      _handleError(error2) {
        const code = error2 && error2.code;
        if (error2 && code !== "ENOENT" && code !== "ENOTDIR" && (!this.options.ignorePermissionErrors || code !== "EPERM" && code !== "EACCES")) {
          this.emit(EV_ERROR, error2);
        }
        return error2 || this.closed;
      }
      _throttle(actionType, path2, timeout) {
        if (!this._throttled.has(actionType)) {
          this._throttled.set(actionType, /* @__PURE__ */ new Map());
        }
        const action = this._throttled.get(actionType);
        const actionPath = action.get(path2);
        if (actionPath) {
          actionPath.count++;
          return false;
        }
        let timeoutObject;
        const clear = () => {
          const item = action.get(path2);
          const count = item ? item.count : 0;
          action.delete(path2);
          clearTimeout(timeoutObject);
          if (item)
            clearTimeout(item.timeoutObject);
          return count;
        };
        timeoutObject = setTimeout(clear, timeout);
        const thr = { timeoutObject, clear, count: 0 };
        action.set(path2, thr);
        return thr;
      }
      _incrReadyCount() {
        return this._readyCount++;
      }
      _awaitWriteFinish(path2, threshold2, event, awfEmit) {
        let timeoutHandler;
        let fullPath = path2;
        if (this.options.cwd && !sysPath.isAbsolute(path2)) {
          fullPath = sysPath.join(this.options.cwd, path2);
        }
        const now = new Date();
        const awaitWriteFinish = (prevStat) => {
          fs$8.stat(fullPath, (err, curStat) => {
            if (err || !this._pendingWrites.has(path2)) {
              if (err && err.code !== "ENOENT")
                awfEmit(err);
              return;
            }
            const now2 = Number(new Date());
            if (prevStat && curStat.size !== prevStat.size) {
              this._pendingWrites.get(path2).lastChange = now2;
            }
            const pw = this._pendingWrites.get(path2);
            const df = now2 - pw.lastChange;
            if (df >= threshold2) {
              this._pendingWrites.delete(path2);
              awfEmit(void 0, curStat);
            } else {
              timeoutHandler = setTimeout(awaitWriteFinish, this.options.awaitWriteFinish.pollInterval, curStat);
            }
          });
        };
        if (!this._pendingWrites.has(path2)) {
          this._pendingWrites.set(path2, {
            lastChange: now,
            cancelWait: () => {
              this._pendingWrites.delete(path2);
              clearTimeout(timeoutHandler);
              return event;
            }
          });
          timeoutHandler = setTimeout(awaitWriteFinish, this.options.awaitWriteFinish.pollInterval);
        }
      }
      _getGlobIgnored() {
        return [...this._ignoredPaths.values()];
      }
      _isIgnored(path2, stats) {
        if (this.options.atomic && DOT_RE.test(path2))
          return true;
        if (!this._userIgnored) {
          const { cwd } = this.options;
          const ign = this.options.ignored;
          const ignored = ign && ign.map(normalizeIgnored(cwd));
          const paths = arrify(ignored).filter((path3) => typeof path3 === STRING_TYPE && !isGlob(path3)).map((path3) => path3 + SLASH_GLOBSTAR);
          const list2 = this._getGlobIgnored().map(normalizeIgnored(cwd)).concat(ignored, paths);
          this._userIgnored = anymatch(list2, void 0, ANYMATCH_OPTS);
        }
        return this._userIgnored([path2, stats]);
      }
      _isntIgnored(path2, stat2) {
        return !this._isIgnored(path2, stat2);
      }
      _getWatchHelpers(path2, depth2) {
        const watchPath = depth2 || this.options.disableGlobbing || !isGlob(path2) ? path2 : globParent(path2);
        const follow = this.options.followSymlinks;
        return new WatchHelper(path2, watchPath, follow, this);
      }
      _getWatchedDir(directory) {
        if (!this._boundRemove)
          this._boundRemove = this._remove.bind(this);
        const dir = sysPath.resolve(directory);
        if (!this._watched.has(dir))
          this._watched.set(dir, new DirEntry(dir, this._boundRemove));
        return this._watched.get(dir);
      }
      _hasReadPermissions(stats) {
        if (this.options.ignorePermissionErrors)
          return true;
        const md = stats && Number.parseInt(stats.mode, 10);
        const st2 = md & 511;
        const it2 = Number.parseInt(st2.toString(8)[0], 10);
        return Boolean(4 & it2);
      }
      _remove(directory, item, isDirectory2) {
        const path2 = sysPath.join(directory, item);
        const fullPath = sysPath.resolve(path2);
        isDirectory2 = isDirectory2 != null ? isDirectory2 : this._watched.has(path2) || this._watched.has(fullPath);
        if (!this._throttle("remove", path2, 100))
          return;
        if (!isDirectory2 && !this.options.useFsEvents && this._watched.size === 1) {
          this.add(directory, item, true);
        }
        const wp = this._getWatchedDir(path2);
        const nestedDirectoryChildren = wp.getChildren();
        nestedDirectoryChildren.forEach((nested) => this._remove(path2, nested));
        const parent = this._getWatchedDir(directory);
        const wasTracked = parent.has(item);
        parent.remove(item);
        if (this._symlinkPaths.has(fullPath)) {
          this._symlinkPaths.delete(fullPath);
        }
        let relPath = path2;
        if (this.options.cwd)
          relPath = sysPath.relative(this.options.cwd, path2);
        if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {
          const event = this._pendingWrites.get(relPath).cancelWait();
          if (event === EV_ADD)
            return;
        }
        this._watched.delete(path2);
        this._watched.delete(fullPath);
        const eventName = isDirectory2 ? EV_UNLINK_DIR : EV_UNLINK;
        if (wasTracked && !this._isIgnored(path2))
          this._emit(eventName, path2);
        if (!this.options.useFsEvents) {
          this._closePath(path2);
        }
      }
      _closePath(path2) {
        this._closeFile(path2);
        const dir = sysPath.dirname(path2);
        this._getWatchedDir(dir).remove(sysPath.basename(path2));
      }
      _closeFile(path2) {
        const closers = this._closers.get(path2);
        if (!closers)
          return;
        closers.forEach((closer) => closer());
        this._closers.delete(path2);
      }
      _addPathCloser(path2, closer) {
        if (!closer)
          return;
        let list2 = this._closers.get(path2);
        if (!list2) {
          list2 = [];
          this._closers.set(path2, list2);
        }
        list2.push(closer);
      }
      _readdirp(root2, opts) {
        if (this.closed)
          return;
        const options2 = __spreadValues2({ type: EV_ALL, alwaysStat: true, lstat: true }, opts);
        let stream2 = readdirp(root2, options2);
        this._streams.add(stream2);
        stream2.once(STR_CLOSE, () => {
          stream2 = void 0;
        });
        stream2.once(STR_END, () => {
          if (stream2) {
            this._streams.delete(stream2);
            stream2 = void 0;
          }
        });
        return stream2;
      }
    };
    chokidar.FSWatcher = FSWatcher;
    var watch = (paths, options2) => {
      const watcher = new FSWatcher(options2);
      watcher.add(paths);
      return watcher;
    };
    chokidar.watch = watch;
    async function resolveHttpServer({ proxy }, app, httpsOptions) {
      if (!httpsOptions) {
        return (init_http(), __toCommonJS(http_exports)).createServer(app);
      }
      if (proxy) {
        return (init_https(), __toCommonJS(https_exports)).createServer(httpsOptions, app);
      } else {
        return (init_http2(), __toCommonJS(http2_exports)).createSecureServer(__spreadProps2(__spreadValues2({}, httpsOptions), {
          allowHTTP1: true
        }), app);
      }
    }
    async function resolveHttpsConfig(https2, cacheDir) {
      if (!https2)
        return void 0;
      const httpsOption = isObject$5(https2) ? __spreadValues2({}, https2) : {};
      const { ca: ca2, cert, key: key2, pfx } = httpsOption;
      Object.assign(httpsOption, {
        ca: readFileIfExists(ca2),
        cert: readFileIfExists(cert),
        key: readFileIfExists(key2),
        pfx: readFileIfExists(pfx)
      });
      if (!httpsOption.key || !httpsOption.cert) {
        httpsOption.cert = httpsOption.key = await getCertificate(cacheDir);
      }
      return httpsOption;
    }
    function readFileIfExists(value) {
      if (typeof value === "string") {
        try {
          return fs__default.readFileSync(path__default.resolve(value));
        } catch (e2) {
          return value;
        }
      }
      return value;
    }
    async function getCertificate(cacheDir) {
      const cachePath = path__default.join(cacheDir, "_cert.pem");
      try {
        const [stat2, content2] = await Promise.all([
          fs$n.promises.stat(cachePath),
          fs$n.promises.readFile(cachePath, "utf8")
        ]);
        if (Date.now() - stat2.ctime.valueOf() > 30 * 24 * 60 * 60 * 1e3) {
          throw new Error("cache is outdated.");
        }
        return content2;
      } catch {
        const content2 = (await Promise.resolve().then(function() {
          return require_dep_958b75cb();
        })).createCertificate();
        fs$n.promises.mkdir(cacheDir, { recursive: true }).then(() => fs$n.promises.writeFile(cachePath, content2)).catch(() => {
        });
        return content2;
      }
    }
    async function httpServerStart(httpServer, serverOptions) {
      return new Promise((resolve2, reject) => {
        let { port, strictPort, host, logger } = serverOptions;
        const onError = (e2) => {
          if (e2.code === "EADDRINUSE") {
            if (strictPort) {
              httpServer.removeListener("error", onError);
              reject(new Error(`Port ${port} is already in use`));
            } else {
              logger.info(`Port ${port} is in use, trying another one...`);
              httpServer.listen(++port, host);
            }
          } else {
            httpServer.removeListener("error", onError);
            reject(e2);
          }
        };
        httpServer.on("error", onError);
        httpServer.listen(port, host, () => {
          httpServer.removeListener("error", onError);
          resolve2(port);
        });
      });
    }
    var bufferUtil$1 = { exports: {} };
    var constants = {
      BINARY_TYPES: ["nodebuffer", "arraybuffer", "fragments"],
      EMPTY_BUFFER: Buffer.alloc(0),
      GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
      kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
      kListener: Symbol("kListener"),
      kStatusCode: Symbol("status-code"),
      kWebSocket: Symbol("websocket"),
      NOOP: () => {
      }
    };
    var { EMPTY_BUFFER: EMPTY_BUFFER$3 } = constants;
    function concat$1(list2, totalLength) {
      if (list2.length === 0)
        return EMPTY_BUFFER$3;
      if (list2.length === 1)
        return list2[0];
      const target = Buffer.allocUnsafe(totalLength);
      let offset2 = 0;
      for (let i2 = 0; i2 < list2.length; i2++) {
        const buf = list2[i2];
        target.set(buf, offset2);
        offset2 += buf.length;
      }
      if (offset2 < totalLength)
        return target.slice(0, offset2);
      return target;
    }
    function _mask(source2, mask, output, offset2, length) {
      for (let i2 = 0; i2 < length; i2++) {
        output[offset2 + i2] = source2[i2] ^ mask[i2 & 3];
      }
    }
    function _unmask(buffer2, mask) {
      for (let i2 = 0; i2 < buffer2.length; i2++) {
        buffer2[i2] ^= mask[i2 & 3];
      }
    }
    function toArrayBuffer$1(buf) {
      if (buf.byteLength === buf.buffer.byteLength) {
        return buf.buffer;
      }
      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
    }
    function toBuffer$2(data2) {
      toBuffer$2.readOnly = true;
      if (Buffer.isBuffer(data2))
        return data2;
      let buf;
      if (data2 instanceof ArrayBuffer) {
        buf = Buffer.from(data2);
      } else if (ArrayBuffer.isView(data2)) {
        buf = Buffer.from(data2.buffer, data2.byteOffset, data2.byteLength);
      } else {
        buf = Buffer.from(data2);
        toBuffer$2.readOnly = false;
      }
      return buf;
    }
    try {
      const bufferUtil2 = __require("bufferutil");
      bufferUtil$1.exports = {
        concat: concat$1,
        mask(source2, mask, output, offset2, length) {
          if (length < 48)
            _mask(source2, mask, output, offset2, length);
          else
            bufferUtil2.mask(source2, mask, output, offset2, length);
        },
        toArrayBuffer: toArrayBuffer$1,
        toBuffer: toBuffer$2,
        unmask(buffer2, mask) {
          if (buffer2.length < 32)
            _unmask(buffer2, mask);
          else
            bufferUtil2.unmask(buffer2, mask);
        }
      };
    } catch (e2) {
      bufferUtil$1.exports = {
        concat: concat$1,
        mask: _mask,
        toArrayBuffer: toArrayBuffer$1,
        toBuffer: toBuffer$2,
        unmask: _unmask
      };
    }
    var kDone = Symbol("kDone");
    var kRun = Symbol("kRun");
    var Limiter$1 = class {
      constructor(concurrency) {
        this[kDone] = () => {
          this.pending--;
          this[kRun]();
        };
        this.concurrency = concurrency || Infinity;
        this.jobs = [];
        this.pending = 0;
      }
      add(job) {
        this.jobs.push(job);
        this[kRun]();
      }
      [kRun]() {
        if (this.pending === this.concurrency)
          return;
        if (this.jobs.length) {
          const job = this.jobs.shift();
          this.pending++;
          job(this[kDone]);
        }
      }
    };
    var limiter = Limiter$1;
    var zlib = zlib__default;
    var bufferUtil = bufferUtil$1.exports;
    var Limiter = limiter;
    var { kStatusCode: kStatusCode$2 } = constants;
    var TRAILER = Buffer.from([0, 0, 255, 255]);
    var kPerMessageDeflate = Symbol("permessage-deflate");
    var kTotalLength = Symbol("total-length");
    var kCallback = Symbol("callback");
    var kBuffers = Symbol("buffers");
    var kError$1 = Symbol("error");
    var zlibLimiter;
    var PerMessageDeflate$4 = class {
      constructor(options2, isServer, maxPayload) {
        this._maxPayload = maxPayload | 0;
        this._options = options2 || {};
        this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
        this._isServer = !!isServer;
        this._deflate = null;
        this._inflate = null;
        this.params = null;
        if (!zlibLimiter) {
          const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;
          zlibLimiter = new Limiter(concurrency);
        }
      }
      static get extensionName() {
        return "permessage-deflate";
      }
      offer() {
        const params = {};
        if (this._options.serverNoContextTakeover) {
          params.server_no_context_takeover = true;
        }
        if (this._options.clientNoContextTakeover) {
          params.client_no_context_takeover = true;
        }
        if (this._options.serverMaxWindowBits) {
          params.server_max_window_bits = this._options.serverMaxWindowBits;
        }
        if (this._options.clientMaxWindowBits) {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        } else if (this._options.clientMaxWindowBits == null) {
          params.client_max_window_bits = true;
        }
        return params;
      }
      accept(configurations) {
        configurations = this.normalizeParams(configurations);
        this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
        return this.params;
      }
      cleanup() {
        if (this._inflate) {
          this._inflate.close();
          this._inflate = null;
        }
        if (this._deflate) {
          const callback = this._deflate[kCallback];
          this._deflate.close();
          this._deflate = null;
          if (callback) {
            callback(new Error("The deflate stream was closed while data was being processed"));
          }
        }
      }
      acceptAsServer(offers) {
        const opts = this._options;
        const accepted = offers.find((params) => {
          if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
            return false;
          }
          return true;
        });
        if (!accepted) {
          throw new Error("None of the extension offers can be accepted");
        }
        if (opts.serverNoContextTakeover) {
          accepted.server_no_context_takeover = true;
        }
        if (opts.clientNoContextTakeover) {
          accepted.client_no_context_takeover = true;
        }
        if (typeof opts.serverMaxWindowBits === "number") {
          accepted.server_max_window_bits = opts.serverMaxWindowBits;
        }
        if (typeof opts.clientMaxWindowBits === "number") {
          accepted.client_max_window_bits = opts.clientMaxWindowBits;
        } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
          delete accepted.client_max_window_bits;
        }
        return accepted;
      }
      acceptAsClient(response) {
        const params = response[0];
        if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
          throw new Error('Unexpected parameter "client_no_context_takeover"');
        }
        if (!params.client_max_window_bits) {
          if (typeof this._options.clientMaxWindowBits === "number") {
            params.client_max_window_bits = this._options.clientMaxWindowBits;
          }
        } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
          throw new Error('Unexpected or invalid parameter "client_max_window_bits"');
        }
        return params;
      }
      normalizeParams(configurations) {
        configurations.forEach((params) => {
          Object.keys(params).forEach((key2) => {
            let value = params[key2];
            if (value.length > 1) {
              throw new Error(`Parameter "${key2}" must have only a single value`);
            }
            value = value[0];
            if (key2 === "client_max_window_bits") {
              if (value !== true) {
                const num = +value;
                if (!Number.isInteger(num) || num < 8 || num > 15) {
                  throw new TypeError(`Invalid value for parameter "${key2}": ${value}`);
                }
                value = num;
              } else if (!this._isServer) {
                throw new TypeError(`Invalid value for parameter "${key2}": ${value}`);
              }
            } else if (key2 === "server_max_window_bits") {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(`Invalid value for parameter "${key2}": ${value}`);
              }
              value = num;
            } else if (key2 === "client_no_context_takeover" || key2 === "server_no_context_takeover") {
              if (value !== true) {
                throw new TypeError(`Invalid value for parameter "${key2}": ${value}`);
              }
            } else {
              throw new Error(`Unknown parameter "${key2}"`);
            }
            params[key2] = value;
          });
        });
        return configurations;
      }
      decompress(data2, fin, callback) {
        zlibLimiter.add((done) => {
          this._decompress(data2, fin, (err, result2) => {
            done();
            callback(err, result2);
          });
        });
      }
      compress(data2, fin, callback) {
        zlibLimiter.add((done) => {
          this._compress(data2, fin, (err, result2) => {
            done();
            callback(err, result2);
          });
        });
      }
      _decompress(data2, fin, callback) {
        const endpoint = this._isServer ? "client" : "server";
        if (!this._inflate) {
          const key2 = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key2] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key2];
          this._inflate = zlib.createInflateRaw(__spreadProps2(__spreadValues2({}, this._options.zlibInflateOptions), {
            windowBits
          }));
          this._inflate[kPerMessageDeflate] = this;
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          this._inflate.on("error", inflateOnError);
          this._inflate.on("data", inflateOnData);
        }
        this._inflate[kCallback] = callback;
        this._inflate.write(data2);
        if (fin)
          this._inflate.write(TRAILER);
        this._inflate.flush(() => {
          const err = this._inflate[kError$1];
          if (err) {
            this._inflate.close();
            this._inflate = null;
            callback(err);
            return;
          }
          const data3 = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);
          if (this._inflate._readableState.endEmitted) {
            this._inflate.close();
            this._inflate = null;
          } else {
            this._inflate[kTotalLength] = 0;
            this._inflate[kBuffers] = [];
            if (fin && this.params[`${endpoint}_no_context_takeover`]) {
              this._inflate.reset();
            }
          }
          callback(null, data3);
        });
      }
      _compress(data2, fin, callback) {
        const endpoint = this._isServer ? "server" : "client";
        if (!this._deflate) {
          const key2 = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key2] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key2];
          this._deflate = zlib.createDeflateRaw(__spreadProps2(__spreadValues2({}, this._options.zlibDeflateOptions), {
            windowBits
          }));
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          this._deflate.on("data", deflateOnData);
        }
        this._deflate[kCallback] = callback;
        this._deflate.write(data2);
        this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
          if (!this._deflate) {
            return;
          }
          let data3 = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);
          if (fin)
            data3 = data3.slice(0, data3.length - 4);
          this._deflate[kCallback] = null;
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._deflate.reset();
          }
          callback(null, data3);
        });
      }
    };
    var permessageDeflate = PerMessageDeflate$4;
    function deflateOnData(chunk) {
      this[kBuffers].push(chunk);
      this[kTotalLength] += chunk.length;
    }
    function inflateOnData(chunk) {
      this[kTotalLength] += chunk.length;
      if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
        this[kBuffers].push(chunk);
        return;
      }
      this[kError$1] = new RangeError("Max payload size exceeded");
      this[kError$1].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
      this[kError$1][kStatusCode$2] = 1009;
      this.removeListener("data", inflateOnData);
      this.reset();
    }
    function inflateOnError(err) {
      this[kPerMessageDeflate]._inflate = null;
      err[kStatusCode$2] = 1007;
      this[kCallback](err);
    }
    var validation = { exports: {} };
    var tokenChars$2 = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      0,
      1,
      0
    ];
    function isValidStatusCode$2(code) {
      return code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;
    }
    function _isValidUTF8(buf) {
      const len = buf.length;
      let i2 = 0;
      while (i2 < len) {
        if ((buf[i2] & 128) === 0) {
          i2++;
        } else if ((buf[i2] & 224) === 192) {
          if (i2 + 1 === len || (buf[i2 + 1] & 192) !== 128 || (buf[i2] & 254) === 192) {
            return false;
          }
          i2 += 2;
        } else if ((buf[i2] & 240) === 224) {
          if (i2 + 2 >= len || (buf[i2 + 1] & 192) !== 128 || (buf[i2 + 2] & 192) !== 128 || buf[i2] === 224 && (buf[i2 + 1] & 224) === 128 || buf[i2] === 237 && (buf[i2 + 1] & 224) === 160) {
            return false;
          }
          i2 += 3;
        } else if ((buf[i2] & 248) === 240) {
          if (i2 + 3 >= len || (buf[i2 + 1] & 192) !== 128 || (buf[i2 + 2] & 192) !== 128 || (buf[i2 + 3] & 192) !== 128 || buf[i2] === 240 && (buf[i2 + 1] & 240) === 128 || buf[i2] === 244 && buf[i2 + 1] > 143 || buf[i2] > 244) {
            return false;
          }
          i2 += 4;
        } else {
          return false;
        }
      }
      return true;
    }
    try {
      const isValidUTF82 = __require("utf-8-validate");
      validation.exports = {
        isValidStatusCode: isValidStatusCode$2,
        isValidUTF8(buf) {
          return buf.length < 150 ? _isValidUTF8(buf) : isValidUTF82(buf);
        },
        tokenChars: tokenChars$2
      };
    } catch (e2) {
      validation.exports = {
        isValidStatusCode: isValidStatusCode$2,
        isValidUTF8: _isValidUTF8,
        tokenChars: tokenChars$2
      };
    }
    var { Writable: Writable$1 } = require$$0__default$3;
    var PerMessageDeflate$3 = permessageDeflate;
    var {
      BINARY_TYPES: BINARY_TYPES$1,
      EMPTY_BUFFER: EMPTY_BUFFER$2,
      kStatusCode: kStatusCode$1,
      kWebSocket: kWebSocket$2
    } = constants;
    var { concat, toArrayBuffer, unmask } = bufferUtil$1.exports;
    var { isValidStatusCode: isValidStatusCode$1, isValidUTF8 } = validation.exports;
    var GET_INFO = 0;
    var GET_PAYLOAD_LENGTH_16 = 1;
    var GET_PAYLOAD_LENGTH_64 = 2;
    var GET_MASK = 3;
    var GET_DATA = 4;
    var INFLATING = 5;
    var Receiver$1 = class extends Writable$1 {
      constructor(options2 = {}) {
        super();
        this._binaryType = options2.binaryType || BINARY_TYPES$1[0];
        this._extensions = options2.extensions || {};
        this._isServer = !!options2.isServer;
        this._maxPayload = options2.maxPayload | 0;
        this._skipUTF8Validation = !!options2.skipUTF8Validation;
        this[kWebSocket$2] = void 0;
        this._bufferedBytes = 0;
        this._buffers = [];
        this._compressed = false;
        this._payloadLength = 0;
        this._mask = void 0;
        this._fragmented = 0;
        this._masked = false;
        this._fin = false;
        this._opcode = 0;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragments = [];
        this._state = GET_INFO;
        this._loop = false;
      }
      _write(chunk, encoding, cb) {
        if (this._opcode === 8 && this._state == GET_INFO)
          return cb();
        this._bufferedBytes += chunk.length;
        this._buffers.push(chunk);
        this.startLoop(cb);
      }
      consume(n3) {
        this._bufferedBytes -= n3;
        if (n3 === this._buffers[0].length)
          return this._buffers.shift();
        if (n3 < this._buffers[0].length) {
          const buf = this._buffers[0];
          this._buffers[0] = buf.slice(n3);
          return buf.slice(0, n3);
        }
        const dst = Buffer.allocUnsafe(n3);
        do {
          const buf = this._buffers[0];
          const offset2 = dst.length - n3;
          if (n3 >= buf.length) {
            dst.set(this._buffers.shift(), offset2);
          } else {
            dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n3), offset2);
            this._buffers[0] = buf.slice(n3);
          }
          n3 -= buf.length;
        } while (n3 > 0);
        return dst;
      }
      startLoop(cb) {
        let err;
        this._loop = true;
        do {
          switch (this._state) {
            case GET_INFO:
              err = this.getInfo();
              break;
            case GET_PAYLOAD_LENGTH_16:
              err = this.getPayloadLength16();
              break;
            case GET_PAYLOAD_LENGTH_64:
              err = this.getPayloadLength64();
              break;
            case GET_MASK:
              this.getMask();
              break;
            case GET_DATA:
              err = this.getData(cb);
              break;
            default:
              this._loop = false;
              return;
          }
        } while (this._loop);
        cb(err);
      }
      getInfo() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        const buf = this.consume(2);
        if ((buf[0] & 48) !== 0) {
          this._loop = false;
          return error$1(RangeError, "RSV2 and RSV3 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_2_3");
        }
        const compressed = (buf[0] & 64) === 64;
        if (compressed && !this._extensions[PerMessageDeflate$3.extensionName]) {
          this._loop = false;
          return error$1(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
        }
        this._fin = (buf[0] & 128) === 128;
        this._opcode = buf[0] & 15;
        this._payloadLength = buf[1] & 127;
        if (this._opcode === 0) {
          if (compressed) {
            this._loop = false;
            return error$1(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
          }
          if (!this._fragmented) {
            this._loop = false;
            return error$1(RangeError, "invalid opcode 0", true, 1002, "WS_ERR_INVALID_OPCODE");
          }
          this._opcode = this._fragmented;
        } else if (this._opcode === 1 || this._opcode === 2) {
          if (this._fragmented) {
            this._loop = false;
            return error$1(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE");
          }
          this._compressed = compressed;
        } else if (this._opcode > 7 && this._opcode < 11) {
          if (!this._fin) {
            this._loop = false;
            return error$1(RangeError, "FIN must be set", true, 1002, "WS_ERR_EXPECTED_FIN");
          }
          if (compressed) {
            this._loop = false;
            return error$1(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
          }
          if (this._payloadLength > 125) {
            this._loop = false;
            return error$1(RangeError, `invalid payload length ${this._payloadLength}`, true, 1002, "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH");
          }
        } else {
          this._loop = false;
          return error$1(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE");
        }
        if (!this._fin && !this._fragmented)
          this._fragmented = this._opcode;
        this._masked = (buf[1] & 128) === 128;
        if (this._isServer) {
          if (!this._masked) {
            this._loop = false;
            return error$1(RangeError, "MASK must be set", true, 1002, "WS_ERR_EXPECTED_MASK");
          }
        } else if (this._masked) {
          this._loop = false;
          return error$1(RangeError, "MASK must be clear", true, 1002, "WS_ERR_UNEXPECTED_MASK");
        }
        if (this._payloadLength === 126)
          this._state = GET_PAYLOAD_LENGTH_16;
        else if (this._payloadLength === 127)
          this._state = GET_PAYLOAD_LENGTH_64;
        else
          return this.haveLength();
      }
      getPayloadLength16() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        this._payloadLength = this.consume(2).readUInt16BE(0);
        return this.haveLength();
      }
      getPayloadLength64() {
        if (this._bufferedBytes < 8) {
          this._loop = false;
          return;
        }
        const buf = this.consume(8);
        const num = buf.readUInt32BE(0);
        if (num > Math.pow(2, 53 - 32) - 1) {
          this._loop = false;
          return error$1(RangeError, "Unsupported WebSocket frame: payload length > 2^53 - 1", false, 1009, "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH");
        }
        this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
        return this.haveLength();
      }
      haveLength() {
        if (this._payloadLength && this._opcode < 8) {
          this._totalPayloadLength += this._payloadLength;
          if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
            this._loop = false;
            return error$1(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH");
          }
        }
        if (this._masked)
          this._state = GET_MASK;
        else
          this._state = GET_DATA;
      }
      getMask() {
        if (this._bufferedBytes < 4) {
          this._loop = false;
          return;
        }
        this._mask = this.consume(4);
        this._state = GET_DATA;
      }
      getData(cb) {
        let data2 = EMPTY_BUFFER$2;
        if (this._payloadLength) {
          if (this._bufferedBytes < this._payloadLength) {
            this._loop = false;
            return;
          }
          data2 = this.consume(this._payloadLength);
          if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {
            unmask(data2, this._mask);
          }
        }
        if (this._opcode > 7)
          return this.controlMessage(data2);
        if (this._compressed) {
          this._state = INFLATING;
          this.decompress(data2, cb);
          return;
        }
        if (data2.length) {
          this._messageLength = this._totalPayloadLength;
          this._fragments.push(data2);
        }
        return this.dataMessage();
      }
      decompress(data2, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate$3.extensionName];
        perMessageDeflate.decompress(data2, this._fin, (err, buf) => {
          if (err)
            return cb(err);
          if (buf.length) {
            this._messageLength += buf.length;
            if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
              return cb(error$1(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"));
            }
            this._fragments.push(buf);
          }
          const er2 = this.dataMessage();
          if (er2)
            return cb(er2);
          this.startLoop(cb);
        });
      }
      dataMessage() {
        if (this._fin) {
          const messageLength = this._messageLength;
          const fragments = this._fragments;
          this._totalPayloadLength = 0;
          this._messageLength = 0;
          this._fragmented = 0;
          this._fragments = [];
          if (this._opcode === 2) {
            let data2;
            if (this._binaryType === "nodebuffer") {
              data2 = concat(fragments, messageLength);
            } else if (this._binaryType === "arraybuffer") {
              data2 = toArrayBuffer(concat(fragments, messageLength));
            } else {
              data2 = fragments;
            }
            this.emit("message", data2, true);
          } else {
            const buf = concat(fragments, messageLength);
            if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
              this._loop = false;
              return error$1(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8");
            }
            this.emit("message", buf, false);
          }
        }
        this._state = GET_INFO;
      }
      controlMessage(data2) {
        if (this._opcode === 8) {
          this._loop = false;
          if (data2.length === 0) {
            this.emit("conclude", 1005, EMPTY_BUFFER$2);
            this.end();
          } else if (data2.length === 1) {
            return error$1(RangeError, "invalid payload length 1", true, 1002, "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH");
          } else {
            const code = data2.readUInt16BE(0);
            if (!isValidStatusCode$1(code)) {
              return error$1(RangeError, `invalid status code ${code}`, true, 1002, "WS_ERR_INVALID_CLOSE_CODE");
            }
            const buf = data2.slice(2);
            if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
              return error$1(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8");
            }
            this.emit("conclude", code, buf);
            this.end();
          }
        } else if (this._opcode === 9) {
          this.emit("ping", data2);
        } else {
          this.emit("pong", data2);
        }
        this._state = GET_INFO;
      }
    };
    var receiver = Receiver$1;
    function error$1(ErrorCtor, message, prefix, statusCode, errorCode) {
      const err = new ErrorCtor(prefix ? `Invalid WebSocket frame: ${message}` : message);
      Error.captureStackTrace(err, error$1);
      err.code = errorCode;
      err[kStatusCode$1] = statusCode;
      return err;
    }
    var { randomFillSync } = require$$1__default$3;
    var PerMessageDeflate$2 = permessageDeflate;
    var { EMPTY_BUFFER: EMPTY_BUFFER$1 } = constants;
    var { isValidStatusCode } = validation.exports;
    var { mask: applyMask, toBuffer: toBuffer$1 } = bufferUtil$1.exports;
    var kByteLength = Symbol("kByteLength");
    var maskBuffer = Buffer.alloc(4);
    var Sender$1 = class {
      constructor(socket, extensions2, generateMask) {
        this._extensions = extensions2 || {};
        if (generateMask) {
          this._generateMask = generateMask;
          this._maskBuffer = Buffer.alloc(4);
        }
        this._socket = socket;
        this._firstFragment = true;
        this._compress = false;
        this._bufferedBytes = 0;
        this._deflating = false;
        this._queue = [];
      }
      static frame(data2, options2) {
        let mask;
        let merge3 = false;
        let offset2 = 2;
        let skipMasking = false;
        if (options2.mask) {
          mask = options2.maskBuffer || maskBuffer;
          if (options2.generateMask) {
            options2.generateMask(mask);
          } else {
            randomFillSync(mask, 0, 4);
          }
          skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
          offset2 = 6;
        }
        let dataLength;
        if (typeof data2 === "string") {
          if ((!options2.mask || skipMasking) && options2[kByteLength] !== void 0) {
            dataLength = options2[kByteLength];
          } else {
            data2 = Buffer.from(data2);
            dataLength = data2.length;
          }
        } else {
          dataLength = data2.length;
          merge3 = options2.mask && options2.readOnly && !skipMasking;
        }
        let payloadLength = dataLength;
        if (dataLength >= 65536) {
          offset2 += 8;
          payloadLength = 127;
        } else if (dataLength > 125) {
          offset2 += 2;
          payloadLength = 126;
        }
        const target = Buffer.allocUnsafe(merge3 ? dataLength + offset2 : offset2);
        target[0] = options2.fin ? options2.opcode | 128 : options2.opcode;
        if (options2.rsv1)
          target[0] |= 64;
        target[1] = payloadLength;
        if (payloadLength === 126) {
          target.writeUInt16BE(dataLength, 2);
        } else if (payloadLength === 127) {
          target[2] = target[3] = 0;
          target.writeUIntBE(dataLength, 4, 6);
        }
        if (!options2.mask)
          return [target, data2];
        target[1] |= 128;
        target[offset2 - 4] = mask[0];
        target[offset2 - 3] = mask[1];
        target[offset2 - 2] = mask[2];
        target[offset2 - 1] = mask[3];
        if (skipMasking)
          return [target, data2];
        if (merge3) {
          applyMask(data2, mask, target, offset2, dataLength);
          return [target];
        }
        applyMask(data2, mask, data2, 0, dataLength);
        return [target, data2];
      }
      close(code, data2, mask, cb) {
        let buf;
        if (code === void 0) {
          buf = EMPTY_BUFFER$1;
        } else if (typeof code !== "number" || !isValidStatusCode(code)) {
          throw new TypeError("First argument must be a valid error code number");
        } else if (data2 === void 0 || !data2.length) {
          buf = Buffer.allocUnsafe(2);
          buf.writeUInt16BE(code, 0);
        } else {
          const length = Buffer.byteLength(data2);
          if (length > 123) {
            throw new RangeError("The message must not be greater than 123 bytes");
          }
          buf = Buffer.allocUnsafe(2 + length);
          buf.writeUInt16BE(code, 0);
          if (typeof data2 === "string") {
            buf.write(data2, 2);
          } else {
            buf.set(data2, 2);
          }
        }
        const options2 = {
          [kByteLength]: buf.length,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 8,
          readOnly: false,
          rsv1: false
        };
        if (this._deflating) {
          this.enqueue([this.dispatch, buf, false, options2, cb]);
        } else {
          this.sendFrame(Sender$1.frame(buf, options2), cb);
        }
      }
      ping(data2, mask, cb) {
        let byteLength;
        let readOnly;
        if (typeof data2 === "string") {
          byteLength = Buffer.byteLength(data2);
          readOnly = false;
        } else {
          data2 = toBuffer$1(data2);
          byteLength = data2.length;
          readOnly = toBuffer$1.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options2 = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 9,
          readOnly,
          rsv1: false
        };
        if (this._deflating) {
          this.enqueue([this.dispatch, data2, false, options2, cb]);
        } else {
          this.sendFrame(Sender$1.frame(data2, options2), cb);
        }
      }
      pong(data2, mask, cb) {
        let byteLength;
        let readOnly;
        if (typeof data2 === "string") {
          byteLength = Buffer.byteLength(data2);
          readOnly = false;
        } else {
          data2 = toBuffer$1(data2);
          byteLength = data2.length;
          readOnly = toBuffer$1.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options2 = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 10,
          readOnly,
          rsv1: false
        };
        if (this._deflating) {
          this.enqueue([this.dispatch, data2, false, options2, cb]);
        } else {
          this.sendFrame(Sender$1.frame(data2, options2), cb);
        }
      }
      send(data2, options2, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate$2.extensionName];
        let opcode = options2.binary ? 2 : 1;
        let rsv1 = options2.compress;
        let byteLength;
        let readOnly;
        if (typeof data2 === "string") {
          byteLength = Buffer.byteLength(data2);
          readOnly = false;
        } else {
          data2 = toBuffer$1(data2);
          byteLength = data2.length;
          readOnly = toBuffer$1.readOnly;
        }
        if (this._firstFragment) {
          this._firstFragment = false;
          if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) {
            rsv1 = byteLength >= perMessageDeflate._threshold;
          }
          this._compress = rsv1;
        } else {
          rsv1 = false;
          opcode = 0;
        }
        if (options2.fin)
          this._firstFragment = true;
        if (perMessageDeflate) {
          const opts = {
            [kByteLength]: byteLength,
            fin: options2.fin,
            generateMask: this._generateMask,
            mask: options2.mask,
            maskBuffer: this._maskBuffer,
            opcode,
            readOnly,
            rsv1
          };
          if (this._deflating) {
            this.enqueue([this.dispatch, data2, this._compress, opts, cb]);
          } else {
            this.dispatch(data2, this._compress, opts, cb);
          }
        } else {
          this.sendFrame(Sender$1.frame(data2, {
            [kByteLength]: byteLength,
            fin: options2.fin,
            generateMask: this._generateMask,
            mask: options2.mask,
            maskBuffer: this._maskBuffer,
            opcode,
            readOnly,
            rsv1: false
          }), cb);
        }
      }
      dispatch(data2, compress, options2, cb) {
        if (!compress) {
          this.sendFrame(Sender$1.frame(data2, options2), cb);
          return;
        }
        const perMessageDeflate = this._extensions[PerMessageDeflate$2.extensionName];
        this._bufferedBytes += options2[kByteLength];
        this._deflating = true;
        perMessageDeflate.compress(data2, options2.fin, (_2, buf) => {
          if (this._socket.destroyed) {
            const err = new Error("The socket was closed while data was being compressed");
            if (typeof cb === "function")
              cb(err);
            for (let i2 = 0; i2 < this._queue.length; i2++) {
              const params = this._queue[i2];
              const callback = params[params.length - 1];
              if (typeof callback === "function")
                callback(err);
            }
            return;
          }
          this._bufferedBytes -= options2[kByteLength];
          this._deflating = false;
          options2.readOnly = false;
          this.sendFrame(Sender$1.frame(buf, options2), cb);
          this.dequeue();
        });
      }
      dequeue() {
        while (!this._deflating && this._queue.length) {
          const params = this._queue.shift();
          this._bufferedBytes -= params[3][kByteLength];
          Reflect.apply(params[0], this, params.slice(1));
        }
      }
      enqueue(params) {
        this._bufferedBytes += params[3][kByteLength];
        this._queue.push(params);
      }
      sendFrame(list2, cb) {
        if (list2.length === 2) {
          this._socket.cork();
          this._socket.write(list2[0]);
          this._socket.write(list2[1], cb);
          this._socket.uncork();
        } else {
          this._socket.write(list2[0], cb);
        }
      }
    };
    var sender = Sender$1;
    var { kForOnEventAttribute: kForOnEventAttribute$1, kListener: kListener$1 } = constants;
    var kCode = Symbol("kCode");
    var kData = Symbol("kData");
    var kError = Symbol("kError");
    var kMessage = Symbol("kMessage");
    var kReason = Symbol("kReason");
    var kTarget = Symbol("kTarget");
    var kType = Symbol("kType");
    var kWasClean = Symbol("kWasClean");
    var Event = class {
      constructor(type) {
        this[kTarget] = null;
        this[kType] = type;
      }
      get target() {
        return this[kTarget];
      }
      get type() {
        return this[kType];
      }
    };
    Object.defineProperty(Event.prototype, "target", { enumerable: true });
    Object.defineProperty(Event.prototype, "type", { enumerable: true });
    var CloseEvent = class extends Event {
      constructor(type, options2 = {}) {
        super(type);
        this[kCode] = options2.code === void 0 ? 0 : options2.code;
        this[kReason] = options2.reason === void 0 ? "" : options2.reason;
        this[kWasClean] = options2.wasClean === void 0 ? false : options2.wasClean;
      }
      get code() {
        return this[kCode];
      }
      get reason() {
        return this[kReason];
      }
      get wasClean() {
        return this[kWasClean];
      }
    };
    Object.defineProperty(CloseEvent.prototype, "code", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "reason", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "wasClean", { enumerable: true });
    var ErrorEvent = class extends Event {
      constructor(type, options2 = {}) {
        super(type);
        this[kError] = options2.error === void 0 ? null : options2.error;
        this[kMessage] = options2.message === void 0 ? "" : options2.message;
      }
      get error() {
        return this[kError];
      }
      get message() {
        return this[kMessage];
      }
    };
    Object.defineProperty(ErrorEvent.prototype, "error", { enumerable: true });
    Object.defineProperty(ErrorEvent.prototype, "message", { enumerable: true });
    var MessageEvent = class extends Event {
      constructor(type, options2 = {}) {
        super(type);
        this[kData] = options2.data === void 0 ? null : options2.data;
      }
      get data() {
        return this[kData];
      }
    };
    Object.defineProperty(MessageEvent.prototype, "data", { enumerable: true });
    var EventTarget = {
      addEventListener(type, listener2, options2 = {}) {
        let wrapper;
        if (type === "message") {
          wrapper = function onMessage(data2, isBinary) {
            const event = new MessageEvent("message", {
              data: isBinary ? data2 : data2.toString()
            });
            event[kTarget] = this;
            listener2.call(this, event);
          };
        } else if (type === "close") {
          wrapper = function onClose(code, message) {
            const event = new CloseEvent("close", {
              code,
              reason: message.toString(),
              wasClean: this._closeFrameReceived && this._closeFrameSent
            });
            event[kTarget] = this;
            listener2.call(this, event);
          };
        } else if (type === "error") {
          wrapper = function onError(error2) {
            const event = new ErrorEvent("error", {
              error: error2,
              message: error2.message
            });
            event[kTarget] = this;
            listener2.call(this, event);
          };
        } else if (type === "open") {
          wrapper = function onOpen() {
            const event = new Event("open");
            event[kTarget] = this;
            listener2.call(this, event);
          };
        } else {
          return;
        }
        wrapper[kForOnEventAttribute$1] = !!options2[kForOnEventAttribute$1];
        wrapper[kListener$1] = listener2;
        if (options2.once) {
          this.once(type, wrapper);
        } else {
          this.on(type, wrapper);
        }
      },
      removeEventListener(type, handler) {
        for (const listener2 of this.listeners(type)) {
          if (listener2[kListener$1] === handler && !listener2[kForOnEventAttribute$1]) {
            this.removeListener(type, listener2);
            break;
          }
        }
      }
    };
    var eventTarget = {
      CloseEvent,
      ErrorEvent,
      Event,
      EventTarget,
      MessageEvent
    };
    var { tokenChars: tokenChars$1 } = validation.exports;
    function push(dest, name, elem) {
      if (dest[name] === void 0)
        dest[name] = [elem];
      else
        dest[name].push(elem);
    }
    function parse$7(header) {
      const offers = /* @__PURE__ */ Object.create(null);
      let params = /* @__PURE__ */ Object.create(null);
      let mustUnescape = false;
      let isEscaping = false;
      let inQuotes = false;
      let extensionName;
      let paramName;
      let start = -1;
      let code = -1;
      let end = -1;
      let i2 = 0;
      for (; i2 < header.length; i2++) {
        code = header.charCodeAt(i2);
        if (extensionName === void 0) {
          if (end === -1 && tokenChars$1[code] === 1) {
            if (start === -1)
              start = i2;
          } else if (i2 !== 0 && (code === 32 || code === 9)) {
            if (end === -1 && start !== -1)
              end = i2;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i2}`);
            }
            if (end === -1)
              end = i2;
            const name = header.slice(start, end);
            if (code === 44) {
              push(offers, name, params);
              params = /* @__PURE__ */ Object.create(null);
            } else {
              extensionName = name;
            }
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i2}`);
          }
        } else if (paramName === void 0) {
          if (end === -1 && tokenChars$1[code] === 1) {
            if (start === -1)
              start = i2;
          } else if (code === 32 || code === 9) {
            if (end === -1 && start !== -1)
              end = i2;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i2}`);
            }
            if (end === -1)
              end = i2;
            push(params, header.slice(start, end), true);
            if (code === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            start = end = -1;
          } else if (code === 61 && start !== -1 && end === -1) {
            paramName = header.slice(start, i2);
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i2}`);
          }
        } else {
          if (isEscaping) {
            if (tokenChars$1[code] !== 1) {
              throw new SyntaxError(`Unexpected character at index ${i2}`);
            }
            if (start === -1)
              start = i2;
            else if (!mustUnescape)
              mustUnescape = true;
            isEscaping = false;
          } else if (inQuotes) {
            if (tokenChars$1[code] === 1) {
              if (start === -1)
                start = i2;
            } else if (code === 34 && start !== -1) {
              inQuotes = false;
              end = i2;
            } else if (code === 92) {
              isEscaping = true;
            } else {
              throw new SyntaxError(`Unexpected character at index ${i2}`);
            }
          } else if (code === 34 && header.charCodeAt(i2 - 1) === 61) {
            inQuotes = true;
          } else if (end === -1 && tokenChars$1[code] === 1) {
            if (start === -1)
              start = i2;
          } else if (start !== -1 && (code === 32 || code === 9)) {
            if (end === -1)
              end = i2;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i2}`);
            }
            if (end === -1)
              end = i2;
            let value = header.slice(start, end);
            if (mustUnescape) {
              value = value.replace(/\\/g, "");
              mustUnescape = false;
            }
            push(params, paramName, value);
            if (code === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            paramName = void 0;
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i2}`);
          }
        }
      }
      if (start === -1 || inQuotes || code === 32 || code === 9) {
        throw new SyntaxError("Unexpected end of input");
      }
      if (end === -1)
        end = i2;
      const token2 = header.slice(start, end);
      if (extensionName === void 0) {
        push(offers, token2, params);
      } else {
        if (paramName === void 0) {
          push(params, token2, true);
        } else if (mustUnescape) {
          push(params, paramName, token2.replace(/\\/g, ""));
        } else {
          push(params, paramName, token2);
        }
        push(offers, extensionName, params);
      }
      return offers;
    }
    function format$1(extensions2) {
      return Object.keys(extensions2).map((extension2) => {
        let configurations = extensions2[extension2];
        if (!Array.isArray(configurations))
          configurations = [configurations];
        return configurations.map((params) => {
          return [extension2].concat(Object.keys(params).map((k2) => {
            let values = params[k2];
            if (!Array.isArray(values))
              values = [values];
            return values.map((v2) => v2 === true ? k2 : `${k2}=${v2}`).join("; ");
          })).join("; ");
        }).join(", ");
      }).join(", ");
    }
    var extension$1 = { format: format$1, parse: parse$7 };
    var EventEmitter$1 = require$$0__default$2;
    var https$2 = require$$1__default$4;
    var http$3 = require$$1__default$2;
    var net = require$$3__default;
    var tls = require$$4__default;
    var { randomBytes, createHash: createHash$1 } = require$$1__default$3;
    var { URL: URL$1 } = require$$0__default$5;
    var PerMessageDeflate$1 = permessageDeflate;
    var Receiver = receiver;
    var Sender = sender;
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      GUID: GUID$1,
      kForOnEventAttribute,
      kListener,
      kStatusCode,
      kWebSocket: kWebSocket$1,
      NOOP
    } = constants;
    var {
      EventTarget: { addEventListener, removeEventListener }
    } = eventTarget;
    var { format, parse: parse$6 } = extension$1;
    var { toBuffer } = bufferUtil$1.exports;
    var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
    var subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;
    var protocolVersions = [8, 13];
    var closeTimeout = 30 * 1e3;
    var WebSocket$1 = class extends EventEmitter$1 {
      constructor(address, protocols, options2) {
        super();
        this._binaryType = BINARY_TYPES[0];
        this._closeCode = 1006;
        this._closeFrameReceived = false;
        this._closeFrameSent = false;
        this._closeMessage = EMPTY_BUFFER;
        this._closeTimer = null;
        this._extensions = {};
        this._paused = false;
        this._protocol = "";
        this._readyState = WebSocket$1.CONNECTING;
        this._receiver = null;
        this._sender = null;
        this._socket = null;
        if (address !== null) {
          this._bufferedAmount = 0;
          this._isServer = false;
          this._redirects = 0;
          if (protocols === void 0) {
            protocols = [];
          } else if (!Array.isArray(protocols)) {
            if (typeof protocols === "object" && protocols !== null) {
              options2 = protocols;
              protocols = [];
            } else {
              protocols = [protocols];
            }
          }
          initAsClient(this, address, protocols, options2);
        } else {
          this._isServer = true;
        }
      }
      get binaryType() {
        return this._binaryType;
      }
      set binaryType(type) {
        if (!BINARY_TYPES.includes(type))
          return;
        this._binaryType = type;
        if (this._receiver)
          this._receiver._binaryType = type;
      }
      get bufferedAmount() {
        if (!this._socket)
          return this._bufferedAmount;
        return this._socket._writableState.length + this._sender._bufferedBytes;
      }
      get extensions() {
        return Object.keys(this._extensions).join();
      }
      get isPaused() {
        return this._paused;
      }
      get onclose() {
        return null;
      }
      get onerror() {
        return null;
      }
      get onopen() {
        return null;
      }
      get onmessage() {
        return null;
      }
      get protocol() {
        return this._protocol;
      }
      get readyState() {
        return this._readyState;
      }
      get url() {
        return this._url;
      }
      setSocket(socket, head, options2) {
        const receiver2 = new Receiver({
          binaryType: this.binaryType,
          extensions: this._extensions,
          isServer: this._isServer,
          maxPayload: options2.maxPayload,
          skipUTF8Validation: options2.skipUTF8Validation
        });
        this._sender = new Sender(socket, this._extensions, options2.generateMask);
        this._receiver = receiver2;
        this._socket = socket;
        receiver2[kWebSocket$1] = this;
        socket[kWebSocket$1] = this;
        receiver2.on("conclude", receiverOnConclude);
        receiver2.on("drain", receiverOnDrain);
        receiver2.on("error", receiverOnError);
        receiver2.on("message", receiverOnMessage);
        receiver2.on("ping", receiverOnPing);
        receiver2.on("pong", receiverOnPong);
        socket.setTimeout(0);
        socket.setNoDelay();
        if (head.length > 0)
          socket.unshift(head);
        socket.on("close", socketOnClose);
        socket.on("data", socketOnData);
        socket.on("end", socketOnEnd);
        socket.on("error", socketOnError$1);
        this._readyState = WebSocket$1.OPEN;
        this.emit("open");
      }
      emitClose() {
        if (!this._socket) {
          this._readyState = WebSocket$1.CLOSED;
          this.emit("close", this._closeCode, this._closeMessage);
          return;
        }
        if (this._extensions[PerMessageDeflate$1.extensionName]) {
          this._extensions[PerMessageDeflate$1.extensionName].cleanup();
        }
        this._receiver.removeAllListeners();
        this._readyState = WebSocket$1.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
      }
      close(code, data2) {
        if (this.readyState === WebSocket$1.CLOSED)
          return;
        if (this.readyState === WebSocket$1.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          return abortHandshake$1(this, this._req, msg);
        }
        if (this.readyState === WebSocket$1.CLOSING) {
          if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
            this._socket.end();
          }
          return;
        }
        this._readyState = WebSocket$1.CLOSING;
        this._sender.close(code, data2, !this._isServer, (err) => {
          if (err)
            return;
          this._closeFrameSent = true;
          if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
            this._socket.end();
          }
        });
        this._closeTimer = setTimeout(this._socket.destroy.bind(this._socket), closeTimeout);
      }
      pause() {
        if (this.readyState === WebSocket$1.CONNECTING || this.readyState === WebSocket$1.CLOSED) {
          return;
        }
        this._paused = true;
        this._socket.pause();
      }
      ping(data2, mask, cb) {
        if (this.readyState === WebSocket$1.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data2 === "function") {
          cb = data2;
          data2 = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data2 === "number")
          data2 = data2.toString();
        if (this.readyState !== WebSocket$1.OPEN) {
          sendAfterClose(this, data2, cb);
          return;
        }
        if (mask === void 0)
          mask = !this._isServer;
        this._sender.ping(data2 || EMPTY_BUFFER, mask, cb);
      }
      pong(data2, mask, cb) {
        if (this.readyState === WebSocket$1.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data2 === "function") {
          cb = data2;
          data2 = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data2 === "number")
          data2 = data2.toString();
        if (this.readyState !== WebSocket$1.OPEN) {
          sendAfterClose(this, data2, cb);
          return;
        }
        if (mask === void 0)
          mask = !this._isServer;
        this._sender.pong(data2 || EMPTY_BUFFER, mask, cb);
      }
      resume() {
        if (this.readyState === WebSocket$1.CONNECTING || this.readyState === WebSocket$1.CLOSED) {
          return;
        }
        this._paused = false;
        if (!this._receiver._writableState.needDrain)
          this._socket.resume();
      }
      send(data2, options2, cb) {
        if (this.readyState === WebSocket$1.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof options2 === "function") {
          cb = options2;
          options2 = {};
        }
        if (typeof data2 === "number")
          data2 = data2.toString();
        if (this.readyState !== WebSocket$1.OPEN) {
          sendAfterClose(this, data2, cb);
          return;
        }
        const opts = __spreadValues2({
          binary: typeof data2 !== "string",
          mask: !this._isServer,
          compress: true,
          fin: true
        }, options2);
        if (!this._extensions[PerMessageDeflate$1.extensionName]) {
          opts.compress = false;
        }
        this._sender.send(data2 || EMPTY_BUFFER, opts, cb);
      }
      terminate() {
        if (this.readyState === WebSocket$1.CLOSED)
          return;
        if (this.readyState === WebSocket$1.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          return abortHandshake$1(this, this._req, msg);
        }
        if (this._socket) {
          this._readyState = WebSocket$1.CLOSING;
          this._socket.destroy();
        }
      }
    };
    Object.defineProperty(WebSocket$1, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket$1.prototype, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket$1, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket$1.prototype, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket$1, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket$1.prototype, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket$1, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    Object.defineProperty(WebSocket$1.prototype, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    [
      "binaryType",
      "bufferedAmount",
      "extensions",
      "isPaused",
      "protocol",
      "readyState",
      "url"
    ].forEach((property) => {
      Object.defineProperty(WebSocket$1.prototype, property, { enumerable: true });
    });
    ["open", "error", "close", "message"].forEach((method) => {
      Object.defineProperty(WebSocket$1.prototype, `on${method}`, {
        enumerable: true,
        get() {
          for (const listener2 of this.listeners(method)) {
            if (listener2[kForOnEventAttribute])
              return listener2[kListener];
          }
          return null;
        },
        set(handler) {
          for (const listener2 of this.listeners(method)) {
            if (listener2[kForOnEventAttribute]) {
              this.removeListener(method, listener2);
              break;
            }
          }
          if (typeof handler !== "function")
            return;
          this.addEventListener(method, handler, {
            [kForOnEventAttribute]: true
          });
        }
      });
    });
    WebSocket$1.prototype.addEventListener = addEventListener;
    WebSocket$1.prototype.removeEventListener = removeEventListener;
    var websocket = WebSocket$1;
    function initAsClient(websocket2, address, protocols, options2) {
      const opts = __spreadProps2(__spreadValues2({
        protocolVersion: protocolVersions[1],
        maxPayload: 100 * 1024 * 1024,
        skipUTF8Validation: false,
        perMessageDeflate: true,
        followRedirects: false,
        maxRedirects: 10
      }, options2), {
        createConnection: void 0,
        socketPath: void 0,
        hostname: void 0,
        protocol: void 0,
        timeout: void 0,
        method: void 0,
        host: void 0,
        path: void 0,
        port: void 0
      });
      if (!protocolVersions.includes(opts.protocolVersion)) {
        throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`);
      }
      let parsedUrl;
      if (address instanceof URL$1) {
        parsedUrl = address;
        websocket2._url = address.href;
      } else {
        try {
          parsedUrl = new URL$1(address);
        } catch (e2) {
          throw new SyntaxError(`Invalid URL: ${address}`);
        }
        websocket2._url = address;
      }
      const isSecure = parsedUrl.protocol === "wss:";
      const isUnixSocket = parsedUrl.protocol === "ws+unix:";
      let invalidURLMessage;
      if (parsedUrl.protocol !== "ws:" && !isSecure && !isUnixSocket) {
        invalidURLMessage = `The URL's protocol must be one of "ws:", "wss:", or "ws+unix:"`;
      } else if (isUnixSocket && !parsedUrl.pathname) {
        invalidURLMessage = "The URL's pathname is empty";
      } else if (parsedUrl.hash) {
        invalidURLMessage = "The URL contains a fragment identifier";
      }
      if (invalidURLMessage) {
        const err = new SyntaxError(invalidURLMessage);
        if (websocket2._redirects === 0) {
          throw err;
        } else {
          emitErrorAndClose(websocket2, err);
          return;
        }
      }
      const defaultPort = isSecure ? 443 : 80;
      const key2 = randomBytes(16).toString("base64");
      const get = isSecure ? https$2.get : http$3.get;
      const protocolSet = /* @__PURE__ */ new Set();
      let perMessageDeflate;
      opts.createConnection = isSecure ? tlsConnect : netConnect;
      opts.defaultPort = opts.defaultPort || defaultPort;
      opts.port = parsedUrl.port || defaultPort;
      opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
      opts.headers = __spreadValues2({
        "Sec-WebSocket-Version": opts.protocolVersion,
        "Sec-WebSocket-Key": key2,
        Connection: "Upgrade",
        Upgrade: "websocket"
      }, opts.headers);
      opts.path = parsedUrl.pathname + parsedUrl.search;
      opts.timeout = opts.handshakeTimeout;
      if (opts.perMessageDeflate) {
        perMessageDeflate = new PerMessageDeflate$1(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);
        opts.headers["Sec-WebSocket-Extensions"] = format({
          [PerMessageDeflate$1.extensionName]: perMessageDeflate.offer()
        });
      }
      if (protocols.length) {
        for (const protocol of protocols) {
          if (typeof protocol !== "string" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {
            throw new SyntaxError("An invalid or duplicated subprotocol was specified");
          }
          protocolSet.add(protocol);
        }
        opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
      }
      if (opts.origin) {
        if (opts.protocolVersion < 13) {
          opts.headers["Sec-WebSocket-Origin"] = opts.origin;
        } else {
          opts.headers.Origin = opts.origin;
        }
      }
      if (parsedUrl.username || parsedUrl.password) {
        opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
      }
      if (isUnixSocket) {
        const parts = opts.path.split(":");
        opts.socketPath = parts[0];
        opts.path = parts[1];
      }
      if (opts.followRedirects) {
        if (websocket2._redirects === 0) {
          websocket2._originalHost = parsedUrl.host;
          const headers = options2 && options2.headers;
          options2 = __spreadProps2(__spreadValues2({}, options2), { headers: {} });
          if (headers) {
            for (const [key3, value] of Object.entries(headers)) {
              options2.headers[key3.toLowerCase()] = value;
            }
          }
        } else if (parsedUrl.host !== websocket2._originalHost) {
          delete opts.headers.authorization;
          delete opts.headers.cookie;
          delete opts.headers.host;
          opts.auth = void 0;
        }
        if (opts.auth && !options2.headers.authorization) {
          options2.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
        }
      }
      let req2 = websocket2._req = get(opts);
      if (opts.timeout) {
        req2.on("timeout", () => {
          abortHandshake$1(websocket2, req2, "Opening handshake has timed out");
        });
      }
      req2.on("error", (err) => {
        if (req2 === null || req2.aborted)
          return;
        req2 = websocket2._req = null;
        emitErrorAndClose(websocket2, err);
      });
      req2.on("response", (res) => {
        const location = res.headers.location;
        const statusCode = res.statusCode;
        if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
          if (++websocket2._redirects > opts.maxRedirects) {
            abortHandshake$1(websocket2, req2, "Maximum redirects exceeded");
            return;
          }
          req2.abort();
          let addr;
          try {
            addr = new URL$1(location, address);
          } catch (e2) {
            const err = new SyntaxError(`Invalid URL: ${location}`);
            emitErrorAndClose(websocket2, err);
            return;
          }
          initAsClient(websocket2, addr, protocols, options2);
        } else if (!websocket2.emit("unexpected-response", req2, res)) {
          abortHandshake$1(websocket2, req2, `Unexpected server response: ${res.statusCode}`);
        }
      });
      req2.on("upgrade", (res, socket, head) => {
        websocket2.emit("upgrade", res);
        if (websocket2.readyState !== WebSocket$1.CONNECTING)
          return;
        req2 = websocket2._req = null;
        const digest = createHash$1("sha1").update(key2 + GUID$1).digest("base64");
        if (res.headers["sec-websocket-accept"] !== digest) {
          abortHandshake$1(websocket2, socket, "Invalid Sec-WebSocket-Accept header");
          return;
        }
        const serverProt = res.headers["sec-websocket-protocol"];
        let protError;
        if (serverProt !== void 0) {
          if (!protocolSet.size) {
            protError = "Server sent a subprotocol but none was requested";
          } else if (!protocolSet.has(serverProt)) {
            protError = "Server sent an invalid subprotocol";
          }
        } else if (protocolSet.size) {
          protError = "Server sent no subprotocol";
        }
        if (protError) {
          abortHandshake$1(websocket2, socket, protError);
          return;
        }
        if (serverProt)
          websocket2._protocol = serverProt;
        const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
        if (secWebSocketExtensions !== void 0) {
          if (!perMessageDeflate) {
            const message = "Server sent a Sec-WebSocket-Extensions header but no extension was requested";
            abortHandshake$1(websocket2, socket, message);
            return;
          }
          let extensions2;
          try {
            extensions2 = parse$6(secWebSocketExtensions);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake$1(websocket2, socket, message);
            return;
          }
          const extensionNames = Object.keys(extensions2);
          if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate$1.extensionName) {
            const message = "Server indicated an extension that was not requested";
            abortHandshake$1(websocket2, socket, message);
            return;
          }
          try {
            perMessageDeflate.accept(extensions2[PerMessageDeflate$1.extensionName]);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake$1(websocket2, socket, message);
            return;
          }
          websocket2._extensions[PerMessageDeflate$1.extensionName] = perMessageDeflate;
        }
        websocket2.setSocket(socket, head, {
          generateMask: opts.generateMask,
          maxPayload: opts.maxPayload,
          skipUTF8Validation: opts.skipUTF8Validation
        });
      });
    }
    function emitErrorAndClose(websocket2, err) {
      websocket2._readyState = WebSocket$1.CLOSING;
      websocket2.emit("error", err);
      websocket2.emitClose();
    }
    function netConnect(options2) {
      options2.path = options2.socketPath;
      return net.connect(options2);
    }
    function tlsConnect(options2) {
      options2.path = void 0;
      if (!options2.servername && options2.servername !== "") {
        options2.servername = net.isIP(options2.host) ? "" : options2.host;
      }
      return tls.connect(options2);
    }
    function abortHandshake$1(websocket2, stream2, message) {
      websocket2._readyState = WebSocket$1.CLOSING;
      const err = new Error(message);
      Error.captureStackTrace(err, abortHandshake$1);
      if (stream2.setHeader) {
        stream2.abort();
        if (stream2.socket && !stream2.socket.destroyed) {
          stream2.socket.destroy();
        }
        stream2.once("abort", websocket2.emitClose.bind(websocket2));
        websocket2.emit("error", err);
      } else {
        stream2.destroy(err);
        stream2.once("error", websocket2.emit.bind(websocket2, "error"));
        stream2.once("close", websocket2.emitClose.bind(websocket2));
      }
    }
    function sendAfterClose(websocket2, data2, cb) {
      if (data2) {
        const length = toBuffer(data2).length;
        if (websocket2._socket)
          websocket2._sender._bufferedBytes += length;
        else
          websocket2._bufferedAmount += length;
      }
      if (cb) {
        const err = new Error(`WebSocket is not open: readyState ${websocket2.readyState} (${readyStates[websocket2.readyState]})`);
        cb(err);
      }
    }
    function receiverOnConclude(code, reason) {
      const websocket2 = this[kWebSocket$1];
      websocket2._closeFrameReceived = true;
      websocket2._closeMessage = reason;
      websocket2._closeCode = code;
      if (websocket2._socket[kWebSocket$1] === void 0)
        return;
      websocket2._socket.removeListener("data", socketOnData);
      process.nextTick(resume, websocket2._socket);
      if (code === 1005)
        websocket2.close();
      else
        websocket2.close(code, reason);
    }
    function receiverOnDrain() {
      const websocket2 = this[kWebSocket$1];
      if (!websocket2.isPaused)
        websocket2._socket.resume();
    }
    function receiverOnError(err) {
      const websocket2 = this[kWebSocket$1];
      if (websocket2._socket[kWebSocket$1] !== void 0) {
        websocket2._socket.removeListener("data", socketOnData);
        process.nextTick(resume, websocket2._socket);
        websocket2.close(err[kStatusCode]);
      }
      websocket2.emit("error", err);
    }
    function receiverOnFinish() {
      this[kWebSocket$1].emitClose();
    }
    function receiverOnMessage(data2, isBinary) {
      this[kWebSocket$1].emit("message", data2, isBinary);
    }
    function receiverOnPing(data2) {
      const websocket2 = this[kWebSocket$1];
      websocket2.pong(data2, !websocket2._isServer, NOOP);
      websocket2.emit("ping", data2);
    }
    function receiverOnPong(data2) {
      this[kWebSocket$1].emit("pong", data2);
    }
    function resume(stream2) {
      stream2.resume();
    }
    function socketOnClose() {
      const websocket2 = this[kWebSocket$1];
      this.removeListener("close", socketOnClose);
      this.removeListener("data", socketOnData);
      this.removeListener("end", socketOnEnd);
      websocket2._readyState = WebSocket$1.CLOSING;
      let chunk;
      if (!this._readableState.endEmitted && !websocket2._closeFrameReceived && !websocket2._receiver._writableState.errorEmitted && (chunk = websocket2._socket.read()) !== null) {
        websocket2._receiver.write(chunk);
      }
      websocket2._receiver.end();
      this[kWebSocket$1] = void 0;
      clearTimeout(websocket2._closeTimer);
      if (websocket2._receiver._writableState.finished || websocket2._receiver._writableState.errorEmitted) {
        websocket2.emitClose();
      } else {
        websocket2._receiver.on("error", receiverOnFinish);
        websocket2._receiver.on("finish", receiverOnFinish);
      }
    }
    function socketOnData(chunk) {
      if (!this[kWebSocket$1]._receiver.write(chunk)) {
        this.pause();
      }
    }
    function socketOnEnd() {
      const websocket2 = this[kWebSocket$1];
      websocket2._readyState = WebSocket$1.CLOSING;
      websocket2._receiver.end();
      this.end();
    }
    function socketOnError$1() {
      const websocket2 = this[kWebSocket$1];
      this.removeListener("error", socketOnError$1);
      this.on("error", NOOP);
      if (websocket2) {
        websocket2._readyState = WebSocket$1.CLOSING;
        this.destroy();
      }
    }
    var { tokenChars } = validation.exports;
    function parse$5(header) {
      const protocols = /* @__PURE__ */ new Set();
      let start = -1;
      let end = -1;
      let i2 = 0;
      for (i2; i2 < header.length; i2++) {
        const code = header.charCodeAt(i2);
        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i2;
        } else if (i2 !== 0 && (code === 32 || code === 9)) {
          if (end === -1 && start !== -1)
            end = i2;
        } else if (code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i2}`);
          }
          if (end === -1)
            end = i2;
          const protocol2 = header.slice(start, end);
          if (protocols.has(protocol2)) {
            throw new SyntaxError(`The "${protocol2}" subprotocol is duplicated`);
          }
          protocols.add(protocol2);
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i2}`);
        }
      }
      if (start === -1 || end !== -1) {
        throw new SyntaxError("Unexpected end of input");
      }
      const protocol = header.slice(start, i2);
      if (protocols.has(protocol)) {
        throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
      }
      protocols.add(protocol);
      return protocols;
    }
    var subprotocol$1 = { parse: parse$5 };
    var EventEmitter = require$$0__default$2;
    var http$2 = require$$1__default$2;
    var { createHash } = require$$1__default$3;
    var extension = extension$1;
    var PerMessageDeflate = permessageDeflate;
    var subprotocol = subprotocol$1;
    var WebSocket = websocket;
    var { GUID, kWebSocket } = constants;
    var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
    var RUNNING = 0;
    var CLOSING = 1;
    var CLOSED = 2;
    var WebSocketServer = class extends EventEmitter {
      constructor(options2, callback) {
        super();
        options2 = __spreadValues2({
          maxPayload: 100 * 1024 * 1024,
          skipUTF8Validation: false,
          perMessageDeflate: false,
          handleProtocols: null,
          clientTracking: true,
          verifyClient: null,
          noServer: false,
          backlog: null,
          server: null,
          host: null,
          path: null,
          port: null,
          WebSocket
        }, options2);
        if (options2.port == null && !options2.server && !options2.noServer || options2.port != null && (options2.server || options2.noServer) || options2.server && options2.noServer) {
          throw new TypeError('One and only one of the "port", "server", or "noServer" options must be specified');
        }
        if (options2.port != null) {
          this._server = http$2.createServer((req2, res) => {
            const body = http$2.STATUS_CODES[426];
            res.writeHead(426, {
              "Content-Length": body.length,
              "Content-Type": "text/plain"
            });
            res.end(body);
          });
          this._server.listen(options2.port, options2.host, options2.backlog, callback);
        } else if (options2.server) {
          this._server = options2.server;
        }
        if (this._server) {
          const emitConnection = this.emit.bind(this, "connection");
          this._removeListeners = addListeners(this._server, {
            listening: this.emit.bind(this, "listening"),
            error: this.emit.bind(this, "error"),
            upgrade: (req2, socket, head) => {
              this.handleUpgrade(req2, socket, head, emitConnection);
            }
          });
        }
        if (options2.perMessageDeflate === true)
          options2.perMessageDeflate = {};
        if (options2.clientTracking) {
          this.clients = /* @__PURE__ */ new Set();
          this._shouldEmitClose = false;
        }
        this.options = options2;
        this._state = RUNNING;
      }
      address() {
        if (this.options.noServer) {
          throw new Error('The server is operating in "noServer" mode');
        }
        if (!this._server)
          return null;
        return this._server.address();
      }
      close(cb) {
        if (this._state === CLOSED) {
          if (cb) {
            this.once("close", () => {
              cb(new Error("The server is not running"));
            });
          }
          process.nextTick(emitClose, this);
          return;
        }
        if (cb)
          this.once("close", cb);
        if (this._state === CLOSING)
          return;
        this._state = CLOSING;
        if (this.options.noServer || this.options.server) {
          if (this._server) {
            this._removeListeners();
            this._removeListeners = this._server = null;
          }
          if (this.clients) {
            if (!this.clients.size) {
              process.nextTick(emitClose, this);
            } else {
              this._shouldEmitClose = true;
            }
          } else {
            process.nextTick(emitClose, this);
          }
        } else {
          const server2 = this._server;
          this._removeListeners();
          this._removeListeners = this._server = null;
          server2.close(() => {
            emitClose(this);
          });
        }
      }
      shouldHandle(req2) {
        if (this.options.path) {
          const index2 = req2.url.indexOf("?");
          const pathname = index2 !== -1 ? req2.url.slice(0, index2) : req2.url;
          if (pathname !== this.options.path)
            return false;
        }
        return true;
      }
      handleUpgrade(req2, socket, head, cb) {
        socket.on("error", socketOnError);
        const key2 = req2.headers["sec-websocket-key"] !== void 0 ? req2.headers["sec-websocket-key"] : false;
        const version2 = +req2.headers["sec-websocket-version"];
        if (req2.method !== "GET" || req2.headers.upgrade.toLowerCase() !== "websocket" || !key2 || !keyRegex.test(key2) || version2 !== 8 && version2 !== 13 || !this.shouldHandle(req2)) {
          return abortHandshake(socket, 400);
        }
        const secWebSocketProtocol = req2.headers["sec-websocket-protocol"];
        let protocols = /* @__PURE__ */ new Set();
        if (secWebSocketProtocol !== void 0) {
          try {
            protocols = subprotocol.parse(secWebSocketProtocol);
          } catch (err) {
            return abortHandshake(socket, 400);
          }
        }
        const secWebSocketExtensions = req2.headers["sec-websocket-extensions"];
        const extensions2 = {};
        if (this.options.perMessageDeflate && secWebSocketExtensions !== void 0) {
          const perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);
          try {
            const offers = extension.parse(secWebSocketExtensions);
            if (offers[PerMessageDeflate.extensionName]) {
              perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
              extensions2[PerMessageDeflate.extensionName] = perMessageDeflate;
            }
          } catch (err) {
            return abortHandshake(socket, 400);
          }
        }
        if (this.options.verifyClient) {
          const info = {
            origin: req2.headers[`${version2 === 8 ? "sec-websocket-origin" : "origin"}`],
            secure: !!(req2.socket.authorized || req2.socket.encrypted),
            req: req2
          };
          if (this.options.verifyClient.length === 2) {
            this.options.verifyClient(info, (verified, code, message, headers) => {
              if (!verified) {
                return abortHandshake(socket, code || 401, message, headers);
              }
              this.completeUpgrade(extensions2, key2, protocols, req2, socket, head, cb);
            });
            return;
          }
          if (!this.options.verifyClient(info))
            return abortHandshake(socket, 401);
        }
        this.completeUpgrade(extensions2, key2, protocols, req2, socket, head, cb);
      }
      completeUpgrade(extensions2, key2, protocols, req2, socket, head, cb) {
        if (!socket.readable || !socket.writable)
          return socket.destroy();
        if (socket[kWebSocket]) {
          throw new Error("server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration");
        }
        if (this._state > RUNNING)
          return abortHandshake(socket, 503);
        const digest = createHash("sha1").update(key2 + GUID).digest("base64");
        const headers = [
          "HTTP/1.1 101 Switching Protocols",
          "Upgrade: websocket",
          "Connection: Upgrade",
          `Sec-WebSocket-Accept: ${digest}`
        ];
        const ws2 = new this.options.WebSocket(null);
        if (protocols.size) {
          const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req2) : protocols.values().next().value;
          if (protocol) {
            headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
            ws2._protocol = protocol;
          }
        }
        if (extensions2[PerMessageDeflate.extensionName]) {
          const params = extensions2[PerMessageDeflate.extensionName].params;
          const value = extension.format({
            [PerMessageDeflate.extensionName]: [params]
          });
          headers.push(`Sec-WebSocket-Extensions: ${value}`);
          ws2._extensions = extensions2;
        }
        this.emit("headers", headers, req2);
        socket.write(headers.concat("\r\n").join("\r\n"));
        socket.removeListener("error", socketOnError);
        ws2.setSocket(socket, head, {
          maxPayload: this.options.maxPayload,
          skipUTF8Validation: this.options.skipUTF8Validation
        });
        if (this.clients) {
          this.clients.add(ws2);
          ws2.on("close", () => {
            this.clients.delete(ws2);
            if (this._shouldEmitClose && !this.clients.size) {
              process.nextTick(emitClose, this);
            }
          });
        }
        cb(ws2, req2);
      }
    };
    var websocketServer = WebSocketServer;
    function addListeners(server2, map2) {
      for (const event of Object.keys(map2))
        server2.on(event, map2[event]);
      return function removeListeners() {
        for (const event of Object.keys(map2)) {
          server2.removeListener(event, map2[event]);
        }
      };
    }
    function emitClose(server2) {
      server2._state = CLOSED;
      server2.emit("close");
    }
    function socketOnError() {
      this.destroy();
    }
    function abortHandshake(socket, code, message, headers) {
      if (socket.writable) {
        message = message || http$2.STATUS_CODES[code];
        headers = __spreadValues2({
          Connection: "close",
          "Content-Type": "text/html",
          "Content-Length": Buffer.byteLength(message)
        }, headers);
        socket.write(`HTTP/1.1 ${code} ${http$2.STATUS_CODES[code]}\r
` + Object.keys(headers).map((h3) => `${h3}: ${headers[h3]}`).join("\r\n") + "\r\n\r\n" + message);
      }
      socket.removeListener("error", socketOnError);
      socket.destroy();
    }
    var HMR_HEADER = "vite-hmr";
    var wsServerEvents = [
      "connection",
      "error",
      "headers",
      "listening",
      "message"
    ];
    function createWebSocketServer(server2, config2, httpsOptions) {
      let wss;
      let httpsServer = void 0;
      const hmr = isObject$5(config2.server.hmr) && config2.server.hmr;
      const hmrServer = hmr && hmr.server;
      const hmrPort = hmr && hmr.port;
      const portsAreCompatible = !hmrPort || hmrPort === config2.server.port;
      const wsServer = hmrServer || portsAreCompatible && server2;
      const customListeners = /* @__PURE__ */ new Map();
      const clientsMap = /* @__PURE__ */ new WeakMap();
      if (wsServer) {
        wss = new websocketServer({ noServer: true });
        wsServer.on("upgrade", (req2, socket, head) => {
          if (req2.headers["sec-websocket-protocol"] === HMR_HEADER) {
            wss.handleUpgrade(req2, socket, head, (ws2) => {
              wss.emit("connection", ws2, req2);
            });
          }
        });
      } else {
        const websocketServerOptions = {};
        const port = hmrPort || 24678;
        const host = hmr && hmr.host || void 0;
        if (httpsOptions) {
          httpsServer = require$$1$4.createServer(httpsOptions, (req2, res) => {
            const statusCode = 426;
            const body = require$$1$3.STATUS_CODES[statusCode];
            if (!body)
              throw new Error(`No body text found for the ${statusCode} status code`);
            res.writeHead(statusCode, {
              "Content-Length": body.length,
              "Content-Type": "text/plain"
            });
            res.end(body);
          });
          httpsServer.listen(port, host);
          websocketServerOptions.server = httpsServer;
        } else {
          websocketServerOptions.port = port;
          if (host) {
            websocketServerOptions.host = host;
          }
        }
        wss = new websocketServer(websocketServerOptions);
      }
      wss.on("connection", (socket) => {
        socket.on("message", (raw) => {
          if (!customListeners.size)
            return;
          let parsed;
          try {
            parsed = JSON.parse(String(raw));
          } catch {
          }
          if (!parsed || parsed.type !== "custom" || !parsed.event)
            return;
          const listeners = customListeners.get(parsed.event);
          if (!(listeners === null || listeners === void 0 ? void 0 : listeners.size))
            return;
          const client = getSocketClent(socket);
          listeners.forEach((listener2) => listener2(parsed.data, client));
        });
        socket.send(JSON.stringify({ type: "connected" }));
        if (bufferedError) {
          socket.send(JSON.stringify(bufferedError));
          bufferedError = null;
        }
      });
      wss.on("error", (e2) => {
        if (e2.code !== "EADDRINUSE") {
          config2.logger.error(colors$1.red(`WebSocket server error:
${e2.stack || e2.message}`), { error: e2 });
        }
      });
      function getSocketClent(socket) {
        if (!clientsMap.has(socket)) {
          clientsMap.set(socket, {
            send: (...args) => {
              let payload;
              if (typeof args[0] === "string") {
                payload = {
                  type: "custom",
                  event: args[0],
                  data: args[1]
                };
              } else {
                payload = args[0];
              }
              socket.send(JSON.stringify(payload));
            },
            socket
          });
        }
        return clientsMap.get(socket);
      }
      let bufferedError = null;
      return {
        on: (event, fn2) => {
          if (wsServerEvents.includes(event))
            wss.on(event, fn2);
          else {
            if (!customListeners.has(event)) {
              customListeners.set(event, /* @__PURE__ */ new Set());
            }
            customListeners.get(event).add(fn2);
          }
        },
        off: (event, fn2) => {
          var _a2;
          if (wsServerEvents.includes(event)) {
            wss.off(event, fn2);
          } else {
            (_a2 = customListeners.get(event)) === null || _a2 === void 0 ? void 0 : _a2.delete(fn2);
          }
        },
        get clients() {
          return new Set(Array.from(wss.clients).map(getSocketClent));
        },
        send(...args) {
          let payload;
          if (typeof args[0] === "string") {
            payload = {
              type: "custom",
              event: args[0],
              data: args[1]
            };
          } else {
            payload = args[0];
          }
          if (payload.type === "error" && !wss.clients.size) {
            bufferedError = payload;
            return;
          }
          const stringified = JSON.stringify(payload);
          wss.clients.forEach((client) => {
            if (client.readyState === 1) {
              client.send(stringified);
            }
          });
        },
        close() {
          return new Promise((resolve2, reject) => {
            wss.clients.forEach((client) => {
              client.terminate();
            });
            wss.close((err) => {
              if (err) {
                reject(err);
              } else {
                if (httpsServer) {
                  httpsServer.close((err2) => {
                    if (err2) {
                      reject(err2);
                    } else {
                      resolve2();
                    }
                  });
                } else {
                  resolve2();
                }
              }
            });
          });
        }
      };
    }
    function baseMiddleware({ config: config2 }) {
      const base2 = config2.base;
      return function viteBaseMiddleware(req2, res, next) {
        var _a2;
        const url2 = req2.url;
        const parsed = require$$0$4.parse(url2);
        const path2 = parsed.pathname || "/";
        if (path2.startsWith(base2)) {
          req2.url = url2.replace(base2, "/");
          return next();
        }
        if (config2.server.middlewareMode) {
          return next();
        }
        if (path2 === "/" || path2 === "/index.html") {
          res.writeHead(302, {
            Location: base2 + (parsed.search || "") + (parsed.hash || "")
          });
          res.end();
          return;
        } else if ((_a2 = req2.headers.accept) === null || _a2 === void 0 ? void 0 : _a2.includes("text/html")) {
          const redirectPath = base2 + url2.slice(1);
          res.writeHead(404, {
            "Content-Type": "text/html"
          });
          res.end(`The server is configured with a public base URL of ${base2} - did you mean to visit <a href="${redirectPath}">${redirectPath}</a> instead?`);
          return;
        }
        next();
      };
    }
    var httpProxy$2 = { exports: {} };
    var eventemitter3 = { exports: {} };
    (function(module2) {
      var has = Object.prototype.hasOwnProperty, prefix = "~";
      function Events() {
      }
      if (Object.create) {
        Events.prototype = /* @__PURE__ */ Object.create(null);
        if (!new Events().__proto__)
          prefix = false;
      }
      function EE2(fn2, context2, once2) {
        this.fn = fn2;
        this.context = context2;
        this.once = once2 || false;
      }
      function addListener(emitter, event, fn2, context2, once2) {
        if (typeof fn2 !== "function") {
          throw new TypeError("The listener must be a function");
        }
        var listener2 = new EE2(fn2, context2 || emitter, once2), evt = prefix ? prefix + event : event;
        if (!emitter._events[evt])
          emitter._events[evt] = listener2, emitter._eventsCount++;
        else if (!emitter._events[evt].fn)
          emitter._events[evt].push(listener2);
        else
          emitter._events[evt] = [emitter._events[evt], listener2];
        return emitter;
      }
      function clearEvent(emitter, evt) {
        if (--emitter._eventsCount === 0)
          emitter._events = new Events();
        else
          delete emitter._events[evt];
      }
      function EventEmitter2() {
        this._events = new Events();
        this._eventsCount = 0;
      }
      EventEmitter2.prototype.eventNames = function eventNames() {
        var names = [], events2, name;
        if (this._eventsCount === 0)
          return names;
        for (name in events2 = this._events) {
          if (has.call(events2, name))
            names.push(prefix ? name.slice(1) : name);
        }
        if (Object.getOwnPropertySymbols) {
          return names.concat(Object.getOwnPropertySymbols(events2));
        }
        return names;
      };
      EventEmitter2.prototype.listeners = function listeners(event) {
        var evt = prefix ? prefix + event : event, handlers = this._events[evt];
        if (!handlers)
          return [];
        if (handlers.fn)
          return [handlers.fn];
        for (var i2 = 0, l2 = handlers.length, ee2 = new Array(l2); i2 < l2; i2++) {
          ee2[i2] = handlers[i2].fn;
        }
        return ee2;
      };
      EventEmitter2.prototype.listenerCount = function listenerCount(event) {
        var evt = prefix ? prefix + event : event, listeners = this._events[evt];
        if (!listeners)
          return 0;
        if (listeners.fn)
          return 1;
        return listeners.length;
      };
      EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt])
          return false;
        var listeners = this._events[evt], len = arguments.length, args, i2;
        if (listeners.fn) {
          if (listeners.once)
            this.removeListener(event, listeners.fn, void 0, true);
          switch (len) {
            case 1:
              return listeners.fn.call(listeners.context), true;
            case 2:
              return listeners.fn.call(listeners.context, a1), true;
            case 3:
              return listeners.fn.call(listeners.context, a1, a2), true;
            case 4:
              return listeners.fn.call(listeners.context, a1, a2, a3), true;
            case 5:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
            case 6:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
          }
          for (i2 = 1, args = new Array(len - 1); i2 < len; i2++) {
            args[i2 - 1] = arguments[i2];
          }
          listeners.fn.apply(listeners.context, args);
        } else {
          var length = listeners.length, j2;
          for (i2 = 0; i2 < length; i2++) {
            if (listeners[i2].once)
              this.removeListener(event, listeners[i2].fn, void 0, true);
            switch (len) {
              case 1:
                listeners[i2].fn.call(listeners[i2].context);
                break;
              case 2:
                listeners[i2].fn.call(listeners[i2].context, a1);
                break;
              case 3:
                listeners[i2].fn.call(listeners[i2].context, a1, a2);
                break;
              case 4:
                listeners[i2].fn.call(listeners[i2].context, a1, a2, a3);
                break;
              default:
                if (!args)
                  for (j2 = 1, args = new Array(len - 1); j2 < len; j2++) {
                    args[j2 - 1] = arguments[j2];
                  }
                listeners[i2].fn.apply(listeners[i2].context, args);
            }
          }
        }
        return true;
      };
      EventEmitter2.prototype.on = function on2(event, fn2, context2) {
        return addListener(this, event, fn2, context2, false);
      };
      EventEmitter2.prototype.once = function once2(event, fn2, context2) {
        return addListener(this, event, fn2, context2, true);
      };
      EventEmitter2.prototype.removeListener = function removeListener(event, fn2, context2, once2) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt])
          return this;
        if (!fn2) {
          clearEvent(this, evt);
          return this;
        }
        var listeners = this._events[evt];
        if (listeners.fn) {
          if (listeners.fn === fn2 && (!once2 || listeners.once) && (!context2 || listeners.context === context2)) {
            clearEvent(this, evt);
          }
        } else {
          for (var i2 = 0, events2 = [], length = listeners.length; i2 < length; i2++) {
            if (listeners[i2].fn !== fn2 || once2 && !listeners[i2].once || context2 && listeners[i2].context !== context2) {
              events2.push(listeners[i2]);
            }
          }
          if (events2.length)
            this._events[evt] = events2.length === 1 ? events2[0] : events2;
          else
            clearEvent(this, evt);
        }
        return this;
      };
      EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
        var evt;
        if (event) {
          evt = prefix ? prefix + event : event;
          if (this._events[evt])
            clearEvent(this, evt);
        } else {
          this._events = new Events();
          this._eventsCount = 0;
        }
        return this;
      };
      EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
      EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
      EventEmitter2.prefixed = prefix;
      EventEmitter2.EventEmitter = EventEmitter2;
      {
        module2.exports = EventEmitter2;
      }
    })(eventemitter3);
    var common$3 = {};
    var requiresPort = function required(port, protocol) {
      protocol = protocol.split(":")[0];
      port = +port;
      if (!port)
        return false;
      switch (protocol) {
        case "http":
        case "ws":
          return port !== 80;
        case "https":
        case "wss":
          return port !== 443;
        case "ftp":
          return port !== 21;
        case "gopher":
          return port !== 70;
        case "file":
          return false;
      }
      return port !== 0;
    };
    (function(exports2) {
      var common2 = exports2, url2 = require$$0__default$5, extend2 = require$$0__default$1._extend, required = requiresPort;
      var upgradeHeader = /(^|,)\s*upgrade\s*($|,)/i, isSSL = /^https|wss/;
      common2.isSSL = isSSL;
      common2.setupOutgoing = function(outgoing, options2, req2, forward) {
        outgoing.port = options2[forward || "target"].port || (isSSL.test(options2[forward || "target"].protocol) ? 443 : 80);
        [
          "host",
          "hostname",
          "socketPath",
          "pfx",
          "key",
          "passphrase",
          "cert",
          "ca",
          "ciphers",
          "secureProtocol"
        ].forEach(function(e2) {
          outgoing[e2] = options2[forward || "target"][e2];
        });
        outgoing.method = options2.method || req2.method;
        outgoing.headers = extend2({}, req2.headers);
        if (options2.headers) {
          extend2(outgoing.headers, options2.headers);
        }
        if (options2.auth) {
          outgoing.auth = options2.auth;
        }
        if (options2.ca) {
          outgoing.ca = options2.ca;
        }
        if (isSSL.test(options2[forward || "target"].protocol)) {
          outgoing.rejectUnauthorized = typeof options2.secure === "undefined" ? true : options2.secure;
        }
        outgoing.agent = options2.agent || false;
        outgoing.localAddress = options2.localAddress;
        if (!outgoing.agent) {
          outgoing.headers = outgoing.headers || {};
          if (typeof outgoing.headers.connection !== "string" || !upgradeHeader.test(outgoing.headers.connection)) {
            outgoing.headers.connection = "close";
          }
        }
        var target = options2[forward || "target"];
        var targetPath = target && options2.prependPath !== false ? target.path || "" : "";
        var outgoingPath = !options2.toProxy ? url2.parse(req2.url).path || "" : req2.url;
        outgoingPath = !options2.ignorePath ? outgoingPath : "";
        outgoing.path = common2.urlJoin(targetPath, outgoingPath);
        if (options2.changeOrigin) {
          outgoing.headers.host = required(outgoing.port, options2[forward || "target"].protocol) && !hasPort(outgoing.host) ? outgoing.host + ":" + outgoing.port : outgoing.host;
        }
        return outgoing;
      };
      common2.setupSocket = function(socket) {
        socket.setTimeout(0);
        socket.setNoDelay(true);
        socket.setKeepAlive(true, 0);
        return socket;
      };
      common2.getPort = function(req2) {
        var res = req2.headers.host ? req2.headers.host.match(/:(\d+)/) : "";
        return res ? res[1] : common2.hasEncryptedConnection(req2) ? "443" : "80";
      };
      common2.hasEncryptedConnection = function(req2) {
        return Boolean(req2.connection.encrypted || req2.connection.pair);
      };
      common2.urlJoin = function() {
        var args = Array.prototype.slice.call(arguments), lastIndex = args.length - 1, last = args[lastIndex], lastSegs = last.split("?"), retSegs;
        args[lastIndex] = lastSegs.shift();
        retSegs = [
          args.filter(Boolean).join("/").replace(/\/+/g, "/").replace("http:/", "http://").replace("https:/", "https://")
        ];
        retSegs.push.apply(retSegs, lastSegs);
        return retSegs.join("?");
      };
      common2.rewriteCookieProperty = function rewriteCookieProperty(header, config2, property) {
        if (Array.isArray(header)) {
          return header.map(function(headerElement) {
            return rewriteCookieProperty(headerElement, config2, property);
          });
        }
        return header.replace(new RegExp("(;\\s*" + property + "=)([^;]+)", "i"), function(match2, prefix, previousValue) {
          var newValue;
          if (previousValue in config2) {
            newValue = config2[previousValue];
          } else if ("*" in config2) {
            newValue = config2["*"];
          } else {
            return match2;
          }
          if (newValue) {
            return prefix + newValue;
          } else {
            return "";
          }
        });
      };
      function hasPort(host) {
        return !!~host.indexOf(":");
      }
    })(common$3);
    var url$2 = require$$0__default$5;
    var common$2 = common$3;
    var redirectRegex = /^201|30(1|2|7|8)$/;
    var webOutgoing = {
      removeChunked: function removeChunked(req2, res, proxyRes) {
        if (req2.httpVersion === "1.0") {
          delete proxyRes.headers["transfer-encoding"];
        }
      },
      setConnection: function setConnection(req2, res, proxyRes) {
        if (req2.httpVersion === "1.0") {
          proxyRes.headers.connection = req2.headers.connection || "close";
        } else if (req2.httpVersion !== "2.0" && !proxyRes.headers.connection) {
          proxyRes.headers.connection = req2.headers.connection || "keep-alive";
        }
      },
      setRedirectHostRewrite: function setRedirectHostRewrite(req2, res, proxyRes, options2) {
        if ((options2.hostRewrite || options2.autoRewrite || options2.protocolRewrite) && proxyRes.headers["location"] && redirectRegex.test(proxyRes.statusCode)) {
          var target = url$2.parse(options2.target);
          var u2 = url$2.parse(proxyRes.headers["location"]);
          if (target.host != u2.host) {
            return;
          }
          if (options2.hostRewrite) {
            u2.host = options2.hostRewrite;
          } else if (options2.autoRewrite) {
            u2.host = req2.headers["host"];
          }
          if (options2.protocolRewrite) {
            u2.protocol = options2.protocolRewrite;
          }
          proxyRes.headers["location"] = u2.format();
        }
      },
      writeHeaders: function writeHeaders(req2, res, proxyRes, options2) {
        var rewriteCookieDomainConfig = options2.cookieDomainRewrite, rewriteCookiePathConfig = options2.cookiePathRewrite, preserveHeaderKeyCase = options2.preserveHeaderKeyCase, rawHeaderKeyMap, setHeader = function(key3, header) {
          if (header == void 0)
            return;
          if (rewriteCookieDomainConfig && key3.toLowerCase() === "set-cookie") {
            header = common$2.rewriteCookieProperty(header, rewriteCookieDomainConfig, "domain");
          }
          if (rewriteCookiePathConfig && key3.toLowerCase() === "set-cookie") {
            header = common$2.rewriteCookieProperty(header, rewriteCookiePathConfig, "path");
          }
          res.setHeader(String(key3).trim(), header);
        };
        if (typeof rewriteCookieDomainConfig === "string") {
          rewriteCookieDomainConfig = { "*": rewriteCookieDomainConfig };
        }
        if (typeof rewriteCookiePathConfig === "string") {
          rewriteCookiePathConfig = { "*": rewriteCookiePathConfig };
        }
        if (preserveHeaderKeyCase && proxyRes.rawHeaders != void 0) {
          rawHeaderKeyMap = {};
          for (var i2 = 0; i2 < proxyRes.rawHeaders.length; i2 += 2) {
            var key2 = proxyRes.rawHeaders[i2];
            rawHeaderKeyMap[key2.toLowerCase()] = key2;
          }
        }
        Object.keys(proxyRes.headers).forEach(function(key3) {
          var header = proxyRes.headers[key3];
          if (preserveHeaderKeyCase && rawHeaderKeyMap) {
            key3 = rawHeaderKeyMap[key3] || key3;
          }
          setHeader(key3, header);
        });
      },
      writeStatusCode: function writeStatusCode(req2, res, proxyRes) {
        if (proxyRes.statusMessage) {
          res.statusCode = proxyRes.statusCode;
          res.statusMessage = proxyRes.statusMessage;
        } else {
          res.statusCode = proxyRes.statusCode;
        }
      }
    };
    var followRedirects$1 = { exports: {} };
    var debug$5;
    var debug_1 = function() {
      if (!debug$5) {
        try {
          debug$5 = require_browser2()("follow-redirects");
        } catch (error2) {
        }
        if (typeof debug$5 !== "function") {
          debug$5 = function() {
          };
        }
      }
      debug$5.apply(null, arguments);
    };
    var url$1 = require$$0__default$5;
    var URL = url$1.URL;
    var http$1 = require$$1__default$2;
    var https$1 = require$$1__default$4;
    var Writable = require$$0__default$3.Writable;
    var assert = require$$5__default;
    var debug$4 = debug_1;
    var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
    var eventHandlers = /* @__PURE__ */ Object.create(null);
    events.forEach(function(event) {
      eventHandlers[event] = function(arg1, arg2, arg3) {
        this._redirectable.emit(event, arg1, arg2, arg3);
      };
    });
    var RedirectionError = createErrorType("ERR_FR_REDIRECTION_FAILURE", "Redirected request failed");
    var TooManyRedirectsError = createErrorType("ERR_FR_TOO_MANY_REDIRECTS", "Maximum number of redirects exceeded");
    var MaxBodyLengthExceededError = createErrorType("ERR_FR_MAX_BODY_LENGTH_EXCEEDED", "Request body larger than maxBodyLength limit");
    var WriteAfterEndError = createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    function RedirectableRequest(options2, responseCallback) {
      Writable.call(this);
      this._sanitizeOptions(options2);
      this._options = options2;
      this._ended = false;
      this._ending = false;
      this._redirectCount = 0;
      this._redirects = [];
      this._requestBodyLength = 0;
      this._requestBodyBuffers = [];
      if (responseCallback) {
        this.on("response", responseCallback);
      }
      var self2 = this;
      this._onNativeResponse = function(response) {
        self2._processResponse(response);
      };
      this._performRequest();
    }
    RedirectableRequest.prototype = Object.create(Writable.prototype);
    RedirectableRequest.prototype.abort = function() {
      abortRequest(this._currentRequest);
      this.emit("abort");
    };
    RedirectableRequest.prototype.write = function(data2, encoding, callback) {
      if (this._ending) {
        throw new WriteAfterEndError();
      }
      if (!(typeof data2 === "string" || typeof data2 === "object" && "length" in data2)) {
        throw new TypeError("data should be a string, Buffer or Uint8Array");
      }
      if (typeof encoding === "function") {
        callback = encoding;
        encoding = null;
      }
      if (data2.length === 0) {
        if (callback) {
          callback();
        }
        return;
      }
      if (this._requestBodyLength + data2.length <= this._options.maxBodyLength) {
        this._requestBodyLength += data2.length;
        this._requestBodyBuffers.push({ data: data2, encoding });
        this._currentRequest.write(data2, encoding, callback);
      } else {
        this.emit("error", new MaxBodyLengthExceededError());
        this.abort();
      }
    };
    RedirectableRequest.prototype.end = function(data2, encoding, callback) {
      if (typeof data2 === "function") {
        callback = data2;
        data2 = encoding = null;
      } else if (typeof encoding === "function") {
        callback = encoding;
        encoding = null;
      }
      if (!data2) {
        this._ended = this._ending = true;
        this._currentRequest.end(null, null, callback);
      } else {
        var self2 = this;
        var currentRequest = this._currentRequest;
        this.write(data2, encoding, function() {
          self2._ended = true;
          currentRequest.end(null, null, callback);
        });
        this._ending = true;
      }
    };
    RedirectableRequest.prototype.setHeader = function(name, value) {
      this._options.headers[name] = value;
      this._currentRequest.setHeader(name, value);
    };
    RedirectableRequest.prototype.removeHeader = function(name) {
      delete this._options.headers[name];
      this._currentRequest.removeHeader(name);
    };
    RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
      var self2 = this;
      function destroyOnTimeout(socket) {
        socket.setTimeout(msecs);
        socket.removeListener("timeout", socket.destroy);
        socket.addListener("timeout", socket.destroy);
      }
      function startTimer(socket) {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
        }
        self2._timeout = setTimeout(function() {
          self2.emit("timeout");
          clearTimer();
        }, msecs);
        destroyOnTimeout(socket);
      }
      function clearTimer() {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
          self2._timeout = null;
        }
        self2.removeListener("abort", clearTimer);
        self2.removeListener("error", clearTimer);
        self2.removeListener("response", clearTimer);
        if (callback) {
          self2.removeListener("timeout", callback);
        }
        if (!self2.socket) {
          self2._currentRequest.removeListener("socket", startTimer);
        }
      }
      if (callback) {
        this.on("timeout", callback);
      }
      if (this.socket) {
        startTimer(this.socket);
      } else {
        this._currentRequest.once("socket", startTimer);
      }
      this.on("socket", destroyOnTimeout);
      this.on("abort", clearTimer);
      this.on("error", clearTimer);
      this.on("response", clearTimer);
      return this;
    };
    [
      "flushHeaders",
      "getHeader",
      "setNoDelay",
      "setSocketKeepAlive"
    ].forEach(function(method) {
      RedirectableRequest.prototype[method] = function(a2, b2) {
        return this._currentRequest[method](a2, b2);
      };
    });
    ["aborted", "connection", "socket"].forEach(function(property) {
      Object.defineProperty(RedirectableRequest.prototype, property, {
        get: function() {
          return this._currentRequest[property];
        }
      });
    });
    RedirectableRequest.prototype._sanitizeOptions = function(options2) {
      if (!options2.headers) {
        options2.headers = {};
      }
      if (options2.host) {
        if (!options2.hostname) {
          options2.hostname = options2.host;
        }
        delete options2.host;
      }
      if (!options2.pathname && options2.path) {
        var searchPos = options2.path.indexOf("?");
        if (searchPos < 0) {
          options2.pathname = options2.path;
        } else {
          options2.pathname = options2.path.substring(0, searchPos);
          options2.search = options2.path.substring(searchPos);
        }
      }
    };
    RedirectableRequest.prototype._performRequest = function() {
      var protocol = this._options.protocol;
      var nativeProtocol = this._options.nativeProtocols[protocol];
      if (!nativeProtocol) {
        this.emit("error", new TypeError("Unsupported protocol " + protocol));
        return;
      }
      if (this._options.agents) {
        var scheme = protocol.substr(0, protocol.length - 1);
        this._options.agent = this._options.agents[scheme];
      }
      var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
      this._currentUrl = url$1.format(this._options);
      request._redirectable = this;
      for (var e2 = 0; e2 < events.length; e2++) {
        request.on(events[e2], eventHandlers[events[e2]]);
      }
      if (this._isRedirect) {
        var i2 = 0;
        var self2 = this;
        var buffers = this._requestBodyBuffers;
        (function writeNext(error2) {
          if (request === self2._currentRequest) {
            if (error2) {
              self2.emit("error", error2);
            } else if (i2 < buffers.length) {
              var buffer2 = buffers[i2++];
              if (!request.finished) {
                request.write(buffer2.data, buffer2.encoding, writeNext);
              }
            } else if (self2._ended) {
              request.end();
            }
          }
        })();
      }
    };
    RedirectableRequest.prototype._processResponse = function(response) {
      var statusCode = response.statusCode;
      if (this._options.trackRedirects) {
        this._redirects.push({
          url: this._currentUrl,
          headers: response.headers,
          statusCode
        });
      }
      var location = response.headers.location;
      if (location && this._options.followRedirects !== false && statusCode >= 300 && statusCode < 400) {
        abortRequest(this._currentRequest);
        response.destroy();
        if (++this._redirectCount > this._options.maxRedirects) {
          this.emit("error", new TooManyRedirectsError());
          return;
        }
        if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
          this._options.method = "GET";
          this._requestBodyBuffers = [];
          removeMatchingHeaders(/^content-/i, this._options.headers);
        }
        var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
        var currentUrlParts = url$1.parse(this._currentUrl);
        var currentHost = currentHostHeader || currentUrlParts.host;
        var currentUrl = /^\w+:/.test(location) ? this._currentUrl : url$1.format(Object.assign(currentUrlParts, { host: currentHost }));
        var redirectUrl;
        try {
          redirectUrl = url$1.resolve(currentUrl, location);
        } catch (cause) {
          this.emit("error", new RedirectionError(cause));
          return;
        }
        debug$4("redirecting to", redirectUrl);
        this._isRedirect = true;
        var redirectUrlParts = url$1.parse(redirectUrl);
        Object.assign(this._options, redirectUrlParts);
        if (!(redirectUrlParts.host === currentHost || isSubdomainOf(redirectUrlParts.host, currentHost))) {
          removeMatchingHeaders(/^authorization$/i, this._options.headers);
        }
        if (typeof this._options.beforeRedirect === "function") {
          var responseDetails = { headers: response.headers };
          try {
            this._options.beforeRedirect.call(null, this._options, responseDetails);
          } catch (err) {
            this.emit("error", err);
            return;
          }
          this._sanitizeOptions(this._options);
        }
        try {
          this._performRequest();
        } catch (cause) {
          this.emit("error", new RedirectionError(cause));
        }
      } else {
        response.responseUrl = this._currentUrl;
        response.redirects = this._redirects;
        this.emit("response", response);
        this._requestBodyBuffers = [];
      }
    };
    function wrap(protocols) {
      var exports2 = {
        maxRedirects: 21,
        maxBodyLength: 10 * 1024 * 1024
      };
      var nativeProtocols = {};
      Object.keys(protocols).forEach(function(scheme) {
        var protocol = scheme + ":";
        var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
        var wrappedProtocol = exports2[scheme] = Object.create(nativeProtocol);
        function request(input, options2, callback) {
          if (typeof input === "string") {
            var urlStr = input;
            try {
              input = urlToOptions(new URL(urlStr));
            } catch (err) {
              input = url$1.parse(urlStr);
            }
          } else if (URL && input instanceof URL) {
            input = urlToOptions(input);
          } else {
            callback = options2;
            options2 = input;
            input = { protocol };
          }
          if (typeof options2 === "function") {
            callback = options2;
            options2 = null;
          }
          options2 = Object.assign({
            maxRedirects: exports2.maxRedirects,
            maxBodyLength: exports2.maxBodyLength
          }, input, options2);
          options2.nativeProtocols = nativeProtocols;
          assert.equal(options2.protocol, protocol, "protocol mismatch");
          debug$4("options", options2);
          return new RedirectableRequest(options2, callback);
        }
        function get(input, options2, callback) {
          var wrappedRequest = wrappedProtocol.request(input, options2, callback);
          wrappedRequest.end();
          return wrappedRequest;
        }
        Object.defineProperties(wrappedProtocol, {
          request: { value: request, configurable: true, enumerable: true, writable: true },
          get: { value: get, configurable: true, enumerable: true, writable: true }
        });
      });
      return exports2;
    }
    function noop$2() {
    }
    function urlToOptions(urlObject) {
      var options2 = {
        protocol: urlObject.protocol,
        hostname: urlObject.hostname.startsWith("[") ? urlObject.hostname.slice(1, -1) : urlObject.hostname,
        hash: urlObject.hash,
        search: urlObject.search,
        pathname: urlObject.pathname,
        path: urlObject.pathname + urlObject.search,
        href: urlObject.href
      };
      if (urlObject.port !== "") {
        options2.port = Number(urlObject.port);
      }
      return options2;
    }
    function removeMatchingHeaders(regex, headers) {
      var lastValue;
      for (var header in headers) {
        if (regex.test(header)) {
          lastValue = headers[header];
          delete headers[header];
        }
      }
      return lastValue === null || typeof lastValue === "undefined" ? void 0 : String(lastValue).trim();
    }
    function createErrorType(code, defaultMessage) {
      function CustomError(cause) {
        Error.captureStackTrace(this, this.constructor);
        if (!cause) {
          this.message = defaultMessage;
        } else {
          this.message = defaultMessage + ": " + cause.message;
          this.cause = cause;
        }
      }
      CustomError.prototype = new Error();
      CustomError.prototype.constructor = CustomError;
      CustomError.prototype.name = "Error [" + code + "]";
      CustomError.prototype.code = code;
      return CustomError;
    }
    function abortRequest(request) {
      for (var e2 = 0; e2 < events.length; e2++) {
        request.removeListener(events[e2], eventHandlers[events[e2]]);
      }
      request.on("error", noop$2);
      request.abort();
    }
    function isSubdomainOf(subdomain, domain) {
      const dot = subdomain.length - domain.length - 1;
      return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
    }
    followRedirects$1.exports = wrap({ http: http$1, https: https$1 });
    followRedirects$1.exports.wrap = wrap;
    var httpNative = require$$1__default$2;
    var httpsNative = require$$1__default$4;
    var web_o = webOutgoing;
    var common$1 = common$3;
    var followRedirects = followRedirects$1.exports;
    web_o = Object.keys(web_o).map(function(pass) {
      return web_o[pass];
    });
    var nativeAgents = { http: httpNative, https: httpsNative };
    var webIncoming = {
      deleteLength: function deleteLength(req2, res, options2) {
        if ((req2.method === "DELETE" || req2.method === "OPTIONS") && !req2.headers["content-length"]) {
          req2.headers["content-length"] = "0";
          delete req2.headers["transfer-encoding"];
        }
      },
      timeout: function timeout(req2, res, options2) {
        if (options2.timeout) {
          req2.socket.setTimeout(options2.timeout);
        }
      },
      XHeaders: function XHeaders(req2, res, options2) {
        if (!options2.xfwd)
          return;
        var encrypted = req2.isSpdy || common$1.hasEncryptedConnection(req2);
        var values = {
          for: req2.connection.remoteAddress || req2.socket.remoteAddress,
          port: common$1.getPort(req2),
          proto: encrypted ? "https" : "http"
        };
        ["for", "port", "proto"].forEach(function(header) {
          req2.headers["x-forwarded-" + header] = (req2.headers["x-forwarded-" + header] || "") + (req2.headers["x-forwarded-" + header] ? "," : "") + values[header];
        });
        req2.headers["x-forwarded-host"] = req2.headers["x-forwarded-host"] || req2.headers["host"] || "";
      },
      stream: function stream2(req2, res, options2, _2, server2, clb) {
        server2.emit("start", req2, res, options2.target || options2.forward);
        var agents = options2.followRedirects ? followRedirects : nativeAgents;
        var http2 = agents.http;
        var https2 = agents.https;
        if (options2.forward) {
          var forwardReq = (options2.forward.protocol === "https:" ? https2 : http2).request(common$1.setupOutgoing(options2.ssl || {}, options2, req2, "forward"));
          var forwardError = createErrorHandler(forwardReq, options2.forward);
          req2.on("error", forwardError);
          forwardReq.on("error", forwardError);
          (options2.buffer || req2).pipe(forwardReq);
          if (!options2.target) {
            return res.end();
          }
        }
        var proxyReq = (options2.target.protocol === "https:" ? https2 : http2).request(common$1.setupOutgoing(options2.ssl || {}, options2, req2));
        proxyReq.on("socket", function(socket) {
          if (server2 && !proxyReq.getHeader("expect")) {
            server2.emit("proxyReq", proxyReq, req2, res, options2);
          }
        });
        if (options2.proxyTimeout) {
          proxyReq.setTimeout(options2.proxyTimeout, function() {
            proxyReq.abort();
          });
        }
        req2.on("aborted", function() {
          proxyReq.abort();
        });
        var proxyError = createErrorHandler(proxyReq, options2.target);
        req2.on("error", proxyError);
        proxyReq.on("error", proxyError);
        function createErrorHandler(proxyReq2, url2) {
          return function proxyError2(err) {
            if (req2.socket.destroyed && err.code === "ECONNRESET") {
              server2.emit("econnreset", err, req2, res, url2);
              return proxyReq2.abort();
            }
            if (clb) {
              clb(err, req2, res, url2);
            } else {
              server2.emit("error", err, req2, res, url2);
            }
          };
        }
        (options2.buffer || req2).pipe(proxyReq);
        proxyReq.on("response", function(proxyRes) {
          if (server2) {
            server2.emit("proxyRes", proxyRes, req2, res);
          }
          if (!res.headersSent && !options2.selfHandleResponse) {
            for (var i2 = 0; i2 < web_o.length; i2++) {
              if (web_o[i2](req2, res, proxyRes, options2)) {
                break;
              }
            }
          }
          if (!res.finished) {
            proxyRes.on("end", function() {
              if (server2)
                server2.emit("end", req2, res, proxyRes);
            });
            if (!options2.selfHandleResponse)
              proxyRes.pipe(res);
          } else {
            if (server2)
              server2.emit("end", req2, res, proxyRes);
          }
        });
      }
    };
    var http = require$$1__default$2;
    var https = require$$1__default$4;
    var common = common$3;
    var wsIncoming = {
      checkMethodAndHeader: function checkMethodAndHeader(req2, socket) {
        if (req2.method !== "GET" || !req2.headers.upgrade) {
          socket.destroy();
          return true;
        }
        if (req2.headers.upgrade.toLowerCase() !== "websocket") {
          socket.destroy();
          return true;
        }
      },
      XHeaders: function XHeaders(req2, socket, options2) {
        if (!options2.xfwd)
          return;
        var values = {
          for: req2.connection.remoteAddress || req2.socket.remoteAddress,
          port: common.getPort(req2),
          proto: common.hasEncryptedConnection(req2) ? "wss" : "ws"
        };
        ["for", "port", "proto"].forEach(function(header) {
          req2.headers["x-forwarded-" + header] = (req2.headers["x-forwarded-" + header] || "") + (req2.headers["x-forwarded-" + header] ? "," : "") + values[header];
        });
      },
      stream: function stream2(req2, socket, options2, head, server2, clb) {
        var createHttpHeader = function(line2, headers) {
          return Object.keys(headers).reduce(function(head2, key2) {
            var value = headers[key2];
            if (!Array.isArray(value)) {
              head2.push(key2 + ": " + value);
              return head2;
            }
            for (var i2 = 0; i2 < value.length; i2++) {
              head2.push(key2 + ": " + value[i2]);
            }
            return head2;
          }, [line2]).join("\r\n") + "\r\n\r\n";
        };
        common.setupSocket(socket);
        if (head && head.length)
          socket.unshift(head);
        var proxyReq = (common.isSSL.test(options2.target.protocol) ? https : http).request(common.setupOutgoing(options2.ssl || {}, options2, req2));
        if (server2) {
          server2.emit("proxyReqWs", proxyReq, req2, socket, options2, head);
        }
        proxyReq.on("error", onOutgoingError);
        proxyReq.on("response", function(res) {
          if (!res.upgrade) {
            socket.write(createHttpHeader("HTTP/" + res.httpVersion + " " + res.statusCode + " " + res.statusMessage, res.headers));
            res.pipe(socket);
          }
        });
        proxyReq.on("upgrade", function(proxyRes, proxySocket, proxyHead) {
          proxySocket.on("error", onOutgoingError);
          proxySocket.on("end", function() {
            server2.emit("close", proxyRes, proxySocket, proxyHead);
          });
          socket.on("error", function() {
            proxySocket.end();
          });
          common.setupSocket(proxySocket);
          if (proxyHead && proxyHead.length)
            proxySocket.unshift(proxyHead);
          socket.write(createHttpHeader("HTTP/1.1 101 Switching Protocols", proxyRes.headers));
          proxySocket.pipe(socket).pipe(proxySocket);
          server2.emit("open", proxySocket);
          server2.emit("proxySocket", proxySocket);
        });
        return proxyReq.end();
        function onOutgoingError(err) {
          if (clb) {
            clb(err, req2, socket);
          } else {
            server2.emit("error", err, req2, socket);
          }
          socket.end();
        }
      }
    };
    (function(module2) {
      var httpProxy2 = module2.exports, extend2 = require$$0__default$1._extend, parse_url = require$$0__default$5.parse, EE3 = eventemitter3.exports, http2 = require$$1__default$2, https2 = require$$1__default$4, web = webIncoming, ws2 = wsIncoming;
      httpProxy2.Server = ProxyServer2;
      function createRightProxy(type) {
        return function(options2) {
          return function(req2, res) {
            var passes = type === "ws" ? this.wsPasses : this.webPasses, args = [].slice.call(arguments), cntr = args.length - 1, head, cbl;
            if (typeof args[cntr] === "function") {
              cbl = args[cntr];
              cntr--;
            }
            var requestOptions = options2;
            if (!(args[cntr] instanceof Buffer) && args[cntr] !== res) {
              requestOptions = extend2({}, options2);
              extend2(requestOptions, args[cntr]);
              cntr--;
            }
            if (args[cntr] instanceof Buffer) {
              head = args[cntr];
            }
            ["target", "forward"].forEach(function(e2) {
              if (typeof requestOptions[e2] === "string")
                requestOptions[e2] = parse_url(requestOptions[e2]);
            });
            if (!requestOptions.target && !requestOptions.forward) {
              return this.emit("error", new Error("Must provide a proper URL as target"));
            }
            for (var i2 = 0; i2 < passes.length; i2++) {
              if (passes[i2](req2, res, requestOptions, head, this, cbl)) {
                break;
              }
            }
          };
        };
      }
      httpProxy2.createRightProxy = createRightProxy;
      function ProxyServer2(options2) {
        EE3.call(this);
        options2 = options2 || {};
        options2.prependPath = options2.prependPath === false ? false : true;
        this.web = this.proxyRequest = createRightProxy("web")(options2);
        this.ws = this.proxyWebsocketRequest = createRightProxy("ws")(options2);
        this.options = options2;
        this.webPasses = Object.keys(web).map(function(pass) {
          return web[pass];
        });
        this.wsPasses = Object.keys(ws2).map(function(pass) {
          return ws2[pass];
        });
        this.on("error", this.onError, this);
      }
      require$$0__default$1.inherits(ProxyServer2, EE3);
      ProxyServer2.prototype.onError = function(err) {
        if (this.listeners("error").length === 1) {
          throw err;
        }
      };
      ProxyServer2.prototype.listen = function(port, hostname) {
        var self2 = this, closure = function(req2, res) {
          self2.web(req2, res);
        };
        this._server = this.options.ssl ? https2.createServer(this.options.ssl, closure) : http2.createServer(closure);
        if (this.options.ws) {
          this._server.on("upgrade", function(req2, socket, head) {
            self2.ws(req2, socket, head);
          });
        }
        this._server.listen(port, hostname);
        return this;
      };
      ProxyServer2.prototype.close = function(callback) {
        var self2 = this;
        if (this._server) {
          this._server.close(done);
        }
        function done() {
          self2._server = null;
          if (callback) {
            callback.apply(null, arguments);
          }
        }
      };
      ProxyServer2.prototype.before = function(type, passName, callback) {
        if (type !== "ws" && type !== "web") {
          throw new Error("type must be `web` or `ws`");
        }
        var passes = type === "ws" ? this.wsPasses : this.webPasses, i2 = false;
        passes.forEach(function(v2, idx) {
          if (v2.name === passName)
            i2 = idx;
        });
        if (i2 === false)
          throw new Error("No such pass");
        passes.splice(i2, 0, callback);
      };
      ProxyServer2.prototype.after = function(type, passName, callback) {
        if (type !== "ws" && type !== "web") {
          throw new Error("type must be `web` or `ws`");
        }
        var passes = type === "ws" ? this.wsPasses : this.webPasses, i2 = false;
        passes.forEach(function(v2, idx) {
          if (v2.name === passName)
            i2 = idx;
        });
        if (i2 === false)
          throw new Error("No such pass");
        passes.splice(i2++, 0, callback);
      };
    })(httpProxy$2);
    var ProxyServer = httpProxy$2.exports.Server;
    function createProxyServer(options2) {
      return new ProxyServer(options2);
    }
    ProxyServer.createProxyServer = createProxyServer;
    ProxyServer.createServer = createProxyServer;
    ProxyServer.createProxy = createProxyServer;
    var httpProxy$1 = ProxyServer;
    var httpProxy = httpProxy$1;
    var debug$3 = createDebugger("vite:proxy");
    function proxyMiddleware(httpServer, config2) {
      const options2 = config2.server.proxy;
      const proxies = {};
      Object.keys(options2).forEach((context2) => {
        let opts = options2[context2];
        if (typeof opts === "string") {
          opts = { target: opts, changeOrigin: true };
        }
        const proxy = httpProxy.createProxyServer(opts);
        proxy.on("error", (err) => {
          config2.logger.error(`${colors$1.red(`http proxy error:`)}
${err.stack}`, {
            timestamp: true,
            error: err
          });
        });
        if (opts.configure) {
          opts.configure(proxy, opts);
        }
        proxies[context2] = [proxy, __spreadValues2({}, opts)];
      });
      if (httpServer) {
        httpServer.on("upgrade", (req2, socket, head) => {
          var _a2;
          const url2 = req2.url;
          for (const context2 in proxies) {
            if (doesProxyContextMatchUrl(context2, url2)) {
              const [proxy, opts] = proxies[context2];
              if ((opts.ws || ((_a2 = opts.target) === null || _a2 === void 0 ? void 0 : _a2.toString().startsWith("ws:"))) && req2.headers["sec-websocket-protocol"] !== HMR_HEADER) {
                if (opts.rewrite) {
                  req2.url = opts.rewrite(url2);
                }
                debug$3(`${req2.url} -> ws ${opts.target}`);
                proxy.ws(req2, socket, head);
                return;
              }
            }
          }
        });
      }
      return function viteProxyMiddleware(req2, res, next) {
        const url2 = req2.url;
        for (const context2 in proxies) {
          if (doesProxyContextMatchUrl(context2, url2)) {
            const [proxy, opts] = proxies[context2];
            const options3 = {};
            if (opts.bypass) {
              const bypassResult = opts.bypass(req2, res, opts);
              if (typeof bypassResult === "string") {
                req2.url = bypassResult;
                debug$3(`bypass: ${req2.url} -> ${bypassResult}`);
                return next();
              } else if (isObject$5(bypassResult)) {
                Object.assign(options3, bypassResult);
                debug$3(`bypass: ${req2.url} use modified options: %O`, options3);
                return next();
              } else if (bypassResult === false) {
                debug$3(`bypass: ${req2.url} -> 404`);
                return res.end(404);
              }
            }
            debug$3(`${req2.url} -> ${opts.target || opts.forward}`);
            if (opts.rewrite) {
              req2.url = opts.rewrite(req2.url);
            }
            proxy.web(req2, res, options3);
            return;
          }
        }
        next();
      };
    }
    function doesProxyContextMatchUrl(context2, url2) {
      return context2.startsWith("^") && new RegExp(context2).test(url2) || url2.startsWith(context2);
    }
    var lib = { exports: {} };
    (function(module2, exports2) {
      var url2 = require$$0__default$5;
      module2.exports = function historyApiFallback(options2) {
        options2 = options2 || {};
        var logger = getLogger(options2);
        return function(req2, res, next) {
          var headers = req2.headers;
          if (req2.method !== "GET") {
            logger("Not rewriting", req2.method, req2.url, "because the method is not GET.");
            return next();
          } else if (!headers || typeof headers.accept !== "string") {
            logger("Not rewriting", req2.method, req2.url, "because the client did not send an HTTP accept header.");
            return next();
          } else if (headers.accept.indexOf("application/json") === 0) {
            logger("Not rewriting", req2.method, req2.url, "because the client prefers JSON.");
            return next();
          } else if (!acceptsHtml(headers.accept, options2)) {
            logger("Not rewriting", req2.method, req2.url, "because the client does not accept HTML.");
            return next();
          }
          var parsedUrl = url2.parse(req2.url);
          var rewriteTarget;
          options2.rewrites = options2.rewrites || [];
          for (var i2 = 0; i2 < options2.rewrites.length; i2++) {
            var rewrite = options2.rewrites[i2];
            var match2 = parsedUrl.pathname.match(rewrite.from);
            if (match2 !== null) {
              rewriteTarget = evaluateRewriteRule(parsedUrl, match2, rewrite.to, req2);
              if (rewriteTarget.charAt(0) !== "/") {
                logger("We recommend using an absolute path for the rewrite target.", "Received a non-absolute rewrite target", rewriteTarget, "for URL", req2.url);
              }
              logger("Rewriting", req2.method, req2.url, "to", rewriteTarget);
              req2.url = rewriteTarget;
              return next();
            }
          }
          var pathname = parsedUrl.pathname;
          if (pathname.lastIndexOf(".") > pathname.lastIndexOf("/") && options2.disableDotRule !== true) {
            logger("Not rewriting", req2.method, req2.url, "because the path includes a dot (.) character.");
            return next();
          }
          rewriteTarget = options2.index || "/index.html";
          logger("Rewriting", req2.method, req2.url, "to", rewriteTarget);
          req2.url = rewriteTarget;
          next();
        };
      };
      function evaluateRewriteRule(parsedUrl, match2, rule, req2) {
        if (typeof rule === "string") {
          return rule;
        } else if (typeof rule !== "function") {
          throw new Error("Rewrite rule can only be of type string or function.");
        }
        return rule({
          parsedUrl,
          match: match2,
          request: req2
        });
      }
      function acceptsHtml(header, options2) {
        options2.htmlAcceptHeaders = options2.htmlAcceptHeaders || ["text/html", "*/*"];
        for (var i2 = 0; i2 < options2.htmlAcceptHeaders.length; i2++) {
          if (header.indexOf(options2.htmlAcceptHeaders[i2]) !== -1) {
            return true;
          }
        }
        return false;
      }
      function getLogger(options2) {
        if (options2 && options2.logger) {
          return options2.logger;
        } else if (options2 && options2.verbose) {
          return console.log.bind(console);
        }
        return function() {
        };
      }
    })(lib);
    var history = lib.exports;
    function spaFallbackMiddleware(root2) {
      const historySpaFallbackMiddleware = history({
        logger: createDebugger("vite:spa-fallback"),
        rewrites: [
          {
            from: /\/$/,
            to({ parsedUrl }) {
              const rewritten = decodeURIComponent(parsedUrl.pathname) + "index.html";
              if (fs__default.existsSync(path__default.join(root2, rewritten))) {
                return rewritten;
              } else {
                return `/index.html`;
              }
            }
          }
        ]
      });
      return function viteSpaFallbackMiddleware(req2, res, next) {
        return historySpaFallbackMiddleware(req2, res, next);
      };
    }
    var etag_1 = etag;
    var crypto = require$$1__default$3;
    var Stats = fs__default.Stats;
    var toString = Object.prototype.toString;
    function entitytag(entity) {
      if (entity.length === 0) {
        return '"0-2jmj7l5rSw0yVb/vlWAYkK/YBwk"';
      }
      var hash = crypto.createHash("sha1").update(entity, "utf8").digest("base64").substring(0, 27);
      var len = typeof entity === "string" ? Buffer.byteLength(entity, "utf8") : entity.length;
      return '"' + len.toString(16) + "-" + hash + '"';
    }
    function etag(entity, options2) {
      if (entity == null) {
        throw new TypeError("argument entity is required");
      }
      var isStats = isstats(entity);
      var weak = options2 && typeof options2.weak === "boolean" ? options2.weak : isStats;
      if (!isStats && typeof entity !== "string" && !Buffer.isBuffer(entity)) {
        throw new TypeError("argument entity must be string, Buffer, or fs.Stats");
      }
      var tag = isStats ? stattag(entity) : entitytag(entity);
      return weak ? "W/" + tag : tag;
    }
    function isstats(obj) {
      if (typeof Stats === "function" && obj instanceof Stats) {
        return true;
      }
      return obj && typeof obj === "object" && "ctime" in obj && toString.call(obj.ctime) === "[object Date]" && "mtime" in obj && toString.call(obj.mtime) === "[object Date]" && "ino" in obj && typeof obj.ino === "number" && "size" in obj && typeof obj.size === "number";
    }
    function stattag(stat2) {
      var mtime = stat2.mtime.getTime().toString(16);
      var size = stat2.size.toString(16);
      return '"' + size + "-" + mtime + '"';
    }
    var alias$1 = {
      js: "application/javascript",
      css: "text/css",
      html: "text/html",
      json: "application/json"
    };
    function send$1(req2, res, content2, type, options2) {
      const { etag: etag2 = etag_1(content2, { weak: true }), cacheControl = "no-cache", headers, map: map2 } = options2;
      if (res.writableEnded) {
        return;
      }
      if (req2.headers["if-none-match"] === etag2) {
        res.statusCode = 304;
        res.end();
        return;
      }
      res.setHeader("Content-Type", alias$1[type] || type);
      res.setHeader("Cache-Control", cacheControl);
      res.setHeader("Etag", etag2);
      if (headers) {
        for (const name in headers) {
          res.setHeader(name, headers[name]);
        }
      }
      if (map2 && map2.mappings) {
        if (type === "js" || type === "css") {
          content2 = getCodeWithSourcemap(type, content2.toString(), map2);
        }
      }
      res.statusCode = 200;
      res.end(content2);
      return;
    }
    var convertSourceMap = {};
    var safeBuffer = { exports: {} };
    (function(module2, exports2) {
      var buffer2 = require$$0__default$6;
      var Buffer2 = buffer2.Buffer;
      function copyProps(src2, dst) {
        for (var key2 in src2) {
          dst[key2] = src2[key2];
        }
      }
      if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
        module2.exports = buffer2;
      } else {
        copyProps(buffer2, exports2);
        exports2.Buffer = SafeBuffer;
      }
      function SafeBuffer(arg, encodingOrOffset, length) {
        return Buffer2(arg, encodingOrOffset, length);
      }
      copyProps(Buffer2, SafeBuffer);
      SafeBuffer.from = function(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          throw new TypeError("Argument must not be a number");
        }
        return Buffer2(arg, encodingOrOffset, length);
      };
      SafeBuffer.alloc = function(size, fill2, encoding) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        var buf = Buffer2(size);
        if (fill2 !== void 0) {
          if (typeof encoding === "string") {
            buf.fill(fill2, encoding);
          } else {
            buf.fill(fill2);
          }
        } else {
          buf.fill(0);
        }
        return buf;
      };
      SafeBuffer.allocUnsafe = function(size) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        return Buffer2(size);
      };
      SafeBuffer.allocUnsafeSlow = function(size) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        return buffer2.SlowBuffer(size);
      };
    })(safeBuffer, safeBuffer.exports);
    (function(exports2) {
      var fs3 = fs__default;
      var path2 = path__default;
      var SafeBuffer = safeBuffer.exports;
      Object.defineProperty(exports2, "commentRegex", {
        get: function getCommentRegex() {
          return /^\s*\/(?:\/|\*)[@#]\s+sourceMappingURL=data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,(?:.*)$/mg;
        }
      });
      Object.defineProperty(exports2, "mapFileCommentRegex", {
        get: function getMapFileCommentRegex() {
          return /(?:\/\/[@#][ \t]+sourceMappingURL=([^\s'"`]+?)[ \t]*$)|(?:\/\*[@#][ \t]+sourceMappingURL=([^\*]+?)[ \t]*(?:\*\/){1}[ \t]*$)/mg;
        }
      });
      function decodeBase64(base64) {
        return (SafeBuffer.Buffer.from(base64, "base64") || "").toString();
      }
      function stripComment(sm) {
        return sm.split(",").pop();
      }
      function readFromFileMap(sm, dir) {
        var r2 = exports2.mapFileCommentRegex.exec(sm);
        var filename2 = r2[1] || r2[2];
        var filepath = path2.resolve(dir, filename2);
        try {
          return fs3.readFileSync(filepath, "utf8");
        } catch (e2) {
          throw new Error("An error occurred while trying to read the map file at " + filepath + "\n" + e2);
        }
      }
      function Converter(sm, opts) {
        opts = opts || {};
        if (opts.isFileComment)
          sm = readFromFileMap(sm, opts.commentFileDir);
        if (opts.hasComment)
          sm = stripComment(sm);
        if (opts.isEncoded)
          sm = decodeBase64(sm);
        if (opts.isJSON || opts.isEncoded)
          sm = JSON.parse(sm);
        this.sourcemap = sm;
      }
      Converter.prototype.toJSON = function(space) {
        return JSON.stringify(this.sourcemap, null, space);
      };
      Converter.prototype.toBase64 = function() {
        var json2 = this.toJSON();
        return (SafeBuffer.Buffer.from(json2, "utf8") || "").toString("base64");
      };
      Converter.prototype.toComment = function(options2) {
        var base64 = this.toBase64();
        var data2 = "sourceMappingURL=data:application/json;charset=utf-8;base64," + base64;
        return options2 && options2.multiline ? "/*# " + data2 + " */" : "//# " + data2;
      };
      Converter.prototype.toObject = function() {
        return JSON.parse(this.toJSON());
      };
      Converter.prototype.addProperty = function(key2, value) {
        if (this.sourcemap.hasOwnProperty(key2))
          throw new Error('property "' + key2 + '" already exists on the sourcemap, use set property instead');
        return this.setProperty(key2, value);
      };
      Converter.prototype.setProperty = function(key2, value) {
        this.sourcemap[key2] = value;
        return this;
      };
      Converter.prototype.getProperty = function(key2) {
        return this.sourcemap[key2];
      };
      exports2.fromObject = function(obj) {
        return new Converter(obj);
      };
      exports2.fromJSON = function(json2) {
        return new Converter(json2, { isJSON: true });
      };
      exports2.fromBase64 = function(base64) {
        return new Converter(base64, { isEncoded: true });
      };
      exports2.fromComment = function(comment) {
        comment = comment.replace(/^\/\*/g, "//").replace(/\*\/$/g, "");
        return new Converter(comment, { isEncoded: true, hasComment: true });
      };
      exports2.fromMapFileComment = function(comment, dir) {
        return new Converter(comment, { commentFileDir: dir, isFileComment: true, isJSON: true });
      };
      exports2.fromSource = function(content2) {
        var m3 = content2.match(exports2.commentRegex);
        return m3 ? exports2.fromComment(m3.pop()) : null;
      };
      exports2.fromMapFileSource = function(content2, dir) {
        var m3 = content2.match(exports2.mapFileCommentRegex);
        return m3 ? exports2.fromMapFileComment(m3.pop(), dir) : null;
      };
      exports2.removeComments = function(src2) {
        return src2.replace(exports2.commentRegex, "");
      };
      exports2.removeMapFileComments = function(src2) {
        return src2.replace(exports2.mapFileCommentRegex, "");
      };
      exports2.generateMapFileComment = function(file, options2) {
        var data2 = "sourceMappingURL=" + file;
        return options2 && options2.multiline ? "/*# " + data2 + " */" : "//# " + data2;
      };
    })(convertSourceMap);
    function extract_names(param) {
      return extract_identifiers(param).map((node2) => node2.name);
    }
    function extract_identifiers(param, nodes = []) {
      switch (param.type) {
        case "Identifier":
          nodes.push(param);
          break;
        case "MemberExpression":
          let object = param;
          while (object.type === "MemberExpression") {
            object = object.object;
          }
          nodes.push(object);
          break;
        case "ObjectPattern":
          const handle_prop = (prop) => {
            if (prop.type === "RestElement") {
              extract_identifiers(prop.argument, nodes);
            } else {
              extract_identifiers(prop.value, nodes);
            }
          };
          param.properties.forEach(handle_prop);
          break;
        case "ArrayPattern":
          const handle_element = (element) => {
            if (element)
              extract_identifiers(element, nodes);
          };
          param.elements.forEach(handle_element);
          break;
        case "RestElement":
          extract_identifiers(param.argument, nodes);
          break;
        case "AssignmentPattern":
          extract_identifiers(param.left, nodes);
          break;
      }
      return nodes;
    }
    var ssrModuleExportsKey = `__vite_ssr_exports__`;
    var ssrImportKey = `__vite_ssr_import__`;
    var ssrDynamicImportKey = `__vite_ssr_dynamic_import__`;
    var ssrExportAllKey = `__vite_ssr_exportAll__`;
    var ssrImportMetaKey = `__vite_ssr_import_meta__`;
    async function ssrTransform(code, inMap, url2) {
      const s2 = new MagicString(code);
      let ast;
      try {
        ast = parser.parse(code, {
          sourceType: "module",
          ecmaVersion: "latest",
          locations: true
        });
      } catch (err) {
        if (!err.loc || !err.loc.line)
          throw err;
        const line2 = err.loc.line;
        throw new Error(`Parse failure: ${err.message}
Contents of line ${line2}: ${code.split("\n")[line2 - 1]}`);
      }
      let uid = 0;
      const deps = /* @__PURE__ */ new Set();
      const dynamicDeps = /* @__PURE__ */ new Set();
      const idToImportMap = /* @__PURE__ */ new Map();
      const declaredConst = /* @__PURE__ */ new Set();
      function defineImport(node2, source2) {
        deps.add(source2);
        const importId = `__vite_ssr_import_${uid++}__`;
        s2.appendLeft(node2.start, `const ${importId} = await ${ssrImportKey}(${JSON.stringify(source2)});
`);
        return importId;
      }
      function defineExport(position, name, local = name) {
        s2.appendLeft(position, `
Object.defineProperty(${ssrModuleExportsKey}, "${name}", { enumerable: true, configurable: true, get(){ return ${local} }});`);
      }
      for (const node2 of ast.body) {
        if (node2.type === "ImportDeclaration") {
          const importId = defineImport(node2, node2.source.value);
          for (const spec of node2.specifiers) {
            if (spec.type === "ImportSpecifier") {
              idToImportMap.set(spec.local.name, `${importId}.${spec.imported.name}`);
            } else if (spec.type === "ImportDefaultSpecifier") {
              idToImportMap.set(spec.local.name, `${importId}.default`);
            } else {
              idToImportMap.set(spec.local.name, importId);
            }
          }
          s2.remove(node2.start, node2.end);
        }
      }
      for (const node2 of ast.body) {
        if (node2.type === "ExportNamedDeclaration") {
          if (node2.declaration) {
            if (node2.declaration.type === "FunctionDeclaration" || node2.declaration.type === "ClassDeclaration") {
              defineExport(node2.end, node2.declaration.id.name);
            } else {
              for (const declaration of node2.declaration.declarations) {
                const names = extract_names(declaration.id);
                for (const name of names) {
                  defineExport(node2.end, name);
                }
              }
            }
            s2.remove(node2.start, node2.declaration.start);
          } else {
            s2.remove(node2.start, node2.end);
            if (node2.source) {
              const importId = defineImport(node2, node2.source.value);
              for (const spec of node2.specifiers) {
                defineExport(node2.end, spec.exported.name, `${importId}.${spec.local.name}`);
              }
            } else {
              for (const spec of node2.specifiers) {
                const local = spec.local.name;
                const binding = idToImportMap.get(local);
                defineExport(node2.end, spec.exported.name, binding || local);
              }
            }
          }
        }
        if (node2.type === "ExportDefaultDeclaration") {
          if ("id" in node2.declaration && node2.declaration.id) {
            const { name } = node2.declaration.id;
            s2.remove(node2.start, node2.start + 15);
            s2.append(`
Object.defineProperty(${ssrModuleExportsKey}, "default", { enumerable: true, value: ${name} });`);
          } else {
            s2.overwrite(node2.start, node2.start + 14, `${ssrModuleExportsKey}.default =`, { contentOnly: true });
          }
        }
        if (node2.type === "ExportAllDeclaration") {
          if (node2.exported) {
            const importId = defineImport(node2, node2.source.value);
            s2.remove(node2.start, node2.end);
            defineExport(node2.end, node2.exported.name, `${importId}`);
          } else {
            const importId = defineImport(node2, node2.source.value);
            s2.remove(node2.start, node2.end);
            s2.appendLeft(node2.end, `${ssrExportAllKey}(${importId});`);
          }
        }
      }
      walk(ast, {
        onIdentifier(id, parent, parentStack) {
          const grandparent = parentStack[1];
          const binding = idToImportMap.get(id.name);
          if (!binding) {
            return;
          }
          if (isStaticProperty(parent) && parent.shorthand) {
            if (!isNodeInPatternWeakMap.get(parent) || isInDestructuringAssignment(parent, parentStack)) {
              s2.appendLeft(id.end, `: ${binding}`);
            }
          } else if (parent.type === "PropertyDefinition" && (grandparent === null || grandparent === void 0 ? void 0 : grandparent.type) === "ClassBody" || parent.type === "ClassDeclaration" && id === parent.superClass) {
            if (!declaredConst.has(id.name)) {
              declaredConst.add(id.name);
              const topNode = parentStack[parentStack.length - 2];
              s2.prependRight(topNode.start, `const ${id.name} = ${binding};
`);
            }
          } else {
            s2.overwrite(id.start, id.end, binding, { contentOnly: true });
          }
        },
        onImportMeta(node2) {
          s2.overwrite(node2.start, node2.end, ssrImportMetaKey, { contentOnly: true });
        },
        onDynamicImport(node2) {
          s2.overwrite(node2.start, node2.start + 6, ssrDynamicImportKey, {
            contentOnly: true
          });
          if (node2.type === "ImportExpression" && node2.source.type === "Literal") {
            dynamicDeps.add(node2.source.value);
          }
        }
      });
      let map2 = s2.generateMap({ hires: true });
      if (inMap && inMap.mappings && inMap.sources.length > 0) {
        map2 = combineSourcemaps(url2, [
          __spreadProps2(__spreadValues2({}, map2), {
            sources: inMap.sources,
            sourcesContent: inMap.sourcesContent
          }),
          inMap
        ]);
      } else {
        map2.sources = [url2];
        map2.sourcesContent = [code];
      }
      return {
        code: s2.toString(),
        map: map2,
        deps: [...deps],
        dynamicDeps: [...dynamicDeps]
      };
    }
    var isNodeInPatternWeakMap = /* @__PURE__ */ new WeakMap();
    function walk(root2, { onIdentifier, onImportMeta, onDynamicImport }) {
      const parentStack = [];
      const scopeMap = /* @__PURE__ */ new WeakMap();
      const identifiers = [];
      const setScope = (node2, name) => {
        let scopeIds = scopeMap.get(node2);
        if (scopeIds && scopeIds.has(name)) {
          return;
        }
        if (!scopeIds) {
          scopeIds = /* @__PURE__ */ new Set();
          scopeMap.set(node2, scopeIds);
        }
        scopeIds.add(name);
      };
      function isInScope(name, parents) {
        return parents.some((node2) => {
          var _a2;
          return node2 && ((_a2 = scopeMap.get(node2)) === null || _a2 === void 0 ? void 0 : _a2.has(name));
        });
      }
      function handlePattern(p2, parentFunction) {
        if (p2.type === "Identifier") {
          setScope(parentFunction, p2.name);
        } else if (p2.type === "RestElement") {
          handlePattern(p2.argument, parentFunction);
        } else if (p2.type === "ObjectPattern") {
          p2.properties.forEach((property) => {
            if (property.type === "RestElement") {
              setScope(parentFunction, property.argument.name);
            } else {
              handlePattern(property.value, parentFunction);
            }
          });
        } else if (p2.type === "ArrayPattern") {
          p2.elements.forEach((element) => {
            if (element) {
              handlePattern(element, parentFunction);
            }
          });
        } else if (p2.type === "AssignmentPattern") {
          handlePattern(p2.left, parentFunction);
        } else {
          setScope(parentFunction, p2.name);
        }
      }
      walk$2(root2, {
        enter(node2, parent) {
          if (node2.type === "ImportDeclaration") {
            return this.skip();
          }
          parent && parentStack.unshift(parent);
          if (node2.type === "MetaProperty" && node2.meta.name === "import") {
            onImportMeta(node2);
          } else if (node2.type === "ImportExpression") {
            onDynamicImport(node2);
          }
          if (node2.type === "Identifier") {
            if (!isInScope(node2.name, parentStack) && isRefIdentifier(node2, parent, parentStack)) {
              identifiers.push([node2, parentStack.slice(0)]);
            }
          } else if (isFunction(node2)) {
            if (node2.type === "FunctionDeclaration") {
              const parentFunction = findParentFunction(parentStack);
              if (parentFunction) {
                setScope(parentFunction, node2.id.name);
              }
            }
            node2.params.forEach((p2) => {
              if (p2.type === "ObjectPattern" || p2.type === "ArrayPattern") {
                handlePattern(p2, node2);
                return;
              }
              walk$2(p2.type === "AssignmentPattern" ? p2.left : p2, {
                enter(child, parent2) {
                  if ((parent2 === null || parent2 === void 0 ? void 0 : parent2.type) === "AssignmentPattern" && (parent2 === null || parent2 === void 0 ? void 0 : parent2.right) === child) {
                    return this.skip();
                  }
                  if (child.type !== "Identifier")
                    return;
                  if (isStaticPropertyKey(child, parent2))
                    return;
                  if ((parent2 === null || parent2 === void 0 ? void 0 : parent2.type) === "TemplateLiteral" && (parent2 === null || parent2 === void 0 ? void 0 : parent2.expressions.includes(child)) || (parent2 === null || parent2 === void 0 ? void 0 : parent2.type) === "CallExpression" && (parent2 === null || parent2 === void 0 ? void 0 : parent2.callee) === child) {
                    return;
                  }
                  setScope(node2, child.name);
                }
              });
            });
          } else if (node2.type === "Property" && parent.type === "ObjectPattern") {
            isNodeInPatternWeakMap.set(node2, true);
          } else if (node2.type === "VariableDeclarator") {
            const parentFunction = findParentFunction(parentStack);
            if (parentFunction) {
              handlePattern(node2.id, parentFunction);
            }
          }
        },
        leave(node2, parent) {
          parent && parentStack.shift();
        }
      });
      identifiers.forEach(([node2, stack2]) => {
        if (!isInScope(node2.name, stack2))
          onIdentifier(node2, stack2[0], stack2);
      });
    }
    function isRefIdentifier(id, parent, parentStack) {
      if (parent.type === "CatchClause" || (parent.type === "VariableDeclarator" || parent.type === "ClassDeclaration") && parent.id === id) {
        return false;
      }
      if (isFunction(parent)) {
        if (parent.id === id) {
          return false;
        }
        if (parent.params.includes(id)) {
          return false;
        }
      }
      if (parent.type === "MethodDefinition") {
        return false;
      }
      if (isStaticPropertyKey(id, parent) || isNodeInPatternWeakMap.get(parent)) {
        return false;
      }
      if (parent.type === "ArrayPattern" && !isInDestructuringAssignment(parent, parentStack)) {
        return false;
      }
      if (parent.type === "MemberExpression" && parent.property === id && !parent.computed) {
        return false;
      }
      if (parent.type === "ExportSpecifier") {
        return false;
      }
      if (id.name === "arguments") {
        return false;
      }
      return true;
    }
    var isStaticProperty = (node2) => node2 && node2.type === "Property" && !node2.computed;
    var isStaticPropertyKey = (node2, parent) => isStaticProperty(parent) && parent.key === node2;
    function isFunction(node2) {
      return /Function(?:Expression|Declaration)$|Method$/.test(node2.type);
    }
    function findParentFunction(parentStack) {
      return parentStack.find((i2) => isFunction(i2));
    }
    function isInDestructuringAssignment(parent, parentStack) {
      if (parent && (parent.type === "Property" || parent.type === "ArrayPattern")) {
        return parentStack.some((i2) => i2.type === "AssignmentExpression");
      }
      return false;
    }
    function totalist(dir, callback, pre = "") {
      dir = path$r.resolve(".", dir);
      let arr = fs$n.readdirSync(dir);
      let i2 = 0, abs, stats;
      for (; i2 < arr.length; i2++) {
        abs = path$r.join(dir, arr[i2]);
        stats = fs$n.statSync(abs);
        stats.isDirectory() ? totalist(abs, callback, path$r.join(pre, arr[i2])) : callback(path$r.join(pre, arr[i2]), abs, stats);
      }
    }
    function parse$4(req2) {
      let raw = req2.url;
      if (raw == null)
        return;
      let prev = req2._parsedUrl;
      if (prev && prev.raw === raw)
        return prev;
      let pathname = raw, search = "", query;
      if (raw.length > 1) {
        let idx = raw.indexOf("?", 1);
        if (idx !== -1) {
          search = raw.substring(idx);
          pathname = raw.substring(0, idx);
          if (search.length > 1) {
            query = qs__namespace.parse(search.substring(1));
          }
        }
      }
      return req2._parsedUrl = { pathname, search, query, raw };
    }
    var noop$1 = () => {
    };
    function isMatch(uri, arr) {
      for (let i2 = 0; i2 < arr.length; i2++) {
        if (arr[i2].test(uri))
          return true;
      }
    }
    function toAssume(uri, extns) {
      let i2 = 0, x2, len = uri.length - 1;
      if (uri.charCodeAt(len) === 47) {
        uri = uri.substring(0, len);
      }
      let arr = [], tmp = `${uri}/index`;
      for (; i2 < extns.length; i2++) {
        x2 = extns[i2] ? `.${extns[i2]}` : "";
        if (uri)
          arr.push(uri + x2);
        arr.push(tmp + x2);
      }
      return arr;
    }
    function viaCache(cache2, uri, extns) {
      let i2 = 0, data2, arr = toAssume(uri, extns);
      for (; i2 < arr.length; i2++) {
        if (data2 = cache2[arr[i2]])
          return data2;
      }
    }
    function viaLocal(dir, isEtag, uri, extns) {
      let i2 = 0, arr = toAssume(uri, extns);
      let abs, stats, name, headers;
      for (; i2 < arr.length; i2++) {
        abs = path$r.normalize(path$r.join(dir, name = arr[i2]));
        if (abs.startsWith(dir) && fs__namespace.existsSync(abs)) {
          stats = fs__namespace.statSync(abs);
          if (stats.isDirectory())
            continue;
          headers = toHeaders(name, stats, isEtag);
          headers["Cache-Control"] = isEtag ? "no-cache" : "no-store";
          return { abs, stats, headers };
        }
      }
    }
    function is404(req2, res) {
      return res.statusCode = 404, res.end();
    }
    function send(req2, res, file, stats, headers) {
      let code = 200, tmp, opts = {};
      headers = __spreadValues2({}, headers);
      for (let key2 in headers) {
        tmp = res.getHeader(key2);
        if (tmp)
          headers[key2] = tmp;
      }
      if (tmp = res.getHeader("content-type")) {
        headers["Content-Type"] = tmp;
      }
      if (req2.headers.range) {
        code = 206;
        let [x2, y3] = req2.headers.range.replace("bytes=", "").split("-");
        let end = opts.end = parseInt(y3, 10) || stats.size - 1;
        let start = opts.start = parseInt(x2, 10) || 0;
        if (start >= stats.size || end >= stats.size) {
          res.setHeader("Content-Range", `bytes */${stats.size}`);
          res.statusCode = 416;
          return res.end();
        }
        headers["Content-Range"] = `bytes ${start}-${end}/${stats.size}`;
        headers["Content-Length"] = end - start + 1;
        headers["Accept-Ranges"] = "bytes";
      }
      res.writeHead(code, headers);
      fs__namespace.createReadStream(file, opts).pipe(res);
    }
    var ENCODING = {
      ".br": "br",
      ".gz": "gzip"
    };
    function toHeaders(name, stats, isEtag) {
      let enc = ENCODING[name.slice(-3)];
      let ctype = lookup(name.slice(0, enc && -3)) || "";
      if (ctype === "text/html")
        ctype += ";charset=utf-8";
      let headers = {
        "Content-Length": stats.size,
        "Content-Type": ctype,
        "Last-Modified": stats.mtime.toUTCString()
      };
      if (enc)
        headers["Content-Encoding"] = enc;
      if (isEtag)
        headers["ETag"] = `W/"${stats.size}-${stats.mtime.getTime()}"`;
      return headers;
    }
    function sirv(dir, opts = {}) {
      dir = path$r.resolve(dir || ".");
      let isNotFound = opts.onNoMatch || is404;
      let setHeaders2 = opts.setHeaders || noop$1;
      let extensions2 = opts.extensions || ["html", "htm"];
      let gzips = opts.gzip && extensions2.map((x2) => `${x2}.gz`).concat("gz");
      let brots = opts.brotli && extensions2.map((x2) => `${x2}.br`).concat("br");
      const FILES = {};
      let fallback = "/";
      let isEtag = !!opts.etag;
      let isSPA = !!opts.single;
      if (typeof opts.single === "string") {
        let idx = opts.single.lastIndexOf(".");
        fallback += !!~idx ? opts.single.substring(0, idx) : opts.single;
      }
      let ignores = [];
      if (opts.ignores !== false) {
        ignores.push(/[/]([A-Za-z\s\d~$._-]+\.\w+){1,}$/);
        if (opts.dotfiles)
          ignores.push(/\/\.\w/);
        else
          ignores.push(/\/\.well-known/);
        [].concat(opts.ignores || []).forEach((x2) => {
          ignores.push(new RegExp(x2, "i"));
        });
      }
      let cc = opts.maxAge != null && `public,max-age=${opts.maxAge}`;
      if (cc && opts.immutable)
        cc += ",immutable";
      else if (cc && opts.maxAge === 0)
        cc += ",must-revalidate";
      if (!opts.dev) {
        totalist(dir, (name, abs, stats) => {
          if (/\.well-known[\\+\/]/.test(name))
            ;
          else if (!opts.dotfiles && /(^\.|[\\+|\/+]\.)/.test(name))
            return;
          let headers = toHeaders(name, stats, isEtag);
          if (cc)
            headers["Cache-Control"] = cc;
          FILES["/" + name.normalize().replace(/\\+/g, "/")] = { abs, stats, headers };
        });
      }
      let lookup2 = opts.dev ? viaLocal.bind(0, dir, isEtag) : viaCache.bind(0, FILES);
      return function(req2, res, next) {
        let extns = [""];
        let pathname = parse$4(req2).pathname;
        let val = req2.headers["accept-encoding"] || "";
        if (gzips && val.includes("gzip"))
          extns.unshift(...gzips);
        if (brots && /(br|brotli)/i.test(val))
          extns.unshift(...brots);
        extns.push(...extensions2);
        if (pathname.indexOf("%") !== -1) {
          try {
            pathname = decodeURIComponent(pathname);
          } catch (err) {
          }
        }
        let data2 = lookup2(pathname, extns) || isSPA && !isMatch(pathname, ignores) && lookup2(fallback, extns);
        if (!data2)
          return next ? next() : isNotFound(req2, res);
        if (isEtag && req2.headers["if-none-match"] === data2.headers["ETag"]) {
          res.writeHead(304);
          return res.end();
        }
        if (gzips || brots) {
          res.setHeader("Vary", "Accept-Encoding");
        }
        setHeaders2(res, pathname, data2.stats);
        send(req2, res, data2.abs, data2.stats, data2.headers);
      };
    }
    var util = require$$0__default$1;
    var braces = braces_1;
    var picomatch = picomatch$3;
    var utils = utils$4;
    var isEmptyString = (val) => val === "" || val === "./";
    var micromatch = (list2, patterns2, options2) => {
      patterns2 = [].concat(patterns2);
      list2 = [].concat(list2);
      let omit = /* @__PURE__ */ new Set();
      let keep = /* @__PURE__ */ new Set();
      let items = /* @__PURE__ */ new Set();
      let negatives = 0;
      let onResult = (state) => {
        items.add(state.output);
        if (options2 && options2.onResult) {
          options2.onResult(state);
        }
      };
      for (let i2 = 0; i2 < patterns2.length; i2++) {
        let isMatch2 = picomatch(String(patterns2[i2]), __spreadProps2(__spreadValues2({}, options2), { onResult }), true);
        let negated = isMatch2.state.negated || isMatch2.state.negatedExtglob;
        if (negated)
          negatives++;
        for (let item of list2) {
          let matched = isMatch2(item, true);
          let match2 = negated ? !matched.isMatch : matched.isMatch;
          if (!match2)
            continue;
          if (negated) {
            omit.add(matched.output);
          } else {
            omit.delete(matched.output);
            keep.add(matched.output);
          }
        }
      }
      let result2 = negatives === patterns2.length ? [...items] : [...keep];
      let matches2 = result2.filter((item) => !omit.has(item));
      if (options2 && matches2.length === 0) {
        if (options2.failglob === true) {
          throw new Error(`No matches found for "${patterns2.join(", ")}"`);
        }
        if (options2.nonull === true || options2.nullglob === true) {
          return options2.unescape ? patterns2.map((p2) => p2.replace(/\\/g, "")) : patterns2;
        }
      }
      return matches2;
    };
    micromatch.match = micromatch;
    micromatch.matcher = (pattern2, options2) => picomatch(pattern2, options2);
    micromatch.isMatch = (str, patterns2, options2) => picomatch(patterns2, options2)(str);
    micromatch.any = micromatch.isMatch;
    micromatch.not = (list2, patterns2, options2 = {}) => {
      patterns2 = [].concat(patterns2).map(String);
      let result2 = /* @__PURE__ */ new Set();
      let items = [];
      let onResult = (state) => {
        if (options2.onResult)
          options2.onResult(state);
        items.push(state.output);
      };
      let matches2 = new Set(micromatch(list2, patterns2, __spreadProps2(__spreadValues2({}, options2), { onResult })));
      for (let item of items) {
        if (!matches2.has(item)) {
          result2.add(item);
        }
      }
      return [...result2];
    };
    micromatch.contains = (str, pattern2, options2) => {
      if (typeof str !== "string") {
        throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
      }
      if (Array.isArray(pattern2)) {
        return pattern2.some((p2) => micromatch.contains(str, p2, options2));
      }
      if (typeof pattern2 === "string") {
        if (isEmptyString(str) || isEmptyString(pattern2)) {
          return false;
        }
        if (str.includes(pattern2) || str.startsWith("./") && str.slice(2).includes(pattern2)) {
          return true;
        }
      }
      return micromatch.isMatch(str, pattern2, __spreadProps2(__spreadValues2({}, options2), { contains: true }));
    };
    micromatch.matchKeys = (obj, patterns2, options2) => {
      if (!utils.isObject(obj)) {
        throw new TypeError("Expected the first argument to be an object");
      }
      let keys = micromatch(Object.keys(obj), patterns2, options2);
      let res = {};
      for (let key2 of keys)
        res[key2] = obj[key2];
      return res;
    };
    micromatch.some = (list2, patterns2, options2) => {
      let items = [].concat(list2);
      for (let pattern2 of [].concat(patterns2)) {
        let isMatch2 = picomatch(String(pattern2), options2);
        if (items.some((item) => isMatch2(item))) {
          return true;
        }
      }
      return false;
    };
    micromatch.every = (list2, patterns2, options2) => {
      let items = [].concat(list2);
      for (let pattern2 of [].concat(patterns2)) {
        let isMatch2 = picomatch(String(pattern2), options2);
        if (!items.every((item) => isMatch2(item))) {
          return false;
        }
      }
      return true;
    };
    micromatch.all = (str, patterns2, options2) => {
      if (typeof str !== "string") {
        throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
      }
      return [].concat(patterns2).every((p2) => picomatch(p2, options2)(str));
    };
    micromatch.capture = (glob2, input, options2) => {
      let posix2 = utils.isWindows(options2);
      let regex = picomatch.makeRe(String(glob2), __spreadProps2(__spreadValues2({}, options2), { capture: true }));
      let match2 = regex.exec(posix2 ? utils.toPosixSlashes(input) : input);
      if (match2) {
        return match2.slice(1).map((v2) => v2 === void 0 ? "" : v2);
      }
    };
    micromatch.makeRe = (...args) => picomatch.makeRe(...args);
    micromatch.scan = (...args) => picomatch.scan(...args);
    micromatch.parse = (patterns2, options2) => {
      let res = [];
      for (let pattern2 of [].concat(patterns2 || [])) {
        for (let str of braces(String(pattern2), options2)) {
          res.push(picomatch.parse(str, options2));
        }
      }
      return res;
    };
    micromatch.braces = (pattern2, options2) => {
      if (typeof pattern2 !== "string")
        throw new TypeError("Expected a string");
      if (options2 && options2.nobrace === true || !/\{.*\}/.test(pattern2)) {
        return [pattern2];
      }
      return braces(pattern2, options2);
    };
    micromatch.braceExpand = (pattern2, options2) => {
      if (typeof pattern2 !== "string")
        throw new TypeError("Expected a string");
      return micromatch.braces(pattern2, __spreadProps2(__spreadValues2({}, options2), { expand: true }));
    };
    var micromatch_1 = micromatch;
    var sirvOptions = {
      dev: true,
      etag: true,
      extensions: [],
      setHeaders(res, pathname) {
        if (/\.[tj]sx?$/.test(pathname)) {
          res.setHeader("Content-Type", "application/javascript");
        }
      }
    };
    function servePublicMiddleware(dir) {
      const serve = sirv(dir, sirvOptions);
      return function viteServePublicMiddleware(req2, res, next) {
        if (isImportRequest(req2.url) || isInternalRequest(req2.url)) {
          return next();
        }
        serve(req2, res, next);
      };
    }
    function serveStaticMiddleware(dir, server2) {
      const serve = sirv(dir, sirvOptions);
      return function viteServeStaticMiddleware(req2, res, next) {
        const cleanedUrl = cleanUrl(req2.url);
        if (cleanedUrl.endsWith("/") || path__default.extname(cleanedUrl) === ".html" || isInternalRequest(req2.url)) {
          return next();
        }
        const url2 = decodeURI(req2.url);
        let redirected;
        for (const { find: find2, replacement: replacement2 } of server2.config.resolve.alias) {
          const matches2 = typeof find2 === "string" ? url2.startsWith(find2) : find2.test(url2);
          if (matches2) {
            redirected = url2.replace(find2, replacement2);
            break;
          }
        }
        if (redirected) {
          if (redirected.startsWith(dir)) {
            redirected = redirected.slice(dir.length);
          }
        }
        const resolvedUrl = redirected || url2;
        let fileUrl = path__default.resolve(dir, resolvedUrl.replace(/^\//, ""));
        if (resolvedUrl.endsWith("/") && !fileUrl.endsWith("/")) {
          fileUrl = fileUrl + "/";
        }
        if (!ensureServingAccess(fileUrl, server2, res, next)) {
          return;
        }
        if (redirected) {
          req2.url = redirected;
        }
        serve(req2, res, next);
      };
    }
    function serveRawFsMiddleware(server2) {
      const serveFromRoot = sirv("/", sirvOptions);
      return function viteServeRawFsMiddleware(req2, res, next) {
        let url2 = decodeURI(req2.url);
        if (url2.startsWith(FS_PREFIX)) {
          if (!ensureServingAccess(slash$1(path__default.resolve(fsPathFromId(url2))), server2, res, next)) {
            return;
          }
          url2 = url2.slice(FS_PREFIX.length);
          if (isWindows$4)
            url2 = url2.replace(/^[A-Z]:/i, "");
          req2.url = url2;
          serveFromRoot(req2, res, next);
        } else {
          next();
        }
      };
    }
    var _matchOptions = { matchBase: true };
    function isFileServingAllowed(url2, server2) {
      if (!server2.config.server.fs.strict)
        return true;
      const file = fsPathFromUrl(url2);
      if (server2.config.server.fs.deny.some((i2) => micromatch_1.isMatch(file, i2, _matchOptions)))
        return false;
      if (server2.moduleGraph.safeModulesPath.has(file))
        return true;
      if (server2.config.server.fs.allow.some((dir) => isParentDirectory(dir, file)))
        return true;
      return false;
    }
    function ensureServingAccess(url2, server2, res, next) {
      if (isFileServingAllowed(url2, server2)) {
        return true;
      }
      if (isFileReadable(cleanUrl(url2))) {
        const urlMessage = `The request url "${url2}" is outside of Vite serving allow list.`;
        const hintMessage = `
${server2.config.server.fs.allow.map((i2) => `- ${i2}`).join("\n")}

Refer to docs https://vitejs.dev/config/#server-fs-allow for configurations and more details.`;
        server2.config.logger.error(urlMessage);
        server2.config.logger.warnOnce(hintMessage + "\n");
        res.statusCode = 403;
        res.write(renderRestrictedErrorHTML(urlMessage + "\n" + hintMessage));
        res.end();
      } else {
        next();
      }
      return false;
    }
    function renderRestrictedErrorHTML(msg) {
      const html = String.raw;
      return html`
    <body>
      <h1>403 Restricted</h1>
      <p>${msg.replace(/\n/g, "<br/>")}</p>
      <style>
        body {
          padding: 1em 2em;
        }
      </style>
    </body>
  `;
    }
    var debugLoad = createDebugger("vite:load");
    var debugTransform = createDebugger("vite:transform");
    var debugCache$1 = createDebugger("vite:cache");
    var isDebug$3 = !!process.env.DEBUG;
    function transformRequest(url2, server2, options2 = {}) {
      const cacheKey = (options2.ssr ? "ssr:" : options2.html ? "html:" : "") + url2;
      const timestamp2 = Date.now();
      const pending = server2._pendingRequests.get(cacheKey);
      if (pending) {
        return server2.moduleGraph.getModuleByUrl(removeTimestampQuery(url2), options2.ssr).then((module2) => {
          if (!module2 || pending.timestamp > module2.lastInvalidationTimestamp) {
            return pending.request;
          } else {
            pending.abort();
            return transformRequest(url2, server2, options2);
          }
        });
      }
      const request = doTransform(url2, server2, options2, timestamp2);
      let cleared = false;
      const clearCache = () => {
        if (!cleared) {
          server2._pendingRequests.delete(cacheKey);
          cleared = true;
        }
      };
      server2._pendingRequests.set(cacheKey, {
        request,
        timestamp: timestamp2,
        abort: clearCache
      });
      request.then(clearCache, clearCache);
      return request;
    }
    async function doTransform(url2, server2, options2, timestamp2) {
      var _a2, _b;
      url2 = removeTimestampQuery(url2);
      const { config: config2, pluginContainer, moduleGraph, watcher } = server2;
      const { root: root2, logger } = config2;
      const prettyUrl = isDebug$3 ? prettifyUrl(url2, root2) : "";
      const ssr = !!options2.ssr;
      const module2 = await server2.moduleGraph.getModuleByUrl(url2, ssr);
      const cached = module2 && (ssr ? module2.ssrTransformResult : module2.transformResult);
      if (cached) {
        isDebug$3 && debugCache$1(`[memory] ${prettyUrl}`);
        return cached;
      }
      const id = ((_a2 = await pluginContainer.resolveId(url2, void 0, { ssr })) === null || _a2 === void 0 ? void 0 : _a2.id) || url2;
      const file = cleanUrl(id);
      let code = null;
      let map2 = null;
      const loadStart = isDebug$3 ? perf_hooks.performance.now() : 0;
      const loadResult = await pluginContainer.load(id, { ssr });
      if (loadResult == null) {
        if (options2.html && !id.endsWith(".html")) {
          return null;
        }
        if (options2.ssr || isFileServingAllowed(file, server2)) {
          try {
            code = await fs$n.promises.readFile(file, "utf-8");
            isDebug$3 && debugLoad(`${timeFrom(loadStart)} [fs] ${prettyUrl}`);
          } catch (e2) {
            if (e2.code !== "ENOENT") {
              throw e2;
            }
          }
        }
        if (code) {
          try {
            map2 = (_b = convertSourceMap.fromSource(code) || convertSourceMap.fromMapFileSource(code, path__default.dirname(file))) === null || _b === void 0 ? void 0 : _b.toObject();
          } catch (e2) {
            logger.warn(`Failed to load source map for ${url2}.`, {
              timestamp: true
            });
          }
        }
      } else {
        isDebug$3 && debugLoad(`${timeFrom(loadStart)} [plugin] ${prettyUrl}`);
        if (isObject$5(loadResult)) {
          code = loadResult.code;
          map2 = loadResult.map;
        } else {
          code = loadResult;
        }
      }
      if (code == null) {
        if (checkPublicFile(url2, config2)) {
          throw new Error(`Failed to load url ${url2} (resolved id: ${id}). This file is in /public and will be copied as-is during build without going through the plugin transforms, and therefore should not be imported from source code. It can only be referenced via HTML tags.`);
        } else {
          return null;
        }
      }
      const mod = await moduleGraph.ensureEntryFromUrl(url2, ssr);
      ensureWatchedFile(watcher, mod.file, root2);
      const transformStart = isDebug$3 ? perf_hooks.performance.now() : 0;
      const transformResult = await pluginContainer.transform(code, id, {
        inMap: map2,
        ssr
      });
      if (transformResult == null || isObject$5(transformResult) && transformResult.code == null) {
        isDebug$3 && debugTransform(timeFrom(transformStart) + colors$1.dim(` [skipped] ${prettyUrl}`));
      } else {
        isDebug$3 && debugTransform(`${timeFrom(transformStart)} ${prettyUrl}`);
        code = transformResult.code;
        map2 = transformResult.map;
      }
      if (map2 && mod.file) {
        map2 = typeof map2 === "string" ? JSON.parse(map2) : map2;
        if (map2.mappings && !map2.sourcesContent) {
          await injectSourcesContent(map2, mod.file, logger);
        }
      }
      const result2 = ssr ? await ssrTransform(code, map2, url2) : {
        code,
        map: map2,
        etag: etag_1(code, { weak: true })
      };
      if (timestamp2 > mod.lastInvalidationTimestamp) {
        if (ssr)
          mod.ssrTransformResult = result2;
        else
          mod.transformResult = result2;
      }
      return result2;
    }
    var ERR_OPTIMIZE_DEPS_PROCESSING_ERROR = "ERR_OPTIMIZE_DEPS_PROCESSING_ERROR";
    var ERR_OUTDATED_OPTIMIZED_DEP = "ERR_OUTDATED_OPTIMIZED_DEP";
    var isDebug$2 = process.env.DEBUG;
    var debug$2 = createDebugger("vite:optimize-deps");
    function optimizedDepsPlugin() {
      let server2;
      return {
        name: "vite:optimized-deps",
        configureServer(_server) {
          server2 = _server;
        },
        async load(id) {
          var _a2, _b;
          if (server2 && isOptimizedDepFile(id, server2.config)) {
            const metadata = (_a2 = server2 === null || server2 === void 0 ? void 0 : server2._optimizedDeps) === null || _a2 === void 0 ? void 0 : _a2.metadata;
            if (metadata) {
              const file = cleanUrl(id);
              const versionMatch = id.match(DEP_VERSION_RE);
              const browserHash = versionMatch ? versionMatch[1].split("=")[1] : void 0;
              const info = optimizedDepInfoFromFile(metadata, file);
              if (info) {
                if (browserHash && info.browserHash !== browserHash) {
                  throwOutdatedRequest(id);
                }
                try {
                  await info.processing;
                } catch {
                  throwProcessingError(id);
                  return;
                }
                const newMetadata = (_b = server2._optimizedDeps) === null || _b === void 0 ? void 0 : _b.metadata;
                if (metadata !== newMetadata) {
                  const currentInfo = optimizedDepInfoFromFile(newMetadata, file);
                  if (info.browserHash !== (currentInfo === null || currentInfo === void 0 ? void 0 : currentInfo.browserHash)) {
                    throwOutdatedRequest(id);
                  }
                }
              }
              isDebug$2 && debug$2(`load ${colors$1.cyan(file)}`);
              try {
                return await fs$n.promises.readFile(file, "utf-8");
              } catch (e2) {
                throwOutdatedRequest(id);
              }
            }
          }
        }
      };
    }
    function throwProcessingError(id) {
      const err = new Error(`Something unexpected happened while optimizing "${id}". The current page should have reloaded by now`);
      err.code = ERR_OPTIMIZE_DEPS_PROCESSING_ERROR;
      throw err;
    }
    function throwOutdatedRequest(id) {
      const err = new Error(`There is a new version of the pre-bundle for "${id}", a page reload is going to ask for it.`);
      err.code = ERR_OUTDATED_OPTIMIZED_DEP;
      throw err;
    }
    var debugCache = createDebugger("vite:cache");
    var isDebug$1 = !!process.env.DEBUG;
    var knownIgnoreList = /* @__PURE__ */ new Set(["/", "/favicon.ico"]);
    function transformMiddleware(server2) {
      const { config: { root: root2, logger }, moduleGraph } = server2;
      const isOptimizedDepUrl = createIsOptimizedDepUrl(server2.config);
      return async function viteTransformMiddleware(req2, res, next) {
        var _a2, _b, _c, _d, _e2, _f;
        if (req2.method !== "GET" || knownIgnoreList.has(req2.url)) {
          return next();
        }
        let url2;
        try {
          url2 = decodeURI(removeTimestampQuery(req2.url)).replace(NULL_BYTE_PLACEHOLDER, "\0");
        } catch (e2) {
          return next(e2);
        }
        const withoutQuery = cleanUrl(url2);
        try {
          const isSourceMap = withoutQuery.endsWith(".map");
          if (isSourceMap) {
            if (isOptimizedDepUrl(url2)) {
              const mapFile = url2.startsWith(FS_PREFIX) ? fsPathFromId(url2) : normalizePath$4(ensureVolumeInPath(path__default.resolve(root2, url2.slice(1))));
              try {
                const map2 = await fs$n.promises.readFile(mapFile, "utf-8");
                return send$1(req2, res, map2, "json", {
                  headers: server2.config.server.headers
                });
              } catch (e2) {
                const dummySourceMap = {
                  version: 3,
                  file: mapFile.replace(/\.map$/, ""),
                  sources: [],
                  sourcesContent: [],
                  names: [],
                  mappings: ";;;;;;;;;"
                };
                return send$1(req2, res, JSON.stringify(dummySourceMap), "json", {
                  cacheControl: "no-cache",
                  headers: server2.config.server.headers
                });
              }
            } else {
              const originalUrl = url2.replace(/\.map($|\?)/, "$1");
              const map2 = (_b = (_a2 = await moduleGraph.getModuleByUrl(originalUrl, false)) === null || _a2 === void 0 ? void 0 : _a2.transformResult) === null || _b === void 0 ? void 0 : _b.map;
              if (map2) {
                return send$1(req2, res, JSON.stringify(map2), "json", {
                  headers: server2.config.server.headers
                });
              } else {
                return next();
              }
            }
          }
          const publicDir = normalizePath$4(server2.config.publicDir);
          const rootDir = normalizePath$4(server2.config.root);
          if (publicDir.startsWith(rootDir)) {
            const publicPath = `${publicDir.slice(rootDir.length)}/`;
            if (url2.startsWith(publicPath)) {
              logger.warn(colors$1.yellow(`files in the public directory are served at the root path.
Instead of ${colors$1.cyan(url2)}, use ${colors$1.cyan(url2.replace(publicPath, "/"))}.`));
            }
          }
          if (isJSRequest(url2) || isImportRequest(url2) || isCSSRequest(url2) || isHTMLProxy(url2)) {
            url2 = removeImportQuery(url2);
            url2 = unwrapId$1(url2);
            if (isCSSRequest(url2) && !isDirectRequest(url2) && ((_c = req2.headers.accept) === null || _c === void 0 ? void 0 : _c.includes("text/css"))) {
              url2 = injectQuery(url2, "direct");
            }
            const ifNoneMatch = req2.headers["if-none-match"];
            if (ifNoneMatch && ((_e2 = (_d = await moduleGraph.getModuleByUrl(url2, false)) === null || _d === void 0 ? void 0 : _d.transformResult) === null || _e2 === void 0 ? void 0 : _e2.etag) === ifNoneMatch) {
              isDebug$1 && debugCache(`[304] ${prettifyUrl(url2, root2)}`);
              res.statusCode = 304;
              return res.end();
            }
            const result2 = await transformRequest(url2, server2, {
              html: (_f = req2.headers.accept) === null || _f === void 0 ? void 0 : _f.includes("text/html")
            });
            if (result2) {
              const type = isDirectCSSRequest(url2) ? "css" : "js";
              const isDep = DEP_VERSION_RE.test(url2) || isOptimizedDepUrl(url2);
              return send$1(req2, res, result2.code, type, {
                etag: result2.etag,
                cacheControl: isDep ? "max-age=31536000,immutable" : "no-cache",
                headers: server2.config.server.headers,
                map: result2.map
              });
            }
          }
        } catch (e2) {
          if ((e2 === null || e2 === void 0 ? void 0 : e2.code) === ERR_OPTIMIZE_DEPS_PROCESSING_ERROR) {
            if (!res.writableEnded) {
              res.statusCode = 504;
              res.end();
            }
            logger.error(e2.message);
            return;
          }
          if ((e2 === null || e2 === void 0 ? void 0 : e2.code) === ERR_OUTDATED_OPTIMIZED_DEP) {
            if (!res.writableEnded) {
              res.statusCode = 504;
              res.end();
            }
            return;
          }
          return next(e2);
        }
        next();
      };
    }
    function createDevHtmlTransformFn(server2) {
      const [preHooks, postHooks] = resolveHtmlTransforms(server2.config.plugins);
      return (url2, html, originalUrl) => {
        return applyHtmlTransforms(html, [...preHooks, devHtmlHook, ...postHooks], {
          path: url2,
          filename: getHtmlFilename(url2, server2),
          server: server2,
          originalUrl
        });
      };
    }
    function getHtmlFilename(url2, server2) {
      if (url2.startsWith(FS_PREFIX)) {
        return decodeURIComponent(fsPathFromId(url2));
      } else {
        return decodeURIComponent(normalizePath$4(path__default.join(server2.config.root, url2.slice(1))));
      }
    }
    var startsWithSingleSlashRE = /^\/(?!\/)/;
    var processNodeUrl = (node2, s2, config2, htmlPath, originalUrl, moduleGraph) => {
      var _a2;
      let url2 = ((_a2 = node2.value) === null || _a2 === void 0 ? void 0 : _a2.content) || "";
      if (moduleGraph) {
        const mod = moduleGraph.urlToModuleMap.get(url2);
        if (mod && mod.lastHMRTimestamp > 0) {
          url2 = injectQuery(url2, `t=${mod.lastHMRTimestamp}`);
        }
      }
      if (startsWithSingleSlashRE.test(url2)) {
        s2.overwrite(node2.value.loc.start.offset, node2.value.loc.end.offset, `"${config2.base + url2.slice(1)}"`, { contentOnly: true });
      } else if (url2.startsWith(".") && originalUrl && originalUrl !== "/" && htmlPath === "/index.html") {
        s2.overwrite(node2.value.loc.start.offset, node2.value.loc.end.offset, `"${path__default.posix.join(path__default.posix.relative(originalUrl, "/"), url2.slice(1))}"`, { contentOnly: true });
      }
    };
    var devHtmlHook = async (html, { path: htmlPath, filename: filename2, server: server2, originalUrl }) => {
      const { config: config2, moduleGraph } = server2;
      const base2 = config2.base || "/";
      const s2 = new MagicString(html);
      let inlineModuleIndex = -1;
      const filePath = cleanUrl(htmlPath);
      const addInlineModule = (node2, ext2) => {
        inlineModuleIndex++;
        const url2 = filePath.replace(normalizePath$4(config2.root), "");
        const contentNode = node2.children[0];
        const code = contentNode.content;
        const map2 = new MagicString(html).snip(contentNode.loc.start.offset, contentNode.loc.end.offset).generateMap({ hires: true });
        map2.sources = [filename2];
        map2.file = filename2;
        addToHTMLProxyCache(config2, url2, inlineModuleIndex, { code, map: map2 });
        const modulePath = `${config2.base + htmlPath.slice(1)}?html-proxy&index=${inlineModuleIndex}.${ext2}`;
        const module2 = server2 === null || server2 === void 0 ? void 0 : server2.moduleGraph.getModuleById(modulePath);
        if (module2) {
          server2 === null || server2 === void 0 ? void 0 : server2.moduleGraph.invalidateModule(module2);
        }
        s2.overwrite(node2.loc.start.offset, node2.loc.end.offset, `<script type="module" src="${modulePath}"><\/script>`, { contentOnly: true });
      };
      await traverseHtml(html, htmlPath, (node2) => {
        if (node2.type !== 1) {
          return;
        }
        if (node2.tag === "script") {
          const { src: src2, isModule } = getScriptInfo(node2);
          if (src2) {
            processNodeUrl(src2, s2, config2, htmlPath, originalUrl, moduleGraph);
          } else if (isModule && node2.children.length) {
            addInlineModule(node2, "js");
          }
        }
        if (node2.tag === "style" && node2.children.length) {
          addInlineModule(node2, "css");
        }
        const assetAttrs = assetAttrsConfig[node2.tag];
        if (assetAttrs) {
          for (const p2 of node2.props) {
            if (p2.type === 6 && p2.value && assetAttrs.includes(p2.name)) {
              processNodeUrl(p2, s2, config2, htmlPath, originalUrl);
            }
          }
        }
      });
      html = s2.toString();
      return {
        html,
        tags: [
          {
            tag: "script",
            attrs: {
              type: "module",
              src: path__default.posix.join(base2, CLIENT_PUBLIC_PATH)
            },
            injectTo: "head-prepend"
          }
        ]
      };
    };
    function indexHtmlMiddleware(server2) {
      return async function viteIndexHtmlMiddleware(req2, res, next) {
        if (res.writableEnded) {
          return next();
        }
        const url2 = req2.url && cleanUrl(req2.url);
        if ((url2 === null || url2 === void 0 ? void 0 : url2.endsWith(".html")) && req2.headers["sec-fetch-dest"] !== "script") {
          const filename2 = getHtmlFilename(url2, server2);
          if (fs__default.existsSync(filename2)) {
            try {
              let html = fs__default.readFileSync(filename2, "utf-8");
              html = await server2.transformIndexHtml(url2, html, req2.originalUrl);
              return send$1(req2, res, html, "html", {
                headers: server2.config.server.headers
              });
            } catch (e2) {
              return next(e2);
            }
          }
        }
        next();
      };
    }
    var logTime = createDebugger("vite:time");
    function timeMiddleware(root2) {
      return function viteTimeMiddleware(req2, res, next) {
        const start = perf_hooks.performance.now();
        const end = res.end;
        res.end = (...args) => {
          logTime(`${timeFrom(start)} ${prettifyUrl(req2.url, root2)}`);
          return end.call(res, ...args);
        };
        next();
      };
    }
    var ModuleNode = class {
      constructor(url2) {
        this.id = null;
        this.file = null;
        this.importers = /* @__PURE__ */ new Set();
        this.importedModules = /* @__PURE__ */ new Set();
        this.acceptedHmrDeps = /* @__PURE__ */ new Set();
        this.isSelfAccepting = false;
        this.transformResult = null;
        this.ssrTransformResult = null;
        this.ssrModule = null;
        this.lastHMRTimestamp = 0;
        this.lastInvalidationTimestamp = 0;
        this.url = url2;
        this.type = isDirectCSSRequest(url2) ? "css" : "js";
      }
    };
    function invalidateSSRModule(mod, seen2) {
      if (seen2.has(mod)) {
        return;
      }
      seen2.add(mod);
      mod.ssrModule = null;
      mod.importers.forEach((importer) => invalidateSSRModule(importer, seen2));
    }
    var ModuleGraph = class {
      constructor(resolveId2) {
        this.resolveId = resolveId2;
        this.urlToModuleMap = /* @__PURE__ */ new Map();
        this.idToModuleMap = /* @__PURE__ */ new Map();
        this.fileToModulesMap = /* @__PURE__ */ new Map();
        this.safeModulesPath = /* @__PURE__ */ new Set();
      }
      async getModuleByUrl(rawUrl, ssr) {
        const [url2] = await this.resolveUrl(rawUrl, ssr);
        return this.urlToModuleMap.get(url2);
      }
      getModuleById(id) {
        return this.idToModuleMap.get(removeTimestampQuery(id));
      }
      getModulesByFile(file) {
        return this.fileToModulesMap.get(file);
      }
      onFileChange(file) {
        const mods = this.getModulesByFile(file);
        if (mods) {
          const seen2 = /* @__PURE__ */ new Set();
          mods.forEach((mod) => {
            this.invalidateModule(mod, seen2);
          });
        }
      }
      invalidateModule(mod, seen2 = /* @__PURE__ */ new Set(), timestamp2 = Date.now()) {
        mod.lastInvalidationTimestamp = timestamp2;
        mod.transformResult = null;
        mod.ssrTransformResult = null;
        invalidateSSRModule(mod, seen2);
      }
      invalidateAll() {
        const timestamp2 = Date.now();
        const seen2 = /* @__PURE__ */ new Set();
        this.idToModuleMap.forEach((mod) => {
          this.invalidateModule(mod, seen2, timestamp2);
        });
      }
      async updateModuleInfo(mod, importedModules, acceptedModules, isSelfAccepting, ssr) {
        mod.isSelfAccepting = isSelfAccepting;
        const prevImports = mod.importedModules;
        const nextImports = mod.importedModules = /* @__PURE__ */ new Set();
        let noLongerImported;
        for (const imported of importedModules) {
          const dep = typeof imported === "string" ? await this.ensureEntryFromUrl(imported, ssr) : imported;
          dep.importers.add(mod);
          nextImports.add(dep);
        }
        prevImports.forEach((dep) => {
          if (!nextImports.has(dep)) {
            dep.importers.delete(mod);
            if (!dep.importers.size) {
              (noLongerImported || (noLongerImported = /* @__PURE__ */ new Set())).add(dep);
            }
          }
        });
        const deps = mod.acceptedHmrDeps = /* @__PURE__ */ new Set();
        for (const accepted of acceptedModules) {
          const dep = typeof accepted === "string" ? await this.ensureEntryFromUrl(accepted, ssr) : accepted;
          deps.add(dep);
        }
        return noLongerImported;
      }
      async ensureEntryFromUrl(rawUrl, ssr) {
        const [url2, resolvedId, meta] = await this.resolveUrl(rawUrl, ssr);
        let mod = this.urlToModuleMap.get(url2);
        if (!mod) {
          mod = new ModuleNode(url2);
          if (meta)
            mod.meta = meta;
          this.urlToModuleMap.set(url2, mod);
          mod.id = resolvedId;
          this.idToModuleMap.set(resolvedId, mod);
          const file = mod.file = cleanUrl(resolvedId);
          let fileMappedModules = this.fileToModulesMap.get(file);
          if (!fileMappedModules) {
            fileMappedModules = /* @__PURE__ */ new Set();
            this.fileToModulesMap.set(file, fileMappedModules);
          }
          fileMappedModules.add(mod);
        }
        return mod;
      }
      createFileOnlyEntry(file) {
        file = normalizePath$4(file);
        let fileMappedModules = this.fileToModulesMap.get(file);
        if (!fileMappedModules) {
          fileMappedModules = /* @__PURE__ */ new Set();
          this.fileToModulesMap.set(file, fileMappedModules);
        }
        const url2 = `${FS_PREFIX}${file}`;
        for (const m3 of fileMappedModules) {
          if (m3.url === url2 || m3.id === file) {
            return m3;
          }
        }
        const mod = new ModuleNode(url2);
        mod.file = file;
        fileMappedModules.add(mod);
        return mod;
      }
      async resolveUrl(url2, ssr) {
        url2 = removeImportQuery(removeTimestampQuery(url2));
        const resolved = await this.resolveId(url2, !!ssr);
        const resolvedId = (resolved === null || resolved === void 0 ? void 0 : resolved.id) || url2;
        const ext2 = path$r.extname(cleanUrl(resolvedId));
        const { pathname, search, hash } = require$$0$4.parse(url2);
        if (ext2 && !pathname.endsWith(ext2)) {
          url2 = pathname + ext2 + (search || "") + (hash || "");
        }
        return [url2, resolvedId, resolved === null || resolved === void 0 ? void 0 : resolved.meta];
      }
    };
    var debugHmr = createDebugger("vite:hmr");
    var normalizedClientDir = normalizePath$4(CLIENT_DIR);
    function getShortName(file, root2) {
      return file.startsWith(root2 + "/") ? path__default.posix.relative(root2, file) : file;
    }
    async function handleHMRUpdate(file, server2) {
      const { ws: ws2, config: config2, moduleGraph } = server2;
      const shortFile = getShortName(file, config2.root);
      const isConfig = file === config2.configFile;
      const isConfigDependency = config2.configFileDependencies.some((name) => file === name);
      const isEnv = config2.inlineConfig.envFile !== false && (file === ".env" || file.startsWith(".env."));
      if (isConfig || isConfigDependency || isEnv) {
        debugHmr(`[config change] ${colors$1.dim(shortFile)}`);
        config2.logger.info(colors$1.green(`${path__default.relative(process.cwd(), file)} changed, restarting server...`), { clear: true, timestamp: true });
        try {
          await server2.restart();
        } catch (e2) {
          config2.logger.error(colors$1.red(e2));
        }
        return;
      }
      debugHmr(`[file change] ${colors$1.dim(shortFile)}`);
      if (file.startsWith(normalizedClientDir)) {
        ws2.send({
          type: "full-reload",
          path: "*"
        });
        return;
      }
      const mods = moduleGraph.getModulesByFile(file);
      const timestamp2 = Date.now();
      const hmrContext = {
        file,
        timestamp: timestamp2,
        modules: mods ? [...mods] : [],
        read: () => readModifiedFile(file),
        server: server2
      };
      for (const plugin of config2.plugins) {
        if (plugin.handleHotUpdate) {
          const filteredModules = await plugin.handleHotUpdate(hmrContext);
          if (filteredModules) {
            hmrContext.modules = filteredModules;
          }
        }
      }
      if (!hmrContext.modules.length) {
        if (file.endsWith(".html")) {
          config2.logger.info(colors$1.green(`page reload `) + colors$1.dim(shortFile), {
            clear: true,
            timestamp: true
          });
          ws2.send({
            type: "full-reload",
            path: config2.server.middlewareMode ? "*" : "/" + normalizePath$4(path__default.relative(config2.root, file))
          });
        } else {
          debugHmr(`[no modules matched] ${colors$1.dim(shortFile)}`);
        }
        return;
      }
      updateModules(shortFile, hmrContext.modules, timestamp2, server2);
    }
    function updateModules(file, modules, timestamp2, { config: config2, ws: ws2 }) {
      const updates = [];
      const invalidatedModules = /* @__PURE__ */ new Set();
      let needFullReload = false;
      for (const mod of modules) {
        invalidate(mod, timestamp2, invalidatedModules);
        if (needFullReload) {
          continue;
        }
        const boundaries = /* @__PURE__ */ new Set();
        const hasDeadEnd = propagateUpdate(mod, boundaries);
        if (hasDeadEnd) {
          needFullReload = true;
          continue;
        }
        updates.push(...[...boundaries].map(({ boundary, acceptedVia }) => ({
          type: `${boundary.type}-update`,
          timestamp: timestamp2,
          path: boundary.url,
          acceptedPath: acceptedVia.url
        })));
      }
      if (needFullReload) {
        config2.logger.info(colors$1.green(`page reload `) + colors$1.dim(file), {
          clear: true,
          timestamp: true
        });
        ws2.send({
          type: "full-reload"
        });
      } else {
        config2.logger.info(updates.map(({ path: path2 }) => colors$1.green(`hmr update `) + colors$1.dim(path2)).join("\n"), { clear: true, timestamp: true });
        ws2.send({
          type: "update",
          updates
        });
      }
    }
    async function handleFileAddUnlink(file, server2, isUnlink = false) {
      var _a2;
      const modules = [...(_a2 = server2.moduleGraph.getModulesByFile(file)) !== null && _a2 !== void 0 ? _a2 : []];
      if (isUnlink && file in server2._globImporters) {
        delete server2._globImporters[file];
      } else {
        for (const i2 in server2._globImporters) {
          const { module: module2, importGlobs } = server2._globImporters[i2];
          for (const { base: base2, pattern: pattern2 } of importGlobs) {
            if (micromatch_1.isMatch(file, pattern2) || micromatch_1.isMatch(path__default.relative(base2, file), pattern2)) {
              modules.push(module2);
              server2.moduleGraph.onFileChange(module2.file);
              break;
            }
          }
        }
      }
      if (modules.length > 0) {
        updateModules(getShortName(file, server2.config.root), modules, Date.now(), server2);
      }
    }
    function propagateUpdate(node2, boundaries, currentChain = [node2]) {
      if (node2.isSelfAccepting) {
        boundaries.add({
          boundary: node2,
          acceptedVia: node2
        });
        for (const importer of node2.importers) {
          if (isCSSRequest(importer.url) && !currentChain.includes(importer)) {
            propagateUpdate(importer, boundaries, currentChain.concat(importer));
          }
        }
        return false;
      }
      if (!node2.importers.size) {
        return true;
      }
      if (!isCSSRequest(node2.url) && [...node2.importers].every((i2) => isCSSRequest(i2.url))) {
        return true;
      }
      for (const importer of node2.importers) {
        const subChain = currentChain.concat(importer);
        if (importer.acceptedHmrDeps.has(node2)) {
          boundaries.add({
            boundary: importer,
            acceptedVia: node2
          });
          continue;
        }
        if (currentChain.includes(importer)) {
          return true;
        }
        if (propagateUpdate(importer, boundaries, subChain)) {
          return true;
        }
      }
      return false;
    }
    function invalidate(mod, timestamp2, seen2) {
      if (seen2.has(mod)) {
        return;
      }
      seen2.add(mod);
      mod.lastHMRTimestamp = timestamp2;
      mod.transformResult = null;
      mod.ssrModule = null;
      mod.ssrTransformResult = null;
      mod.importers.forEach((importer) => {
        if (!importer.acceptedHmrDeps.has(mod)) {
          invalidate(importer, timestamp2, seen2);
        }
      });
    }
    function handlePrunedModules(mods, { ws: ws2 }) {
      const t = Date.now();
      mods.forEach((mod) => {
        mod.lastHMRTimestamp = t;
        debugHmr(`[dispose] ${colors$1.dim(mod.file)}`);
      });
      ws2.send({
        type: "prune",
        paths: [...mods].map((m3) => m3.url)
      });
    }
    function lexAcceptedHmrDeps(code, start, urls) {
      let state = 0;
      let prevState = 0;
      let currentDep = "";
      function addDep(index2) {
        urls.add({
          url: currentDep,
          start: index2 - currentDep.length - 1,
          end: index2 + 1
        });
        currentDep = "";
      }
      for (let i2 = start; i2 < code.length; i2++) {
        const char = code.charAt(i2);
        switch (state) {
          case 0:
          case 4:
            if (char === `'`) {
              prevState = state;
              state = 1;
            } else if (char === `"`) {
              prevState = state;
              state = 2;
            } else if (char === "`") {
              prevState = state;
              state = 3;
            } else if (/\s/.test(char)) {
              continue;
            } else {
              if (state === 0) {
                if (char === `[`) {
                  state = 4;
                } else {
                  return true;
                }
              } else if (state === 4) {
                if (char === `]`) {
                  return false;
                } else if (char === ",") {
                  continue;
                } else {
                  error(i2);
                }
              }
            }
            break;
          case 1:
            if (char === `'`) {
              addDep(i2);
              if (prevState === 0) {
                return false;
              } else {
                state = prevState;
              }
            } else {
              currentDep += char;
            }
            break;
          case 2:
            if (char === `"`) {
              addDep(i2);
              if (prevState === 0) {
                return false;
              } else {
                state = prevState;
              }
            } else {
              currentDep += char;
            }
            break;
          case 3:
            if (char === "`") {
              addDep(i2);
              if (prevState === 0) {
                return false;
              } else {
                state = prevState;
              }
            } else if (char === "$" && code.charAt(i2 + 1) === "{") {
              error(i2);
            } else {
              currentDep += char;
            }
            break;
          default:
            throw new Error("unknown import.meta.hot lexer state");
        }
      }
      return false;
    }
    function error(pos2) {
      const err = new Error(`import.meta.accept() can only accept string literals or an Array of string literals.`);
      err.pos = pos2;
      throw err;
    }
    async function readModifiedFile(file) {
      const content2 = fs__default.readFileSync(file, "utf-8");
      if (!content2) {
        const mtime = fs__default.statSync(file).mtimeMs;
        await new Promise((r2) => {
          let n3 = 0;
          const poll = async () => {
            n3++;
            const newMtime = fs__default.statSync(file).mtimeMs;
            if (newMtime !== mtime || n3 > 10) {
              r2(0);
            } else {
              setTimeout(poll, 10);
            }
          };
          setTimeout(poll, 10);
        });
        return fs__default.readFileSync(file, "utf-8");
      } else {
        return content2;
      }
    }
    var isWsl$2 = { exports: {} };
    var fs$7 = fs__default;
    var isDocker$2;
    function hasDockerEnv() {
      try {
        fs$7.statSync("/.dockerenv");
        return true;
      } catch (_2) {
        return false;
      }
    }
    function hasDockerCGroup() {
      try {
        return fs$7.readFileSync("/proc/self/cgroup", "utf8").includes("docker");
      } catch (_2) {
        return false;
      }
    }
    var isDocker_1 = () => {
      if (isDocker$2 === void 0) {
        isDocker$2 = hasDockerEnv() || hasDockerCGroup();
      }
      return isDocker$2;
    };
    var os$2 = require$$1__default;
    var fs$6 = fs__default;
    var isDocker$1 = isDocker_1;
    var isWsl$1 = () => {
      if (process.platform !== "linux") {
        return false;
      }
      if (os$2.release().toLowerCase().includes("microsoft")) {
        if (isDocker$1()) {
          return false;
        }
        return true;
      }
      try {
        return fs$6.readFileSync("/proc/version", "utf8").toLowerCase().includes("microsoft") ? !isDocker$1() : false;
      } catch (_2) {
        return false;
      }
    };
    if (process.env.__IS_WSL_TEST__) {
      isWsl$2.exports = isWsl$1;
    } else {
      isWsl$2.exports = isWsl$1();
    }
    var defineLazyProp = (object, propertyName, fn2) => {
      const define = (value) => Object.defineProperty(object, propertyName, { value, enumerable: true, writable: true });
      Object.defineProperty(object, propertyName, {
        configurable: true,
        enumerable: true,
        get() {
          const result2 = fn2();
          define(result2);
          return result2;
        },
        set(value) {
          define(value);
        }
      });
      return object;
    };
    var path$8 = path__default;
    var childProcess$2 = require$$1__default$5;
    var { promises: fs$5, constants: fsConstants } = fs__default;
    var isWsl = isWsl$2.exports;
    var isDocker = isDocker_1;
    var defineLazyProperty = defineLazyProp;
    var localXdgOpenPath = path$8.join(__dirname, "xdg-open");
    var { platform, arch } = process;
    var getWslDrivesMountPoint = (() => {
      const defaultMountPoint = "/mnt/";
      let mountPoint;
      return async function() {
        if (mountPoint) {
          return mountPoint;
        }
        const configFilePath = "/etc/wsl.conf";
        let isConfigFileExists = false;
        try {
          await fs$5.access(configFilePath, fsConstants.F_OK);
          isConfigFileExists = true;
        } catch {
        }
        if (!isConfigFileExists) {
          return defaultMountPoint;
        }
        const configContent = await fs$5.readFile(configFilePath, { encoding: "utf8" });
        const configMountPoint = /(?<!#.*)root\s*=\s*(?<mountPoint>.*)/g.exec(configContent);
        if (!configMountPoint) {
          return defaultMountPoint;
        }
        mountPoint = configMountPoint.groups.mountPoint.trim();
        mountPoint = mountPoint.endsWith("/") ? mountPoint : `${mountPoint}/`;
        return mountPoint;
      };
    })();
    var pTryEach = async (array2, mapper) => {
      let latestError;
      for (const item of array2) {
        try {
          return await mapper(item);
        } catch (error2) {
          latestError = error2;
        }
      }
      throw latestError;
    };
    var baseOpen = async (options2) => {
      options2 = __spreadValues2({
        wait: false,
        background: false,
        newInstance: false,
        allowNonzeroExitCode: false
      }, options2);
      if (Array.isArray(options2.app)) {
        return pTryEach(options2.app, (singleApp) => baseOpen(__spreadProps2(__spreadValues2({}, options2), {
          app: singleApp
        })));
      }
      let { name: app, arguments: appArguments = [] } = options2.app || {};
      appArguments = [...appArguments];
      if (Array.isArray(app)) {
        return pTryEach(app, (appName) => baseOpen(__spreadProps2(__spreadValues2({}, options2), {
          app: {
            name: appName,
            arguments: appArguments
          }
        })));
      }
      let command;
      const cliArguments = [];
      const childProcessOptions = {};
      if (platform === "darwin") {
        command = "open";
        if (options2.wait) {
          cliArguments.push("--wait-apps");
        }
        if (options2.background) {
          cliArguments.push("--background");
        }
        if (options2.newInstance) {
          cliArguments.push("--new");
        }
        if (app) {
          cliArguments.push("-a", app);
        }
      } else if (platform === "win32" || isWsl && !isDocker()) {
        const mountPoint = await getWslDrivesMountPoint();
        command = isWsl ? `${mountPoint}c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe` : `${process.env.SYSTEMROOT}\\System32\\WindowsPowerShell\\v1.0\\powershell`;
        cliArguments.push("-NoProfile", "-NonInteractive", "\u2013ExecutionPolicy", "Bypass", "-EncodedCommand");
        if (!isWsl) {
          childProcessOptions.windowsVerbatimArguments = true;
        }
        const encodedArguments = ["Start"];
        if (options2.wait) {
          encodedArguments.push("-Wait");
        }
        if (app) {
          encodedArguments.push(`"\`"${app}\`""`, "-ArgumentList");
          if (options2.target) {
            appArguments.unshift(options2.target);
          }
        } else if (options2.target) {
          encodedArguments.push(`"${options2.target}"`);
        }
        if (appArguments.length > 0) {
          appArguments = appArguments.map((arg) => `"\`"${arg}\`""`);
          encodedArguments.push(appArguments.join(","));
        }
        options2.target = Buffer.from(encodedArguments.join(" "), "utf16le").toString("base64");
      } else {
        if (app) {
          command = app;
        } else {
          const isBundled = !__dirname || __dirname === "/";
          let exeLocalXdgOpen = false;
          try {
            await fs$5.access(localXdgOpenPath, fsConstants.X_OK);
            exeLocalXdgOpen = true;
          } catch {
          }
          const useSystemXdgOpen = process.versions.electron || platform === "android" || isBundled || !exeLocalXdgOpen;
          command = useSystemXdgOpen ? "xdg-open" : localXdgOpenPath;
        }
        if (appArguments.length > 0) {
          cliArguments.push(...appArguments);
        }
        if (!options2.wait) {
          childProcessOptions.stdio = "ignore";
          childProcessOptions.detached = true;
        }
      }
      if (options2.target) {
        cliArguments.push(options2.target);
      }
      if (platform === "darwin" && appArguments.length > 0) {
        cliArguments.push("--args", ...appArguments);
      }
      const subprocess = childProcess$2.spawn(command, cliArguments, childProcessOptions);
      if (options2.wait) {
        return new Promise((resolve2, reject) => {
          subprocess.once("error", reject);
          subprocess.once("close", (exitCode) => {
            if (options2.allowNonzeroExitCode && exitCode > 0) {
              reject(new Error(`Exited with code ${exitCode}`));
              return;
            }
            resolve2(subprocess);
          });
        });
      }
      subprocess.unref();
      return subprocess;
    };
    var open = (target, options2) => {
      if (typeof target !== "string") {
        throw new TypeError("Expected a `target`");
      }
      return baseOpen(__spreadProps2(__spreadValues2({}, options2), {
        target
      }));
    };
    var openApp = (name, options2) => {
      if (typeof name !== "string") {
        throw new TypeError("Expected a `name`");
      }
      const { arguments: appArguments = [] } = options2 || {};
      if (appArguments !== void 0 && appArguments !== null && !Array.isArray(appArguments)) {
        throw new TypeError("Expected `appArguments` as Array type");
      }
      return baseOpen(__spreadProps2(__spreadValues2({}, options2), {
        app: {
          name,
          arguments: appArguments
        }
      }));
    };
    function detectArchBinary(binary2) {
      if (typeof binary2 === "string" || Array.isArray(binary2)) {
        return binary2;
      }
      const { [arch]: archBinary } = binary2;
      if (!archBinary) {
        throw new Error(`${arch} is not supported`);
      }
      return archBinary;
    }
    function detectPlatformBinary({ [platform]: platformBinary }, { wsl }) {
      if (wsl && isWsl) {
        return detectArchBinary(wsl);
      }
      if (!platformBinary) {
        throw new Error(`${platform} is not supported`);
      }
      return detectArchBinary(platformBinary);
    }
    var apps = {};
    defineLazyProperty(apps, "chrome", () => detectPlatformBinary({
      darwin: "google chrome",
      win32: "chrome",
      linux: ["google-chrome", "google-chrome-stable", "chromium"]
    }, {
      wsl: {
        ia32: "/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe",
        x64: ["/mnt/c/Program Files/Google/Chrome/Application/chrome.exe", "/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe"]
      }
    }));
    defineLazyProperty(apps, "firefox", () => detectPlatformBinary({
      darwin: "firefox",
      win32: "C:\\Program Files\\Mozilla Firefox\\firefox.exe",
      linux: "firefox"
    }, {
      wsl: "/mnt/c/Program Files/Mozilla Firefox/firefox.exe"
    }));
    defineLazyProperty(apps, "edge", () => detectPlatformBinary({
      darwin: "microsoft edge",
      win32: "msedge",
      linux: ["microsoft-edge", "microsoft-edge-dev"]
    }, {
      wsl: "/mnt/c/Program Files (x86)/Microsoft/Edge/Application/msedge.exe"
    }));
    open.apps = apps;
    open.openApp = openApp;
    var open_1 = open;
    var crossSpawn = { exports: {} };
    var windows$1 = isexe$3;
    isexe$3.sync = sync$2;
    var fs$4 = fs__default;
    function checkPathExt(path2, options2) {
      var pathext = options2.pathExt !== void 0 ? options2.pathExt : process.env.PATHEXT;
      if (!pathext) {
        return true;
      }
      pathext = pathext.split(";");
      if (pathext.indexOf("") !== -1) {
        return true;
      }
      for (var i2 = 0; i2 < pathext.length; i2++) {
        var p2 = pathext[i2].toLowerCase();
        if (p2 && path2.substr(-p2.length).toLowerCase() === p2) {
          return true;
        }
      }
      return false;
    }
    function checkStat$1(stat2, path2, options2) {
      if (!stat2.isSymbolicLink() && !stat2.isFile()) {
        return false;
      }
      return checkPathExt(path2, options2);
    }
    function isexe$3(path2, options2, cb) {
      fs$4.stat(path2, function(er2, stat2) {
        cb(er2, er2 ? false : checkStat$1(stat2, path2, options2));
      });
    }
    function sync$2(path2, options2) {
      return checkStat$1(fs$4.statSync(path2), path2, options2);
    }
    var mode = isexe$2;
    isexe$2.sync = sync$1;
    var fs$3 = fs__default;
    function isexe$2(path2, options2, cb) {
      fs$3.stat(path2, function(er2, stat2) {
        cb(er2, er2 ? false : checkStat(stat2, options2));
      });
    }
    function sync$1(path2, options2) {
      return checkStat(fs$3.statSync(path2), options2);
    }
    function checkStat(stat2, options2) {
      return stat2.isFile() && checkMode(stat2, options2);
    }
    function checkMode(stat2, options2) {
      var mod = stat2.mode;
      var uid = stat2.uid;
      var gid = stat2.gid;
      var myUid = options2.uid !== void 0 ? options2.uid : process.getuid && process.getuid();
      var myGid = options2.gid !== void 0 ? options2.gid : process.getgid && process.getgid();
      var u2 = parseInt("100", 8);
      var g2 = parseInt("010", 8);
      var o2 = parseInt("001", 8);
      var ug = u2 | g2;
      var ret = mod & o2 || mod & g2 && gid === myGid || mod & u2 && uid === myUid || mod & ug && myUid === 0;
      return ret;
    }
    var core;
    if (process.platform === "win32" || commonjsGlobal.TESTING_WINDOWS) {
      core = windows$1;
    } else {
      core = mode;
    }
    var isexe_1 = isexe$1;
    isexe$1.sync = sync;
    function isexe$1(path2, options2, cb) {
      if (typeof options2 === "function") {
        cb = options2;
        options2 = {};
      }
      if (!cb) {
        if (typeof Promise !== "function") {
          throw new TypeError("callback not provided");
        }
        return new Promise(function(resolve2, reject) {
          isexe$1(path2, options2 || {}, function(er2, is2) {
            if (er2) {
              reject(er2);
            } else {
              resolve2(is2);
            }
          });
        });
      }
      core(path2, options2 || {}, function(er2, is2) {
        if (er2) {
          if (er2.code === "EACCES" || options2 && options2.ignoreErrors) {
            er2 = null;
            is2 = false;
          }
        }
        cb(er2, is2);
      });
    }
    function sync(path2, options2) {
      try {
        return core.sync(path2, options2 || {});
      } catch (er2) {
        if (options2 && options2.ignoreErrors || er2.code === "EACCES") {
          return false;
        } else {
          throw er2;
        }
      }
    }
    var isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
    var path$7 = path__default;
    var COLON = isWindows ? ";" : ":";
    var isexe = isexe_1;
    var getNotFoundError = (cmd) => Object.assign(new Error(`not found: ${cmd}`), { code: "ENOENT" });
    var getPathInfo = (cmd, opt) => {
      const colon = opt.colon || COLON;
      const pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? [""] : [
        ...isWindows ? [process.cwd()] : [],
        ...(opt.path || process.env.PATH || "").split(colon)
      ];
      const pathExtExe = isWindows ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "";
      const pathExt = isWindows ? pathExtExe.split(colon) : [""];
      if (isWindows) {
        if (cmd.indexOf(".") !== -1 && pathExt[0] !== "")
          pathExt.unshift("");
      }
      return {
        pathEnv,
        pathExt,
        pathExtExe
      };
    };
    var which$1 = (cmd, opt, cb) => {
      if (typeof opt === "function") {
        cb = opt;
        opt = {};
      }
      if (!opt)
        opt = {};
      const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
      const found = [];
      const step = (i2) => new Promise((resolve2, reject) => {
        if (i2 === pathEnv.length)
          return opt.all && found.length ? resolve2(found) : reject(getNotFoundError(cmd));
        const ppRaw = pathEnv[i2];
        const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
        const pCmd = path$7.join(pathPart, cmd);
        const p2 = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
        resolve2(subStep(p2, i2, 0));
      });
      const subStep = (p2, i2, ii2) => new Promise((resolve2, reject) => {
        if (ii2 === pathExt.length)
          return resolve2(step(i2 + 1));
        const ext2 = pathExt[ii2];
        isexe(p2 + ext2, { pathExt: pathExtExe }, (er2, is2) => {
          if (!er2 && is2) {
            if (opt.all)
              found.push(p2 + ext2);
            else
              return resolve2(p2 + ext2);
          }
          return resolve2(subStep(p2, i2, ii2 + 1));
        });
      });
      return cb ? step(0).then((res) => cb(null, res), cb) : step(0);
    };
    var whichSync = (cmd, opt) => {
      opt = opt || {};
      const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
      const found = [];
      for (let i2 = 0; i2 < pathEnv.length; i2++) {
        const ppRaw = pathEnv[i2];
        const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
        const pCmd = path$7.join(pathPart, cmd);
        const p2 = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
        for (let j2 = 0; j2 < pathExt.length; j2++) {
          const cur = p2 + pathExt[j2];
          try {
            const is2 = isexe.sync(cur, { pathExt: pathExtExe });
            if (is2) {
              if (opt.all)
                found.push(cur);
              else
                return cur;
            }
          } catch (ex) {
          }
        }
      }
      if (opt.all && found.length)
        return found;
      if (opt.nothrow)
        return null;
      throw getNotFoundError(cmd);
    };
    var which_1 = which$1;
    which$1.sync = whichSync;
    var pathKey$1 = { exports: {} };
    var pathKey = (options2 = {}) => {
      const environment = options2.env || process.env;
      const platform2 = options2.platform || process.platform;
      if (platform2 !== "win32") {
        return "PATH";
      }
      return Object.keys(environment).reverse().find((key2) => key2.toUpperCase() === "PATH") || "Path";
    };
    pathKey$1.exports = pathKey;
    pathKey$1.exports.default = pathKey;
    var path$6 = path__default;
    var which = which_1;
    var getPathKey = pathKey$1.exports;
    function resolveCommandAttempt(parsed, withoutPathExt) {
      const env2 = parsed.options.env || process.env;
      const cwd = process.cwd();
      const hasCustomCwd = parsed.options.cwd != null;
      const shouldSwitchCwd = hasCustomCwd && process.chdir !== void 0 && !process.chdir.disabled;
      if (shouldSwitchCwd) {
        try {
          process.chdir(parsed.options.cwd);
        } catch (err) {
        }
      }
      let resolved;
      try {
        resolved = which.sync(parsed.command, {
          path: env2[getPathKey({ env: env2 })],
          pathExt: withoutPathExt ? path$6.delimiter : void 0
        });
      } catch (e2) {
      } finally {
        if (shouldSwitchCwd) {
          process.chdir(cwd);
        }
      }
      if (resolved) {
        resolved = path$6.resolve(hasCustomCwd ? parsed.options.cwd : "", resolved);
      }
      return resolved;
    }
    function resolveCommand$1(parsed) {
      return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);
    }
    var resolveCommand_1 = resolveCommand$1;
    var _escape = {};
    var metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;
    function escapeCommand(arg) {
      arg = arg.replace(metaCharsRegExp, "^$1");
      return arg;
    }
    function escapeArgument(arg, doubleEscapeMetaChars) {
      arg = `${arg}`;
      arg = arg.replace(/(\\*)"/g, '$1$1\\"');
      arg = arg.replace(/(\\*)$/, "$1$1");
      arg = `"${arg}"`;
      arg = arg.replace(metaCharsRegExp, "^$1");
      if (doubleEscapeMetaChars) {
        arg = arg.replace(metaCharsRegExp, "^$1");
      }
      return arg;
    }
    _escape.command = escapeCommand;
    _escape.argument = escapeArgument;
    var shebangRegex$1 = /^#!(.*)/;
    var shebangRegex = shebangRegex$1;
    var shebangCommand$1 = (string2 = "") => {
      const match2 = string2.match(shebangRegex);
      if (!match2) {
        return null;
      }
      const [path2, argument] = match2[0].replace(/#! ?/, "").split(" ");
      const binary2 = path2.split("/").pop();
      if (binary2 === "env") {
        return argument;
      }
      return argument ? `${binary2} ${argument}` : binary2;
    };
    var fs$2 = fs__default;
    var shebangCommand = shebangCommand$1;
    function readShebang$1(command) {
      const size = 150;
      const buffer2 = Buffer.alloc(size);
      let fd;
      try {
        fd = fs$2.openSync(command, "r");
        fs$2.readSync(fd, buffer2, 0, size, 0);
        fs$2.closeSync(fd);
      } catch (e2) {
      }
      return shebangCommand(buffer2.toString());
    }
    var readShebang_1 = readShebang$1;
    var path$5 = path__default;
    var resolveCommand = resolveCommand_1;
    var escape = _escape;
    var readShebang = readShebang_1;
    var isWin$1 = process.platform === "win32";
    var isExecutableRegExp = /\.(?:com|exe)$/i;
    var isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
    function detectShebang(parsed) {
      parsed.file = resolveCommand(parsed);
      const shebang = parsed.file && readShebang(parsed.file);
      if (shebang) {
        parsed.args.unshift(parsed.file);
        parsed.command = shebang;
        return resolveCommand(parsed);
      }
      return parsed.file;
    }
    function parseNonShell(parsed) {
      if (!isWin$1) {
        return parsed;
      }
      const commandFile = detectShebang(parsed);
      const needsShell = !isExecutableRegExp.test(commandFile);
      if (parsed.options.forceShell || needsShell) {
        const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);
        parsed.command = path$5.normalize(parsed.command);
        parsed.command = escape.command(parsed.command);
        parsed.args = parsed.args.map((arg) => escape.argument(arg, needsDoubleEscapeMetaChars));
        const shellCommand = [parsed.command].concat(parsed.args).join(" ");
        parsed.args = ["/d", "/s", "/c", `"${shellCommand}"`];
        parsed.command = process.env.comspec || "cmd.exe";
        parsed.options.windowsVerbatimArguments = true;
      }
      return parsed;
    }
    function parse$3(command, args, options2) {
      if (args && !Array.isArray(args)) {
        options2 = args;
        args = null;
      }
      args = args ? args.slice(0) : [];
      options2 = Object.assign({}, options2);
      const parsed = {
        command,
        args,
        options: options2,
        file: void 0,
        original: {
          command,
          args
        }
      };
      return options2.shell ? parsed : parseNonShell(parsed);
    }
    var parse_1 = parse$3;
    var isWin = process.platform === "win32";
    function notFoundError(original, syscall) {
      return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
        code: "ENOENT",
        errno: "ENOENT",
        syscall: `${syscall} ${original.command}`,
        path: original.command,
        spawnargs: original.args
      });
    }
    function hookChildProcess(cp2, parsed) {
      if (!isWin) {
        return;
      }
      const originalEmit = cp2.emit;
      cp2.emit = function(name, arg1) {
        if (name === "exit") {
          const err = verifyENOENT(arg1, parsed);
          if (err) {
            return originalEmit.call(cp2, "error", err);
          }
        }
        return originalEmit.apply(cp2, arguments);
      };
    }
    function verifyENOENT(status2, parsed) {
      if (isWin && status2 === 1 && !parsed.file) {
        return notFoundError(parsed.original, "spawn");
      }
      return null;
    }
    function verifyENOENTSync(status2, parsed) {
      if (isWin && status2 === 1 && !parsed.file) {
        return notFoundError(parsed.original, "spawnSync");
      }
      return null;
    }
    var enoent$1 = {
      hookChildProcess,
      verifyENOENT,
      verifyENOENTSync,
      notFoundError
    };
    var cp = require$$1__default$5;
    var parse$2 = parse_1;
    var enoent = enoent$1;
    function spawn(command, args, options2) {
      const parsed = parse$2(command, args, options2);
      const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);
      enoent.hookChildProcess(spawned, parsed);
      return spawned;
    }
    function spawnSync(command, args, options2) {
      const parsed = parse$2(command, args, options2);
      const result2 = cp.spawnSync(parsed.command, parsed.args, parsed.options);
      result2.error = result2.error || enoent.verifyENOENTSync(result2.status, parsed);
      return result2;
    }
    crossSpawn.exports = spawn;
    crossSpawn.exports.spawn = spawn;
    crossSpawn.exports.sync = spawnSync;
    crossSpawn.exports._parse = parse$2;
    crossSpawn.exports._enoent = enoent;
    var spawn$1 = crossSpawn.exports;
    var OSX_CHROME = "google chrome";
    function openBrowser(url2, opt, logger) {
      const browser2 = typeof opt === "string" ? opt : process.env.BROWSER || "";
      if (browser2.toLowerCase().endsWith(".js")) {
        return executeNodeScript(browser2, url2, logger);
      } else if (browser2.toLowerCase() !== "none") {
        return startBrowserProcess(browser2, url2);
      }
      return false;
    }
    function executeNodeScript(scriptPath, url2, logger) {
      const extraArgs = process.argv.slice(2);
      const child = spawn$1(process.execPath, [scriptPath, ...extraArgs, url2], {
        stdio: "inherit"
      });
      child.on("close", (code) => {
        if (code !== 0) {
          logger.error(colors$1.red(`
The script specified as BROWSER environment variable failed.

${colors$1.cyan(scriptPath)} exited with code ${code}.`), { error: null });
        }
      });
      return true;
    }
    function startBrowserProcess(browser2, url2) {
      const shouldTryOpenChromeWithAppleScript = process.platform === "darwin" && (browser2 === "" || browser2 === OSX_CHROME);
      if (shouldTryOpenChromeWithAppleScript) {
        try {
          require$$1$5.execSync('ps cax | grep "Google Chrome"');
          require$$1$5.execSync('osascript openChrome.applescript "' + encodeURI(url2) + '"', {
            cwd: path__default.dirname(__require.resolve("vite/bin/openChrome.applescript")),
            stdio: "ignore"
          });
          return true;
        } catch (err) {
        }
      }
      if (process.platform === "darwin" && browser2 === "open") {
        browser2 = void 0;
      }
      try {
        const options2 = browser2 ? { app: { name: browser2 } } : {};
        open_1(url2, options2).catch(() => {
        });
        return true;
      } catch (err) {
        return false;
      }
    }
    var shellQuote$1 = {};
    shellQuote$1.quote = function(xs2) {
      return xs2.map(function(s2) {
        if (s2 && typeof s2 === "object") {
          return s2.op.replace(/(.)/g, "\\$1");
        } else if (/["\s]/.test(s2) && !/'/.test(s2)) {
          return "'" + s2.replace(/(['\\])/g, "\\$1") + "'";
        } else if (/["'\s]/.test(s2)) {
          return '"' + s2.replace(/(["\\$`!])/g, "\\$1") + '"';
        } else {
          return String(s2).replace(/([A-Za-z]:)?([#!"$&'()*,:;<=>?@\[\\\]^`{|}])/g, "$1\\$2");
        }
      }).join(" ");
    };
    var CONTROL = "(?:" + [
      "\\|\\|",
      "\\&\\&",
      ";;",
      "\\|\\&",
      "\\<\\(",
      ">>",
      ">\\&",
      "[&;()|<>]"
    ].join("|") + ")";
    var META = "|&;()<> \\t";
    var BAREWORD = `(\\\\['"` + META + `]|[^\\s'"` + META + "])+";
    var SINGLE_QUOTE = '"((\\\\"|[^"])*?)"';
    var DOUBLE_QUOTE = "'((\\\\'|[^'])*?)'";
    var TOKEN = "";
    for (i = 0; i < 4; i++) {
      TOKEN += (Math.pow(16, 8) * Math.random()).toString(16);
    }
    var i;
    shellQuote$1.parse = function(s2, env2, opts) {
      var mapped = parse$1(s2, env2, opts);
      if (typeof env2 !== "function")
        return mapped;
      return mapped.reduce(function(acc, s3) {
        if (typeof s3 === "object")
          return acc.concat(s3);
        var xs2 = s3.split(RegExp("(" + TOKEN + ".*?" + TOKEN + ")", "g"));
        if (xs2.length === 1)
          return acc.concat(xs2[0]);
        return acc.concat(xs2.filter(Boolean).map(function(x2) {
          if (RegExp("^" + TOKEN).test(x2)) {
            return JSON.parse(x2.split(TOKEN)[1]);
          } else
            return x2;
        }));
      }, []);
    };
    function parse$1(s2, env2, opts) {
      var chunker = new RegExp([
        "(" + CONTROL + ")",
        "(" + BAREWORD + "|" + SINGLE_QUOTE + "|" + DOUBLE_QUOTE + ")*"
      ].join("|"), "g");
      var match2 = s2.match(chunker).filter(Boolean);
      var commented = false;
      if (!match2)
        return [];
      if (!env2)
        env2 = {};
      if (!opts)
        opts = {};
      return match2.map(function(s3, j2) {
        if (commented) {
          return;
        }
        if (RegExp("^" + CONTROL + "$").test(s3)) {
          return { op: s3 };
        }
        var SQ = "'";
        var DQ = '"';
        var DS = "$";
        var BS = opts.escape || "\\";
        var quote = false;
        var esc = false;
        var out2 = "";
        var isGlob2 = false;
        for (var i2 = 0, len = s3.length; i2 < len; i2++) {
          var c3 = s3.charAt(i2);
          isGlob2 = isGlob2 || !quote && (c3 === "*" || c3 === "?");
          if (esc) {
            out2 += c3;
            esc = false;
          } else if (quote) {
            if (c3 === quote) {
              quote = false;
            } else if (quote == SQ) {
              out2 += c3;
            } else {
              if (c3 === BS) {
                i2 += 1;
                c3 = s3.charAt(i2);
                if (c3 === DQ || c3 === BS || c3 === DS) {
                  out2 += c3;
                } else {
                  out2 += BS + c3;
                }
              } else if (c3 === DS) {
                out2 += parseEnvVar();
              } else {
                out2 += c3;
              }
            }
          } else if (c3 === DQ || c3 === SQ) {
            quote = c3;
          } else if (RegExp("^" + CONTROL + "$").test(c3)) {
            return { op: s3 };
          } else if (RegExp("^#$").test(c3)) {
            commented = true;
            if (out2.length) {
              return [out2, { comment: s3.slice(i2 + 1) + match2.slice(j2 + 1).join(" ") }];
            }
            return [{ comment: s3.slice(i2 + 1) + match2.slice(j2 + 1).join(" ") }];
          } else if (c3 === BS) {
            esc = true;
          } else if (c3 === DS) {
            out2 += parseEnvVar();
          } else
            out2 += c3;
        }
        if (isGlob2)
          return { op: "glob", pattern: out2 };
        return out2;
        function parseEnvVar() {
          i2 += 1;
          var varend, varname;
          if (s3.charAt(i2) === "{") {
            i2 += 1;
            if (s3.charAt(i2) === "}") {
              throw new Error("Bad substitution: " + s3.substr(i2 - 2, 3));
            }
            varend = s3.indexOf("}", i2);
            if (varend < 0) {
              throw new Error("Bad substitution: " + s3.substr(i2));
            }
            varname = s3.substr(i2, varend - i2);
            i2 = varend;
          } else if (/[*@#?$!_\-]/.test(s3.charAt(i2))) {
            varname = s3.charAt(i2);
            i2 += 1;
          } else {
            varend = s3.substr(i2).match(/[^\w\d_]/);
            if (!varend) {
              varname = s3.substr(i2);
              i2 = s3.length;
            } else {
              varname = s3.substr(i2, varend.index);
              i2 += varend.index - 1;
            }
          }
          return getVar(null, "", varname);
        }
      }).reduce(function(prev, arg) {
        if (arg === void 0) {
          return prev;
        }
        return prev.concat(arg);
      }, []);
      function getVar(_2, pre, key2) {
        var r2 = typeof env2 === "function" ? env2(key2) : env2[key2];
        if (r2 === void 0 && key2 != "")
          r2 = "";
        else if (r2 === void 0)
          r2 = "$";
        if (typeof r2 === "object") {
          return pre + TOKEN + JSON.stringify(r2) + TOKEN;
        } else
          return pre + r2;
      }
    }
    var osx = {
      "/Applications/Atom.app/Contents/MacOS/Atom": "atom",
      "/Applications/Atom Beta.app/Contents/MacOS/Atom Beta": "/Applications/Atom Beta.app/Contents/MacOS/Atom Beta",
      "/Applications/Brackets.app/Contents/MacOS/Brackets": "brackets",
      "/Applications/Sublime Text.app/Contents/MacOS/Sublime Text": "/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl",
      "/Applications/Sublime Text.app/Contents/MacOS/sublime_text": "/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl",
      "/Applications/Sublime Text 2.app/Contents/MacOS/Sublime Text 2": "/Applications/Sublime Text 2.app/Contents/SharedSupport/bin/subl",
      "/Applications/Sublime Text Dev.app/Contents/MacOS/Sublime Text": "/Applications/Sublime Text Dev.app/Contents/SharedSupport/bin/subl",
      "/Applications/Visual Studio Code.app/Contents/MacOS/Electron": "code",
      "/Applications/Visual Studio Code - Insiders.app/Contents/MacOS/Electron": "code-insiders",
      "/Applications/AppCode.app/Contents/MacOS/appcode": "/Applications/AppCode.app/Contents/MacOS/appcode",
      "/Applications/CLion.app/Contents/MacOS/clion": "/Applications/CLion.app/Contents/MacOS/clion",
      "/Applications/IntelliJ IDEA.app/Contents/MacOS/idea": "/Applications/IntelliJ IDEA.app/Contents/MacOS/idea",
      "/Applications/PhpStorm.app/Contents/MacOS/phpstorm": "/Applications/PhpStorm.app/Contents/MacOS/phpstorm",
      "/Applications/PyCharm.app/Contents/MacOS/pycharm": "/Applications/PyCharm.app/Contents/MacOS/pycharm",
      "/Applications/PyCharm CE.app/Contents/MacOS/pycharm": "/Applications/PyCharm CE.app/Contents/MacOS/pycharm",
      "/Applications/RubyMine.app/Contents/MacOS/rubymine": "/Applications/RubyMine.app/Contents/MacOS/rubymine",
      "/Applications/WebStorm.app/Contents/MacOS/webstorm": "/Applications/WebStorm.app/Contents/MacOS/webstorm"
    };
    var linux = {
      atom: "atom",
      Brackets: "brackets",
      code: "code",
      emacs: "emacs",
      "idea.sh": "idea",
      "phpstorm.sh": "phpstorm",
      "pycharm.sh": "pycharm",
      "rubymine.sh": "rubymine",
      sublime_text: "subl",
      vim: "vim",
      "webstorm.sh": "webstorm"
    };
    var windows = [
      "Brackets.exe",
      "Code.exe",
      "atom.exe",
      "sublime_text.exe",
      "notepad++.exe",
      "clion.exe",
      "clion64.exe",
      "idea.exe",
      "idea64.exe",
      "phpstorm.exe",
      "phpstorm64.exe",
      "pycharm.exe",
      "pycharm64.exe",
      "rubymine.exe",
      "rubymine64.exe",
      "webstorm.exe",
      "webstorm64.exe"
    ];
    var path$4 = path__default;
    var shellQuote = shellQuote$1;
    var childProcess$1 = require$$1__default$5;
    var COMMON_EDITORS_OSX = osx;
    var COMMON_EDITORS_LINUX = linux;
    var COMMON_EDITORS_WIN = windows;
    var guess = function guessEditor2(specifiedEditor) {
      if (specifiedEditor) {
        return shellQuote.parse(specifiedEditor);
      }
      try {
        if (process.platform === "darwin") {
          const output = childProcess$1.execSync("ps x").toString();
          const processNames = Object.keys(COMMON_EDITORS_OSX);
          for (let i2 = 0; i2 < processNames.length; i2++) {
            const processName = processNames[i2];
            if (output.indexOf(processName) !== -1) {
              return [COMMON_EDITORS_OSX[processName]];
            }
          }
        } else if (process.platform === "win32") {
          const output = childProcess$1.execSync('powershell -Command "Get-Process | Select-Object Path"', {
            stdio: ["pipe", "pipe", "ignore"]
          }).toString();
          const runningProcesses = output.split("\r\n");
          for (let i2 = 0; i2 < runningProcesses.length; i2++) {
            if (!runningProcesses[i2]) {
              continue;
            }
            const fullProcessPath = runningProcesses[i2].trim();
            const shortProcessName = path$4.basename(fullProcessPath);
            if (COMMON_EDITORS_WIN.indexOf(shortProcessName) !== -1) {
              return [fullProcessPath];
            }
          }
        } else if (process.platform === "linux") {
          const output = childProcess$1.execSync("ps x --no-heading -o comm --sort=comm").toString();
          const processNames = Object.keys(COMMON_EDITORS_LINUX);
          for (let i2 = 0; i2 < processNames.length; i2++) {
            const processName = processNames[i2];
            if (output.indexOf(processName) !== -1) {
              return [COMMON_EDITORS_LINUX[processName]];
            }
          }
        }
      } catch (error2) {
      }
      if (process.env.VISUAL) {
        return [process.env.VISUAL];
      } else if (process.env.EDITOR) {
        return [process.env.EDITOR];
      }
      return [null];
    };
    var path$3 = path__default;
    var getArgs = function getArgumentsForPosition2(editor, fileName, lineNumber, columnNumber = 1) {
      const editorBasename = path$3.basename(editor).replace(/\.(exe|cmd|bat)$/i, "");
      switch (editorBasename) {
        case "atom":
        case "Atom":
        case "Atom Beta":
        case "subl":
        case "sublime":
        case "sublime_text":
        case "wstorm":
        case "charm":
          return [`${fileName}:${lineNumber}:${columnNumber}`];
        case "notepad++":
          return ["-n" + lineNumber, fileName];
        case "vim":
        case "mvim":
          return [`+call cursor(${lineNumber}, ${columnNumber})`, fileName];
        case "joe":
          return [`+${lineNumber}`, fileName];
        case "emacs":
        case "emacsclient":
          return [`+${lineNumber}:${columnNumber}`, fileName];
        case "rmate":
        case "mate":
        case "mine":
          return ["--line", lineNumber, fileName];
        case "code":
        case "code-insiders":
        case "Code":
          return ["-r", "-g", `${fileName}:${lineNumber}:${columnNumber}`];
        case "appcode":
        case "clion":
        case "clion64":
        case "idea":
        case "idea64":
        case "phpstorm":
        case "phpstorm64":
        case "pycharm":
        case "pycharm64":
        case "rubymine":
        case "rubymine64":
        case "webstorm":
        case "webstorm64":
          return ["--line", lineNumber, fileName];
      }
      return [fileName];
    };
    var fs$1 = fs__default;
    var os$1 = require$$1__default;
    var path$2 = path__default;
    var colors = picocolors.exports;
    var childProcess = require$$1__default$5;
    var guessEditor = guess;
    var getArgumentsForPosition = getArgs;
    function wrapErrorCallback(cb) {
      return (fileName, errorMessage) => {
        console.log();
        console.log(colors.red("Could not open " + path$2.basename(fileName) + " in the editor."));
        if (errorMessage) {
          if (errorMessage[errorMessage.length - 1] !== ".") {
            errorMessage += ".";
          }
          console.log(colors.red("The editor process exited with an error: " + errorMessage));
        }
        console.log();
        if (cb)
          cb(fileName, errorMessage);
      };
    }
    function isTerminalEditor(editor) {
      switch (editor) {
        case "vim":
        case "emacs":
        case "nano":
          return true;
      }
      return false;
    }
    var positionRE = /:(\d+)(:(\d+))?$/;
    function parseFile(file) {
      const fileName = file.replace(positionRE, "");
      const match2 = file.match(positionRE);
      const lineNumber = match2 && match2[1];
      const columnNumber = match2 && match2[3];
      return {
        fileName,
        lineNumber,
        columnNumber
      };
    }
    var _childProcess = null;
    function launchEditor(file, specifiedEditor, onErrorCallback) {
      const parsed = parseFile(file);
      let { fileName } = parsed;
      const { lineNumber, columnNumber } = parsed;
      if (!fs$1.existsSync(fileName)) {
        return;
      }
      if (typeof specifiedEditor === "function") {
        onErrorCallback = specifiedEditor;
        specifiedEditor = void 0;
      }
      onErrorCallback = wrapErrorCallback(onErrorCallback);
      const [editor, ...args] = guessEditor(specifiedEditor);
      if (!editor) {
        onErrorCallback(fileName, null);
        return;
      }
      if (process.platform === "linux" && fileName.startsWith("/mnt/") && /Microsoft/i.test(os$1.release())) {
        fileName = path$2.relative("", fileName);
      }
      if (lineNumber) {
        const extraArgs = getArgumentsForPosition(editor, fileName, lineNumber, columnNumber);
        args.push.apply(args, extraArgs);
      } else {
        args.push(fileName);
      }
      if (_childProcess && isTerminalEditor(editor)) {
        _childProcess.kill("SIGKILL");
      }
      if (process.platform === "win32") {
        _childProcess = childProcess.spawn("cmd.exe", ["/C", editor].concat(args), { stdio: "inherit" });
      } else {
        _childProcess = childProcess.spawn(editor, args, { stdio: "inherit" });
      }
      _childProcess.on("exit", function(errorCode) {
        _childProcess = null;
        if (errorCode) {
          onErrorCallback(fileName, "(code " + errorCode + ")");
        }
      });
      _childProcess.on("error", function(error2) {
        onErrorCallback(fileName, error2.message);
      });
    }
    var launchEditor_1 = launchEditor;
    var url = require$$0__default$5;
    var path$1 = path__default;
    var launch = launchEditor_1;
    var launchEditorMiddleware = (specifiedEditor, srcRoot, onErrorCallback) => {
      if (typeof specifiedEditor === "function") {
        onErrorCallback = specifiedEditor;
        specifiedEditor = void 0;
      }
      if (typeof srcRoot === "function") {
        onErrorCallback = srcRoot;
        srcRoot = void 0;
      }
      srcRoot = srcRoot || process.cwd();
      return function launchEditorMiddleware2(req2, res, next) {
        const { file } = url.parse(req2.url, true).query || {};
        if (!file) {
          res.statusCode = 500;
          res.end(`launch-editor-middleware: required query param "file" is missing.`);
        } else {
          launch(path$1.resolve(srcRoot, file), specifiedEditor, onErrorCallback);
          res.end();
        }
      };
    };
    var offset;
    try {
      new Function("throw new Error(1)")();
    } catch (e2) {
      const match2 = /:(\d+):\d+\)$/.exec(e2.stack.split("\n")[1]);
      offset = match2 ? +match2[1] - 1 : 0;
    }
    function ssrRewriteStacktrace(stack2, moduleGraph) {
      return stack2.split("\n").map((line2) => {
        return line2.replace(/^ {4}at (?:(.+?)\s+\()?(?:(.+?):(\d+)(?::(\d+))?)\)?/, (input, varName, url2, line3, column2) => {
          var _a2;
          if (!url2)
            return input;
          const mod = moduleGraph.urlToModuleMap.get(url2);
          const rawSourceMap = (_a2 = mod === null || mod === void 0 ? void 0 : mod.ssrTransformResult) === null || _a2 === void 0 ? void 0 : _a2.map;
          if (!rawSourceMap) {
            return input;
          }
          const traced = new TraceMap(rawSourceMap);
          const pos2 = originalPositionFor(traced, {
            line: Number(line3) - offset,
            column: Number(column2)
          });
          if (!pos2.source || pos2.line == null || pos2.column == null) {
            return input;
          }
          const source2 = `${pos2.source}:${pos2.line}:${pos2.column}`;
          if (!varName || varName === "eval") {
            return `    at ${source2}`;
          } else {
            return `    at ${varName} (${source2})`;
          }
        });
      }).join("\n");
    }
    function rebindErrorStacktrace(e2, stacktrace) {
      const { configurable, writable } = Object.getOwnPropertyDescriptor(e2, "stack");
      if (configurable) {
        Object.defineProperty(e2, "stack", {
          value: stacktrace,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else if (writable) {
        e2.stack = stacktrace;
      }
    }
    function ssrRequireHookPlugin(config2) {
      var _a2, _b;
      if (config2.command !== "build" || !((_a2 = config2.resolve.dedupe) === null || _a2 === void 0 ? void 0 : _a2.length) || ((_b = config2.ssr) === null || _b === void 0 ? void 0 : _b.noExternal) === true || isBuildOutputEsm(config2)) {
        return null;
      }
      return {
        name: "vite:ssr-require-hook",
        transform(code, id) {
          const moduleInfo = this.getModuleInfo(id);
          if (moduleInfo === null || moduleInfo === void 0 ? void 0 : moduleInfo.isEntry) {
            const s2 = new MagicString(code);
            s2.prepend(`;(${dedupeRequire.toString()})(${JSON.stringify(config2.resolve.dedupe)});
`);
            return {
              code: s2.toString(),
              map: s2.generateMap({
                source: id,
                hires: true
              })
            };
          }
        }
      };
    }
    function dedupeRequire(dedupe) {
      const Module = (init_module(), __toCommonJS(module_exports));
      const resolveFilename = Module._resolveFilename;
      Module._resolveFilename = function(request, parent, isMain, options2) {
        if (request[0] !== "." && request[0] !== "/") {
          const parts = request.split("/");
          const pkgName = parts[0][0] === "@" ? parts[0] + "/" + parts[1] : parts[0];
          if (dedupe.includes(pkgName)) {
            parent = module;
          }
        }
        return resolveFilename(request, parent, isMain, options2);
      };
    }
    function hookNodeResolve(getResolver) {
      const Module = (init_module(), __toCommonJS(module_exports));
      const prevResolver = Module._resolveFilename;
      Module._resolveFilename = getResolver(prevResolver);
      return () => {
        Module._resolveFilename = prevResolver;
      };
    }
    function isBuildOutputEsm(config2) {
      var _a2;
      const outputs = arraify((_a2 = config2.build.rollupOptions) === null || _a2 === void 0 ? void 0 : _a2.output);
      return outputs.some((output) => (output === null || output === void 0 ? void 0 : output.format) === "es" || (output === null || output === void 0 ? void 0 : output.format) === "esm");
    }
    var pendingModules = /* @__PURE__ */ new Map();
    var pendingImports = /* @__PURE__ */ new Map();
    async function ssrLoadModule(url2, server2, context2 = { global }, urlStack = [], fixStacktrace) {
      url2 = unwrapId$1(url2).replace(NULL_BYTE_PLACEHOLDER, "\0");
      const pending = pendingModules.get(url2);
      if (pending) {
        return pending;
      }
      const modulePromise = instantiateModule(url2, server2, context2, urlStack, fixStacktrace);
      pendingModules.set(url2, modulePromise);
      modulePromise.catch(() => {
        pendingImports.delete(url2);
      }).finally(() => {
        pendingModules.delete(url2);
      });
      return modulePromise;
    }
    async function instantiateModule(url2, server2, context2 = { global }, urlStack = [], fixStacktrace) {
      const { moduleGraph } = server2;
      const mod = await moduleGraph.ensureEntryFromUrl(url2, true);
      if (mod.ssrModule) {
        return mod.ssrModule;
      }
      const result2 = mod.ssrTransformResult || await transformRequest(url2, server2, { ssr: true });
      if (!result2) {
        throw new Error(`failed to load module for ssr: ${url2}`);
      }
      const ssrModule = {
        [Symbol.toStringTag]: "Module"
      };
      Object.defineProperty(ssrModule, "__esModule", { value: true });
      mod.ssrModule = ssrModule;
      const ssrImportMeta = {
        url: require$$0$4.pathToFileURL(mod.file).toString()
      };
      urlStack = urlStack.concat(url2);
      const isCircular = (url3) => urlStack.includes(url3);
      const { isProduction, resolve: { dedupe, preserveSymlinks }, root: root2 } = server2.config;
      const resolveOptions = {
        dedupe,
        extensions: [".js", ".cjs", ".json"],
        isBuild: true,
        isProduction,
        isRequire: true,
        mainFields: ["main"],
        preserveSymlinks,
        root: root2
      };
      const pendingDeps = [];
      const ssrImport = async (dep) => {
        var _a2, _b;
        if (dep[0] !== "." && dep[0] !== "/") {
          return nodeImport(dep, mod.file, resolveOptions);
        }
        dep = unwrapId$1(dep);
        if (!isCircular(dep) && !((_a2 = pendingImports.get(dep)) === null || _a2 === void 0 ? void 0 : _a2.some(isCircular))) {
          pendingDeps.push(dep);
          if (pendingDeps.length === 1) {
            pendingImports.set(url2, pendingDeps);
          }
          const mod2 = await ssrLoadModule(dep, server2, context2, urlStack, fixStacktrace);
          if (pendingDeps.length === 1) {
            pendingImports.delete(url2);
          } else {
            pendingDeps.splice(pendingDeps.indexOf(dep), 1);
          }
          return mod2;
        }
        return (_b = moduleGraph.urlToModuleMap.get(dep)) === null || _b === void 0 ? void 0 : _b.ssrModule;
      };
      const ssrDynamicImport = (dep) => {
        if (dep[0] === ".") {
          dep = path__default.posix.resolve(path__default.dirname(url2), dep);
        }
        return ssrImport(dep);
      };
      function ssrExportAll(sourceModule) {
        for (const key2 in sourceModule) {
          if (key2 !== "default") {
            Object.defineProperty(ssrModule, key2, {
              enumerable: true,
              configurable: true,
              get() {
                return sourceModule[key2];
              }
            });
          }
        }
      }
      try {
        const AsyncFunction = async function() {
        }.constructor;
        const initModule = new AsyncFunction(`global`, ssrModuleExportsKey, ssrImportMetaKey, ssrImportKey, ssrDynamicImportKey, ssrExportAllKey, result2.code + `
//# sourceURL=${mod.url}`);
        await initModule(context2.global, ssrModule, ssrImportMeta, ssrImport, ssrDynamicImport, ssrExportAll);
      } catch (e2) {
        if (e2.stack && fixStacktrace !== false) {
          const stacktrace = ssrRewriteStacktrace(e2.stack, moduleGraph);
          rebindErrorStacktrace(e2, stacktrace);
          server2.config.logger.error(`Error when evaluating SSR module ${url2}:
${stacktrace}`, {
            timestamp: true,
            clear: server2.config.clearScreen,
            error: e2
          });
        }
        throw e2;
      }
      return Object.freeze(ssrModule);
    }
    async function nodeImport(id, importer, resolveOptions) {
      const viteResolve = (id2, importer2, options2 = resolveOptions) => {
        const resolved = tryNodeResolve(id2, importer2, options2, false);
        if (!resolved) {
          const err = new Error(`Cannot find module '${id2}' imported from '${importer2}'`);
          err.code = "ERR_MODULE_NOT_FOUND";
          throw err;
        }
        return resolved.id;
      };
      const unhookNodeResolve = hookNodeResolve((nodeResolve) => (id2, parent, isMain, options2) => {
        if (!bareImportRE.test(id2) || path__default.isAbsolute(id2) || isBuiltin(id2) || id2.endsWith(".node")) {
          return nodeResolve(id2, parent, isMain, options2);
        }
        if (parent) {
          let resolved = viteResolve(id2, parent.id);
          if (resolved) {
            resolved = path__default.normalize(resolved);
          }
          return resolved;
        }
        return id2;
      });
      let url2;
      if (id.startsWith("node:") || isBuiltin(id)) {
        url2 = id;
      } else {
        url2 = viteResolve(id, importer, typeof jest === "undefined" ? __spreadProps2(__spreadValues2({}, resolveOptions), { tryEsmOnly: true }) : resolveOptions);
        if (usingDynamicImport) {
          url2 = require$$0$4.pathToFileURL(url2).toString();
        }
      }
      try {
        const mod = await dynamicImport(url2);
        return proxyESM(mod);
      } finally {
        unhookNodeResolve();
      }
    }
    function proxyESM(mod) {
      if (isPrimitive(mod))
        return { default: mod };
      let defaultExport = "default" in mod ? mod.default : mod;
      if (!isPrimitive(defaultExport) && "__esModule" in defaultExport) {
        mod = defaultExport;
        if ("default" in defaultExport) {
          defaultExport = defaultExport.default;
        }
      }
      return new Proxy(mod, {
        get(mod2, prop) {
          var _a2;
          if (prop === "default")
            return defaultExport;
          return (_a2 = mod2[prop]) !== null && _a2 !== void 0 ? _a2 : defaultExport === null || defaultExport === void 0 ? void 0 : defaultExport[prop];
        }
      });
    }
    function isPrimitive(value) {
      return !value || typeof value !== "object" && typeof value !== "function";
    }
    var isDebugEnabled = _debug("vite:deps").enabled;
    var debounceMs = 100;
    function createOptimizedDeps(server2) {
      const { config: config2 } = server2;
      const { logger } = config2;
      const sessionTimestamp = Date.now().toString();
      const cachedMetadata = loadCachedDepOptimizationMetadata(config2);
      const optimizedDeps = {
        metadata: cachedMetadata || createOptimizedDepsMetadata(config2, sessionTimestamp),
        registerMissingImport
      };
      let handle;
      let newDepsDiscovered = false;
      let newDepsToLog = [];
      let newDepsToLogHandle;
      const logNewlyDiscoveredDeps = () => {
        if (newDepsToLog.length) {
          config2.logger.info(colors$1.green(`\u2728 new dependencies optimized: ${depsLogString(newDepsToLog)}`), {
            timestamp: true
          });
          newDepsToLog = [];
        }
      };
      let depOptimizationProcessing = newDepOptimizationProcessing();
      let depOptimizationProcessingQueue = [];
      const resolveEnqueuedProcessingPromises = () => {
        for (const processing of depOptimizationProcessingQueue) {
          processing.resolve();
        }
        depOptimizationProcessingQueue = [];
      };
      let enqueuedRerun;
      let currentlyProcessing = false;
      if (!cachedMetadata) {
        currentlyProcessing = true;
        const scanPhaseProcessing = newDepOptimizationProcessing();
        optimizedDeps.scanProcessing = scanPhaseProcessing.promise;
        const warmUp = async () => {
          try {
            debuggerViteDeps(colors$1.green(`scanning for dependencies...`), {
              timestamp: true
            });
            const { metadata } = optimizedDeps;
            const discovered = await discoverProjectDependencies(config2, sessionTimestamp);
            for (const depInfo of Object.values(discovered)) {
              addOptimizedDepInfo(metadata, "discovered", __spreadProps2(__spreadValues2({}, depInfo), {
                processing: depOptimizationProcessing.promise
              }));
            }
            debuggerViteDeps(colors$1.green(`dependencies found: ${depsLogString(Object.keys(discovered))}`), {
              timestamp: true
            });
            scanPhaseProcessing.resolve();
            optimizedDeps.scanProcessing = void 0;
            runOptimizer();
          } catch (e2) {
            logger.error(e2.message);
            if (optimizedDeps.scanProcessing) {
              scanPhaseProcessing.resolve();
              optimizedDeps.scanProcessing = void 0;
            }
          }
        };
        setTimeout(warmUp, 0);
      }
      async function runOptimizer(isRerun = false) {
        enqueuedRerun = void 0;
        currentlyProcessing = true;
        if (handle)
          clearTimeout(handle);
        let { metadata } = optimizedDeps;
        const newDeps = {};
        for (const dep of Object.keys(metadata.optimized)) {
          newDeps[dep] = __spreadValues2({}, metadata.optimized[dep]);
        }
        for (const dep of Object.keys(metadata.discovered)) {
          const _a2 = metadata.discovered[dep], { processing } = _a2, info = __objRest(_a2, ["processing"]);
          newDeps[dep] = info;
        }
        newDepsDiscovered = false;
        depOptimizationProcessingQueue.push(depOptimizationProcessing);
        depOptimizationProcessing = newDepOptimizationProcessing();
        try {
          const processingResult = await runOptimizeDeps(config2, newDeps);
          const newData = processingResult.metadata;
          const needsReload = metadata.hash !== newData.hash || Object.keys(metadata.optimized).some((dep) => {
            return metadata.optimized[dep].fileHash !== newData.optimized[dep].fileHash;
          });
          const commitProcessing = () => {
            processingResult.commit();
            for (const id in metadata.discovered) {
              if (!newData.optimized[id]) {
                addOptimizedDepInfo(newData, "discovered", metadata.discovered[id]);
              }
            }
            if (!needsReload) {
              newData.browserHash = metadata.browserHash;
              for (const dep in newData.chunks) {
                newData.chunks[dep].browserHash = metadata.browserHash;
              }
              for (const dep in newData.optimized) {
                newData.optimized[dep].browserHash = (metadata.optimized[dep] || metadata.discovered[dep]).browserHash;
              }
            }
            for (const o2 in newData.optimized) {
              const discovered = metadata.discovered[o2];
              if (discovered) {
                const optimized = newData.optimized[o2];
                discovered.browserHash = optimized.browserHash;
                discovered.fileHash = optimized.fileHash;
                discovered.needsInterop = optimized.needsInterop;
                discovered.processing = void 0;
              }
            }
            if (isRerun) {
              newDepsToLog.push(...Object.keys(newData.optimized).filter((dep) => !metadata.optimized[dep]));
            }
            metadata = optimizedDeps.metadata = newData;
            resolveEnqueuedProcessingPromises();
          };
          if (!needsReload) {
            commitProcessing();
            if (!isDebugEnabled) {
              if (newDepsToLogHandle)
                clearTimeout(newDepsToLogHandle);
              newDepsToLogHandle = setTimeout(() => {
                newDepsToLogHandle = void 0;
                logNewlyDiscoveredDeps();
              }, 2 * debounceMs);
            } else {
              debuggerViteDeps(colors$1.green(`\u2728 optimized dependencies unchanged`), {
                timestamp: true
              });
            }
          } else {
            if (newDepsDiscovered) {
              processingResult.cancel();
              debuggerViteDeps(colors$1.green(`\u2728 delaying reload as new dependencies have been found...`), {
                timestamp: true
              });
            } else {
              commitProcessing();
              if (!isDebugEnabled) {
                if (newDepsToLogHandle)
                  clearTimeout(newDepsToLogHandle);
                newDepsToLogHandle = void 0;
                logNewlyDiscoveredDeps();
              }
              logger.info(colors$1.green(`\u2728 optimized dependencies changed. reloading`), {
                timestamp: true
              });
              fullReload();
            }
          }
        } catch (e2) {
          logger.error(colors$1.red(`error while updating dependencies:
${e2.stack}`), { timestamp: true, error: e2 });
          resolveEnqueuedProcessingPromises();
          metadata.discovered = {};
          fullReload();
        }
        currentlyProcessing = false;
        enqueuedRerun === null || enqueuedRerun === void 0 ? void 0 : enqueuedRerun();
      }
      function fullReload() {
        server2.moduleGraph.invalidateAll();
        server2.ws.send({
          type: "full-reload",
          path: "*"
        });
      }
      async function rerun() {
        const deps = Object.keys(optimizedDeps.metadata.discovered);
        const depsString = depsLogString(deps);
        debuggerViteDeps(colors$1.green(`new dependencies found: ${depsString}`), {
          timestamp: true
        });
        runOptimizer(true);
      }
      function getDiscoveredBrowserHash(hash, deps, missing) {
        return getHash(hash + JSON.stringify(deps) + JSON.stringify(missing) + sessionTimestamp);
      }
      function registerMissingImport(id, resolved, ssr) {
        if (optimizedDeps.scanProcessing) {
          config2.logger.error("Vite internal error: registering missing import before initial scanning is over");
        }
        const { metadata } = optimizedDeps;
        const optimized = metadata.optimized[id];
        if (optimized) {
          return optimized;
        }
        const chunk = metadata.chunks[id];
        if (chunk) {
          return chunk;
        }
        let missing = metadata.discovered[id];
        if (missing) {
          return missing;
        }
        newDepsDiscovered = true;
        missing = addOptimizedDepInfo(metadata, "discovered", {
          id,
          file: getOptimizedDepPath(id, server2.config),
          src: resolved,
          browserHash: getDiscoveredBrowserHash(metadata.hash, depsFromOptimizedDepInfo(metadata.optimized), depsFromOptimizedDepInfo(metadata.discovered)),
          processing: depOptimizationProcessing.promise
        });
        enqueuedRerun = void 0;
        if (handle)
          clearTimeout(handle);
        if (newDepsToLogHandle)
          clearTimeout(newDepsToLogHandle);
        newDepsToLogHandle = void 0;
        handle = setTimeout(() => {
          handle = void 0;
          enqueuedRerun = rerun;
          if (!currentlyProcessing) {
            enqueuedRerun();
          }
        }, debounceMs);
        return missing;
      }
      return optimizedDeps;
    }
    var ROOT_FILES = [
      "pnpm-workspace.yaml",
      "lerna.json"
    ];
    function hasWorkspacePackageJSON(root2) {
      const path2 = path$r.join(root2, "package.json");
      if (!isFileReadable(path2)) {
        return false;
      }
      const content2 = JSON.parse(fs__default.readFileSync(path2, "utf-8")) || {};
      return !!content2.workspaces;
    }
    function hasRootFile(root2) {
      return ROOT_FILES.some((file) => fs__default.existsSync(path$r.join(root2, file)));
    }
    function hasPackageJSON(root2) {
      const path2 = path$r.join(root2, "package.json");
      return fs__default.existsSync(path2);
    }
    function searchForPackageRoot(current, root2 = current) {
      if (hasPackageJSON(current))
        return current;
      const dir = path$r.dirname(current);
      if (!dir || dir === current)
        return root2;
      return searchForPackageRoot(dir, root2);
    }
    function searchForWorkspaceRoot(current, root2 = searchForPackageRoot(current)) {
      if (hasRootFile(current))
        return current;
      if (hasWorkspacePackageJSON(current))
        return current;
      const dir = path$r.dirname(current);
      if (!dir || dir === current)
        return root2;
      return searchForWorkspaceRoot(dir, root2);
    }
    async function createServer(inlineConfig = {}) {
      const config2 = await resolveConfig(inlineConfig, "serve", "development");
      const root2 = config2.root;
      const serverConfig = config2.server;
      const httpsOptions = await resolveHttpsConfig(config2.server.https, config2.cacheDir);
      let { middlewareMode } = serverConfig;
      if (middlewareMode === true) {
        middlewareMode = "ssr";
      }
      const middlewares = connect();
      const httpServer = middlewareMode ? null : await resolveHttpServer(serverConfig, middlewares, httpsOptions);
      const ws2 = createWebSocketServer(httpServer, config2, httpsOptions);
      const _a2 = serverConfig.watch || {}, { ignored = [] } = _a2, watchOptions = __objRest(_a2, ["ignored"]);
      const watcher = chokidar.watch(path__default.resolve(root2), __spreadValues2({
        ignored: [
          "**/node_modules/**",
          "**/.git/**",
          ...Array.isArray(ignored) ? ignored : [ignored]
        ],
        ignoreInitial: true,
        ignorePermissionErrors: true,
        disableGlobbing: true
      }, watchOptions));
      const moduleGraph = new ModuleGraph((url2, ssr) => container.resolveId(url2, void 0, { ssr }));
      const container = await createPluginContainer(config2, moduleGraph, watcher);
      const closeHttpServer = createServerCloseFn(httpServer);
      let exitProcess;
      const server2 = {
        config: config2,
        middlewares,
        get app() {
          config2.logger.warn(`ViteDevServer.app is deprecated. Use ViteDevServer.middlewares instead.`);
          return middlewares;
        },
        httpServer,
        watcher,
        pluginContainer: container,
        ws: ws2,
        moduleGraph,
        ssrTransform,
        transformWithEsbuild,
        transformRequest(url2, options2) {
          return transformRequest(url2, server2, options2);
        },
        transformIndexHtml: null,
        async ssrLoadModule(url2, opts) {
          if (!server2._ssrExternals) {
            let knownImports = [];
            const optimizedDeps = server2._optimizedDeps;
            if (optimizedDeps) {
              await optimizedDeps.scanProcessing;
              knownImports = [
                ...Object.keys(optimizedDeps.metadata.optimized),
                ...Object.keys(optimizedDeps.metadata.discovered)
              ];
            }
            server2._ssrExternals = resolveSSRExternal(config2, knownImports);
          }
          return ssrLoadModule(url2, server2, void 0, void 0, opts === null || opts === void 0 ? void 0 : opts.fixStacktrace);
        },
        ssrFixStacktrace(e2) {
          if (e2.stack) {
            const stacktrace = ssrRewriteStacktrace(e2.stack, moduleGraph);
            rebindErrorStacktrace(e2, stacktrace);
          }
        },
        ssrRewriteStacktrace(stack2) {
          return ssrRewriteStacktrace(stack2, moduleGraph);
        },
        listen(port, isRestart) {
          return startServer(server2, port, isRestart);
        },
        async close() {
          process.off("SIGTERM", exitProcess);
          if (!middlewareMode && process.env.CI !== "true") {
            process.stdin.off("end", exitProcess);
          }
          await Promise.all([
            watcher.close(),
            ws2.close(),
            container.close(),
            closeHttpServer()
          ]);
        },
        printUrls() {
          if (httpServer) {
            printCommonServerUrls(httpServer, config2.server, config2);
          } else {
            throw new Error("cannot print server URLs in middleware mode.");
          }
        },
        async restart(forceOptimize) {
          if (!server2._restartPromise) {
            server2._forceOptimizeOnRestart = !!forceOptimize;
            server2._restartPromise = restartServer(server2).finally(() => {
              server2._restartPromise = null;
              server2._forceOptimizeOnRestart = false;
            });
          }
          return server2._restartPromise;
        },
        _optimizedDeps: null,
        _ssrExternals: null,
        _globImporters: /* @__PURE__ */ Object.create(null),
        _restartPromise: null,
        _forceOptimizeOnRestart: false,
        _pendingRequests: /* @__PURE__ */ new Map()
      };
      server2.transformIndexHtml = createDevHtmlTransformFn(server2);
      exitProcess = async () => {
        try {
          await server2.close();
        } finally {
          process.exit(0);
        }
      };
      process.once("SIGTERM", exitProcess);
      if (!middlewareMode && process.env.CI !== "true") {
        process.stdin.on("end", exitProcess);
      }
      const { packageCache } = config2;
      const setPackageData = packageCache.set.bind(packageCache);
      packageCache.set = (id, pkg) => {
        if (id.endsWith(".json")) {
          watcher.add(id);
        }
        return setPackageData(id, pkg);
      };
      watcher.on("change", async (file) => {
        file = normalizePath$4(file);
        if (file.endsWith("/package.json")) {
          return invalidatePackageData(packageCache, file);
        }
        moduleGraph.onFileChange(file);
        if (serverConfig.hmr !== false) {
          try {
            await handleHMRUpdate(file, server2);
          } catch (err) {
            ws2.send({
              type: "error",
              err: prepareError(err)
            });
          }
        }
      });
      watcher.on("add", (file) => {
        handleFileAddUnlink(normalizePath$4(file), server2);
      });
      watcher.on("unlink", (file) => {
        handleFileAddUnlink(normalizePath$4(file), server2, true);
      });
      if (!middlewareMode && httpServer) {
        httpServer.once("listening", () => {
          serverConfig.port = httpServer.address().port;
        });
      }
      const postHooks = [];
      for (const plugin of config2.plugins) {
        if (plugin.configureServer) {
          postHooks.push(await plugin.configureServer(server2));
        }
      }
      if (process.env.DEBUG) {
        middlewares.use(timeMiddleware(root2));
      }
      const { cors } = serverConfig;
      if (cors !== false) {
        middlewares.use(corsMiddleware(typeof cors === "boolean" ? {} : cors));
      }
      const { proxy } = serverConfig;
      if (proxy) {
        middlewares.use(proxyMiddleware(httpServer, config2));
      }
      if (config2.base !== "/") {
        middlewares.use(baseMiddleware(server2));
      }
      middlewares.use("/__open-in-editor", launchEditorMiddleware());
      middlewares.use("/__vite_ping", function viteHMRPingMiddleware(_2, res) {
        res.end("pong");
      });
      if (config2.publicDir) {
        middlewares.use(servePublicMiddleware(config2.publicDir));
      }
      middlewares.use(transformMiddleware(server2));
      middlewares.use(serveRawFsMiddleware(server2));
      middlewares.use(serveStaticMiddleware(root2, server2));
      if (!middlewareMode || middlewareMode === "html") {
        middlewares.use(spaFallbackMiddleware(root2));
      }
      postHooks.forEach((fn2) => fn2 && fn2());
      if (!middlewareMode || middlewareMode === "html") {
        middlewares.use(indexHtmlMiddleware(server2));
        middlewares.use(function vite404Middleware(_2, res) {
          res.statusCode = 404;
          res.end();
        });
      }
      middlewares.use(errorMiddleware(server2, !!middlewareMode));
      if (!middlewareMode && httpServer) {
        let isOptimized = false;
        const listen = httpServer.listen.bind(httpServer);
        httpServer.listen = async (port, ...args) => {
          if (!isOptimized) {
            try {
              await container.buildStart({});
              server2._optimizedDeps = createOptimizedDeps(server2);
              isOptimized = true;
            } catch (e2) {
              httpServer.emit("error", e2);
              return;
            }
          }
          return listen(port, ...args);
        };
      } else {
        await container.buildStart({});
        server2._optimizedDeps = createOptimizedDeps(server2);
      }
      return server2;
    }
    async function startServer(server2, inlinePort, isRestart = false) {
      var _a2;
      const httpServer = server2.httpServer;
      if (!httpServer) {
        throw new Error("Cannot call server.listen in middleware mode.");
      }
      const options2 = server2.config.server;
      const port = (_a2 = inlinePort !== null && inlinePort !== void 0 ? inlinePort : options2.port) !== null && _a2 !== void 0 ? _a2 : 3e3;
      const hostname = resolveHostname(options2.host);
      const protocol = options2.https ? "https" : "http";
      const info = server2.config.logger.info;
      const base2 = server2.config.base;
      const serverPort = await httpServerStart(httpServer, {
        port,
        strictPort: options2.strictPort,
        host: hostname.host,
        logger: server2.config.logger
      });
      const profileSession = global.__vite_profile_session;
      if (profileSession) {
        profileSession.post("Profiler.stop", (err, { profile }) => {
          if (!err) {
            const outPath = path__default.resolve("./vite-profile.cpuprofile");
            fs__default.writeFileSync(outPath, JSON.stringify(profile));
            info(colors$1.yellow(`  CPU profile written to ${colors$1.white(colors$1.dim(outPath))}
`));
          } else {
            throw err;
          }
        });
      }
      if (options2.open && !isRestart) {
        const path2 = typeof options2.open === "string" ? options2.open : base2;
        openBrowser(path2.startsWith("http") ? path2 : `${protocol}://${hostname.name}:${serverPort}${path2}`, true, server2.config.logger);
      }
      return server2;
    }
    function createServerCloseFn(server2) {
      if (!server2) {
        return () => {
        };
      }
      let hasListened = false;
      const openSockets = /* @__PURE__ */ new Set();
      server2.on("connection", (socket) => {
        openSockets.add(socket);
        socket.on("close", () => {
          openSockets.delete(socket);
        });
      });
      server2.once("listening", () => {
        hasListened = true;
      });
      return () => new Promise((resolve2, reject) => {
        openSockets.forEach((s2) => s2.destroy());
        if (hasListened) {
          server2.close((err) => {
            if (err) {
              reject(err);
            } else {
              resolve2();
            }
          });
        } else {
          resolve2();
        }
      });
    }
    function resolvedAllowDir(root2, dir) {
      return normalizePath$4(path__default.resolve(root2, dir));
    }
    function resolveServerOptions(root2, raw) {
      var _a2, _b, _c, _d;
      const server2 = __spreadValues2({
        preTransformRequests: true
      }, raw);
      let allowDirs = (_a2 = server2.fs) === null || _a2 === void 0 ? void 0 : _a2.allow;
      const deny = ((_b = server2.fs) === null || _b === void 0 ? void 0 : _b.deny) || [".env", ".env.*", "*.{crt,pem}"];
      if (!allowDirs) {
        allowDirs = [searchForWorkspaceRoot(root2)];
      }
      allowDirs = allowDirs.map((i2) => resolvedAllowDir(root2, i2));
      const resolvedClientDir = resolvedAllowDir(root2, CLIENT_DIR);
      if (!allowDirs.some((dir) => isParentDirectory(dir, resolvedClientDir))) {
        allowDirs.push(resolvedClientDir);
      }
      server2.fs = {
        strict: (_d = (_c = server2.fs) === null || _c === void 0 ? void 0 : _c.strict) !== null && _d !== void 0 ? _d : true,
        allow: allowDirs,
        deny
      };
      return server2;
    }
    async function restartServer(server2) {
      global.__vite_start_time = perf_hooks.performance.now();
      const { port: prevPort, host: prevHost } = server2.config.server;
      await server2.close();
      let inlineConfig = server2.config.inlineConfig;
      if (server2._forceOptimizeOnRestart) {
        inlineConfig = mergeConfig(inlineConfig, {
          server: {
            force: true
          }
        });
      }
      let newServer = null;
      try {
        newServer = await createServer(inlineConfig);
      } catch (err) {
        server2.config.logger.error(err.message, {
          timestamp: true
        });
        return;
      }
      for (const key2 in newServer) {
        if (key2 === "_restartPromise") {
          newServer[key2] = server2[key2];
        } else if (key2 !== "app") {
          server2[key2] = newServer[key2];
        }
      }
      const { logger, server: { port, host, middlewareMode } } = server2.config;
      if (!middlewareMode) {
        await server2.listen(port, true);
        logger.info("server restarted.", { timestamp: true });
        if (port !== prevPort || host !== prevHost) {
          logger.info("");
          server2.printUrls();
        }
      } else {
        logger.info("server restarted.", { timestamp: true });
      }
      newServer._restartPromise = null;
    }
    var index = {
      __proto__: null,
      createServer,
      resolveServerOptions,
      searchForWorkspaceRoot
    };
    var noop = () => {
    };
    var mimes = /text|javascript|\/json|xml/i;
    var threshold = 1024;
    var level = -1;
    var brotli = false;
    var getChunkSize = (chunk, enc) => chunk ? Buffer.byteLength(chunk, enc) : 0;
    function compression() {
      const brotliOpts = typeof brotli === "object" && brotli || {};
      const gzipOpts = {};
      if (!zlib__default.createBrotliCompress)
        brotli = false;
      return (req2, res, next = noop) => {
        const accept = req2.headers["accept-encoding"] + "";
        const encoding = (brotli && accept.match(/\bbr\b/) || accept.match(/\bgzip\b/) || [])[0];
        if (req2.method === "HEAD" || !encoding)
          return next();
        let compress;
        let pendingStatus;
        let pendingListeners = [];
        let started = false;
        let size = 0;
        function start() {
          started = true;
          size = res.getHeader("Content-Length") | 0 || size;
          const compressible = mimes.test(String(res.getHeader("Content-Type") || "text/plain"));
          const cleartext = !res.getHeader("Content-Encoding");
          const listeners = pendingListeners || [];
          if (compressible && cleartext && size >= threshold) {
            res.setHeader("Content-Encoding", encoding);
            res.removeHeader("Content-Length");
            if (encoding === "br") {
              const params = {
                [zlib__default.constants.BROTLI_PARAM_QUALITY]: level,
                [zlib__default.constants.BROTLI_PARAM_SIZE_HINT]: size
              };
              compress = zlib__default.createBrotliCompress({
                params: Object.assign(params, brotliOpts)
              });
            } else {
              compress = zlib__default.createGzip(Object.assign({ level }, gzipOpts));
            }
            compress.on("data", (chunk) => write.call(res, chunk) === false && compress.pause());
            on2.call(res, "drain", () => compress.resume());
            compress.on("end", () => end.call(res));
            listeners.forEach((p2) => compress.on.apply(compress, p2));
          } else {
            pendingListeners = null;
            listeners.forEach((p2) => on2.apply(res, p2));
          }
          writeHead.call(res, pendingStatus || res.statusCode);
        }
        const { end, write, on: on2, writeHead } = res;
        res.writeHead = function(status2, reason, headers) {
          if (typeof reason !== "string")
            [headers, reason] = [reason, headers];
          if (headers)
            for (let i2 in headers)
              res.setHeader(i2, headers[i2]);
          pendingStatus = status2;
          return this;
        };
        res.write = function(chunk, enc, cb) {
          size += getChunkSize(chunk, enc);
          if (!started)
            start();
          if (!compress)
            return write.apply(this, arguments);
          return compress.write.apply(compress, arguments);
        };
        res.end = function(chunk, enc, cb) {
          if (arguments.length > 0 && typeof chunk !== "function") {
            size += getChunkSize(chunk, enc);
          }
          if (!started)
            start();
          if (!compress)
            return end.apply(this, arguments);
          return compress.end.apply(compress, arguments);
        };
        res.on = function(type, listener2) {
          if (!pendingListeners || type !== "drain")
            on2.call(this, type, listener2);
          else if (compress)
            compress.on(type, listener2);
          else
            pendingListeners.push([type, listener2]);
          return this;
        };
        next();
      };
    }
    function resolvePreviewOptions(preview2, server2) {
      var _a2, _b, _c, _d, _e2, _f, _g;
      return {
        port: preview2 === null || preview2 === void 0 ? void 0 : preview2.port,
        strictPort: (_a2 = preview2 === null || preview2 === void 0 ? void 0 : preview2.strictPort) !== null && _a2 !== void 0 ? _a2 : server2.strictPort,
        host: (_b = preview2 === null || preview2 === void 0 ? void 0 : preview2.host) !== null && _b !== void 0 ? _b : server2.host,
        https: (_c = preview2 === null || preview2 === void 0 ? void 0 : preview2.https) !== null && _c !== void 0 ? _c : server2.https,
        open: (_d = preview2 === null || preview2 === void 0 ? void 0 : preview2.open) !== null && _d !== void 0 ? _d : server2.open,
        proxy: (_e2 = preview2 === null || preview2 === void 0 ? void 0 : preview2.proxy) !== null && _e2 !== void 0 ? _e2 : server2.proxy,
        cors: (_f = preview2 === null || preview2 === void 0 ? void 0 : preview2.cors) !== null && _f !== void 0 ? _f : server2.cors,
        headers: (_g = preview2 === null || preview2 === void 0 ? void 0 : preview2.headers) !== null && _g !== void 0 ? _g : server2.headers
      };
    }
    async function preview(inlineConfig) {
      var _a2, _b;
      const config2 = await resolveConfig(inlineConfig, "serve", "production");
      const app = connect();
      const httpServer = await resolveHttpServer(config2.preview, app, await resolveHttpsConfig((_a2 = config2.preview) === null || _a2 === void 0 ? void 0 : _a2.https, config2.cacheDir));
      const { cors } = config2.preview;
      if (cors !== false) {
        app.use(corsMiddleware(typeof cors === "boolean" ? {} : cors));
      }
      if (config2.preview.proxy) {
        app.use(proxyMiddleware(httpServer, config2));
      }
      app.use(compression());
      const distDir = path__default.resolve(config2.root, config2.build.outDir);
      app.use(config2.base, sirv(distDir, {
        etag: true,
        dev: true,
        single: true
      }));
      const options2 = config2.preview;
      const hostname = resolveHostname(options2.host);
      const port = (_b = options2.port) !== null && _b !== void 0 ? _b : 4173;
      const protocol = options2.https ? "https" : "http";
      const logger = config2.logger;
      const base2 = config2.base;
      const serverPort = await httpServerStart(httpServer, {
        port,
        strictPort: options2.strictPort,
        host: hostname.host,
        logger
      });
      if (options2.open) {
        const path2 = typeof options2.open === "string" ? options2.open : base2;
        openBrowser(path2.startsWith("http") ? path2 : `${protocol}://${hostname.name}:${serverPort}${path2}`, true, logger);
      }
      return {
        config: config2,
        httpServer,
        printUrls() {
          printCommonServerUrls(httpServer, config2.preview, config2);
        }
      };
    }
    var preview$1 = {
      __proto__: null,
      resolvePreviewOptions,
      preview
    };
    function matches(pattern2, importee) {
      if (pattern2 instanceof RegExp) {
        return pattern2.test(importee);
      }
      if (importee.length < pattern2.length) {
        return false;
      }
      if (importee === pattern2) {
        return true;
      }
      return importee.startsWith(pattern2 + "/");
    }
    function getEntries({ entries, customResolver }) {
      if (!entries) {
        return [];
      }
      const resolverFunctionFromOptions = resolveCustomResolver(customResolver);
      if (Array.isArray(entries)) {
        return entries.map((entry2) => {
          return {
            find: entry2.find,
            replacement: entry2.replacement,
            resolverFunction: resolveCustomResolver(entry2.customResolver) || resolverFunctionFromOptions
          };
        });
      }
      return Object.entries(entries).map(([key2, value]) => {
        return { find: key2, replacement: value, resolverFunction: resolverFunctionFromOptions };
      });
    }
    function resolveCustomResolver(customResolver) {
      if (customResolver) {
        if (typeof customResolver === "function") {
          return customResolver;
        }
        if (typeof customResolver.resolveId === "function") {
          return customResolver.resolveId;
        }
      }
      return null;
    }
    function alias(options2 = {}) {
      const entries = getEntries(options2);
      if (entries.length === 0) {
        return {
          name: "alias",
          resolveId: () => null
        };
      }
      return {
        name: "alias",
        async buildStart(inputOptions) {
          await Promise.all([...Array.isArray(options2.entries) ? options2.entries : [], options2].map(({ customResolver }) => customResolver && typeof customResolver === "object" && typeof customResolver.buildStart === "function" && customResolver.buildStart.call(this, inputOptions)));
        },
        resolveId(importee, importer, resolveOptions) {
          if (!importer) {
            return null;
          }
          const matchedEntry = entries.find((entry2) => matches(entry2.find, importee));
          if (!matchedEntry) {
            return null;
          }
          const updatedId = importee.replace(matchedEntry.find, matchedEntry.replacement);
          if (matchedEntry.resolverFunction) {
            return matchedEntry.resolverFunction.call(this, updatedId, importer, resolveOptions);
          }
          return this.resolve(updatedId, importer, Object.assign({ skipSelf: true }, resolveOptions)).then((resolved) => resolved || { id: updatedId });
        }
      };
    }
    var jsonExtRE = /\.json($|\?)(?!commonjs-(proxy|external))/;
    function jsonPlugin(options2 = {}, isBuild) {
      return {
        name: "vite:json",
        transform(json2, id) {
          if (!jsonExtRE.test(id))
            return null;
          if (SPECIAL_QUERY_RE.test(id))
            return null;
          try {
            if (options2.stringify) {
              if (isBuild) {
                return {
                  code: `export default JSON.parse(${JSON.stringify(JSON.stringify(JSON.parse(json2)))})`,
                  map: { mappings: "" }
                };
              } else {
                return `export default JSON.parse(${JSON.stringify(json2)})`;
              }
            }
            const parsed = JSON.parse(json2);
            return {
              code: dataToEsm(parsed, {
                preferConst: true,
                namedExports: options2.namedExports
              }),
              map: { mappings: "" }
            };
          } catch (e2) {
            const errorMessageList = /[\d]+/.exec(e2.message);
            const position = errorMessageList && parseInt(errorMessageList[0], 10);
            const msg = position ? `, invalid JSON syntax found at line ${position}` : `.`;
            this.error(`Failed to parse JSON file` + msg, e2.idx);
          }
        }
      };
    }
    var isDebug = !!process.env.DEBUG;
    var debug$1 = createDebugger("vite:import-analysis");
    var clientDir = normalizePath$4(CLIENT_DIR);
    var skipRE = /\.(map|json)$/;
    var canSkip = (id) => skipRE.test(id) || isDirectCSSRequest(id);
    var optimizedDepChunkRE = /\/chunk-[A-Z0-9]{8}\.js/;
    var optimizedDepDynamicRE = /-[A-Z0-9]{8}\.js/;
    function isExplicitImportRequired(url2) {
      return !isJSRequest(cleanUrl(url2)) && !isCSSRequest(url2);
    }
    function markExplicitImport(url2) {
      if (isExplicitImportRequired(url2)) {
        return injectQuery(url2, "import");
      }
      return url2;
    }
    function importAnalysisPlugin(config2) {
      const { root: root2, base: base2 } = config2;
      const clientPublicPath = path__default.posix.join(base2, CLIENT_PUBLIC_PATH);
      const resolve2 = config2.createResolver({
        preferRelative: true,
        tryIndex: false,
        extensions: []
      });
      let server2;
      return {
        name: "vite:import-analysis",
        configureServer(_server) {
          server2 = _server;
        },
        async transform(source2, importer, options2) {
          const ssr = (options2 === null || options2 === void 0 ? void 0 : options2.ssr) === true;
          const prettyImporter = prettifyUrl(importer, root2);
          if (canSkip(importer)) {
            isDebug && debug$1(colors$1.dim(`[skipped] ${prettyImporter}`));
            return null;
          }
          const start = perf_hooks.performance.now();
          await init;
          let imports = [];
          if (source2.charCodeAt(0) === 65279) {
            source2 = source2.slice(1);
          }
          try {
            imports = parse$h(source2)[0];
          } catch (e2) {
            const isVue = importer.endsWith(".vue");
            const maybeJSX = !isVue && isJSRequest(importer);
            const msg = isVue ? `Install @vitejs/plugin-vue to handle .vue files.` : maybeJSX ? `If you are using JSX, make sure to name the file with the .jsx or .tsx extension.` : `You may need to install appropriate plugins to handle the ${path__default.extname(importer)} file format.`;
            this.error(`Failed to parse source for import analysis because the content contains invalid JS syntax. ` + msg, e2.idx);
          }
          if (!imports.length) {
            isDebug && debug$1(`${timeFrom(start)} ${colors$1.dim(`[no imports] ${prettyImporter}`)}`);
            return source2;
          }
          let hasHMR = false;
          let isSelfAccepting = false;
          let hasEnv = false;
          let needQueryInjectHelper = false;
          let s2;
          const str = () => s2 || (s2 = new MagicString(source2));
          const { moduleGraph } = server2;
          const importerModule = moduleGraph.getModuleById(importer);
          const importedUrls = /* @__PURE__ */ new Set();
          const staticImportedUrls = /* @__PURE__ */ new Set();
          const acceptedUrls = /* @__PURE__ */ new Set();
          const toAbsoluteUrl = (url2) => path__default.posix.resolve(path__default.posix.dirname(importerModule.url), url2);
          const normalizeUrl = async (url2, pos2) => {
            var _a2;
            if (base2 !== "/" && url2.startsWith(base2)) {
              url2 = url2.replace(base2, "/");
            }
            let importerFile = importer;
            if (moduleListContains((_a2 = config2.optimizeDeps) === null || _a2 === void 0 ? void 0 : _a2.exclude, url2)) {
              const optimizedDeps = server2._optimizedDeps;
              if (optimizedDeps) {
                await optimizedDeps.scanProcessing;
                for (const optimizedModule of optimizedDeps.metadata.depInfoList) {
                  if (!optimizedModule.src)
                    continue;
                  if (optimizedModule.file === importerModule.file) {
                    importerFile = optimizedModule.src;
                  }
                }
              }
            }
            const resolved = await this.resolve(url2, importerFile);
            if (!resolved) {
              if (ssr) {
                return [url2, url2];
              }
              this.error(`Failed to resolve import "${url2}" from "${path__default.relative(process.cwd(), importerFile)}". Does the file exist?`, pos2);
            }
            const isRelative = url2.startsWith(".");
            const isSelfImport = !isRelative && cleanUrl(url2) === cleanUrl(importer);
            if (resolved.id.startsWith(root2 + "/")) {
              url2 = resolved.id.slice(root2.length);
            } else if (resolved.id.startsWith(getDepsCacheDir(config2)) || fs__default.existsSync(cleanUrl(resolved.id))) {
              url2 = path__default.posix.join(FS_PREFIX + resolved.id);
            } else {
              url2 = resolved.id;
            }
            if (isExternalUrl(url2)) {
              return [url2, url2];
            }
            if (!url2.startsWith(".") && !url2.startsWith("/")) {
              url2 = VALID_ID_PREFIX + resolved.id.replace("\0", NULL_BYTE_PLACEHOLDER);
            }
            if (!ssr) {
              url2 = markExplicitImport(url2);
              if ((isRelative || isSelfImport) && !/[\?&]import=?\b/.test(url2) && !url2.match(DEP_VERSION_RE)) {
                const versionMatch = importer.match(DEP_VERSION_RE);
                if (versionMatch) {
                  url2 = injectQuery(url2, versionMatch[1]);
                }
              }
              try {
                const depModule = await moduleGraph.ensureEntryFromUrl(url2, ssr);
                if (depModule.lastHMRTimestamp > 0) {
                  url2 = injectQuery(url2, `t=${depModule.lastHMRTimestamp}`);
                }
              } catch (e2) {
                e2.pos = pos2;
                throw e2;
              }
              url2 = base2 + url2.replace(/^\//, "");
            }
            return [url2, resolved.id];
          };
          const importRewrites = [];
          for (let index2 = 0; index2 < imports.length; index2++) {
            const {
              s: start2,
              e: end,
              ss: expStart,
              se: expEnd,
              d: dynamicIndex,
              n: specifier
            } = imports[index2];
            const rawUrl = source2.slice(start2, end);
            if (rawUrl === "import.meta") {
              const prop = source2.slice(end, end + 4);
              if (prop === ".hot") {
                hasHMR = true;
                if (source2.slice(end + 4, end + 11) === ".accept") {
                  if (lexAcceptedHmrDeps(source2, source2.indexOf("(", end + 11) + 1, acceptedUrls)) {
                    isSelfAccepting = true;
                  }
                }
              } else if (prop === ".env") {
                hasEnv = true;
              } else if (prop === ".glo" && source2[end + 4] === "b") {
                const { imports: imports2, importsString, exp, endIndex, base: base3, pattern: pattern2, isEager } = await transformImportGlob(source2, start2, importer, index2, root2, config2.logger, normalizeUrl, resolve2);
                str().prepend(importsString);
                str().overwrite(expStart, endIndex, exp, { contentOnly: true });
                imports2.forEach((url2) => {
                  url2 = url2.replace(base3, "/");
                  importedUrls.add(url2);
                  if (isEager)
                    staticImportedUrls.add(url2);
                });
                if (!(importerModule.file in server2._globImporters)) {
                  server2._globImporters[importerModule.file] = {
                    module: importerModule,
                    importGlobs: []
                  };
                }
                server2._globImporters[importerModule.file].importGlobs.push({
                  base: base3,
                  pattern: pattern2
                });
              }
              continue;
            }
            const isDynamicImport = dynamicIndex > -1;
            if (specifier) {
              if (isExternalUrl(specifier) || isDataUrl(specifier)) {
                continue;
              }
              if (ssr) {
                if (server2._ssrExternals && shouldExternalizeForSSR(specifier, server2._ssrExternals)) {
                  continue;
                }
                if (isBuiltin(specifier)) {
                  continue;
                }
              }
              if (specifier === clientPublicPath) {
                continue;
              }
              if (specifier.startsWith("/") && !config2.assetsInclude(cleanUrl(specifier)) && !specifier.endsWith(".json") && checkPublicFile(specifier, config2)) {
                throw new Error(`Cannot import non-asset file ${specifier} which is inside /public.JS/CSS files inside /public are copied as-is on build and can only be referenced via <script src> or <link href> in html.`);
              }
              const [normalizedUrl, resolvedId] = await normalizeUrl(specifier, start2);
              const url2 = normalizedUrl;
              server2 === null || server2 === void 0 ? void 0 : server2.moduleGraph.safeModulesPath.add(fsPathFromUrl(url2));
              if (url2 !== specifier) {
                importRewrites.push(async () => {
                  let rewriteDone = false;
                  if ((server2 === null || server2 === void 0 ? void 0 : server2._optimizedDeps) && isOptimizedDepFile(resolvedId, config2) && !resolvedId.match(optimizedDepChunkRE)) {
                    const file = cleanUrl(resolvedId);
                    const needsInterop2 = await optimizedDepNeedsInterop(server2._optimizedDeps.metadata, file);
                    if (needsInterop2 === void 0) {
                      if (!file.match(optimizedDepDynamicRE)) {
                        config2.logger.error(colors$1.red(`Vite Error, ${url2} optimized info should be defined`));
                      }
                    } else if (needsInterop2) {
                      debug$1(`${url2} needs interop`);
                      if (isDynamicImport) {
                        str().overwrite(expStart, expEnd, `import('${url2}').then(m => m.default && m.default.__esModule ? m.default : ({ ...m.default, default: m.default }))`, { contentOnly: true });
                      } else {
                        const exp = source2.slice(expStart, expEnd);
                        const rewritten = transformCjsImport(exp, url2, rawUrl, index2);
                        if (rewritten) {
                          str().overwrite(expStart, expEnd, rewritten, {
                            contentOnly: true
                          });
                        } else {
                          str().overwrite(start2, end, url2, { contentOnly: true });
                        }
                      }
                      rewriteDone = true;
                    }
                  }
                  if (!rewriteDone) {
                    str().overwrite(start2, end, isDynamicImport ? `'${url2}'` : url2, { contentOnly: true });
                  }
                });
              }
              const urlWithoutBase = url2.replace(base2, "/");
              importedUrls.add(urlWithoutBase);
              if (!isDynamicImport) {
                staticImportedUrls.add(urlWithoutBase);
              }
            } else if (!importer.startsWith(clientDir) && !ssr) {
              const hasViteIgnore = /\/\*\s*@vite-ignore\s*\*\//.test(source2.slice(dynamicIndex + 1, end));
              const url2 = rawUrl.replace(/\/\*[\s\S]*?\*\/|([^\\:]|^)\/\/.*$/gm, "").trim();
              if (!hasViteIgnore && !isSupportedDynamicImport(url2)) {
                this.warn(`
` + colors$1.cyan(importerModule.file) + `
` + generateCodeFrame(source2, start2) + `
The above dynamic import cannot be analyzed by vite.
See ${colors$1.blue(`https://github.com/rollup/plugins/tree/master/packages/dynamic-import-vars#limitations`)} for supported dynamic import formats. If this is intended to be left as-is, you can use the /* @vite-ignore */ comment inside the import() call to suppress this warning.
`);
              }
              if (!/^('.*'|".*"|`.*`)$/.test(url2) || isExplicitImportRequired(url2.slice(1, -1))) {
                needQueryInjectHelper = true;
                str().overwrite(start2, end, `__vite__injectQuery(${url2}, 'import')`, { contentOnly: true });
              }
            }
          }
          if (hasEnv) {
            let env2 = `import.meta.env = ${JSON.stringify(__spreadProps2(__spreadValues2({}, config2.env), {
              SSR: !!ssr
            }))};`;
            for (const key2 in config2.define) {
              if (key2.startsWith(`import.meta.env.`)) {
                const val = config2.define[key2];
                env2 += `${key2} = ${typeof val === "string" ? val : JSON.stringify(val)};`;
              }
            }
            str().prepend(env2);
          }
          if (hasHMR && !ssr) {
            debugHmr(`${isSelfAccepting ? `[self-accepts]` : acceptedUrls.size ? `[accepts-deps]` : `[detected api usage]`} ${prettyImporter}`);
            str().prepend(`import { createHotContext as __vite__createHotContext } from "${clientPublicPath}";import.meta.hot = __vite__createHotContext(${JSON.stringify(importerModule.url)});`);
          }
          if (needQueryInjectHelper) {
            str().prepend(`import { injectQuery as __vite__injectQuery } from "${clientPublicPath}";`);
          }
          const normalizedAcceptedUrls = /* @__PURE__ */ new Set();
          for (const { url: url2, start: start2, end } of acceptedUrls) {
            const [normalized] = await moduleGraph.resolveUrl(toAbsoluteUrl(markExplicitImport(url2)), ssr);
            normalizedAcceptedUrls.add(normalized);
            str().overwrite(start2, end, JSON.stringify(normalized), {
              contentOnly: true
            });
          }
          if (!isCSSRequest(importer)) {
            const pluginImports = this._addedImports;
            if (pluginImports) {
              (await Promise.all([...pluginImports].map((id) => normalizeUrl(id, 0)))).forEach(([url2]) => importedUrls.add(url2));
            }
            if (ssr && importerModule.isSelfAccepting) {
              isSelfAccepting = true;
            }
            const prunedImports = await moduleGraph.updateModuleInfo(importerModule, importedUrls, normalizedAcceptedUrls, isSelfAccepting, ssr);
            if (hasHMR && prunedImports) {
              handlePrunedModules(prunedImports, server2);
            }
          }
          isDebug && debug$1(`${timeFrom(start)} ${colors$1.dim(`[${importedUrls.size} imports rewritten] ${prettyImporter}`)}`);
          if (config2.server.preTransformRequests && staticImportedUrls.size) {
            staticImportedUrls.forEach((url2) => {
              url2 = unwrapId$1(removeImportQuery(url2)).replace(NULL_BYTE_PLACEHOLDER, "\0");
              transformRequest(url2, server2, { ssr }).catch((e2) => {
                if ((e2 === null || e2 === void 0 ? void 0 : e2.code) === ERR_OUTDATED_OPTIMIZED_DEP) {
                  return;
                }
                config2.logger.error(e2.message);
              });
            });
          }
          for (const rewrite of importRewrites) {
            await rewrite();
          }
          if (s2) {
            return s2.toString();
          } else {
            return source2;
          }
        }
      };
    }
    function isSupportedDynamicImport(url2) {
      url2 = url2.trim().slice(1, -1);
      if (!url2.startsWith("./") && !url2.startsWith("../")) {
        return false;
      }
      if (!path__default.extname(url2)) {
        return false;
      }
      if (url2.startsWith("./${") && url2.indexOf("/") === url2.lastIndexOf("/")) {
        return false;
      }
      return true;
    }
    function transformCjsImport(importExp, url2, rawUrl, importIndex) {
      const node2 = parse$d(importExp, {
        ecmaVersion: "latest",
        sourceType: "module"
      }).body[0];
      if (node2.type === "ImportDeclaration" || node2.type === "ExportNamedDeclaration") {
        if (!node2.specifiers.length) {
          return `import "${url2}"`;
        }
        const importNames = [];
        const exportNames = [];
        let defaultExports = "";
        for (const spec of node2.specifiers) {
          if (spec.type === "ImportSpecifier" && spec.imported.type === "Identifier") {
            const importedName = spec.imported.name;
            const localName = spec.local.name;
            importNames.push({ importedName, localName });
          } else if (spec.type === "ImportDefaultSpecifier") {
            importNames.push({
              importedName: "default",
              localName: spec.local.name
            });
          } else if (spec.type === "ImportNamespaceSpecifier") {
            importNames.push({ importedName: "*", localName: spec.local.name });
          } else if (spec.type === "ExportSpecifier" && spec.exported.type === "Identifier") {
            const importedName = spec.local.name;
            const exportedName = spec.exported.name;
            if (exportedName === "default") {
              defaultExports = makeLegalIdentifier$1(`__vite__cjsExportDefault_${importIndex}`);
              importNames.push({ importedName, localName: defaultExports });
            } else {
              importNames.push({ importedName, localName: exportedName });
              exportNames.push(exportedName);
            }
          }
        }
        const cjsModuleName = makeLegalIdentifier$1(`__vite__cjsImport${importIndex}_${rawUrl}`);
        const lines = [`import ${cjsModuleName} from "${url2}"`];
        importNames.forEach(({ importedName, localName }) => {
          if (importedName === "*") {
            lines.push(`const ${localName} = ${cjsModuleName}`);
          } else if (importedName === "default") {
            lines.push(`const ${localName} = ${cjsModuleName}.__esModule ? ${cjsModuleName}.default : ${cjsModuleName}`);
          } else {
            lines.push(`const ${localName} = ${cjsModuleName}["${importedName}"]`);
          }
        });
        if (defaultExports) {
          lines.push(`export default ${defaultExports}`);
        }
        if (exportNames.length) {
          lines.push(`export { ${exportNames.join(", ")} }`);
        }
        return lines.join("; ");
      }
    }
    var normalizedClientEntry = normalizePath$4(CLIENT_ENTRY);
    var normalizedEnvEntry = normalizePath$4(ENV_ENTRY);
    function clientInjectionsPlugin(config2) {
      return {
        name: "vite:client-inject",
        transform(code, id, options2) {
          if (id === normalizedClientEntry || id === normalizedEnvEntry) {
            let options3 = config2.server.hmr;
            options3 = options3 && typeof options3 !== "boolean" ? options3 : {};
            const host = options3.host || null;
            const protocol = options3.protocol || null;
            const timeout = options3.timeout || 3e4;
            const overlay = options3.overlay !== false;
            let port;
            if (isObject$5(config2.server.hmr)) {
              port = config2.server.hmr.clientPort || config2.server.hmr.port;
            }
            if (config2.server.middlewareMode) {
              port = String(port || 24678);
            } else {
              port = String(port || options3.port || config2.server.port);
            }
            let hmrBase = config2.base;
            if (options3.path) {
              hmrBase = path__default.posix.join(hmrBase, options3.path);
            }
            if (hmrBase !== "/") {
              port = path__default.posix.normalize(`${port}${hmrBase}`);
            }
            return code.replace(`__MODE__`, JSON.stringify(config2.mode)).replace(`__BASE__`, JSON.stringify(config2.base)).replace(`__DEFINES__`, serializeDefine(config2.define || {})).replace(`__HMR_PROTOCOL__`, JSON.stringify(protocol)).replace(`__HMR_HOSTNAME__`, JSON.stringify(host)).replace(`__HMR_PORT__`, JSON.stringify(port)).replace(`__HMR_TIMEOUT__`, JSON.stringify(timeout)).replace(`__HMR_ENABLE_OVERLAY__`, JSON.stringify(overlay));
          } else if (!(options2 === null || options2 === void 0 ? void 0 : options2.ssr) && code.includes("process.env.NODE_ENV")) {
            return code.replace(/\bprocess\.env\.NODE_ENV\b/g, JSON.stringify(config2.mode));
          }
        }
      };
    }
    function serializeDefine(define) {
      let res = `{`;
      for (const key2 in define) {
        const val = define[key2];
        res += `${JSON.stringify(key2)}: ${typeof val === "string" ? `(${val})` : JSON.stringify(val)}, `;
      }
      return res + `}`;
    }
    var wasmHelperId = "/__vite-wasm-helper";
    var wasmHelper = async (opts = {}, url2) => {
      let result2;
      if (url2.startsWith("data:")) {
        const binaryString = atob(url2.replace(/^data:.*?base64,/, ""));
        const bytes = new Uint8Array(binaryString.length);
        for (let i2 = 0; i2 < binaryString.length; i2++) {
          bytes[i2] = binaryString.charCodeAt(i2);
        }
        result2 = await WebAssembly.instantiate(bytes, opts);
      } else {
        const response = await fetch(url2);
        const contentType = response.headers.get("Content-Type") || "";
        if ("instantiateStreaming" in WebAssembly && contentType.startsWith("application/wasm")) {
          result2 = await WebAssembly.instantiateStreaming(response, opts);
        } else {
          const buffer2 = await response.arrayBuffer();
          result2 = await WebAssembly.instantiate(buffer2, opts);
        }
      }
      return result2.instance.exports;
    };
    var wasmHelperCode = wasmHelper.toString();
    var wasmPlugin = (config2) => {
      return {
        name: "vite:wasm",
        resolveId(id) {
          if (id === wasmHelperId) {
            return id;
          }
        },
        async load(id) {
          if (id === wasmHelperId) {
            return `export default ${wasmHelperCode}`;
          }
          if (!id.endsWith(".wasm")) {
            return;
          }
          const url2 = await fileToUrl(id, config2, this);
          return `
import initWasm from "${wasmHelperId}"
export default opts => initWasm(opts, ${JSON.stringify(url2)})
`;
        }
      };
    };
    var WorkerFileId = "worker_file";
    var workerCache = /* @__PURE__ */ new WeakMap();
    function emitWorkerFile(ctx, config2, asset, type) {
      const fileName = asset.fileName;
      const workerMap = workerCache.get(config2);
      if (workerMap[type].has(fileName)) {
        return workerMap[type].get(fileName);
      }
      const hash = ctx.emitFile(asset);
      workerMap[type].set(fileName, hash);
      workerMap.emitted.set(hash, fileName);
      return hash;
    }
    function emitWorkerAssets(ctx, config2, asset) {
      const { format: format2 } = config2.worker;
      return emitWorkerFile(ctx, config2, asset, format2 === "es" ? "chunks" : "assets");
    }
    function emitWorkerChunks(ctx, config2, asset) {
      return emitWorkerFile(ctx, config2, asset, "chunks");
    }
    async function bundleWorkerEntry(ctx, config2, id, query) {
      const rollup = (init_rollup_browser(), __toCommonJS(rollup_browser_exports));
      const { plugins: plugins2, rollupOptions, format: format2 } = config2.worker;
      const bundle = await rollup.rollup(__spreadProps2(__spreadValues2({}, rollupOptions), {
        input: cleanUrl(id),
        plugins: plugins2,
        onwarn(warning, warn2) {
          onRollupWarning(warning, warn2, config2);
        },
        preserveEntrySignatures: false
      }));
      let chunk;
      try {
        const { output: [outputChunk, ...outputChunks] } = await bundle.generate({
          format: format2,
          sourcemap: config2.build.sourcemap
        });
        chunk = outputChunk;
        outputChunks.forEach((outputChunk2) => {
          if (outputChunk2.type === "asset") {
            emitWorkerAssets(ctx, config2, outputChunk2);
          } else if (outputChunk2.type === "chunk") {
            emitWorkerChunks(ctx, config2, {
              fileName: path__default.posix.join(config2.build.assetsDir, outputChunk2.fileName),
              source: outputChunk2.code,
              type: "asset"
            });
          }
        });
      } finally {
        await bundle.close();
      }
      return emitSourcemapForWorkerEntry(ctx, config2, id, query, chunk);
    }
    function emitSourcemapForWorkerEntry(context2, config2, id, query, chunk) {
      let { code, map: sourcemap } = chunk;
      if (sourcemap) {
        if (config2.build.sourcemap === "inline") {
          const dataUrl = sourcemap.toUrl();
          code += `//# sourceMappingURL=${dataUrl}`;
        } else if (config2.build.sourcemap === "hidden" || config2.build.sourcemap === true) {
          const basename = path__default.parse(cleanUrl(id)).name;
          const data2 = sourcemap.toString();
          const content2 = Buffer.from(data2);
          const contentHash = getAssetHash(content2);
          const fileName = `${basename}.${contentHash}.js.map`;
          const filePath = path__default.posix.join(config2.build.assetsDir, fileName);
          if (!context2.cache.has(contentHash)) {
            context2.cache.set(contentHash, true);
            context2.emitFile({
              fileName: filePath,
              type: "asset",
              source: data2
            });
          }
          if (config2.build.sourcemap === true) {
            const sourceMapUrl = (query === null || query === void 0 ? void 0 : query.inline) != null ? filePath : fileName;
            code += `//# sourceMappingURL=${sourceMapUrl}`;
          }
        }
      }
      return Buffer.from(code);
    }
    async function workerFileToUrl(ctx, config2, id, query) {
      const workerMap = workerCache.get(config2);
      let hash = workerMap.bundle.get(id);
      if (hash) {
        return config2.base + workerMap.emitted.get(hash);
      }
      const code = await bundleWorkerEntry(ctx, config2, id, query);
      const basename = path__default.parse(cleanUrl(id)).name;
      const contentHash = getAssetHash(code);
      const fileName = path__default.posix.join(config2.build.assetsDir, `${basename}.${contentHash}.js`);
      hash = emitWorkerAssets(ctx, config2, {
        fileName,
        type: "asset",
        source: code
      });
      workerMap.bundle.set(id, hash);
      return `__VITE_ASSET__${hash}__`;
    }
    function webWorkerPlugin(config2) {
      const isBuild = config2.command === "build";
      const isWorker = config2.isWorker;
      return {
        name: "vite:worker",
        buildStart() {
          workerCache.set(config2, {
            assets: /* @__PURE__ */ new Map(),
            chunks: /* @__PURE__ */ new Map(),
            bundle: /* @__PURE__ */ new Map(),
            emitted: /* @__PURE__ */ new Map()
          });
        },
        load(id) {
          var _a2;
          if (isBuild) {
            const parsedQuery = parseRequest(id);
            if (parsedQuery && ((_a2 = parsedQuery.worker) !== null && _a2 !== void 0 ? _a2 : parsedQuery.sharedworker) != null) {
              return "";
            }
          }
        },
        async transform(_2, id) {
          var _a2;
          const query = parseRequest(id);
          if (query && query[WorkerFileId] != null) {
            return {
              code: `import '${ENV_PUBLIC_PATH}'
` + _2
            };
          }
          if (query == null || query && ((_a2 = query.worker) !== null && _a2 !== void 0 ? _a2 : query.sharedworker) == null) {
            return;
          }
          let url2;
          if (isBuild) {
            if (query.inline != null) {
              const code = await bundleWorkerEntry(this, config2, id, query);
              const { format: format2 } = config2.worker;
              const workerOptions2 = format2 === "es" ? '{type: "module"}' : "{}";
              return {
                code: `const encodedJs = "${code.toString("base64")}";
            const blob = typeof window !== "undefined" && window.Blob && new Blob([atob(encodedJs)], { type: "text/javascript;charset=utf-8" });
            export default function WorkerWrapper() {
              const objURL = blob && (window.URL || window.webkitURL).createObjectURL(blob);
              try {
                return objURL ? new Worker(objURL, ${workerOptions2}) : new Worker("data:application/javascript;base64," + encodedJs, {type: "module"});
              } finally {
                objURL && (window.URL || window.webkitURL).revokeObjectURL(objURL);
              }
            }`,
                map: { mappings: "" }
              };
            } else {
              url2 = await workerFileToUrl(this, config2, id, query);
            }
          } else {
            url2 = await fileToUrl(cleanUrl(id), config2, this);
            url2 = injectQuery(url2, WorkerFileId);
          }
          const workerConstructor = query.sharedworker != null ? "SharedWorker" : "Worker";
          const workerOptions = { type: "module" };
          return {
            code: `export default function WorkerWrapper() {
          return new ${workerConstructor}(${JSON.stringify(url2)}, ${JSON.stringify(workerOptions, null, 2)})
        }`,
            map: { mappings: "" }
          };
        },
        renderChunk(code) {
          if (isWorker && code.includes("import.meta.url")) {
            return code.replace("import.meta.url", "self.location.href");
          }
        }
      };
    }
    function preAliasPlugin() {
      let server2;
      return {
        name: "vite:pre-alias",
        configureServer(_server) {
          server2 = _server;
        },
        async resolveId(id, importer, options2) {
          if (!(options2 === null || options2 === void 0 ? void 0 : options2.ssr) && bareImportRE.test(id) && !(options2 === null || options2 === void 0 ? void 0 : options2.scan)) {
            return await tryOptimizedResolve(id, server2, importer);
          }
        }
      };
    }
    var nonJsRe = /\.(json)($|\?)/;
    var isNonJsRequest = (request) => nonJsRe.test(request);
    function definePlugin(config2) {
      const isBuild = config2.command === "build";
      const processNodeEnv = {
        "process.env.NODE_ENV": JSON.stringify("development"),
        "global.process.env.NODE_ENV": JSON.stringify("development"),
        "globalThis.process.env.NODE_ENV": JSON.stringify("development")
      };
      const userDefine = {};
      for (const key2 in config2.define) {
        const val = config2.define[key2];
        userDefine[key2] = typeof val === "string" ? val : JSON.stringify(val);
      }
      const importMetaKeys = {};
      if (isBuild) {
        const env2 = __spreadProps2(__spreadValues2({}, config2.env), {
          SSR: !!config2.build.ssr
        });
        for (const key2 in env2) {
          importMetaKeys[`import.meta.env.${key2}`] = JSON.stringify(env2[key2]);
        }
        Object.assign(importMetaKeys, {
          "import.meta.env.": `({}).`,
          "import.meta.env": JSON.stringify(config2.env),
          "import.meta.hot": `false`
        });
      }
      function generatePattern(ssr) {
        var _a2;
        const processEnv = {};
        const isNeedProcessEnv = !ssr || ((_a2 = config2.ssr) === null || _a2 === void 0 ? void 0 : _a2.target) === "webworker";
        if (isNeedProcessEnv) {
          Object.assign(processEnv, {
            "process.env.": `({}).`,
            "global.process.env.": `({}).`,
            "globalThis.process.env.": `({}).`
          });
        }
        const replacements = __spreadValues2(__spreadValues2(__spreadValues2(__spreadValues2({}, isNeedProcessEnv ? processNodeEnv : {}), userDefine), importMetaKeys), processEnv);
        const replacementsKeys = Object.keys(replacements);
        const pattern2 = replacementsKeys.length ? new RegExp("(?<!(?<!\\.\\.)\\.)\\b(" + replacementsKeys.map((str) => {
          return str.replace(/[-[\]/{}()*+?.\\^$|]/g, "\\$&");
        }).join("|") + ")\\b(?!\\s*?=[^=])", "g") : null;
        return [replacements, pattern2];
      }
      const defaultPattern = generatePattern(false);
      const ssrPattern = generatePattern(true);
      return {
        name: "vite:define",
        transform(code, id, options2) {
          const ssr = (options2 === null || options2 === void 0 ? void 0 : options2.ssr) === true;
          if (!ssr && !isBuild) {
            return;
          }
          if (isHTMLRequest(id) || isCSSRequest(id) || isNonJsRequest(id) || config2.assetsInclude(id)) {
            return;
          }
          const [replacements, pattern2] = ssr ? ssrPattern : defaultPattern;
          if (!pattern2) {
            return null;
          }
          if (ssr && !isBuild) {
            return code.replace(pattern2, (_2, match3) => {
              return "" + replacements[match3];
            });
          }
          const s2 = new MagicString(code);
          let hasReplaced = false;
          let match2;
          while (match2 = pattern2.exec(code)) {
            hasReplaced = true;
            const start = match2.index;
            const end = start + match2[0].length;
            const replacement2 = "" + replacements[match2[1]];
            s2.overwrite(start, end, replacement2, { contentOnly: true });
          }
          if (!hasReplaced) {
            return null;
          }
          const result2 = { code: s2.toString() };
          if (config2.build.sourcemap) {
            result2.map = s2.generateMap({ hires: true });
          }
          return result2;
        }
      };
    }
    var WORKER_FILE_ID = "worker_url_file";
    function getWorkerType(code, noCommentsCode, i2) {
      function err(e2, pos2) {
        const error2 = new Error(e2);
        error2.pos = pos2;
        throw error2;
      }
      const commaIndex = noCommentsCode.indexOf(",", i2);
      if (commaIndex === -1) {
        return "classic";
      }
      const endIndex = noCommentsCode.indexOf(")", i2);
      if (commaIndex > endIndex) {
        return "classic";
      }
      let workerOptsString = code.substring(commaIndex + 1, endIndex);
      const hasViteIgnore = /\/\*\s*@vite-ignore\s*\*\//.test(workerOptsString);
      if (hasViteIgnore) {
        return "ignore";
      }
      workerOptsString = noCommentsCode.substring(commaIndex + 1, endIndex);
      if (!workerOptsString.trim().length) {
        return "classic";
      }
      let workerOpts = { type: "classic" };
      try {
        workerOpts = lib$2.parse(workerOptsString);
      } catch (e2) {
        err("Vite is unable to parse the worker options as the value is not static.To ignore this error, please use /* @vite-ignore */ in the worker options.", commaIndex + 1);
      }
      if (["classic", "module"].includes(workerOpts.type)) {
        return workerOpts.type;
      }
      return "classic";
    }
    function workerImportMetaUrlPlugin(config2) {
      const isBuild = config2.command === "build";
      let server2;
      return {
        name: "vite:worker-import-meta-url",
        configureServer(_server) {
          server2 = _server;
        },
        async transform(code, id, options2) {
          var _a2;
          const query = parseRequest(id);
          if (query && query[WORKER_FILE_ID] != null && query["type"] != null) {
            const workerType = query["type"];
            let injectEnv = "";
            if (workerType === "classic") {
              injectEnv = `importScripts('${ENV_PUBLIC_PATH}')
`;
            } else if (workerType === "module") {
              injectEnv = `import '${ENV_PUBLIC_PATH}'
`;
            } else if (workerType === "ignore") {
              if (isBuild) {
                injectEnv = "";
              } else if (server2) {
                const { moduleGraph } = server2;
                const module2 = moduleGraph.getModuleById(ENV_ENTRY);
                injectEnv = ((_a2 = module2 === null || module2 === void 0 ? void 0 : module2.transformResult) === null || _a2 === void 0 ? void 0 : _a2.code) || "";
              }
            }
            return {
              code: injectEnv + code
            };
          }
          if ((code.includes("new Worker") || code.includes("new ShareWorker")) && code.includes("new URL") && code.includes(`import.meta.url`)) {
            const importMetaUrlRE = /\bnew\s+(Worker|SharedWorker)\s*\(\s*(new\s+URL\s*\(\s*('[^']+'|"[^"]+"|`[^`]+`)\s*,\s*import\.meta\.url\s*\))/g;
            const noCommentsCode = code.replace(multilineCommentsRE, blankReplacer).replace(singlelineCommentsRE, blankReplacer);
            const noStringCode = noCommentsCode.replace(stringsRE, (m3) => `'${" ".repeat(m3.length - 2)}'`);
            let match2;
            let s2 = null;
            while (match2 = importMetaUrlRE.exec(noStringCode)) {
              const { 0: allExp, 2: exp, 3: emptyUrl, index: index2 } = match2;
              const urlIndex = allExp.indexOf(exp) + index2;
              const urlStart = allExp.indexOf(emptyUrl) + index2;
              const urlEnd = urlStart + emptyUrl.length;
              const rawUrl = code.slice(urlStart, urlEnd);
              if (options2 === null || options2 === void 0 ? void 0 : options2.ssr) {
                this.error(`\`new URL(url, import.meta.url)\` is not supported in SSR.`, urlIndex);
              }
              if (rawUrl[0] === "`" && /\$\{/.test(rawUrl)) {
                this.error(`\`new URL(url, import.meta.url)\` is not supported in dynamic template string.`, urlIndex);
              }
              s2 || (s2 = new MagicString(code));
              const workerType = getWorkerType(code, noCommentsCode, index2 + allExp.length);
              const file = path__default.resolve(path__default.dirname(id), rawUrl.slice(1, -1));
              let url2;
              if (isBuild) {
                url2 = await workerFileToUrl(this, config2, file, query);
              } else {
                url2 = await fileToUrl(cleanUrl(file), config2, this);
                url2 = injectQuery(url2, WORKER_FILE_ID);
                url2 = injectQuery(url2, `type=${workerType}`);
              }
              s2.overwrite(urlIndex, urlIndex + exp.length, JSON.stringify(url2), {
                contentOnly: true
              });
            }
            if (s2) {
              return {
                code: s2.toString(),
                map: config2.build.sourcemap ? s2.generateMap({ hires: true }) : null
              };
            }
            return null;
          }
        }
      };
    }
    function metadataPlugin() {
      return {
        name: "vite:build-metadata",
        async renderChunk(_code, chunk) {
          chunk.viteMetadata = {
            importedAssets: /* @__PURE__ */ new Set(),
            importedCss: /* @__PURE__ */ new Set()
          };
          return null;
        }
      };
    }
    async function resolvePlugins(config2, prePlugins, normalPlugins, postPlugins) {
      const isBuild = config2.command === "build";
      const buildPlugins = isBuild ? (await Promise.resolve().then(function() {
        return build$1;
      })).resolveBuildPlugins(config2) : { pre: [], post: [] };
      return [
        isBuild ? metadataPlugin() : null,
        isBuild ? null : preAliasPlugin(),
        alias({ entries: config2.resolve.alias }),
        ...prePlugins,
        config2.build.polyfillModulePreload ? modulePreloadPolyfillPlugin(config2) : null,
        resolvePlugin(__spreadProps2(__spreadValues2({}, config2.resolve), {
          root: config2.root,
          isProduction: config2.isProduction,
          isBuild,
          packageCache: config2.packageCache,
          ssrConfig: config2.ssr,
          asSrc: true
        })),
        isBuild ? null : optimizedDepsPlugin(),
        htmlInlineProxyPlugin(config2),
        cssPlugin(config2),
        config2.esbuild !== false ? esbuildPlugin(config2.esbuild) : null,
        jsonPlugin(__spreadValues2({
          namedExports: true
        }, config2.json), isBuild),
        wasmPlugin(config2),
        webWorkerPlugin(config2),
        assetPlugin(config2),
        ...normalPlugins,
        definePlugin(config2),
        cssPostPlugin(config2),
        config2.build.ssr ? ssrRequireHookPlugin(config2) : null,
        isBuild && buildHtmlPlugin(config2),
        workerImportMetaUrlPlugin(config2),
        ...buildPlugins.pre,
        ...postPlugins,
        ...buildPlugins.post,
        ...isBuild ? [] : [clientInjectionsPlugin(config2), importAnalysisPlugin(config2)]
      ].filter(Boolean);
    }
    var main$1 = { exports: {} };
    var fs = fs__default;
    var path = path__default;
    var os = require$$1__default;
    function log(message) {
      console.log(`[dotenv][DEBUG] ${message}`);
    }
    var NEWLINE = "\n";
    var RE_INI_KEY_VAL = /^\s*([\w.-]+)\s*=\s*("[^"]*"|'[^']*'|.*?)(\s+#.*)?$/;
    var RE_NEWLINES = /\\n/g;
    var NEWLINES_MATCH = /\r\n|\n|\r/;
    function parse(src2, options2) {
      const debug2 = Boolean(options2 && options2.debug);
      const multiline = Boolean(options2 && options2.multiline);
      const obj = {};
      const lines = src2.toString().split(NEWLINES_MATCH);
      for (let idx = 0; idx < lines.length; idx++) {
        let line2 = lines[idx];
        const keyValueArr = line2.match(RE_INI_KEY_VAL);
        if (keyValueArr != null) {
          const key2 = keyValueArr[1];
          let val = keyValueArr[2] || "";
          let end = val.length - 1;
          const isDoubleQuoted = val[0] === '"' && val[end] === '"';
          const isSingleQuoted = val[0] === "'" && val[end] === "'";
          const isMultilineDoubleQuoted = val[0] === '"' && val[end] !== '"';
          const isMultilineSingleQuoted = val[0] === "'" && val[end] !== "'";
          if (multiline && (isMultilineDoubleQuoted || isMultilineSingleQuoted)) {
            const quoteChar = isMultilineDoubleQuoted ? '"' : "'";
            val = val.substring(1);
            while (idx++ < lines.length - 1) {
              line2 = lines[idx];
              end = line2.length - 1;
              if (line2[end] === quoteChar) {
                val += NEWLINE + line2.substring(0, end);
                break;
              }
              val += NEWLINE + line2;
            }
          } else if (isSingleQuoted || isDoubleQuoted) {
            val = val.substring(1, end);
            if (isDoubleQuoted) {
              val = val.replace(RE_NEWLINES, NEWLINE);
            }
          } else {
            val = val.trim();
          }
          obj[key2] = val;
        } else if (debug2) {
          const trimmedLine = line2.trim();
          if (trimmedLine.length && trimmedLine[0] !== "#") {
            log(`Failed to match key and value when parsing line ${idx + 1}: ${line2}`);
          }
        }
      }
      return obj;
    }
    function resolveHome(envPath) {
      return envPath[0] === "~" ? path.join(os.homedir(), envPath.slice(1)) : envPath;
    }
    function config(options2) {
      let dotenvPath = path.resolve(process.cwd(), ".env");
      let encoding = "utf8";
      const debug2 = Boolean(options2 && options2.debug);
      const override = Boolean(options2 && options2.override);
      const multiline = Boolean(options2 && options2.multiline);
      if (options2) {
        if (options2.path != null) {
          dotenvPath = resolveHome(options2.path);
        }
        if (options2.encoding != null) {
          encoding = options2.encoding;
        }
      }
      try {
        const parsed = DotenvModule.parse(fs.readFileSync(dotenvPath, { encoding }), { debug: debug2, multiline });
        Object.keys(parsed).forEach(function(key2) {
          if (!Object.prototype.hasOwnProperty.call(process.env, key2)) {
            process.env[key2] = parsed[key2];
          } else {
            if (override === true) {
              process.env[key2] = parsed[key2];
            }
            if (debug2) {
              if (override === true) {
                log(`"${key2}" is already defined in \`process.env\` and WAS overwritten`);
              } else {
                log(`"${key2}" is already defined in \`process.env\` and was NOT overwritten`);
              }
            }
          }
        });
        return { parsed };
      } catch (e2) {
        if (debug2) {
          log(`Failed to load ${dotenvPath} ${e2.message}`);
        }
        return { error: e2 };
      }
    }
    var DotenvModule = {
      config,
      parse
    };
    main$1.exports.config = DotenvModule.config;
    main$1.exports.parse = DotenvModule.parse;
    main$1.exports = DotenvModule;
    var dotenv = main$1.exports;
    var dotenvExpand = function(config2) {
      var environment = config2.ignoreProcessEnv ? {} : process.env;
      var interpolate = function(envValue) {
        var matches2 = envValue.match(/(.?\${?(?:[a-zA-Z0-9_]+)?}?)/g) || [];
        return matches2.reduce(function(newEnv, match2) {
          var parts = /(.?)\${?([a-zA-Z0-9_]+)?}?/g.exec(match2);
          var prefix = parts[1];
          var value2, replacePart;
          if (prefix === "\\") {
            replacePart = parts[0];
            value2 = replacePart.replace("\\$", "$");
          } else {
            var key2 = parts[2];
            replacePart = parts[0].substring(prefix.length);
            value2 = environment.hasOwnProperty(key2) ? environment[key2] : config2.parsed[key2] || "";
            value2 = interpolate(value2);
          }
          return newEnv.replace(replacePart, value2);
        }, envValue);
      };
      for (var configKey in config2.parsed) {
        var value = environment.hasOwnProperty(configKey) ? environment[configKey] : config2.parsed[configKey];
        config2.parsed[configKey] = interpolate(value);
      }
      for (var processKey in config2.parsed) {
        environment[processKey] = config2.parsed[processKey];
      }
      return config2;
    };
    var main = dotenvExpand;
    var debug = createDebugger("vite:config");
    function defineConfig(config2) {
      return config2;
    }
    async function resolveConfig(inlineConfig, command, defaultMode = "development") {
      var _a2, _b, _c, _d, _e2, _f, _g, _h2, _j, _k, _l, _m;
      let config2 = inlineConfig;
      let configFileDependencies = [];
      let mode2 = inlineConfig.mode || defaultMode;
      if (mode2 === "production") {
        "development" = "production";
      }
      const configEnv = {
        mode: mode2,
        command
      };
      let { configFile } = config2;
      if (configFile !== false) {
        const loadResult = await loadConfigFromFile(configEnv, configFile, config2.root, config2.logLevel);
        if (loadResult) {
          config2 = mergeConfig(loadResult.config, config2);
          configFile = loadResult.path;
          configFileDependencies = loadResult.dependencies;
        }
      }
      const logger = createLogger(config2.logLevel, {
        allowClearScreen: config2.clearScreen,
        customLogger: config2.customLogger
      });
      mode2 = inlineConfig.mode || config2.mode || mode2;
      configEnv.mode = mode2;
      const rawUserPlugins = (config2.plugins || []).flat().filter((p2) => {
        if (!p2) {
          return false;
        } else if (!p2.apply) {
          return true;
        } else if (typeof p2.apply === "function") {
          return p2.apply(__spreadProps2(__spreadValues2({}, config2), { mode: mode2 }), configEnv);
        } else {
          return p2.apply === command;
        }
      });
      const [prePlugins, normalPlugins, postPlugins] = sortUserPlugins(rawUserPlugins);
      const resolvedWorkerOptions = {
        format: ((_a2 = config2.worker) === null || _a2 === void 0 ? void 0 : _a2.format) || "iife",
        plugins: [],
        rollupOptions: ((_b = config2.worker) === null || _b === void 0 ? void 0 : _b.rollupOptions) || {}
      };
      const userPlugins = [...prePlugins, ...normalPlugins, ...postPlugins];
      for (const p2 of userPlugins) {
        if (p2.config) {
          const res = await p2.config(config2, configEnv);
          if (res) {
            config2 = mergeConfig(config2, res);
          }
        }
      }
      const resolvedRoot = normalizePath$4(config2.root ? path__default.resolve(config2.root) : process.cwd());
      const clientAlias = [
        { find: /^[\/]?@vite\/env/, replacement: () => ENV_ENTRY },
        { find: /^[\/]?@vite\/client/, replacement: () => CLIENT_ENTRY }
      ];
      const resolvedAlias = normalizeAlias(mergeAlias(clientAlias, ((_c = config2.resolve) === null || _c === void 0 ? void 0 : _c.alias) || config2.alias || []));
      const resolveOptions = __spreadProps2(__spreadValues2({
        dedupe: config2.dedupe
      }, config2.resolve), {
        alias: resolvedAlias
      });
      const envDir = config2.envDir ? normalizePath$4(path__default.resolve(resolvedRoot, config2.envDir)) : resolvedRoot;
      const userEnv = inlineConfig.envFile !== false && loadEnv(mode2, envDir, resolveEnvPrefix(config2));
      const isProduction = (process.env.VITE_USER_NODE_ENV || mode2) === "production";
      if (isProduction) {
        "development" = "production";
      }
      const BASE_URL = resolveBaseUrl(config2.base, command === "build", logger);
      const resolvedBuildOptions = resolveBuildOptions(config2.build);
      const pkgPath = lookupFile(resolvedRoot, [`package.json`], { pathOnly: true });
      const cacheDir = config2.cacheDir ? path__default.resolve(resolvedRoot, config2.cacheDir) : pkgPath ? path__default.join(path__default.dirname(pkgPath), `node_modules/.vite`) : path__default.join(resolvedRoot, `.vite`);
      const assetsFilter = config2.assetsInclude ? createFilter$1(config2.assetsInclude) : () => false;
      const createResolver = (options2) => {
        let aliasContainer;
        let resolverContainer;
        return async (id, importer, aliasOnly, ssr) => {
          var _a3;
          let container;
          if (aliasOnly) {
            container = aliasContainer || (aliasContainer = await createPluginContainer(__spreadProps2(__spreadValues2({}, resolved), {
              plugins: [alias({ entries: resolved.resolve.alias })]
            })));
          } else {
            container = resolverContainer || (resolverContainer = await createPluginContainer(__spreadProps2(__spreadValues2({}, resolved), {
              plugins: [
                alias({ entries: resolved.resolve.alias }),
                resolvePlugin(__spreadValues2(__spreadProps2(__spreadValues2({}, resolved.resolve), {
                  root: resolvedRoot,
                  isProduction,
                  isBuild: command === "build",
                  ssrConfig: resolved.ssr,
                  asSrc: true,
                  preferRelative: false,
                  tryIndex: true
                }), options2))
              ]
            })));
          }
          return (_a3 = await container.resolveId(id, importer, { ssr })) === null || _a3 === void 0 ? void 0 : _a3.id;
        };
      };
      const { publicDir } = config2;
      const resolvedPublicDir = publicDir !== false && publicDir !== "" ? path__default.resolve(resolvedRoot, typeof publicDir === "string" ? publicDir : "public") : "";
      const server2 = resolveServerOptions(resolvedRoot, config2.server);
      const resolved = __spreadProps2(__spreadValues2({}, config2), {
        configFile: configFile ? normalizePath$4(configFile) : void 0,
        configFileDependencies: configFileDependencies.map((name) => normalizePath$4(path__default.resolve(name))),
        inlineConfig,
        root: resolvedRoot,
        base: BASE_URL,
        resolve: resolveOptions,
        publicDir: resolvedPublicDir,
        cacheDir,
        command,
        mode: mode2,
        isWorker: false,
        isProduction,
        plugins: userPlugins,
        server: server2,
        build: resolvedBuildOptions,
        preview: resolvePreviewOptions(config2.preview, server2),
        env: __spreadProps2(__spreadValues2({}, userEnv), {
          BASE_URL,
          MODE: mode2,
          DEV: !isProduction,
          PROD: isProduction
        }),
        assetsInclude(file) {
          return DEFAULT_ASSETS_RE.test(file) || assetsFilter(file);
        },
        logger,
        packageCache: /* @__PURE__ */ new Map(),
        createResolver,
        optimizeDeps: __spreadProps2(__spreadValues2({}, config2.optimizeDeps), {
          esbuildOptions: __spreadValues2({
            keepNames: (_d = config2.optimizeDeps) === null || _d === void 0 ? void 0 : _d.keepNames,
            preserveSymlinks: (_e2 = config2.resolve) === null || _e2 === void 0 ? void 0 : _e2.preserveSymlinks
          }, (_f = config2.optimizeDeps) === null || _f === void 0 ? void 0 : _f.esbuildOptions)
        }),
        worker: resolvedWorkerOptions
      });
      const [workerPrePlugins, workerNormalPlugins, workerPostPlugins] = sortUserPlugins((_g = config2.worker) === null || _g === void 0 ? void 0 : _g.plugins);
      const workerResolved = __spreadProps2(__spreadValues2({}, resolved), { isWorker: true });
      resolved.worker.plugins = await resolvePlugins(workerResolved, workerPrePlugins, workerNormalPlugins, workerPostPlugins);
      await Promise.all(resolved.worker.plugins.map((p2) => {
        var _a3;
        return (_a3 = p2.configResolved) === null || _a3 === void 0 ? void 0 : _a3.call(p2, workerResolved);
      }));
      resolved.plugins = await resolvePlugins(resolved, prePlugins, normalPlugins, postPlugins);
      await Promise.all(userPlugins.map((p2) => {
        var _a3;
        return (_a3 = p2.configResolved) === null || _a3 === void 0 ? void 0 : _a3.call(p2, resolved);
      }));
      if (process.env.DEBUG) {
        debug(`using resolved config: %O`, __spreadProps2(__spreadValues2({}, resolved), {
          plugins: resolved.plugins.map((p2) => p2.name)
        }));
      }
      const logDeprecationWarning = (deprecatedOption, hint, error2) => {
        logger.warn(colors$1.yellow(colors$1.bold(`(!) "${deprecatedOption}" option is deprecated. ${hint}${error2 ? `
${error2.stack}` : ""}`)));
      };
      if ((_h2 = config2.build) === null || _h2 === void 0 ? void 0 : _h2.base) {
        logDeprecationWarning("build.base", '"base" is now a root-level config option.');
        config2.base = config2.build.base;
      }
      Object.defineProperty(resolvedBuildOptions, "base", {
        enumerable: false,
        get() {
          logDeprecationWarning("build.base", '"base" is now a root-level config option.', new Error());
          return resolved.base;
        }
      });
      if (config2.alias) {
        logDeprecationWarning("alias", 'Use "resolve.alias" instead.');
      }
      Object.defineProperty(resolved, "alias", {
        enumerable: false,
        get() {
          logDeprecationWarning("alias", 'Use "resolve.alias" instead.', new Error());
          return resolved.resolve.alias;
        }
      });
      if (config2.dedupe) {
        logDeprecationWarning("dedupe", 'Use "resolve.dedupe" instead.');
      }
      Object.defineProperty(resolved, "dedupe", {
        enumerable: false,
        get() {
          logDeprecationWarning("dedupe", 'Use "resolve.dedupe" instead.', new Error());
          return resolved.resolve.dedupe;
        }
      });
      if ((_j = config2.optimizeDeps) === null || _j === void 0 ? void 0 : _j.keepNames) {
        logDeprecationWarning("optimizeDeps.keepNames", 'Use "optimizeDeps.esbuildOptions.keepNames" instead.');
      }
      Object.defineProperty(resolved.optimizeDeps, "keepNames", {
        enumerable: false,
        get() {
          var _a3;
          logDeprecationWarning("optimizeDeps.keepNames", 'Use "optimizeDeps.esbuildOptions.keepNames" instead.', new Error());
          return (_a3 = resolved.optimizeDeps.esbuildOptions) === null || _a3 === void 0 ? void 0 : _a3.keepNames;
        }
      });
      if ((_k = config2.build) === null || _k === void 0 ? void 0 : _k.polyfillDynamicImport) {
        logDeprecationWarning("build.polyfillDynamicImport", '"polyfillDynamicImport" has been removed. Please use @vitejs/plugin-legacy if your target browsers do not support dynamic imports.');
      }
      Object.defineProperty(resolvedBuildOptions, "polyfillDynamicImport", {
        enumerable: false,
        get() {
          logDeprecationWarning("build.polyfillDynamicImport", '"polyfillDynamicImport" has been removed. Please use @vitejs/plugin-legacy if your target browsers do not support dynamic imports.', new Error());
          return false;
        }
      });
      if ((_l = config2.build) === null || _l === void 0 ? void 0 : _l.cleanCssOptions) {
        logDeprecationWarning("build.cleanCssOptions", "Vite now uses esbuild for CSS minification.");
      }
      if (((_m = config2.build) === null || _m === void 0 ? void 0 : _m.terserOptions) && config2.build.minify !== "terser") {
        logger.warn(colors$1.yellow(`build.terserOptions is specified but build.minify is not set to use Terser. Note Vite now defaults to use esbuild for minification. If you still prefer Terser, set build.minify to "terser".`));
      }
      return resolved;
    }
    function resolveBaseUrl(base2 = "/", isBuild, logger) {
      if (base2 === "" || base2 === "./") {
        return isBuild ? base2 : "/";
      }
      if (base2.startsWith(".")) {
        logger.warn(colors$1.yellow(colors$1.bold(`(!) invalid "base" option: ${base2}. The value can only be an absolute URL, ./, or an empty string.`)));
        base2 = "/";
      }
      if (isExternalUrl(base2)) {
        if (!isBuild) {
          const parsed = require$$0$4.parse(base2);
          base2 = parsed.pathname || "/";
        }
      } else {
        if (!base2.startsWith("/")) {
          logger.warn(colors$1.yellow(colors$1.bold(`(!) "base" option should start with a slash.`)));
          base2 = "/" + base2;
        }
      }
      if (!base2.endsWith("/")) {
        logger.warn(colors$1.yellow(colors$1.bold(`(!) "base" option should end with a slash.`)));
        base2 += "/";
      }
      return base2;
    }
    function mergeConfigRecursively(defaults, overrides, rootPath) {
      const merged = __spreadValues2({}, defaults);
      for (const key2 in overrides) {
        const value = overrides[key2];
        if (value == null) {
          continue;
        }
        const existing = merged[key2];
        if (existing == null) {
          merged[key2] = value;
          continue;
        }
        if (key2 === "alias" && (rootPath === "resolve" || rootPath === "")) {
          merged[key2] = mergeAlias(existing, value);
          continue;
        } else if (key2 === "assetsInclude" && rootPath === "") {
          merged[key2] = [].concat(existing, value);
          continue;
        } else if (key2 === "noExternal" && existing === true) {
          continue;
        }
        if (Array.isArray(existing) || Array.isArray(value)) {
          merged[key2] = [...arraify(existing !== null && existing !== void 0 ? existing : []), ...arraify(value !== null && value !== void 0 ? value : [])];
          continue;
        }
        if (isObject$5(existing) && isObject$5(value)) {
          merged[key2] = mergeConfigRecursively(existing, value, rootPath ? `${rootPath}.${key2}` : key2);
          continue;
        }
        merged[key2] = value;
      }
      return merged;
    }
    function mergeConfig(defaults, overrides, isRoot = true) {
      return mergeConfigRecursively(defaults, overrides, isRoot ? "" : ".");
    }
    function mergeAlias(a2, b2) {
      if (!a2)
        return b2;
      if (!b2)
        return a2;
      if (isObject$5(a2) && isObject$5(b2)) {
        return __spreadValues2(__spreadValues2({}, a2), b2);
      }
      return [...normalizeAlias(b2), ...normalizeAlias(a2)];
    }
    function normalizeAlias(o2 = []) {
      return Array.isArray(o2) ? o2.map(normalizeSingleAlias) : Object.keys(o2).map((find2) => normalizeSingleAlias({
        find: find2,
        replacement: o2[find2]
      }));
    }
    function normalizeSingleAlias({ find: find2, replacement: replacement2, customResolver }) {
      if (typeof find2 === "string" && find2.endsWith("/") && replacement2.endsWith("/")) {
        find2 = find2.slice(0, find2.length - 1);
        replacement2 = replacement2.slice(0, replacement2.length - 1);
      }
      const alias2 = {
        find: find2,
        replacement: replacement2
      };
      if (customResolver) {
        alias2.customResolver = customResolver;
      }
      return alias2;
    }
    function sortUserPlugins(plugins2) {
      const prePlugins = [];
      const postPlugins = [];
      const normalPlugins = [];
      if (plugins2) {
        plugins2.flat().forEach((p2) => {
          if (p2.enforce === "pre")
            prePlugins.push(p2);
          else if (p2.enforce === "post")
            postPlugins.push(p2);
          else
            normalPlugins.push(p2);
        });
      }
      return [prePlugins, normalPlugins, postPlugins];
    }
    async function loadConfigFromFile(configEnv, configFile, configRoot = process.cwd(), logLevel) {
      const start = perf_hooks.performance.now();
      const getTime = () => `${(perf_hooks.performance.now() - start).toFixed(2)}ms`;
      let resolvedPath;
      let isTS = false;
      let isESM = false;
      let dependencies = [];
      try {
        const pkg = lookupFile(configRoot, ["package.json"]);
        if (pkg && JSON.parse(pkg).type === "module") {
          isESM = true;
        }
      } catch (e2) {
      }
      if (configFile) {
        resolvedPath = path__default.resolve(configFile);
        isTS = configFile.endsWith(".ts");
        if (configFile.endsWith(".mjs")) {
          isESM = true;
        }
      } else {
        const jsconfigFile = path__default.resolve(configRoot, "vite.config.js");
        if (fs__default.existsSync(jsconfigFile)) {
          resolvedPath = jsconfigFile;
        }
        if (!resolvedPath) {
          const mjsconfigFile = path__default.resolve(configRoot, "vite.config.mjs");
          if (fs__default.existsSync(mjsconfigFile)) {
            resolvedPath = mjsconfigFile;
            isESM = true;
          }
        }
        if (!resolvedPath) {
          const tsconfigFile = path__default.resolve(configRoot, "vite.config.ts");
          if (fs__default.existsSync(tsconfigFile)) {
            resolvedPath = tsconfigFile;
            isTS = true;
          }
        }
        if (!resolvedPath) {
          const cjsConfigFile = path__default.resolve(configRoot, "vite.config.cjs");
          if (fs__default.existsSync(cjsConfigFile)) {
            resolvedPath = cjsConfigFile;
            isESM = false;
          }
        }
      }
      if (!resolvedPath) {
        debug("no config file found.");
        return null;
      }
      try {
        let userConfig;
        if (isESM) {
          const fileUrl = (init_url(), __toCommonJS(url_exports)).pathToFileURL(resolvedPath);
          const bundled = await bundleConfigFile(resolvedPath, true);
          dependencies = bundled.dependencies;
          if (isTS) {
            fs__default.writeFileSync(resolvedPath + ".js", bundled.code);
            userConfig = (await dynamicImport(`${fileUrl}.js?t=${Date.now()}`)).default;
            fs__default.unlinkSync(resolvedPath + ".js");
            debug(`TS + native esm config loaded in ${getTime()}`, fileUrl);
          } else {
            userConfig = (await dynamicImport(`${fileUrl}?t=${Date.now()}`)).default;
            debug(`native esm config loaded in ${getTime()}`, fileUrl);
          }
        }
        if (!userConfig) {
          const bundled = await bundleConfigFile(resolvedPath);
          dependencies = bundled.dependencies;
          userConfig = await loadConfigFromBundledFile(resolvedPath, bundled.code);
          debug(`bundled config file loaded in ${getTime()}`);
        }
        const config2 = await (typeof userConfig === "function" ? userConfig(configEnv) : userConfig);
        if (!isObject$5(config2)) {
          throw new Error(`config must export or return an object.`);
        }
        return {
          path: normalizePath$4(resolvedPath),
          config: config2,
          dependencies
        };
      } catch (e2) {
        createLogger(logLevel).error(colors$1.red(`failed to load config from ${resolvedPath}`), { error: e2 });
        throw e2;
      }
    }
    async function bundleConfigFile(fileName, isESM = false) {
      const result2 = await esbuild.build({
        absWorkingDir: process.cwd(),
        entryPoints: [fileName],
        outfile: "out.js",
        write: false,
        platform: "node",
        bundle: true,
        format: isESM ? "esm" : "cjs",
        sourcemap: "inline",
        metafile: true,
        plugins: [
          {
            name: "externalize-deps",
            setup(build2) {
              build2.onResolve({ filter: /.*/ }, (args) => {
                const id = args.path;
                if (id[0] !== "." && !path__default.isAbsolute(id)) {
                  return {
                    external: true
                  };
                }
              });
            }
          },
          {
            name: "replace-import-meta",
            setup(build2) {
              build2.onLoad({ filter: /\.[jt]s$/ }, async (args) => {
                const contents = await fs__default.promises.readFile(args.path, "utf8");
                return {
                  loader: args.path.endsWith(".ts") ? "ts" : "js",
                  contents: contents.replace(/\bimport\.meta\.url\b/g, JSON.stringify(`file://${args.path}`)).replace(/\b__dirname\b/g, JSON.stringify(path__default.dirname(args.path))).replace(/\b__filename\b/g, JSON.stringify(args.path))
                };
              });
            }
          }
        ]
      });
      const { text } = result2.outputFiles[0];
      return {
        code: text,
        dependencies: result2.metafile ? Object.keys(result2.metafile.inputs) : []
      };
    }
    async function loadConfigFromBundledFile(fileName, bundledCode) {
      const extension2 = path__default.extname(fileName);
      const defaultLoader = __require.extensions[extension2];
      __require.extensions[extension2] = (module2, filename2) => {
        if (filename2 === fileName) {
          module2._compile(bundledCode, filename2);
        } else {
          defaultLoader(module2, filename2);
        }
      };
      delete __require.cache[__require.resolve(fileName)];
      const raw = __require(fileName);
      const config2 = raw.__esModule ? raw.default : raw;
      __require.extensions[extension2] = defaultLoader;
      return config2;
    }
    function loadEnv(mode2, envDir, prefixes = "VITE_") {
      var _a2;
      if (mode2 === "local") {
        throw new Error(`"local" cannot be used as a mode name because it conflicts with the .local postfix for .env files.`);
      }
      prefixes = arraify(prefixes);
      const env2 = {};
      const envFiles = [
        `.env.${mode2}.local`,
        `.env.${mode2}`,
        `.env.local`,
        `.env`
      ];
      for (const key2 in process.env) {
        if (prefixes.some((prefix) => key2.startsWith(prefix)) && env2[key2] === void 0) {
          env2[key2] = process.env[key2];
        }
      }
      for (const file of envFiles) {
        const path2 = lookupFile(envDir, [file], { pathOnly: true, rootDir: envDir });
        if (path2) {
          const parsed = dotenv.parse(fs__default.readFileSync(path2), {
            debug: ((_a2 = process.env.DEBUG) === null || _a2 === void 0 ? void 0 : _a2.includes("vite:dotenv")) || void 0
          });
          main({
            parsed,
            ignoreProcessEnv: true
          });
          for (const [key2, value] of Object.entries(parsed)) {
            if (prefixes.some((prefix) => key2.startsWith(prefix)) && env2[key2] === void 0) {
              env2[key2] = value;
            } else if (key2 === "NODE_ENV" && process.env.VITE_USER_NODE_ENV === void 0) {
              process.env.VITE_USER_NODE_ENV = value;
            }
          }
        }
      }
      return env2;
    }
    function resolveEnvPrefix({ envPrefix = "VITE_" }) {
      envPrefix = arraify(envPrefix);
      if (envPrefix.some((prefix) => prefix === "")) {
        throw new Error(`envPrefix option contains value '', which could lead unexpected exposure of sensitive information.`);
      }
      return envPrefix;
    }
    exports.build = build;
    exports.build$1 = build$1;
    exports.colors = colors$1;
    exports.commonjsGlobal = commonjsGlobal;
    exports.createLogger = createLogger;
    exports.createServer = createServer;
    exports.defineConfig = defineConfig;
    exports.formatPostcssSourceMap = formatPostcssSourceMap;
    exports.getAugmentedNamespace = getAugmentedNamespace;
    exports.getDefaultExportFromCjs = getDefaultExportFromCjs;
    exports.index = index$1;
    exports.index$1 = index;
    exports.isCSSRequest = isCSSRequest;
    exports.loadConfigFromFile = loadConfigFromFile;
    exports.loadEnv = loadEnv;
    exports.mergeConfig = mergeConfig;
    exports.normalizePath = normalizePath$4;
    exports.optimizeDeps = optimizeDeps;
    exports.preview = preview;
    exports.preview$1 = preview$1;
    exports.printHttpServerUrls = printHttpServerUrls;
    exports.resolveConfig = resolveConfig;
    exports.resolveEnvPrefix = resolveEnvPrefix;
    exports.resolvePackageData = resolvePackageData;
    exports.resolvePackageEntry = resolvePackageEntry;
    exports.searchForWorkspaceRoot = searchForWorkspaceRoot;
    exports.send = send$1;
    exports.sortUserPlugins = sortUserPlugins;
    exports.transformWithEsbuild = transformWithEsbuild;
  }
});

// node_modules/vite/dist/node/index.js
var require_node2 = __commonJS({
  "node_modules/vite/dist/node/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var index2 = require_dep_611778e0();
    init_fs();
    init_path();
    init_tty();
    init_util();
    init_net();
    init_events();
    init_url();
    init_http();
    init_stream();
    init_os();
    require_resolve();
    init_module();
    init_perf_hooks();
    init_https();
    init_zlib();
    init_crypto();
    init_tls();
    init_assert();
    require_main();
    init_buffer();
    init_querystring();
    init_child_process();
    init_worker_threads();
    init_readline();
    var SplitVendorChunkCache = class {
      constructor() {
        this.cache = /* @__PURE__ */ new Map();
      }
      reset() {
        this.cache = /* @__PURE__ */ new Map();
      }
    };
    function splitVendorChunk(options2 = {}) {
      var _a2;
      const cache2 = (_a2 = options2.cache) !== null && _a2 !== void 0 ? _a2 : new SplitVendorChunkCache();
      return (id, { getModuleInfo }) => {
        if (id.includes("node_modules") && !index2.isCSSRequest(id) && staticImportedByEntry(id, getModuleInfo, cache2.cache)) {
          return "vendor";
        }
      };
    }
    function staticImportedByEntry(id, getModuleInfo, cache2, importStack = []) {
      if (cache2.has(id)) {
        return cache2.get(id);
      }
      if (importStack.includes(id)) {
        cache2.set(id, false);
        return false;
      }
      const mod = getModuleInfo(id);
      if (!mod) {
        cache2.set(id, false);
        return false;
      }
      if (mod.isEntry) {
        cache2.set(id, true);
        return true;
      }
      const someImporterIs = mod.importers.some((importer) => staticImportedByEntry(importer, getModuleInfo, cache2, importStack.concat(id)));
      cache2.set(id, someImporterIs);
      return someImporterIs;
    }
    function splitVendorChunkPlugin() {
      const caches = [];
      function createSplitVendorChunk(output, config2) {
        var _a2;
        const cache2 = new SplitVendorChunkCache();
        caches.push(cache2);
        const build2 = (_a2 = config2.build) !== null && _a2 !== void 0 ? _a2 : {};
        const format2 = output === null || output === void 0 ? void 0 : output.format;
        if (!build2.ssr && !build2.lib && format2 !== "umd" && format2 !== "iife") {
          return splitVendorChunk({ cache: cache2 });
        }
      }
      return {
        name: "vite:split-vendor-chunk",
        config(config2) {
          var _a2, _b;
          let outputs = (_b = (_a2 = config2 === null || config2 === void 0 ? void 0 : config2.build) === null || _a2 === void 0 ? void 0 : _a2.rollupOptions) === null || _b === void 0 ? void 0 : _b.output;
          if (outputs) {
            outputs = Array.isArray(outputs) ? outputs : [outputs];
            for (const output of outputs) {
              const viteManualChunks = createSplitVendorChunk(output, config2);
              if (viteManualChunks) {
                if (output.manualChunks) {
                  if (typeof output.manualChunks === "function") {
                    const userManualChunks = output.manualChunks;
                    output.manualChunks = (id, api) => {
                      var _a3;
                      return (_a3 = userManualChunks(id, api)) !== null && _a3 !== void 0 ? _a3 : viteManualChunks(id, api);
                    };
                  }
                } else {
                  output.manualChunks = viteManualChunks;
                }
              }
            }
          } else {
            return {
              build: {
                rollupOptions: {
                  output: {
                    manualChunks: createSplitVendorChunk({}, config2)
                  }
                }
              }
            };
          }
        },
        buildStart() {
          caches.forEach((cache2) => cache2.reset());
        }
      };
    }
    exports2.build = index2.build;
    exports2.createLogger = index2.createLogger;
    exports2.createServer = index2.createServer;
    exports2.defineConfig = index2.defineConfig;
    exports2.formatPostcssSourceMap = index2.formatPostcssSourceMap;
    exports2.loadConfigFromFile = index2.loadConfigFromFile;
    exports2.loadEnv = index2.loadEnv;
    exports2.mergeConfig = index2.mergeConfig;
    exports2.normalizePath = index2.normalizePath;
    exports2.optimizeDeps = index2.optimizeDeps;
    exports2.preview = index2.preview;
    exports2.printHttpServerUrls = index2.printHttpServerUrls;
    exports2.resolveConfig = index2.resolveConfig;
    exports2.resolveEnvPrefix = index2.resolveEnvPrefix;
    exports2.resolvePackageData = index2.resolvePackageData;
    exports2.resolvePackageEntry = index2.resolvePackageEntry;
    exports2.searchForWorkspaceRoot = index2.searchForWorkspaceRoot;
    exports2.send = index2.send;
    exports2.sortUserPlugins = index2.sortUserPlugins;
    exports2.transformWithEsbuild = index2.transformWithEsbuild;
    exports2.splitVendorChunk = splitVendorChunk;
    exports2.splitVendorChunkPlugin = splitVendorChunkPlugin;
  }
});

// dep:vite
var vite_default = require_node2();
export {
  vite_default as default
};
/*
  @license
	Rollup.js v2.70.1
	Mon, 14 Mar 2022 05:50:08 GMT - commit b8315e03f9790d610a413316fbf6d565f9340cab

	https://github.com/rollup/rollup

	Released under the MIT License.
*/
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
/*!
 * Array of passes.
 *
 * A `pass` is just a function that is executed on `req, res, options`
 * so that you can easily add new checks while still keeping the base
 * flexible.
 */
/*!
 * Array of passes.
 *
 * A `pass` is just a function that is executed on `req, socket, options`
 * so that you can easily add new checks while still keeping the base
 * flexible.
 */
/*!
 * Caron dimonio, con occhi di bragia
 * loro accennando, tutte le raccoglie;
 * batte col remo qualunque sadagia 
 *
 * Charon the demon, with the eyes of glede,
 * Beckoning to them, collects them all together,
 * Beats with his oar whoever lags behind
 *          
 *          Dante - The Divine Comedy (Canto III)
 */
/*!
 * connect
 * Copyright(c) 2010 Sencha Inc.
 * Copyright(c) 2011 TJ Holowaychuk
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * ee-first
 * Copyright(c) 2014 Jonathan Ong
 * MIT Licensed
 */
/*!
 * encodeurl
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */
/*!
 * etag
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * fill-range <https://github.com/jonschlinkert/fill-range>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * finalhandler
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * is-extglob <https://github.com/jonschlinkert/is-extglob>
 *
 * Copyright (c) 2014-2016, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * is-glob <https://github.com/jonschlinkert/is-glob>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * is-number <https://github.com/jonschlinkert/is-number>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * normalize-path <https://github.com/jonschlinkert/normalize-path>
 *
 * Copyright (c) 2014-2018, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * on-finished
 * Copyright(c) 2013 Jonathan Ong
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * parseurl
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * statuses
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * to-regex-range <https://github.com/micromatch/to-regex-range>
 *
 * Copyright (c) 2015-present, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * unpipe
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * vary
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
/*! https://mths.be/cssesc v3.0.0 by @mathias */
/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*! run-parallel. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/**
 * Autoload Config for PostCSS
 *
 * @author Michael Ciniawsky @michael-ciniawsky <michael.ciniawsky@gmail.com>
 * @license MIT
 *
 * @module postcss-load-config
 * @version 2.1.0
 *
 * @requires comsiconfig
 * @requires ./options
 * @requires ./plugins
 */
//# sourceMappingURL=vite.js.map
